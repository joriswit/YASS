{
YASS - Yet Another Sokoban Solver and Optimizer - For Small Levels
Version 2.136b June 20, 2016
Copyright (c) 2016 by Brian Damgaard, Denmark

This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>.
}

{   YASS - Yet Another Sokoban Solver and Optimzer - For Small Levels
    -----------------------------------------------------------------

    Credits and acknowledgments
    ---------------------------

    Many people have contributed to this program, and I'm particularly
    indebted to:

    Lee J Haywood for providing most of the basic deadlock patterns,
    for sharing a lot of ideas, and for a long-standing correspondence
    on Sokoban issues.

    Matthias Meger for sharing a lot of ideas and for a long-standing
    correspondence on solvers, optimizers, and deadlock-detection.

    Sebastien Gouezel for inventing the "Vicinity search" optimization
    method, and generously sharing information on the method and its
    implementation. By sharing his ideas and insights on the subject,
    he has made a significant and lasting contribution to the Sokoban
    game itself, transcending the implementation of the algorithm in
    the YASS optimizer.

    Features
    --------
    The program offers two independent features:
    * Search for solutions of Sokoban puzzles.
    * Search for improvements of existing solutions.

    Solving and optimizing Sokoban puzzles are complicated tasks for a
    computer program, so the program can only handle small puzzles.

    The solver can find push-optimal solutions for some small puzzles,
    whereas other puzzles may be solved without a push-optimality guarantee.

    Please note that the found push-optimal solutions are not optimized
    for moves, i.e., there may be other solutions with the same number of
    pushes, but with fewer non-pushing moves.
}

{///$DEFINE CONSOLE_APPLICATION}               {either CONSOLE_APPLICATION, or PLUGIN_MODULE}
{or}
{$DEFINE PLUGIN_MODULE}                        {a plug-in module (a dll on the Windows platform)}

{$IFDEF CONSOLE_APPLICATION}
  {$UNDEF PLUGIN_MODULE}                       {for safety}
{$ELSE}
  {$DEFINE PLUGIN_MODULE}
{$ENDIF}

{///$DEFINE DELPHI}                            {compiler: use only one of these: DELPHI of FPC}
{$DEFINE FPC}                                  {compiler: use only one of these: DELPHI of FPC}

{///$DEFINE WINDOWS}                           {use this on the Windows platform only}

{$IFDEF DELPHI}
  {$APPTYPE CONSOLE}                           {use this with DELPHI only}
  {$UNDEF FPC}                                 {for safety}
  {$M 1048576,2097152}                         {stack size, minimum 1 MiB}
  {///$STACKCHECKS ON}                         {stack checks, only for debugging}
{$ENDIF}
      
{$IFDEF FPC}
  {$MODE DELPHI} {$PACKENUM 1}                 {use this with FPC only}
  {$UNDEF DELPHI}                              {for safety}
  {$M 1048576,0}                               {stack size, minimum 1 MiB}
{$ENDIF}

{$DEFINE LIGHTWEIGHT_DEADLOCK_GENERATION}      {this generates a reasonable number of deadlocks and works pretty fast}

{$R-}                                          {'R-': range checking disabled}

{$IFDEF CONSOLE_APPLICATION}
  Program YASS;                                {YASS - Yet Another Sokoban Solver and Optimizer - For Small Levels}
{$ELSE}
  unit YASS;                                   {if it isn't compiled as a console program then compile it as a unit, i.e, a module}
  interface
{$ENDIF}

{$IFDEF WINDOWS}
  {$IFDEF PLUGIN_MODULE}
  uses         SysUtils, Windows;              {for exception handling, e.g., in 'GetAsMuchMemoryAsPossible'}
  {$ELSE}
  uses         Windows;                        {for timing and memorystatus}
  {$ENDIF}
{$ELSE}
  {$IFDEF PLUGIN_MODULE}
  uses         SysUtils;                       {for exception handling, e.g., in 'GetAsMuchMemoryAsPossible'}
  {$ENDIF}
{$ENDIF}

{General Constants}

const
  ASTERISK                 = '*';              {ascii characters}
  BACKSLASH                = '\';
  COLON                    = ':';
  COMMA                    = ',';
  CR                       = Chr(13);
  DOUBLE_QUOTE             = '"';
  EQUAL                    = '=';
  HYPHEN                   = '-';
  LAZY_COLON               = '..';
  LEFT_BRACKET             = '[';
  LEFT_PAREN               = '(';
  LF                       = Chr(10); CRLF = CR+LF;
  NL                       = CRLF; {newline}
  NULL_CHAR                = Chr(0);
  PERIOD                   = '.';
  QUOTE                    = '''';
  RIGHT_BRACKET            = ']';
  RIGHT_PAREN               = ')';
  SEMICOLON                = ';';
  SLASH                    = '/';
  SPACE                    = ' ';
  TAB                      = Chr(9);
  UNDERSCORE               = '_';

  MAXIMUM_ASCII_CODE_POINT = 127; {must be a (2^N)-1 number, where N is a non-negative integer; ASCII characters are 7-bit character code points}

  ONE_KIBI                 = 1024;                                              {"kibi" used to be 'kilo' before year 2000}
  ONE_THOUSAND             = 1000;

  ONE_MEBI                 = ONE_KIBI*ONE_KIBI;                                 {"mebi" used to be "mega" before year 2000}
  ONE_MILLION              = ONE_THOUSAND*ONE_THOUSAND;

  SIXTEEN_KIBI             = 16*ONE_KIBI;

{Constants and type declarations required before declaring other constants and other types}

type                                           {first some number types}
  Int8                     = ShortInt;         {nobody can remember that 'SmallInt'  means signed   16 bit integer in Delphi4, hence, this alias comes in handy}
  UInt8                    = Byte;             {'byte' is ambiguous; in Delphi4 it's an unsigned 8-bit number, but some other languages have different conventions; therefore, the 'UInt8' alias comes in handy}
  Int16                    = SmallInt;         {nobody can remember that 'SmallInt'  means signed   16 bit integer in Delphi4, hence, this alias comes in handy}
  UInt16                   = Word;             {for historical reasons,  'Word'      means unsigned 16 bit integer in Delphi4, but it's problematic to use a term like that with newer processors}
  UInt32                   = Cardinal;         {for historical reasons,  'Cardinal'  means unsigned 32 bit integer in Delphi4, but it's problematic to use a term like that with newer processors}
  UInt                     = Cardinal;         {unsigned machine word integer; must be the same size as a pointer}

  TTimeMS                  = {$IFDEF WINDOWS} DWORD; {$ELSE} UInt32; {$ENDIF}

const
  BITS_PER_BYTE            = 8;
  BITS_PER_INTEGER         = BITS_PER_BYTE*SizeOf(Integer);
  BITS_PER_UNSIGNED_INTEGER= BITS_PER_BYTE*SizeOf(UInt);
  MAX_BOARD_WIDTH          = 50;
  MAX_BOX_COUNT            = High(UInt8);      {limited by the slot 'BoxNo' in 'TMove'; must be a 2^N-1 number where 'N' is an integer > 0, so the value can be used as a bit mask to isolate a box number or a goal number}
  MAX_HISTORY_BOX_MOVES    = 700;              {actually, it's pushes, not moves; originally it was limited by stack-size, but the tables for the recursive search are now allocated outside the stack; each +100 pushes cost ~1 MiB extra static data area}
  MAX_OPTIMIZER_SEARCH_DEPTH
                           = 99;               {must be < 'MAX_HISTORY_BOX_MOVES' div 4}
  MAX_ROOM_COUNT           = High(UInt8);      {maximum number of rooms on the board}
  MAX_SMALL_BOX_SET_COUNT  = BITS_PER_INTEGER; {must be a power of 2 so 'MAX_SMALL_BOX_SET_COUNT-1' can be used as a bit mask for modulo calculations}

  MAX_VICINITY_BOX_COUNT   = 4;                {for optimizer pruning; the number of boxes that are allowed to move for each position on the existing best path, i.e., the "spine"}
  BOX_GOAL_BIT_MASK        = High(MAX_BOX_COUNT); {since it's a mask, it must be a 2^N-1 number where 'N' is an integer > 0}

  {Sokoban plugin flags must match the Sokoban plugin specification}
  SOKOBAN_PLUGIN_FLAG_UNSOLVED
                           = 0;
  SOKOBAN_PLUGIN_FLAG_SOLUTION
                           = 1;
  SOKOBAN_PLUGIN_FLAG_MOVES
                           = 2;
  SOKOBAN_PLUGIN_FLAG_PUSHES
                           = 4;
  SOKOBAN_PLUGIN_FLAG_BOX_LINES
                           = 8;
  SOKOBAN_PLUGIN_FLAG_BOX_CHANGES
                           = 16;
  SOKOBAN_PLUGIN_FLAG_PUSHING_SESSIONS
                           = 32;
  SOKOBAN_PLUGIN_FLAG_PLAYER_LINES
                           = 64;
  SOKOBAN_PLUGIN_FLAG_SECONDARY_MOVES
                           = 128;
  SOKOBAN_PLUGIN_FLAG_SECONDARY_PUSHES
                           = 256;
  SOKOBAN_PLUGIN_FLAG_SECONDARY_BOX_LINES
                           = 512;
  SOKOBAN_PLUGIN_FLAG_SECONDARY_BOX_CHANGES
                           = 1024;
  SOKOBAN_PLUGIN_FLAG_SECONDARY_PUSHING_SESSIONS
                           = 2048;
  SOKOBAN_PLUGIN_FLAG_SECONDARY_PLAYER_LINES
                           = 4096;
type
  TAxis                    = (aVertical,aHorizontal);
  TBoxNo                   = 0..MAX_BOX_COUNT;
  PBoxNo                   = ^TBoxNo;
  TBoxSet                  = set of TBoxNo;
  TBoxSetWithCount         = record
    Count                  : Integer; {number of boxes in the set}
    BoxSet                 : TBoxSet; {box number bit set}
                             end;
  TDirection               = (dUp,dLeft,dDown,dRight); {order must not change, e.g., the directions must be listed in alternate axis order; see also 'TDeadlockSetFlag' for more constraints}
  TDirectionArrayOfIntegers
                           = array[TDirection] of Integer;
  TDirectionMap            = array[TDirection] of TDirection;
  TDirectionSet            = set of TDirection;
  {caution: if more directions are added to 'TDirection' (e.g., for the Hexoban variant), then 'TDeadlockSetFlag' must be updated accordingly}
  TDeadlockSetFlag         = (dsfControllerSet,dsfDiagonalCenterSquares,dsfFreezeSet,
                              dsfHasDisconnectedInnerFloors,
                              dsfHasOnlyListedFloors,
                              dsfHasUnspecifiedInnerFloors,
                              dsfIsADeadlock,
                              dsfIsADeadlockButTableOverflow,
                              dsfIsANoProgressDeadlockCandidate,
                              dsfIsANoProgressPattern, {a no-progress-pattern is not necessarily a deadlock}
                              dsfIsAnOverflowSet,
                              dsfIsOnlyADeadlockForListedPlayerAccessAreasOutsideFence, {meaning the deadlock status cannot be deducted from the status and reachability of squares inside the fenced-in area for a corral-type deadlock}
                              dsfPlayerIsInsideSet,dsfPlayerMustBeOutsideSet,
                              dsfTestForFreezingSquare,dsfTestFrozenGoalsSet,
                              dsfUp,dsfLeft,dsfDown,dsfRight);
  TGoalSet                 = TBoxSet;
  TLevelStatisticsFlag     = (lsfMovesImproved,lsfOptimalSolution,lsfPushesImproved,lsfSecondaryMetricsImproved);
  TLevelStatisticsFlags    = set of TLevelStatisticsFlag;
  TMove                    = packed record BoxNo:TBoxNo; Direction:TDirection; end; {'packed': sequence of unaligned slots, without gaps}
  THashValue               = Int64;
  THistory                 = record
    Count                  : Integer;
    Moves                  : array[0..MAX_HISTORY_BOX_MOVES] of TMove;
                             end;
  TOptimization            = (opMovesPushes,opPushesMoves,opPushesOnly,opBoxLinesMoves,opBoxLinesPushes); {order must not change, and the two boxlines optimizations must be the last ones; see also 'OPTIMIZATIONS_TO_SOKOBAN_PLUGIN_FLAGS'}
  TOptimizationMethod      = (omBoxPermutations,omBoxPermutationsWithTimeLimit,omRearrangement,omVicinitySearch,omGlobalSearch); // order cannot change; except for the first element (the fallback strategy), they are defined in method invocation order
  TOptimizationMethodEnabled
                           = array[TOptimizationMethod] of Boolean;
  TOptimizationMethodOrder = array[0..Ord(High(TOptimizationMethod))-Ord(Low(TOptimizationMethod))] of TOptimizationMethod; // element 0 must always be the fallback strategy 'omBoxPermutations'
  TOptimizationMethodSet   = set of TOptimizationMethod;
  TPluginResult            = (prOK,
                              prConstraintsViolation,
                              prInvalidLevel,
                              prUnsolvable,
                              prUnsolved,
                              prGameTooLong,
                              prInvalidSettings,
                              prFailed,
                              prTimeout,
                              prTerminatedByUser);
  TScore                   = UInt16;   {e.g., scores and pushes in a position stored in the transposition table; see 'TPosition'}
  TSearchLimits            = record    {limits controlling the currently running search; solving or optimizing a level may require multiple searches with different limits}
    DepthLimit             : Integer;  {maximum search depth}
    PushCountLimit         : Int64;    {maximum number of pushes}
    TimeLimitMS            : TTimeMS;  {maximum search time, milliseconds}
                             end;
  TSearchMethod            = (smBackward,smForward,smOptimize,smPerimeter);
  TSmallBoxSet             = set of 0..MAX_SMALL_BOX_SET_COUNT-1; {game box numbers [1..n] are mapped to set box numbers [0..n-1]}
  TSquareColor             = (scWhite,scLightGray,scDarkGray,scBlack); {order must not change; meaning in deadlock set calculation: outside square, floor, box, wall}
  TTimeStamp               = UInt32;
  TVicinitySettings        = array[0..MAX_VICINITY_BOX_COUNT+1] of Integer;     {the vicinity settings are right-justified and in descending order with first and last element as zero-value sentinels}

{Constants}

const
  BOX                      = 1;                {board, internal representation}
  FLOOR                    = 2;
  GOAL                     = 4;
  PLAYER                   = 8;
  WALL                     = 16;
  BOARD_PIECES             = BOX + FLOOR + GOAL + PLAYER + WALL;

  FLAG_BOX_REACHABLE_SQUARE= 32;               {flags used for each square}
  FLAG_BOX_START_SQUARE    = 64;
  FLAG_GATE_SQUARE         = 128;
  FLAG_ILLEGAL_BOX_SQUARE  = 256;
  FLAG_NOT_SELECTED_SQUARE = 512;
  FLAG_SQUARE_SET          = 1024;
  FLAG_TUNNEL_UP           = 2048;
  FLAG_TUNNEL_LEFT         = 4096;
  FLAG_TUNNEL_DOWN         = 8192;
  FLAG_TUNNEL_RIGHT        = 16384;
  FLAG_VISITED_SQUARE      = 32768;
  BOARD_SQUARE_FLAGS       = FLAG_BOX_REACHABLE_SQUARE+FLAG_BOX_START_SQUARE+FLAG_GATE_SQUARE+FLAG_ILLEGAL_BOX_SQUARE+
                             FLAG_NOT_SELECTED_SQUARE+FLAG_SQUARE_SET+
                             FLAG_TUNNEL_UP+FLAG_TUNNEL_LEFT+FLAG_TUNNEL_DOWN+FLAG_TUNNEL_RIGHT+
                             FLAG_VISITED_SQUARE;

  CH_BOX                   = 'b'; CH_BOX_ON_GOAL           = 'B'; {all board characters and move characters must be 7-bit ASCII characters}
  CH_BOX_XSB               = '$'; CH_BOX_ON_GOAL_XSB       = '*';
  CH_GOAL                  = '.';
  CH_FLOOR                 = SPACE;
  CH_PLAYER                = 'p'; CH_PLAYER_ON_GOAL        = 'P';
  CH_PLAYER_XSB            = '@'; CH_PLAYER_ON_GOAL_XSB    = '+';
  CH_SQUARE_SET            = '%';
  CH_WALL                  = '#';

  ALL_DIRECTIONS_SET       : TDirectionSet = [dUp,dLeft,dDown,dRight]; {caution: after adding more directions to 'TDirection' (e.g., for the Hexoban variant), this constant must be updated accordingly}
  AXIS_COUNT               = Succ(Ord(High(TAxis))-Ord(Low(TAxis))); {number of axis}
  AXIS_TO_TEXT             : array[TAxis] of String
                           = ('vertical','horizontal');
  BOX_BIT_SHIFT_COUNT      = 16;                         {goal numbers/packing order set numbers and box numbers are stored in the upper bits of each board square}
  CORRAL_BOX_SQUARES_MEMORY_BLOCK_BYTE_SIZE              {memory blocks for corral position box squares are dynamically allocated; the blocks are "stolen" from the transposition table memory block}
                           = 16* ONE_KIBI;
  DEADLOCK_SCORE           = High(TScore);               {must be 'TScore' high value}
  DEAD_END_SCORE           = DEADLOCK_SCORE-1;           {must be 1 less than 'DEADLOCK_SCORE'}
  DEFAULT_BOXES_NOT_ON_BEST_PATH_LIMIT
                           = MaxInt div 2;
  DEFAULT_DEADLOCK_SETS_ADJACENT_OPEN_SQUARES_LIMIT      {limits the search for expanded deadlock-sets}
                           = 1;
  DEFAULT_DEADLOCK_SETS_BOX_LIMIT_FOR_PRECALCULATED_SETS
                           = 8;                          {limits the search for expanded deadlock-sets}
  DEFAULT_DEADLOCK_SETS_BOX_LIMIT_FOR_DYNAMIC_SETS
                           = 16;                         {box limit for dynamically calculated deadlock sets during the search (solver only)}
  DEFAULT_LOG_FILE_ENABLED = False;
  DEFAULT_MEMORY_BYTE_SIZE = 64*ONE_MEBI;                {64 MiB}
  DEFAULT_PUSH_COUNT_LIMIT : Int64 = High(Int64);        {number of pushes to generate before giving up; high-value of a 64-bit integer amounts to 'unlimited'; if the value is lowered, then the text in 'ShowHelp()' must change accordingly}
  DEFAULT_MOVE_STEP_INCREMENT
                           = 5;
  DEFAULT_OPTIMIZATION     = opPushesMoves;              {optimize pushes and moves}
  DEFAULT_OPTIMIZER_BOX_PERMUTATIONS_SEARCH_TIME_LIMIT_MS {the optimizer's box-permutations-search iterates the number of boxes until an iteration exceeds the time limit}
                           = 15*ONE_THOUSAND;
  DEFAULT_OPTIMIZER_ENABLED= True;                       {'True': perform small optimizations after the solver has found a solution; not to be confused with the optimizer module}
  DEFAULT_OPTIMIZER_FALLBACK_STRATEGY_ENABLED            {the default optimization strategy is the "N-box permutations", but without the time-limit that governs this method when it runs as one of the 3 selectable methods}
                           = False;
  DEFAULT_OPTIMIZER_SEARCH_DEPTH
                           = MAX_OPTIMIZER_SEARCH_DEPTH;
  DEFAULT_PACKING_ORDER_BOX_COUNT_THRESHOLD
                           = 9;                          {packing-order solving is only activated if the number of boxes >= 'threshold'}
  DEFAULT_PACKING_ORDER_ENABLED
                           = True;
  DEFAULT_REUSE_NODES_ENABLED
                           = False;                      {'True': simple-memory-bounded search (SMA) (it has not been tested for a long time, and it may need refreshment before it works again}
  DEFAULT_SEARCH_DEPTH     = MAX_HISTORY_BOX_MOVES;      {caution: texts in 'ShowHelp' must change if the value differs from the maximum value}
  DEFAULT_SEARCH_METHOD    = smPerimeter;
  DEFAULT_SEARCH_TIME_LIMIT_MS
                           = 10 {minutes} * 60 {seconds} * 1000 {milliseconds};
  DEFAULT_STOP_WHEN_SOLVED = True;                       {'True': stop when a solution has been found, i.e., don't search for shorter solutions}
  DEFAULT_VICINITY_SETTINGS: TVicinitySettings = (0,0,0,20,10,0); {the vicinity settings are right-justified and in descending order with first and last element as zero-value sentinels}
  DIRECTION_BIT_COUNT      = 3;                          {caution: must cover the number of directions}
  DIRECTION_BIT_MASK       = (1 shl DIRECTION_BIT_COUNT)-1;
  DIRECTION_COUNT          = Succ(Ord(High(TDirection))-Ord(Low(TDirection))); {number of directions}
  DIRECTION_TO_AXIS        : array[TDirection] of TAxis
                           = (aVertical,aHorizontal,aVertical,aHorizontal);
  DIRECTION_TO_CHAR        : array[TDirection] of Char
                           = ('u','l','d','r');          {caution: must be lowercase, otherwise modify 'CharToDirection'}
  DIRECTION_TO_DEADLOCK_SET_FLAG
                           : array[TDirection] of TDeadlockSetFlag
                           = (dsfUp,dsfLeft,dsfDown,dsfRight);
  DIRECTION_TO_TEXT        : array[TDirection] of String
                           = ('up','left','down','right');
  DIRECTION_TO_TUNNEL_FLAG : array[TDirection] of Cardinal
                           = (FLAG_TUNNEL_UP,FLAG_TUNNEL_LEFT,FLAG_TUNNEL_DOWN,FLAG_TUNNEL_RIGHT);
  {caution: if more directions are added to 'TDirection' (e.g., for the Hexoban variant), then 'DIRECTION_TO_TUNNEL_FLAGS' must be updated accordingly}
  DIRECTION_TO_TUNNEL_FLAGS: Cardinal=FLAG_TUNNEL_UP+FLAG_TUNNEL_LEFT+FLAG_TUNNEL_DOWN+FLAG_TUNNEL_RIGHT;
  EMPTY_GOAL_PENALTY       = 32;               {penalty per unfilled target square (goal or parking space) during a packing order search; preferably a 2^n number for fast multiplications}
  FLAG_POSITION_BASE       = 1;
  FLAG_POSITION_VISITED    = 2;
  GAME_LINE_LENGTH         = 70;               {print line length for games, i.e., solutions and snapshots}
  GOAL_BIT_SHIFT_COUNT     = 24;               {each square on the board contains its goal number or packing order set number, if any, in the upper bits}
  GRAPH_FILE_EXT           = '.tmp';           {the nodes from the backward search are temporarilty saved to a disk file when the solver performs a perimeter search, i.e., a backward search followed by a forward search}
  INFINITY                 = (MaxInt div 2)-1; {(-INFINITY), (2*INFINITY), and (2*(-INFINITY)) must be legal integer values}
  LOG_FILE_EXT             = '.log';
  MAX_BACKWARD_SEARCH_POSITIONS                {saving the entire game graph to disk can be a time-consuming task; in order to reserve time for a subsequent forward search, the backward search doesn't necessarily use all the available memory}
                           = High(Integer);    {'High': unlimited, i.e., use all the available memory, also for the backward search}
  MAX_BOARD_HEIGHT         = MAX_BOARD_WIDTH;
  MAX_BOARD_SIZE           = (MAX_BOARD_WIDTH+2) * (MAX_BOARD_HEIGHT+2); {'0' left/top border; '+1': right/bottom border}
  MAX_BOX_CHANGES_OPTIMIZATION_TIME_LIMIT_MS
                           = High(TTimeMS);    //30 * ONE_THOUSAND; {limit for the box-changes optimization; without a limit, large wide open levels may run 'forever'}
  MAX_BOX_COUNT_FOR_CALCULATING_MINIMUM_LOWER_BOUND
                           = 100;              {with more boxes it may take a long time to calculate a lower bound}
  MAX_DEADLOCK_SEARCH_DEPTH
                           = 50;               {maximum search depth for the deadlock search which tries to prove that a given game state is a deadlock}
  MAX_DEADLOCK_SET_CANDIDATE_PUSH_COUNT
                           = 100*ONE_THOUSAND; {arbitrary limit but the hope is to ensure a reasonable bound on the running time}
  MAX_DEADLOCK_SETS        = 16*ONE_KIBI;      {must be <= High( Int16 ); typically, there aren't more than 500-600 precalculated deadlock sets, and with more sets the performance begins to suffer}
  MAX_DEADLOCK_SETS_PER_SQUARE
                           = MAX_DEADLOCK_SETS;{arbitrary maximum number of deadlock set numbers per square; it must be bigger than 'MIN_DEADLOCK_SETS_PER_SQUARE'}
  MAX_DEADLOCK_SETS_SQUARES_OUTSIDE_FENCE      {'outside-fence' squares are only saved for some of the deadlock sets}
                           = 8*ONE_KIBI;
  MAX_DEADLOCK_SETS_SEARCH_TIME_MS
                           = 5 * 60 * ONE_THOUSAND; {arbitrary limit but should provide a reasonable bound on the running time}
  MAX_EXPAND_DEADLOCK_SET_PUSH_COUNT
                           = 10000;            {limit the number of pushes for attempts to derive new deadlock patterns after having proved that a pattern is a deadlock}
  MAX_HISTORY_PLAYER_MOVES = Pred(High(TScore)); {limited by the slot 'Height' in 'TPosition'}
  MAX_OPTIMIZER_BACKWARD_SEARCH_POSITIONS_COUNT
                           = 100*ONE_THOUSAND; {the size is rather critical; the backward search only plays a supporting role, and a too large limit will waste time as well as positions in the transposition table}
  MAX_OPTIMIZER_SEARCH_DEPTH_FOR_ADDING_BEST_PATH_PERMUTATIONS
                           = 50;               {'50': a rather arbitrary depth limit (push count limit), but it must small enough to guard against stack overflow and to ensure that the transposition table isn't filled with best path permutations}
  MAX_OPTIMIZER_SUCCESSIVE_GLOBAL_OPTIMIZATION_SEARCHES
                           = 1;                {the optimizer performs this number of successful global-optimization searches before it changes optimization method}
  MAX_PACKING_ORDER_CALCULATION_TIME_MS        {maximum time for precalculation of a packing order; a somewhat arbitrary limit, but the precalculation should not take up too large a fraction of the total running time}
                           = 90 {seconds} * ONE_THOUSAND; {milliseconds}
  MAX_PACKING_ORDER_PARK_BOXES_ATTEMPTS         {maximum park-box attempts for the packing order calculation; the number should be small enough to guarantee a reasonably small running time upper bound}
                           =400*ONE_KIBI;
  MAX_SEARCH_TIME_LIMIT_MS = High(Integer)-1001; {'-1001': high-values are reserved for meaning 'unlimited'}
  MAX_SINGLE_STEP_MOVES    = MAX_BOARD_WIDTH*MAX_BOARD_HEIGHT+DIRECTION_COUNT*MAX_BOX_COUNT;
  MAX_TRANSPOSITION_TABLE_BYTE_SIZE            {limit the transposition table byte size to a signed integer and leave some memory free for other purposes}
                           : Integer
                           =
                           {$IFDEF PLUGIN_MODULE}
                             (MaxInt div 10) * 9; {only use 90% of the total memory address space; the host program might run other memory-consuming tasks in parallel with the plug-in}
                           {$ELSE}
                             MaxInt - 16*ONE_MEBI;
                           {$ENDIF}
  MAX_VICINITY_SQUARES     = {MAX_BOARD_WIDTH*MAX_BOARD_HEIGHT} 999; {the only reason for the 999-limit is that it allows a settings window to operate with 3-digits only for the spin-edit controls}
  MIN_BOX_LIMIT_FOR_DYNAMIC_DEADLOCK_SETS      {calculating and storing dynamic deadlock sets are time-consuming operations; the minimum box limit must be reasonably small}
                           = 6;
  MIN_DEADLOCK_SETS_PER_SQUARE
                           = 255;              {arbitrary minimum number of elements in a vector with deadlock set numbers, but it should at least provide room for closed edges}
  MIN_NO_PROGRESS_DEADLOCK_SET_CANDIDATE_BOX_COUNT
                           = 3;                {threshold for checking whether not-pushed boxes should be checked for being deadlocked}
  MIN_SEARCH_TIME_FOR_EACH_SEARCH_METHOD_MS    {if there is less search time left, then special rules apply regarding which solver methods to use; for instance, one of the methods may get all the running time instead of giving all methods a try}
                           = 60 {seconds} * ONE_THOUSAND; {milliseconds}
  NEXT_DIRECTION           : TDirectionMap {next anti-clockwise direction}
                           = (dLeft,dDown,dRight,dUp);
  OPPOSITE_DIRECTION       : TDirectionMap
                           = (dDown,dRight,dUp,dLeft);
  OPTIMIZATION_METHOD_TO_CHAR {must be uppercase characters 'A'..'Z'; they are used for parsing, e.g., in 'GetCommandlineParameters()'}
                           : array[TOptimizationMethod] of Char
                           = ('B','P','R','V','G'); {Box permutations, Box permutations with time limit, Rearrangement, Vicinity search, Global search}
  OPTIMIZATIONS_TO_SOKOBAN_PLUGIN_FLAGS
                           : array[TOptimization] of Integer
                           = (SOKOBAN_PLUGIN_FLAG_MOVES    +SOKOBAN_PLUGIN_FLAG_SECONDARY_PUSHES,  {opMovesPushes}
                              SOKOBAN_PLUGIN_FLAG_PUSHES   +SOKOBAN_PLUGIN_FLAG_SECONDARY_MOVES,   {opPushesMoves}
                              SOKOBAN_PLUGIN_FLAG_PUSHES,                                          {opPushesOnly}
                              SOKOBAN_PLUGIN_FLAG_BOX_LINES+SOKOBAN_PLUGIN_FLAG_SECONDARY_MOVES,   {opBoxLinesMoves}
                              SOKOBAN_PLUGIN_FLAG_BOX_LINES+SOKOBAN_PLUGIN_FLAG_SECONDARY_PUSHES); {opBoxLinesPushes}


  {if a level falls below the following threshold pair, the optimizer's}
  {box-permutations-search stops, assuming the level is so small that it's better}
  {to spend the time on the global optimization search}
  OPTIMIZER_BOX_PERMUTATIONS_SEARCH_SMALL_LEVEL_THRESHOLD_BOXES
                           = 5;
  OPTIMIZER_BOX_PERMUTATIONS_SEARCH_SMALL_LEVEL_THRESHOLD_TIME_MS
                           = 1500;

  OPTIMIZER_GLOBAL_OPTIMIZATION_UPDATE_DELAY_POSITIONS
                           // = 0; {'0': '1000' is a reasonable size to see how it works, and to see that it can reduce the running time in levels with recurring updates}
                           = 1000;
  OPTIMIZER_GLOBAL_OPTIMIZATION_UPDATE_IMMIDIATELY_THRESHOLD
                           = 5; {when the savings in the number of moves in a new better path to a position is less than the threshold, then the position is put on a delay-queue for later batch-updating; it's not put directly on the open-queue}

  PLAYER_POSITION_MOVE_AXIS= 1 shl (BITS_PER_BYTE*SizeOf(UInt16)-1);            {the high-bit in 'TPosition.PlayerPos' is used for the move-axis}
  PLAYER_POSITION_MASK     = PLAYER_POSITION_MOVE_AXIS-1;

  PLAYERS_REACHABLE_SQUARES_TIMESTAMP_UPPER_BOUND                   {timestamp upper bound; timestamps wrap around when the upper bound is reached; at that time the individual squares are reset to '0' for floors and 'high-value' for wall squares}
                           = High(TTimeStamp)-2*5*MAX_BOARD_SIZE;   {'*5': must be >= '*5' to ensure that 'CalculatePlayersDistanceToReachableSquares' works correctly}
                                                                    {'*2': so 'CalculatePlayersReachableSquares' and 'CalculateCorralSquares' starting with cleared timestamps can visit all player access areas without timestamp wrap around}

  POSITION_BEST_PATH_TAG   : UInt8 = 1 shl (DIRECTION_BIT_COUNT);   {flag-bit in 'TPosition.Move.Direction'; optimizer only}
  POSITION_DEADLOCK_TAG    : UInt8 = 1 shl (DIRECTION_BIT_COUNT+4); {flag-bit in 'TPosition.Move.Direction'; solver only; the value must be '1 shl (DIRECTION_BIT_COUNT+4)'}
  POSITION_NO_LEGAL_PUSHES_TEST_TAG
                           : UInt8 = 1 shl (DIRECTION_BIT_COUNT+2); {flag-bit in 'TPosition.Move.Direction'; solver-corrals only; must match 'POSITION_PATH_TAG' which isn't used used in connection with solver-corrals}
  POSITION_NOT_STORED_DEADLOCK_TAG
                           : UInt8 = 1 shl (DIRECTION_BIT_COUNT+3); {flag-bit in 'TPosition.Move.Direction'; solver-corrals only; must match 'POSITION_REVISIT_TAG' which isn't used in connection with solver-corrals}
  POSITION_OPEN_TAG        : UInt8 = 1 shl (DIRECTION_BIT_COUNT+1); {flag-bit in 'TPosition.Move.Direction'}
  POSITION_PACKING_ORDER_TAG
                           : UInt8 = 1 shl (DIRECTION_BIT_COUNT);   {flag-bit in 'TPosition.Move.Direction'; solver only; the value must be '1 shl DIRECTION_BIT_COUNT', e.g., see 'DoPush()' and 'UndoPush()'}
  POSITION_PATH_TAG        : UInt8 = 1 shl (DIRECTION_BIT_COUNT+2); {flag-bit in 'TPosition.Move.Direction'}
  POSITION_REVISIT_TAG     : UInt8 = 1 shl (DIRECTION_BIT_COUNT+3); {flag-bit in 'TPosition.Move.Direction'; solver only}
  POSITION_TARGET_TAG      : UInt8 = 1 shl (DIRECTION_BIT_COUNT+4); {flag-bit in 'TPosition.Move.Direction'; optimizer only}
//POSITION_TARGET_PATH_TAG : UInt8 = 1 shl (DIRECTION_BIT_COUNT+4); {flag-bit in 'TPosition.Move.Direction'; optimizer only}
  POSITION_TARGET_PATH_TAG : UInt8 = 0;                             {flag-bit in 'TPosition.Move.Direction'; optimizer only; not in production}
  POSITION_VISITED_TAG     : UInt8 = 1 shl (DIRECTION_BIT_COUNT+3); {flag-bit in 'TPosition.Move.Direction'; optimizer only}

{ POSITION_POINTER_FLAGS   = FLAG_POSITION_BASE+FLAG_POSITION_VISITED;}
{ POSITION_POINTER_MASK    : Integer = (not POSITION_POINTER_FLAGS);}
  PREVIOUS_DIRECTION       : TDirectionMap {previous anti-clockwise direction}
                           = (dRight,dUp,dLeft,dDown);
  REARRANGEMENT_OPTIMIZATION_KEEP_EXISTING_BOX_SESSIONS_PATH_LENGTH_THRESHOLD
                           = 1500; {if the path length of the game >= threshold, then the global optimization limits the exponential growth by keeping the existing box-sessions when it calls 'RearrangementOptimization()'}
  ROOM_PRUNING_ROOM_SIZE_THRESHOLD
    {room pruning narrows the search down to box pushes inside the current room }
    {if the last push doesn't seem to involve the global game state outside the }
    {room; room pruning makes the solver search incomplete;                     }
    {YASS re-expands positions if no solutions are found in the room-pruned part}
    {of the game graph, hence, the threshold can be as low as '2'; otherwise,   }
    {the threshold  - because of the incompleteness - should be so high that    }
    {room pruning only is triggered for large levels, where an exhaustive search}
    {probably is out of reach anyway; '16' may be a good threshold in that case;}
                           = 2;
  SEARCH_STATE_INDEX_CORRAL_PRUNING                   {the corral pruning needs to calculate the player's reachable squares inside each "pocket" or "room" on the board made by the boxes}
                           = MAX_HISTORY_BOX_MOVES+4; {must be the highest index in the 'TSolver.SearchStates' vector because it's used in the vector declaration; see also 'SEARCH_STATE_INDEX_DO_PUSH'}
  SEARCH_STATE_INDEX_DO_PUSH
                           = MAX_HISTORY_BOX_MOVES+3; {private 'TSolver.SearchStates' vector member for 'DoPush()' and 'IsALegalPush()'; see also 'SEARCH_STATE_INDEX_CORRAL_PRUNING'}
  SEARCH_STATE_INDEX_SCRATCHPAD_1
                           = MAX_HISTORY_BOX_MOVES+2; {'TSolver.SearchStates' vector member scratchpad 1}
  SEARCH_STATE_INDEX_VISITED_ACCESS_AREA_FOR_CHECKING_DEADLOCK_CANDIDATE_SEARCH
                           = MAX_HISTORY_BOX_MOVES+1; {'TSolver.SearchStates' vector member scratchpad 1}

  SOKOBAN_PLUGIN_STATUS_TEXT_BUFFER_SIZE
                           = 256; {must match the Sokoban plugin specification; includes null-character terminator}
  SOKOBAN_FILE_EXT         = '.sok';
  SOKOBAN_PLUGIN_CALL_BACK_FUNCTION_THRESHOLD_TIME_MS
                           = 3 {seconds} * 1000 {milli seconds};
  SOLVER_PROGRESS_CHECK_POINT_INTERVAL
                           = 10*ONE_THOUSAND; {check for progress each time this number of positions have been expanded}
  TT_AVERAGE_BUCKET_SIZE   = 16; {transposition table: on average, each lookup visits half the number of items in a bucket}

{Texts}

  TEXT_APPLICATION_COPYRIGHT
                           = 'Copyright (c) 2016 by Brian Damgaard';
  TEXT_APPLICATION_TITLE   = 'YASS';
  TEXT_APPLICATION_TITLE_LONG
                           = TEXT_APPLICATION_TITLE+' - Yet Another Sokoban Solver and Optimizer - For Small Levels';
  TEXT_APPLICATION_VERSION_NUMBER
                           = '2.136a';
  TEXT_BACKWARD_SEARCH     = 'Backward search';
  TEXT_BEST_RESULT_SO_FAR  = 'Best result so far: ';
  TEXT_CALCULATING_PACKING_ORDER
                           = 'Calculating packing order';
  TEXT_CREATE_FREEZE_DEADLOCK_SET_FAILED
                           = 'The freeze set in the controller/freeze set pair could not be created because of table overflow, hence, the preceding controller set has been deleted.';
  TEXT_FILE_IO_ERROR       = 'File input/output error';
  TEXT_FILE_READ_ERROR     = 'File read error';
  TEXT_FORWARD_SEARCH      = 'Forward search';
  TEXT_FORWARD_SEARCH_PACKING_ORDER
                           = 'Packing order search';
  TEXT_INTERNAL_ERROR      = 'Internal Error';
  TEXT_LEVEL               = 'Level';
  TEXT_LEVEL_HAS_TOO_MANY_BOXES_AND_GOALS
                           = 'Level has too many boxes/goals';
  TEXT_LEVEL_HAS_TOO_MANY_COLUMNS
                           = 'Level has too many columns';
  TEXT_LEVEL_HAS_TOO_MANY_ROWS
                           = 'Level has too many rows';
  TEXT_LEVEL_HAS_NO_PLAYER = 'Level has no player';
  TEXT_LEVEL_HAS_NOT_THE_SAME_NUMBER_OF_BOXES_AND_GOALS
                           = 'Level has not the same number of boxes and goals';
  TEXT_LEVEL_SOLVED        = 'Level solved';
  TEXT_LEVEL_SOLVED_MAY_NOT_BE_OPTIMAL
                           = TEXT_LEVEL_SOLVED+' (solution may not be optimal)';
  TEXT_LEVEL_UNSOLVABLE    = 'Level not solvable';
  TEXT_LEVEL_UNSOLVED      = 'Level not solved';
  TEXT_MEBI_BYTES          = 'MiB';
  TEXT_MEMORY_FULL         = 'Memory full.';
  TEXT_NO_FILE_ERROR       = 'No file';
  TEXT_NO_YES              : array[Boolean] of String = ('No','Yes');
  TEXT_OPEN                = 'Open';
  TEXT_OPTIMIZING_GAME     = 'Optimizing game...';
  TEXT_PACKING_ORDER       = 'Packing order';
  TEXT_PLUGIN_RESULT       : array[TPluginResult] of String
                           = ('OK',
                              'Constraints violation',
                              'Invalid level',
                              'Unsolvable',
                              'Unsolved',
                              'Game too long',
                              'Invalid settings',
                              'Failed',
                              'Time limit exceeded',
                              'Terminated by user');
  TEXT_PRESS_ENTER         = 'Press [Enter]';
  TEXT_PUSHES              = 'pushes';
  TEXT_PUSH_PULL           : array[Boolean] of String = ('Push','Pull');
  TEXT_SAVE_POSITIONS_TO_DISK
                           = 'Saving positions to disk...';
  TEXT_SEARCH_STATUS_BOX_PERMUTATIONS
                           = '-box permutations: Pushes ';
  TEXT_SEARCH_STATUS_GLOBAL_OPTIMIZATION
                           = '  (Global optimization: Transposition table: ';
  TEXT_SEARCH_STATUS_REARRANGEMENT_OPTIMIZATION
                           = '  (Rearrangement optimization: Pushes ';
  TEXT_SEARCH_STATUS_VICINITY_1
                           = '  (Vicinity search: Positions: ';
  TEXT_SEARCH_STATUS_VICINITY_2
                           = '  (Vicinity search: Position queue: ';
  TEXT_SEARCH_STATUS_VICINITY_3
                           = 'Vicinity search (';
  TEXT_SEARCH_STATUS_VICINITY_4
                           = SPACE+TEXT_MEBI_BYTES+'): Generating positions ';
  TEXT_SEARCH_STATUS_VICINITY_5
                           = 'Vicinity search: ';
  TEXT_SEARCH_DEPTH        = 'Depth: ';

  TEXT_SEARCH_METHOD       : array[TSearchMethod] of String =
    ('backward','forward','optimize','perimeter');
  TEXT_SNAPSHOT            = 'Snapshot';
  TEXT_SOLUTION            = 'Solution';
  TEXT_SOLUTIONS           = 'Solutions';
  TEXT_SOLUTION_INFO_1     = 'Solution: '; {number of pushes is inserted here}
  TEXT_SOLUTION_INFO_2     = ' pushes. Search for a shorter solution continues.';
  TEXT_SOLUTION_METHOD     : array[Boolean] of String =
    ('Move-optimal solutions','Push-optimal solutions');
  TEXT_STATISTICS_FILENAME_SUFFIX
                           =', Statistics.txt';
  TEXT_TERMINATED_BY_USER  = 'Terminated by user';
  TEXT_TIME_LIMIT_EXCEEDED = 'Time-limit exceeded';
  TEXT_TRACING_BEST_FOUND_PATH
                           = 'Tracing best found path';
  TEXT_TRIVIAL_SOLUTION_1  = 'This level has a trivial 0-push solution.';
  TEXT_TRIVIAL_SOLUTION_2  = 'The search continues for a nontrivial solution.';
  TEXT_VERSION             = 'Version';

{Types}

type
  TBoard                   = array[0..MAX_BOARD_SIZE]   of UInt;
  TBoardAsTextLines        = array[0..MAX_BOARD_HEIGHT] of String[255]; //String[MAX_BOARD_WIDTH];
  TBoardOfBooleans         = array[0..MAX_BOARD_SIZE]   of Boolean;
  TBoardOfBoxSets          = array[0..MAX_BOARD_SIZE]   of TBoxSet;
  TBoardOfBytes            = array[0..MAX_BOARD_SIZE]   of UInt8;
  TBoardOfDirectionSets    = array[0..MAX_BOARD_SIZE]   of TDirectionSet;
  TBoardOfGoalSets         = array[0..MAX_BOARD_SIZE]   of TGoalSet;
  TBoardOfIntegers         = array[0..MAX_BOARD_SIZE]   of Integer;
  TBoardOfSquareColors     = array[0..MAX_BOARD_SIZE]   of TSquareColor;
  TBoardOfTimeStamps       = array[0..MAX_BOARD_SIZE]   of TTimeStamp;
  TBoardOfUnsignedIntegers = array[0..MAX_BOARD_SIZE]   of UInt;
  TBoardSquareSet          = record
    Count                  : Integer;
    Squares                : TBoardOfIntegers;
                             end;
  TBoardTimeStamps         = record
    Squares                : TBoardOfTimeStamps;
    TimeStamp              : TTimeStamp;
                             end;
  TBoxArrayOfIntegers      = array[TBoxNo] of Integer;
  TBoxGoalSets             = array[TBoxNo] of TBoxSetWithCount; {for each box/goal, a set of box/goal numbers, e.g., for a mapping from goal numbers to pull-reachable box starting positions for each goal}
  TBoxNumbers              = array[TBoxNo] of TBoxNo;
  TBoxSquare               = Integer; {must be a signed integer-type value so negated values can indicate a flag value for the square}
  PBoxSquare               = ^TBoxSquare;
  TBoxSquare2              = UInt16; {for compact box square vectors, e.g., TCorralPositions.BoxSquare'}
  PBoxSquare2              = ^TBoxSquare2;
  TBoxSquares2             = array[TBoxNo] of TBoxSquare2;
  TBoxSquares              = array[TBoxNo] of TBoxSquare;
  PBoxSquares              = ^TBoxSquares;
  TBoxSquaresMemoryBlock   = record {corral box squares stored in the transposition table together with the normal game positions}
    BoxSquare              : PBoxSquare2; {next free box square       in the memory block allocated for the box squares}
    BoxSquaresCountDown    : Integer;     {number of free box squares in the memory block allocated for the box squares}
                             end;
  TBoxNumberSet            = record
    Count                  : Integer;
    Numbers                : TBoxNumbers;
                             end;
  TBoxSquareSet            = record
    Count                  : Integer;
    Squares                : TBoxSquares;
                             end;
  TColRow                  = packed record Col,Row: UInt8; end;

  TDeadlockSearchHistoryGameState
                           = record
    BoxNo                  : TBoxNo; {last pushed box leading to this position}
    BoxPos                 : TBoxSquares2;
    HashValue              : THashValue;
    PlayerPos              : Integer; {normalized player position}
  end;
  TDeadlockSearchHistory   = array[0..MAX_DEADLOCK_SEARCH_DEPTH]
                             of TDeadlockSearchHistoryGameState;
  TDeadlockSearchTranspositionTable
  {the number of items in the deadlock search transposition table must
   match "highest index + 1" and must be a 2^N number, where N is a
   non-negative integer; the size must be small because each game state produced
   during the search is matched against each item in the transposition table}
                           = array[ 0 .. 127 ] of TDeadlockSearchHistoryGameState;
  TDeadlockSetCapacities   = array[0..MAX_DEADLOCK_SETS] of Integer;
  TDeadlockSetFlagsSet     = set of TDeadlockSetFlag;
  TDeadlockSetCandidate    = record
    Boxes                  : TBoardSquareSet;
    Capacity               : Integer;
    CenterSquare           : Integer;
    EscapedBoxesCountDown  : Integer;
    Flags                  : TDeadlockSetFlagsSet;
    Floors                 : TBoardSquareSet;                           {not necessarily including the center square and its adjacent squares}
    GoalCount              : Integer;
    PaintedFloorCount      : Integer;
    MaxBoxCount            : Integer;                                   {max. allowed number of boxes; may differ from 'Game.BoxCount'}
    SquareColors           : TBoardOfSquareColors;
    SquareOutsideFence     : Integer;                                   {for a fence-type (corral-type) deadlock, a square which is known to be outside the fence}
    SquaresOutsideFence    : TBoardSquareSet;                           {more squares known to be outside the fence}
                             end;
  TDeadlockSetNo           = UInt16;                                    {a deadlock set number}
  TDeadlockSetNumbers      = array [ 0 .. ( MaxInt div SizeOf( TDeadlockSetNo ) ) - 1 ] of TDeadlockSetNo; {vector with deadlock set numbers}
  PDeadlockSetNumbers      = ^TDeadlockSetNumbers;
  TSquareDeadlockSetNumbers
                           = array[0..MAX_BOARD_SIZE] of PDeadlockSetNumbers; {for each square, the deadlock set numbers it's a part of}
  TDeadlockSets            = record
    AdjacentOpenSquaresLimit                                            {limits the search for expanded deadlock-sets}
                           : Integer;
    BoxLimitForDynamicSets : Integer;                                   {limits the storage and computation of dynamic deadlock-sets during level solving}
    BoxLimitForPrecalculatedSets                                        {limits the search for expanded deadlock-sets}
                           : Integer;
    CandidatePushCount     : Integer;                                   {number of generated pushes for current deadlock-set candidate}
    Capacity               : TDeadlockSetCapacities;                    {number of boxes that can be pushed to a deadlock-set without causing an overflow}
    CenterSquare           : array[0..MAX_DEADLOCK_SETS] of Int16;
    ControllerAndFreezeSetPairsEnabled                                  {'True': 'IsALegalPush' takes controller/freeze-set deadlock pairs into account; 'False': 'IsALegalPush' ignores them}
                           : Boolean;
    Count                  : Integer;
    DynamicSetsCount       : Integer;                                   {number of dynamically calculated deadlock-sets}
    PathDeadlockCount      : Integer;                                   {number of deadlocked positions on the current path}
    Flags                  : array[0..MAX_DEADLOCK_SETS] of TDeadlockSetFlagsSet;
    FloorCount             : array[0..MAX_DEADLOCK_SETS] of Int16;
    HashKey                : array[0..MAX_DEADLOCK_SETS] of THashValue;
    History                : TDeadlockSearchHistory;                    {contains all pushes along the current path in the depth-first deadlock search which tries to prove that a game state is a deadlock; allocated globally to reduce runtime stack size}
    SequenceNo             : Integer;                                   {sequential deadlock set numbers for printing; internal numbers differ from sequence numbers when redundant deadlocks are pruned}
    LevelTotalPushCount    : Integer;                                   {total number of generated pushes for all tested candidates for current level}
    NewDynamicDeadlockSets : Boolean;                                   {'True': the solver main loop must backtrack to the start position so new deadlocks are considered when a position is selected for expansion}
    IsALegalPushOverflowingSetsCount                                    {global result value for 'IsALegalPush'}
                           : Integer;
    IsALegalPushOverflowingSets                                         {global result value for 'IsALegalPush'}
                           : array[0..MAX_DEADLOCK_SETS] of Integer;
    PrecalculatedSetsCount : Integer;                                   {number of precalculated deadlock-sets, as opposed to the dynamic deadlock-sets}
    PrecalculatedSquareSetNumbers                                       {for each square, the precalculated deadlock-sets it's a part of}
                           : TSquareDeadlockSetNumbers;
    RedundantSetsCount     : Integer;                                   {newcoming sets may make previously found sets redundant}
    SequenceNumbers        : array[0..MAX_DEADLOCK_SETS] of Integer;    {deadlock-sets are sequentially numbered in the log-file, but redundant sets are pruned, hence, 'Index' and 'SequenceNo' may defer}
    SessionDeadlockSetsCount                                            {total number of deadlock sets for all processed levels}
                           : Integer;
    SessionDeadlockSetsTableOverflowCount                               {total number of deadlock sets not saved because of table overflows for all processed levels}
                           : Integer;
    SessionPlayerMustBeOutsideSetCount
                           : Integer;
    SessionTestedGamesCount
                           : Integer;                                   {total number of tested original games}
    SquaresCount           : array[0..MAX_DEADLOCK_SETS] of Integer;    {number of squares for each set}
    SquareSetCount         : array[0..MAX_BOARD_SIZE]    of Integer;    {for each square, the number of deadlock-sets it's a part of}
    SquareSetNumbers       : TSquareDeadlockSetNumbers;                 {for each square, the deadlock-sets it's a part of}
    SquareOutsideFence     : array[0..MAX_DEADLOCK_SETS] of TBoxSquare2;{for single-room corral-type deadlocks, the most recent player position that has been proved to be outside the fence}
    SquaresOutsideFence    : array[0..MAX_DEADLOCK_SETS_SQUARES_OUTSIDE_FENCE] of TBoxSquare2; {'outside-fence' squares are only saved for some deadlock sets}
    SquaresOutsideFenceIndex
                           : array[0..MAX_DEADLOCK_SETS] of Int16;      {index into the 'SquaresOutsideFence' vector; the indexed cell contains the square count, and the actual squares follow in the cells 'index+1' .. 'index+n'}
    SquaresOutsideFenceTop : Integer;                                   {the last used item in 'SquaresOutsideFence', i.e., the next free index is 'SquaresOutsideFenceTop' + 1}
    Statistics             : array[0..MAX_DEADLOCK_SETS] of Cardinal;   {number of times each deadlock has been triggered}
    TimeLimitMS            : TTimeMS;
    TimeMS                 : TTimeMS;
    {the small transposition table defined here contains selected game states during the depth-first deadlock search which tries to prove that a game state is a deadlock; it's allocated globally to reduce runtime stack size}
    TranspositionTable     : TDeadlockSearchTranspositionTable;
                             end;
  TRoomSquare              = record
     RoomNo                : Integer; {the number of the room to which this square belongs, if any}
     StraightLineEntryPointDistances
                           : array[TDirection] of Byte; {for each line emanating from the square, the distance to the nearest square outside the room in that direction, if any}
                             end;
  TRooms                   = record
    Count                  : Integer;
//  RoomBoxCount           : array[0..MAX_ROOM_COUNT] of UInt8; {number of boxes in each room for the current game state; not in production}
    Squares                : array[0..MAX_BOARD_SIZE] of TRoomSquare;
                             end;
  TGame                    = record
    Board                  : TBoard; {current game state; 'Board' = 'BoxPos' + 'PlayerPos'}
    BoardHeight            : Integer;
    BoardSize              : Integer; {(Width+2)*(Height*2): the extra 2 is for a wall-filled border}
    BoardWidth             : Integer;
    BoxCount               : Integer;
    BoxPos                 : TBoxSquares; {current game state; 'Board' = 'BoxPos' + 'PlayerPos'}
    DeadlockSets           : TDeadlockSets;
    DistanceToNearestGoal  : TBoardOfIntegers;
    DistanceToNearestBoxStartPosition
                           : TBoardOfIntegers;
    EndPlayerPos           : Integer; {player's end position in the original snapshot/solution}                           
    FloorCount             : Integer; {number of floor squares on the board}
    FreezeTestTimeStamps   : TBoardTimeStamps; {timestamps for visited squares/axis during a freeze-test}
    GoalCount              : Integer;
    GoalPos                : TBoxSquares;
    HashValue              : THashValue;
    History                : THistory;
    InitializationTimeMS   : TTimeMS; {'Game.DeadlocksSet.TimeMS' + 'Solver.PackingOrder.TimeMS'}
    IsAnOptimalSolution    : Boolean; {is the game stored in 'History' an optimal solution?}
    OriginalBoard          : TBoard;  {original board, i.e., before pre-processing operations like tube-filling}
    OriginalBoxPos         : TBoxSquares; {matching 'OriginalBoard'}
    OriginalPlayerPos      : Integer; {matching 'OriginalBoard'}
    OriginalSolution       : String;  {solution from inputfile, not the solution found by this application}
    OriginalSolutionMoveCount
                           : Integer;
    OriginalSolutionPushCount
                           : Integer;
    PackingOrderPushCount  : Integer; {number of pushes on current path that stem from packing-order search}
    PlayerPos              : Integer; {current game state; 'Board' = 'BoxPos' + 'PlayerPos'}
    ReverseMode            : Boolean;
    Rooms                  : TRooms;
    ShowDeadlockSetsEnabled: Boolean;
    SimpleLowerBound       : Integer;
    StartBoxPos            : TBoxSquares; {box starting position after board normalization by 'FillTubes'}
    StartPlayerPos         : Integer; {player's starting position after board normalization by 'FillTubes'}
    SolutionPathHashValues : array[0..MAX_HISTORY_BOX_MOVES+1] of THashValue;
    SortedBoxSquares       : TBoxArrayOfIntegers;
    SquareOffsetForward    : TDirectionArrayOfIntegers;
    SquareOffsetLeft       : TDirectionArrayOfIntegers;
    SquareOffsetRight      : TDirectionArrayOfIntegers;
    Title                  : String;
    TubeFillingMoveCount   : Integer; {player moves}
    TubeFillingPlayerLines : Integer; {player lines}
    TubeFillingPushCount   : Integer; {box pushes}
                             end;
  POptimizerPosition       = ^TOptimizerPosition;
  PPosition                = ^TPosition;
  PPPosition               = ^PPosition;
  TGraphFileItem           = packed record
    Move                   : TMove;
    PushCount              : TScore;
    Parent                 : PPosition; {later the parent can be retrieved from the file using 'TTIndexOf(Parent)' as file record number}
                             end;
  TGraphFile               = record
    FileName               : String;
    GraphFile              : file of Byte;
                             end;
  TLegend                  = record
    CharToItem             : array[Low(Char)..High(Char)] of UInt8;
    XSBNotation            : Boolean;
                             end;
  PLevelStatistics         = ^TLevelStatistics;
  TLevelStatistics         = record
    CorralPositionCount    : Int64;
    CorralPositionBoxCount : Int64;
    DeadlockedOpenPositionsCount
                           : Int64;
    DeadlockPositionsCount : Int64;
    DeadlockSetsPushCount  : Int64;
    DeadlockSetsTimeMS     : TTimeMS;
    DynamicDeadlockSetsCount
                           : Int64;
    Flags                  : TLevelStatisticsFlags;
    ForwardPositionCount   : Int64;
    GeneratedMovesCount    : Int64;
    GeneratedPushesCount   : Int64;
    Height                 : Cardinal;
    InitializationTimeMS   : TTimeMS;
    LowerBound             : Cardinal;
    Name                   : String;
    MoveCount              : Int64;
    NewPathCount           : Int64;
    Next                   : PLevelStatistics;
    OptimizerTimeMS        : TTimeMS;
    PackingOrderTimeMS     : TTimeMS;
    PrecalculatedDeadlockSetsCount
                           : Int64;
    PositionCount          : Int64;
    PushCount              : Int64;
    RoomPositionCount      : Int64;
    SolverTimeMS           : TTimeMS;
    Width                  : Cardinal;
                             end;
  TLogFile                 = record
    Enabled                : Boolean;
    FileName               : String;  {a non-blank name signals that logging really is active, i.e., the file is open and no file-i/o errors have occurred}
    TextFile               : TextFile;
                             end;
  TOptimizerGameMetrics    = record
    BoxChanges             : Integer;
    BoxLines               : Integer;
    HasPlayerLines         : Boolean; {'True': the player lines metric has been calculated}
    LastPlayerDirection    : TDirection;
    LastPushedBoxNo        : Integer;
    LastPushedDirection    : TDirection;
    LastPushingMoveNo      : Integer;
    MoveCount              : Integer;
    PlayerLines            : Integer;
    PushCount              : Integer;
    PushingSessions        : Integer;
                             end;
  TMovesFromSquare         = array[0..MAX_BOARD_SIZE - 1,TDirection] of Integer;
  TOptimizer               = record
    BoxesNotOnBestPathLimit: Cardinal; {for forward pruning; maximum number of boxes allowed to deviate from the set of squares belonging to the best path}
    BoxPermutationsSearchTimeLimitMS
                           : TTimeMS;
//  ByteBitCount           : array[Byte] of Byte; {number of bits for each bit pattern in a byte}
//  ByteHighBitIndex       : array[Byte] of Byte; {highest set bit for each bit pattern in a byte; note that ByteHighBit[0]=0, i.e., it's not a valid entry in the table}
    Enabled                : Boolean;  {'True': try to optimize a found solution by various transformations, e.g., reducing the number of non-pushing player-moves in a push-optimal solution}
    GameMetrics            : TOptimizerGameMetrics; {current game state metrics information}
    IterationResult        : Boolean;  {'True': optimizations found during the current iteration}
    MethodEnabled          : TOptimizationMethodEnabled;
    MethodOrder            : TOptimizationMethodOrder;
//  MovesFromSquare        : TMovesFromSquare;
    Optimization           : TOptimization; {optimize moves/pushes, pushes/moves, etc.}
    OriginalMetrics        : TOptimizerGameMetrics; {game metrics for the caller's solution/snapshot, before it is optimized}
    PruningNode            : PPosition;
    PurgeCount             : Cardinal;
    QuickVicinitySearchEnabled
                           : Boolean;  {'True': start vicinity-search with a 1-box 999/0 search (this often speeds up a 2-box search)}
    Result                 : TPluginResult;
    SearchLimits           : TSearchLimits; {limits controlling the currrently running search; solving or optimizing a level may require multiple searches with different limits}
    SearchResultStatusText : String;
    SearchStateStatusText  : String;   {e.g., 'N-box permutations, pushes 999-999'}
    TimeMS                 : TTimeMS;  {elapsed time, milli seconds}
    UpdateQueueRoot        : PPosition;
    UpdateSearchTreePushCount          {used for triggering time-checks during the update}
                           : Int64;
    VicinitySettings       : TVicinitySettings;
                             end;
  TSquareGoalDistance      = array[0..MAX_BOARD_SIZE,TBoxNo] of UInt8; {'UInt8': otherwise the table gets unreasonable large; distances above are truncated to 254, and '255' is reserved for meaning 'INFINITY', i.e., no path to the square}
  TPackingOrder            = record
    BoxCountThreshold      : Integer;  {threshold for trying to use a packing-order to solve the level}
    DistancesBasedOnPackingOrder       {when non-zero, square->goal distances taking the packing order into account have been calculated and are available in the table at index 'normal goal number' + 'DistancesBasedOnPackingOrder' for each of the goals}
                           : Integer;
    Enabled                : Boolean;  {packing-order enabled/disabled}
    FirstSetMemberIndex    : array[0..MAX_BOX_COUNT+1] of Integer; {index of first goal member in 'SetMembers' for each set number, i.e., for each phase}
    GoalBoxSets            : TBoxGoalSets; {for each goal, the set of reachable box starting positions from the goal}
    GoalSetNo              : array[TBoxNo] of TBoxNo; {mapping each goal number to its packing order set number, i.e., its phase}
    GoalAndParkingSquareCount {total number of goals and parking squares; during packing order search, a box may be parked somewhere on the board before the box is brought to its final goal square}
                           : Integer;
    NextGoalAtSameSquare   : TBoxNumbers; {circular linked lists for goals/parking places sharing the same square; a square can at the same time be a real goal square and used as parking space one or more times}
    ParkedBoxDestinationGoalSetNo
                           : TBoxNumbers; {for each parked box, the set number of the goal the parked box came from; a parked box should preferably stay at its parking square until it's time to fill the goal the parked box originally came from}
    SetCount               : Integer;  {number of packing-order goal-sets, i.e., game phases when the packing order is used by the search for a solution}
    SetMembers             : TBoxNumbers; {goal sets, e.g., sets A,B, and C with 2,3, and 2 members look like: [0,a1,a2,b1,b2,b3,c1,c2] (vector element 0 is unused); the corresponding 'FirstSetMemberIndex' vector is: [0,1,3,6,8]; '8' is a sentinel}
    SquareGoalDistance     : TSquareGoalDistance; {distances from each square to each goal or parking square}
    TimeMS                 : TTimeMS;  {precalculation time, milli seconds}
                             end;
  TPositionLinks           = record    {the ordering of the fields must not change}
    Prev                   : PPosition;
    Next                   : PPosition;
                             end;
  TPositionPackingOrder    = packed record  {must be 2 bytes; otherwise 'TPosition' requires substantial modifications}
    SetNo                  : UInt8;
    SetMemberIndex         : UInt8;
                             end;
  TPositionType            = (ptNull,ptCorral,ptOpen,ptClosed,ptOptimizer,ptPerimeter);
  TPosition                = packed record  {'packed': literal sequence of unaligned slots, without gaps (they must be carefully aligned manually)}
    HashValue              : THashValue;    {must be first slot for fast addressing}
    HashBucket             : TPositionLinks;{double-linked list of positions that hash into the same bucket; the positions in the bucket are sorted in ascending order on 'HashValue'}
    Parent                 : PPosition;     {predecessor position}
    PlayerPos              : UInt16;        {'0' marks an unused position}
    Move                   : TMove;         {the move leading to this position; note that 'Move.Direction' is 'dirty', it contains flags as well as the direction}
    PushCount              : TScore;        {for the solver, this is the also the search-depth; for the optimizer it's only a metric}
    Score                  : TScore;        {node cost; normally 'pushes + heuristic estimate'; special: perimeter-nodes from a previous search in the opposite direction have 'Score' = 0}
{   Unused                 : UInt16;}       {so the record size is n*SizeOf(Integer)}
{   TimeStamp              : TPositionTimeStamp;} {slot removed in order to save space; high-value marks locked positions, e.g., nodes on current path}
    case TPositionType of                   {node-type dependent information for open nodes, closed nodes, and perimeter nodes}
      ptNull:
        (GameState         : Uint32;        {the optimizer method 'vicinity search' stores the game-state for each position on the best path; the game-state is a [box-configuration-index, player-square] tuple}
         Unused3           : Integer;
         PackingOrderAndSuccessorCount      {must cover 'PackingOrder' and 'SuccessorCount'}
                           : Integer);
      ptCorral:                             {corral nodes, i.e., "box-fences" stored in the transposition table together with the normal game positions}
        (Unused4           : TPositionLinks;
         BoxSquare         : PBoxSquare2);  {points to the first element in the vector with the box squares belonging to the corral; the number of squares is stored in 'TPosition.Move.BoxNo'}
      ptOpen:                               {open nodes, i.e., nodes on the open-list; precondition: open nodes have no successors, i.e., no 'Parent' pointers back to an open node}
        (ScoreBucket       : TPositionLinks;{double-linked list of positions on the open-list having the same score}
         PackingOrder      : TPositionPackingOrder;
         SuccessorCount    : UInt16);       {number of immediate successors stored in the transposition table, i.e., nodes having this node as parent}
      ptClosed:                             {closed nodes (interior nodes), i.e., nodes stored in the transposition table but not on the open-list and not on the perimeter-list}
        (BestForgottenScore: TScore;        {best score for pruned successors, if any}
         Unused5           : UInt16;
         NextPartiallyExpandedPosition
                           : PPosition;     {the list root for partially expanded positions is 'Positions.PartiallyExpandedPositionsList'}
         PackingOrder2     : TPositionPackingOrder; {must be located at the same offset as 'PackingOrder'; this "same address" naming convention applies to all 'TPosition' record fields ending with a number}
         SuccessorCount2   : UInt16);       {number of immediate successors stored in the transposition table, i.e., nodes having this node as parent}
      ptPerimeter:                          {perimeter nodes, i.e., nodes from a previous search in the opposite direction; identified by 'Score' = 0 even though the position itself isn't a solution state}
        (ListLinks         : TPositionLinks;{double-linked list with all perimeter positions; must match the 'ScoreBucket' field}
         PathLengthToSolution
                           : UInt16;        {number of pushes to reach the solution from this position}
         SuccessorCount3   : UInt16);       {= 0}
      ptOptimizer:                          {see 'TOptimizerPosition' for more optimizer fields}
        (SmallBoxSet       : TSmallBoxSet;  {only available for nodes not on the open-queue which uses the overlapping 'ScoreBucket'}
         Successor         : PPosition;     {only available for nodes not on the open-queue which uses the overlapping 'ScoreBucket'}
         PlayerLines       : UInt16;
         SuccessorCount4   : UInt16);
                             end;
  TPositionPointersVector  = array[0..(MaxInt div SizeOf(PPosition))-1] of PPosition;
  PPositionPointersVector  = ^TPositionPointersVector;
  TPositionVector          = array[0..(MaxInt div SizeOf(TPosition))-1] of TPosition;
  PPositionVector          = ^TPositionVector;
  TOpenPositions           = record
    Buckets                : array[0..MAX_HISTORY_BOX_MOVES+(1+MAX_BOX_COUNT)*EMPTY_GOAL_PENALTY] of PPosition; {bucket-sorting open positions means that the sort is O(1), i.e., as fast as possible}
    Count                  : Cardinal;      {number of open positions}
    HighValueItemCount     : Cardinal;      {number of positions with the highest possible score (used for a special list by the optimizer)}
    MaxValue               : Integer;       {highest stored score}
    MinValue               : Integer;       {lowest  stored score}
    NoProgressRover        : Integer;       {once in a while choose a game state from this bucket for expansion, instead of taking a game state with the minimum score}
    SortCount              : Cardinal;
    WorstRover             : PPosition;
    WorstUnprotectedPosition
                           : PPosition;
                             end;
  TSearchStatistics        = record     {statistics and debugging info}
    BackwardMoveCount      : Cardinal;
    BackwardPositionCount  : Cardinal;
    BackwardPullCount      : Cardinal;
    CalculateCorralDeadlockStatusCount
                           : Cardinal;
    CorralPositionsCount   : Cardinal;
    CorralPositionsBoxCount: Cardinal;
    DeadlockedOpenPositionsCount
                           : Cardinal;
    DeadlockPositionsCount : Cardinal;
    DroppedCount           : Cardinal;   {number of dropped positions}
    DuplicatesCount        : Cardinal;
    Enqueue1Count          : Cardinal;
    Enqueue2Count          : Cardinal;
    ForwardPositionCount   : Cardinal;
    FreezeTestDeadlockCount: Cardinal;
    Lookup1Count           : Cardinal;
    Lookup2Count           : Cardinal;
    Lookup3Count           : Cardinal;
    MoveCount              : Cardinal;
    NewBestPositionCount   : Cardinal;
    NewPathCount           : Cardinal;
    NoPushDeadEndsCount    : Cardinal;
    ReuseCount             : Cardinal;
    RoomPositionsCount     : Cardinal;
    SetPosition1Count      : Cardinal;
    SetPosition2Count      : Cardinal;
                             end;
  TPositions               = record      {transposition-table and open-queue}
    BackwardPositionsList  : PPosition;  {linked list of positions generated backwards} {not in production}
    BackwardPositionsListCount
                           : Cardinal;   {number of positions on 'BackwardPositionsList'}
    BestPosition           : PPosition;
    BestScore              : Cardinal;   {best score; the score stored in the best position is unreliable because it may be overwritten with a backup score}
    Capacity               : Cardinal;   {size of the transposition table measured in 'TPosition' records by the solver, and measured in 'TOptimizerPosition' records by the optimizer}
    Count                  : Cardinal;   {number of game positions stored in the transposition table}
    CorralBoxSquares       : TBoxSquaresMemoryBlock; {box squares belonging to the corrals stored in the transposition table together with the normal game positions}
    CurrentPosition        : PPosition;  {current position during the search, i.e., the game board state matches this position}
    DebugPosition          : PPosition;  {global variable for debugging}
    EndOfPositions         : Pointer;    {address past end of the transposition table items in the 'Positions' vector; from that address, the memory contains reserved areas like the hash buckets and the precalculated deadlock sets}
    FreeList               : PPosition;  {linked list of unused positions}
    HashBucketCount        : Integer;    {vector-length of 'HashBuckets'; it must must be a power of 2 so masking with ('HashBucketCount'-1) produces a proper hash-bucket index}
    HashBucketMask         : Integer;    {'HashBucketCount' - 1}
    HashBuckets            : PPositionPointersVector; {the vector length must be a power of 2}
    MemoryByteSize         : Cardinal;   {total memory size in bytes, including 'Positions', 'HashBuckets' and precalculated deadlock sets}
    OpenPositions          : TOpenPositions;
    PartiallyExpandedPositionsList       {linked list of positions not fully expanded by the solver search; if the search doesn't find a solution, it may try a full expansion of these positions later}
                           : PPosition;
    PerimeterList          : PPosition;  {linked list of positions from a previous search in the opposite direction}
    PerimeterListCount     : Cardinal;   {number of positions on 'PerimeterList'}
    Positions              : PPositionVector;
    SearchStatistics       : TSearchStatistics;
    SolutionPosition       : PPosition;
    StartPosition          : PPosition;  {start position for the search}
    SquareHashValues       : array[0..MAX_BOARD_SIZE] of THashValue; {constants for calculating Zobrist hash-keys}
    UninitializedItemCount : Integer;    {start-value = 'Capacity'}
                             end;
  TRandomState             = record RandomNumber:Integer; end;
  TReader                  = record
    CurrentTextLine        : String;
    FirstLevelNo           : Cardinal;
    LastLevelNo            : Cardinal;
    InputFile              : TextFile;
    InputFileName          : String;
    LevelCount             : Cardinal;
    PreviousTextLine       : String;    {actually, it's not always the previous line but rather the previous line that might be a game title}
                             end;
  TPlayersReachableSquares = record
    Calculated             : Boolean;   {updated by 'CalculatePlayersReachableSquares'; the caller is responsible for proper initialization before calling 'TTAdd' and 'TTlookup'}
    MinPlayerPos           : Integer;   {the top-left reachable square is used as normalized player position}
    Squares                : TBoardOfTimeStamps; {the player's reachable squares have the value 'TimeStamp'; squares with neighboring boxes have the value 'TimeStamp' + 1}
    TimeStamp              : TTimeStamp;{incremented by 2 on each call to 'CalculatePlayersReachableSquares'}
    UsePlayersReachableSquaresFromPredecessor
                           : Boolean;   {copy calculation from predecessor (with small modifications) instead of performing a full calculation from scratch (not in production)}
                             end;
  TSearchState             = record     {the solver is recursive but the machine stack is limited to 1 MiB, hence, large tables must be allocated statically outside the stack}
    case Boolean of False  : (PlayersReachableSquares : TPlayersReachableSquares);
                             end;
  TSingleStepMoves         = array[0..MAX_SINGLE_STEP_MOVES] of TMove;
  TSokobanCallBackFunction = function:Integer; stdcall;
  TSokobanStatus           = packed record {for plugin interface functions like "SolveEx" and its accompanying call-back function}
    Size                   : UInt32;    {size filled in by caller; record size = SizeOf(record)}
    Flags                  : UInt32;
    MovesGenerated         : Int64;
    PushesGenerated        : Int64;
    StatesGenerated        : Int64;     {number of positions}
   {$IFDEF CONSOLE_APPLICATION}
      StatusText           : String;
    {$ELSE}                             {when the source-file is compiled as a plugin module, the status text is a string buffer inside the status record}
      StatusText           : array[0..(SOKOBAN_PLUGIN_STATUS_TEXT_BUFFER_SIZE div SizeOf(Char))-1] of Char; {null-terminated string}
    {$ENDIF}
    TimeMS                 : UInt32;    {milli seconds}
                             end;
  PSokobanStatus           = ^TSokobanStatus;
  TProgressCheckPoint      = record     {check solver progress each time a certain number of positions have been expanded}
    BestScore              : Integer;
    BoxTimeStamps          : array[ TBoxNo ] of Cardinal;
    NoProgressCount        : Integer;
    PushCountDown          : Integer;
    PushedBoxes            : array[0..MAX_BOX_COUNT] of Boolean;
    Score                  : Integer;   {score at check point time}
                             end;
  TSolver                  = record
    AddedCorralBoxesCount  : Int64;
    BackwardSearchDepthLimit
                           : Integer;   {maximum backward search limit (may differ from 'DepthLimit' in a perimeter-search, that is, first a backward search and then a forward search}
    CorralCount            : Int64;
    CorralSearchDepth      : Cardinal;
    DeadEndCount           : Int64;
    DeadEndDuplicatesCount : Int64;
    Enabled                : Boolean;   {'True': solve levels; 'False': optimize existing solutions only}
    ExposedInwardsCorralCount1,
    ExposedInwardsCorralCount2
                           : Int64;
    FindPushOptimalSolution: Boolean;   {solving for A) box pushes, or B) player moves (not implemented)}
    LastCallBackTimeMS     : TTimeMS;   {milliseconds}
    HighestSearchDepth     : Cardinal;  {highest search depth during the forward search}
    LimitExceededPushCount : Int64;     {number of positions that exceed one of the search limits, e.g., depth limit and positions limit}
    LowerBound             : Cardinal;
    PackingOrder           : TPackingOrder; {packing-order info}
    MoveCount              : Int64;     {search statistics}
    ProgressCheckPoint     : TProgressCheckPoint; {check progress each time a certain number of positions have been expanded}
    PushCount              : Int64;     {search statistics}
    ReuseNodesEnabled      : Boolean;   {reuse nodes when the transposition-table is full, i.e., prune least promising nodes}
    ReusePlayersReachableSquaresFromPredecessorCount
                           : array[Boolean] of Int64;
    SearchLimits           : TSearchLimits; {limits controlling the currrently running search; solving or optimizing a level may require multiple searches with different limits}
    SearchMethod           : TSearchMethod; {backward, forward, optimize, perimeter}
    SearchStates           : array[0..SEARCH_STATE_INDEX_CORRAL_PRUNING] of TSearchState;
    ShowBestPosition       : Boolean;   {show best found position when the solver doesn't find a solution (for testing)}
    SokobanCallBackFunction
                           : TSokobanCallBackFunction;
    SokobanStatus          : TSokobanStatus; {only used if the caller doesn't provide a pointer to its own status record}
    SokobanStatusPointer   : PSokobanStatus; {status info; points to 'SokobanStatus' if the caller doesn't provide its own record}
    StartTimeMS            : TTimeMS;   {search time start; defined global here for slightly faster access}
    StopWhenSolved         : Boolean;   {'True': stop when a solution has been found, i.e., don't search for shorter solutions}
    Terminated             : Boolean;   {'True' indicates that the solver has been requested to terminate; stopping the currently running search only is done by calling 'TerminateSearch'}
    TimeCheckCount         : Integer;
    TimeMS                 : TTimeMS;   {time, milliseconds}
                             end;

  TSquareDirectionArrayOfInteger
                           = array[0..MAX_BOARD_SIZE,TDirection] of Integer;
  TUserInterface           = record
    Prompt                 : Boolean; {if 'False': don't confirm messages, i.e., in the console program version don't require the user to press [Enter] after messages; important messages may be lost, so use it at your own risk}
                             end;
  TOptimizerPosition       = record {extended version of 'TPosition'; unfortunately, Pascal doesn't support extended records directly, hence, 'TPosition' is included as a field in this extended version}
    Position               : TPosition; {see 'TPosition' for more optimizer-related fields}
    MoveCount              : UInt16;
    BoxLines               : UInt16;
    BoxChanges             : UInt16;
    PushingSessions        : UInt16;
                             end;
//POptimizerPosition       = ^TOptimizerPosition;
  TOptimizerPositionVector = array[0..(MaxInt div SizeOf(TOptimizerPosition))-1] of TOptimizerPosition;
  POptimizerPositionVector = ^TOptimizerPositionVector;

{Global Variables}

var
  Game                     : TGame;
  GraphFile                : TGraphFile;
  Legend                   : TLegend;
  LevelStatistics          : PLevelStatistics;
  LogFile                  : TLogFile;
  Optimizer                : TOptimizer; {optimization info, i.e., settings and statistics}
  Positions                : TPositions; {transposition-table, open-queue, and statistics}
  RandomState              : TRandomState;
  Reader                   : TReader;
  Solver                   : TSolver;
  UserInterface            : TUserInterface;
{-----------------------------------------------------------------------------}

{$IFDEF PLUGIN_MODULE}

  {exported functions}

  function  BoardToText(const LineTerminator__:String):String;
  function  CalculateDefaultMemoryByteSize:Integer;
  function  ColRowToSquare(Col__,Row__:Integer):Integer;
  function  CreateLogFile(const FileName__:String):Boolean;
  procedure Finalize;
  function  GameHistoryMovesAsText:String;
  function  GetPhysicalMemoryByteSize:UInt32;
  procedure InitializeBoard(BoardWidth__,BoardHeight__:Integer; FillSquares__:Boolean);
  function  InitializeGame(var PluginResult__:TPluginResult; var ErrorText__:String):Boolean;
  function  Initialize(MemoryByteSize__:Cardinal;
                       PushCountLimit__:Int64;
                       DepthLimit__,
                       BackwardSearchDepthLimit__:Cardinal;
                       OptimizerPushCountLimit__:Int64;
                       OptimizerDepthLimit__,
                       DeadlockSetsAdjacentOpenSquaresLimit__,
                       DeadlockSetsBoxLimitForDynamicSets__,
                        DeadlockSetsBoxLimitForPrecalculatedSets__:Cardinal;
                       SearchMethod__:TSearchMethod;
                       SolverEnabled__,
                       OptimizerEnabled__,
                       OptimizerQuickVicinitySearchEnabled__,
                       ShowBestSolution__,
                       StopWhenSolved__,
                       Prompt__,
                       ReuseNodesEnabled__,
                       LogFileEnabled__,
                       PackingOrderEnabled__:Boolean;
                       PackingOrderBoxCountThreshold__:Integer;
                       TimeLimitMS__,
                       OptimizerTimeLimitMS__,
                       BoxPermutationsSearchTimeLimitMS__:TTimeMS;
                       OptimizationMethodEnabled__:TOptimizationMethodEnabled;
                       OptimizationMethodOrder__:TOptimizationMethodOrder;
                       Optimization__:TOptimization;
                       VicinitySettings__:TVicinitySettings;
                       SokobanCallBackFunction__:TSokobanCallBackFunction;
                       SokobanStatusPointer__:PSokobanStatus
                      ):Boolean;
  function  Max(a__,b__:Integer):Integer;
  function  Min(a__,b__:Integer):Integer;
  function  OptimizationMethodOrderToString(const OptimizationMethodOrder__:TOptimizationMethodOrder):String;
  function  OptimizeGame(MovesAsTextBufferByteSize__:Integer; MovesAsText__:PChar):Boolean;
  function  PathToText(Position__:PPosition; TextBufferSize__:Integer; MovesAsText__:PChar; var IsASolution__:Boolean; var Result__:TPluginResult):Boolean;
  function  Search:Boolean;
  procedure Terminate;

  implementation
{$ENDIF}

{-----------------------------------------------------------------------------}

{Forward Declarations}

{$IFNDEF PLUGIN_MODULE} {if the module is compiled as a plugin (a dll), then 'BoardToText' is declared in the interface section}
  function  BoardToText(const LineTerminator__:String):String; forward;
{$ENDIF}
procedure BoardToTextLines(var BoardAsTextLines__:TBoardAsTextLines); forward;
function  CalculatePlayerPath(ToSquare__:Integer; PreferredFinalDirection__:TDirection; MakeMoves__:Boolean; var MoveCount__,LineCount__:Integer; var FinalDirection__:TDirection; var Moves__:TSingleStepMoves):Boolean; forward;
function  CalculatePlayersReachableSquares(Index__:Integer):Integer; forward;
procedure ClearPlayersReachableSquares(Index__:Integer); forward;
function  FirstPushToText(var PushNo__:Integer; var Text__:String):Boolean; forward;
{$IFDEF PLUGIN_MODULE}
  function GetAvailableUserMemoryByteSize:UInt32; forward;
{$ELSE} {if the module is compiled as a plugin (a dll), then 'InitializeBoard' and 'InitializeGame' are declared in the interface section}
  procedure InitializeBoard(BoardWidth__,BoardHeight__:Integer; FillSquares__:Boolean); forward;
  function  InitializeGame(var PluginResult__:TPluginResult; var ErrorText__:String):Boolean; forward;
{$ENDIF}
function  IsAFreezingMove(FromSquareNo__,ToSquareNo__:Integer; ABoxFreezingOnAGoalSquareCountsAsAFreezingMove__:Boolean):Boolean; forward;
function  LoadNextLevelFromFile(const OutputFileName__:String):Boolean; forward; {a simple version, parsing board and optional heading titles only}
procedure MovePlayer(PlayerPos__:Integer); forward;
function  Msg(const Text__,Caption__:String):Boolean; forward;
function  NextPushToText(var PushNo__:Integer; var Text__:String):Boolean; forward;
function  OPENCheck(const Caption__:String):Boolean; forward;
function  OPENListLength(Position__:PPosition):Integer; forward;
procedure OPENRemove(Position__:PPosition); forward;
{$IFNDEF PLUGIN_MODULE} {if the module is compiled as a plugin (a dll), then 'OptimizeGame' is declared in the interface section}
  function  OptimizeGame(MovesAsTextBufferByteSize__:Integer; MovesAsText__:PChar):Boolean; forward;
{$ENDIF}
function  ReplayGame(const Moves__:String):Boolean; forward;
function  SaveLevelToFile(const FileName__,LevelName__:String):Boolean; forward;
//procedure ShowBoxDistanceToAllSquares(const Distances__:TBoardOfIntegers); forward;
function  ShowDeadlockSetNumbers : Integer; forward;
procedure SquareToColRow(Square__:Integer; var Col__,Row__:Integer); forward;
procedure TimeCheck; forward;
function  TTIsOnPath(Position__,Path__:PPosition):Boolean; forward;
function  TTListLength(Position__:PPosition):Integer; forward;
function  TTLookup(HashValue__:THashValue; PlayerPos__,SearchDepth__:Integer; var Position__:PPosition):Boolean; forward;
procedure TTRemove(Position__:PPosition); forward;
function  WriteLevelToFile({const} var F:Text; const LevelName__:String):Boolean; forward;
function  WritePathToFile(Position__:POptimizerPosition; {const} var F:Text; var PluginResult__:TPluginResult):Boolean; forward; // only implemented for optimizer positions, i.e., positions of type 'TOptimizerPosition'
{-----------------------------------------------------------------------------}

{General Utilities}

function  Align( Value__, Alignment__ : Integer ) : Integer;
begin // returns the smallest value >= "Value__" which is a multiple of
      // "Alignment__", except when that value overflows the return value data
      // type;
      // precondition : the value and the alignment are non-negative integers;
  if   Alignment__ <> 0 then
       Result      := Value__ + ( ( Alignment__ - ( Value__ mod Alignment__ ) ) mod Alignment__ )
  else Result      := Value__;
end;

function  CalculateElapsedTimeMS(StartTimeMS__,StopTimeMS__:TTimeMS):TTimeMS;
begin
  if   StopTimeMS__>=StartTimeMS__ then
       Result:=StopTimeMS__-StartTimeMS__
  else Result:=High(StopTimeMS__)-StartTimeMS__+StopTimeMS__+1; {clock wrap around; assume it only wrapped around once}
end;

procedure DoNothing;
begin
end;

procedure DN; {do nothing}
begin
end;

function  FileNameWithExtension(const FileName__,Extension__:String):String;
var i:Integer;
begin
  i:=Length(FileName__);
  while (i<>0) and (FileName__[i]<>PERIOD) do Dec(i);
  if   i<>0 then Result:=Copy(FileName__,1,Pred(i))
  else Result:=FileName__;
  Result:=Result+Extension__;
end;

{$IFDEF PLUGIN_MODULE}
procedure GetAsMuchMemoryAsPossible(var Memory__:Pointer; var ByteSize__:Cardinal; MinimumByteSize__:Cardinal);
const {$IFDEF WINDOWS}
        RESERVE_MEMORY_BYTE_SIZE=  8*ONE_MEBI; {for safety, leave some memory unused; for instance, opening the 'Settings' window while the plugin is running will need some working memory}
      {$ENDIF}
      START_DECREMENT           = 16*ONE_MEBI; {start decreasing with 16 MiB, and end up decreasing with 256 MiB at a time in each attempt to allocate a memory block}
      MAX_DECREMENT             =256*ONE_MEBI;

var Decrement {$IFDEF WINDOWS}, UserMemoryByteSize {$ENDIF} :Cardinal;
begin {try to allocate maximum 'ByteSize__' bytes of memory, minimum 'MinimumByteSize__' bytes}
  Memory__:=nil;
  if ByteSize__>0 then begin
     {$IFDEF WINDOWS}
       UserMemoryByteSize:=GetAvailableUserMemoryByteSize;
       if   UserMemoryByteSize>RESERVE_MEMORY_BYTE_SIZE then
            Dec(UserMemoryByteSize,RESERVE_MEMORY_BYTE_SIZE)
       else UserMemoryByteSize:=0;
       if   UserMemoryByteSize<ByteSize__ then ByteSize__:=UserMemoryByteSize;
     {$ENDIF}
     Decrement:=START_DECREMENT;
     repeat try    if   ByteSize__>0 then
                        GetMem(Memory__,ByteSize__)
                   else OutOfMemoryError;
            except on E:Exception do
                   if   E is EOutOfMemory then begin
                        Memory__:=nil;
                        if   ByteSize__>MinimumByteSize__ then begin
                             if   ByteSize__>Decrement then
                                  Dec(ByteSize__,Decrement)
                             else ByteSize__:=MinimumByteSize__;
                             if   Decrement<MAX_DECREMENT then Decrement:=Decrement*2; {increase the step size, in case the memory allocation fails again}
                             end
                        else ByteSize__:=0; {exit the procedure without allocating a memory block}
                        end;
                   else raise; {re-raise the unhandled exception}
            end;
     until  (Memory__<>nil) or (ByteSize__=0); {until the function succeeds and allocates a memory block, or until it fails allocating a memory block of size 'MinimumByteSize__'}
     end;
end;
{$ENDIF}

function  GetAvailablePhysicalMemoryByteSize:UInt32;
{$IFDEF WINDOWS}
var MemoryStatus:TMemoryStatus;
begin
  MemoryStatus.dwLength:=SizeOf(MemoryStatus);
  GlobalMemoryStatus(MemoryStatus);
  Result:=MemoryStatus.dwAvailPhys;
{$ELSE}
begin
  Result:=0;
{$ENDIF}
end;

function  GetAvailableUserMemoryByteSize:UInt32;
{$IFDEF WINDOWS}
var MemoryStatus:TMemoryStatus;
begin
  MemoryStatus.dwLength:=SizeOf(MemoryStatus);
  GlobalMemoryStatus(MemoryStatus);
  Result:=MemoryStatus.dwAvailVirtual;
{$ELSE}
begin
  Result:=0;
{$ENDIF}
end;

function  GetPhysicalMemoryByteSize:UInt32;
{$IFDEF WINDOWS}
var MemoryStatus:TMemoryStatus;
begin
  MemoryStatus.dwLength:=SizeOf(MemoryStatus);
  GlobalMemoryStatus(MemoryStatus);
  Result:=MemoryStatus.dwTotalPhys;
{$ELSE}
begin
  Result:=0;
{$ENDIF}
end;

function  GetTimeMS:TTimeMS;
begin {returns a time measured in milliseconds; the base doesn't matter, the time is only used in relative calculations}
{$IFDEF WINDOWS}
  Result:=GetTickCount; {Windows function}
{$ELSE}
  Result:=0;            {no timing}
{$ENDIF}
end;

procedure InitializeRandomState(RandomNumber__:Integer);
begin
  RandomState.RandomNumber:=Abs(RandomNumber__);
end;

function  IntToStr(Number__:Integer):String;
begin
  Str(Number__,Result);
end;

function  Int64ToStr(Number__:Int64):String;
begin
  Str(Number__,Result);
end;

function  IntToStrWithPluralDependentText(Number__:Integer; const Text__:String):String;
begin
  if   Number__<>1 then Result:=IntToStr(Number__)+SPACE+Text__+'s'
  else Result:=IntToStr(Number__)+SPACE+Text__;
end;

{$IFDEF WINDOWS}
  function  IsKeyPressed( VirtualKeyCode__ : Integer ) : Boolean;
  begin // returns 'True' if the given key currently is pressed
    Result := ( GetASyncKeyState( VirtualKeyCode__ ) and
                ( 1 shl ( ( SizeOf( SHORT ) * BITS_PER_BYTE ) - 1 ) ) ) <> 0;
  end;
{$ENDIF}

function  LoCase(Char__:Char):Char;
begin
  Result:=Char__;
  if (Result>='A') and (Result<='Z') then
     Result:=Chr(Ord('a')+Ord(Result)-Ord('A'));
end;

function  Log2(Number__:Integer):Integer;
begin
  Result:=-1;
  while Number__>0 do begin Inc(Result); Number__:=Number__ div 2; end;
end;

function  HasCharCI(const String__:String; Char__:Char):Boolean;
begin {returns 'True' if the string contains the character, case insensitive}
  Result:=(System.Pos(LoCase(Char__),String__)<>0) or
          (System.Pos(UpCase(Char__),String__)<>0);
end;

function  Max(a__,b__:Integer):Integer;
begin
  if a__>=b__ then Max:=a__
  else Max:=b__;
end;

function  Min(a__,b__:Integer):Integer;
begin
  if a__<=b__ then Min:=a__
  else Min:=b__;
end;

function  PowerOf2(Number__:Integer):Integer;
begin // precondition: 0 <= 'Number__' < ( BITS_PER_INTEGER - 1 )
  Result:=1 shl Number__;
end;

function  Random(Range__:Integer):Integer; {own random function so results are reproducable}
const a=1366; c=150889; m=714025; {don't modify these values unless you know what you are doing}
begin
  RandomState.RandomNumber:=(a * (RandomState.RandomNumber mod m) + c) mod m;
  if   Range__<>0 then Result:=RandomState.RandomNumber mod Range__
  else Result:=0;
end;

function  StrStartsWith(const Text__,Prefix__:String):Boolean;
begin
  Result:=(Prefix__<>'') and
          (Length(Text__)>=Length(Prefix__)) and
          (Copy(  Text__,1,Length(Prefix__))=Prefix__);
end;

function  StrToInt(const s__:String; var i__:Integer):Boolean;
var ErrorPos:Integer;
begin
  Val(s__,i__,ErrorPos); Result:=ErrorPos=0;
end;

{$IFDEF WINDOWS}
  function  WasKeyPressed( VirtualKeyCode__ : Integer ) : Boolean;
  begin // returns 'True' if the given key has been pressed
    Result := ( GetASyncKeyState( VirtualKeyCode__ ) and
                Succ( 1 shl ( ( SizeOf( SHORT ) * BITS_PER_BYTE ) - 1 ) ) ) <>
              0;
    if Result then // wait until the key isn't pressed
       repeat
       until ( GetASyncKeyState( VirtualKeyCode__ ) and
               Succ( 1 shl ( ( SizeOf( SHORT ) * BITS_PER_BYTE ) - 1 ) ) ) = 0;
  end;
{$ENDIF}

{-----------------------------------------------------------------------------}

{Utilities}

function  BoxNoAtSquare(SquareNo__:Integer):Integer;
var BoxNo:Integer;
begin // returns the number of the box at the square 'SquareNo__', if any
  Result:=0;
  for BoxNo:=1 to Game.BoxCount do
      if Game.BoxPos[BoxNo]=SquareNo__ then begin
         Result:=BoxNo; break;
         end;
end;

function  CalculateDefaultMemoryByteSize:Integer;
var PhysicalMemoryBytes,PhysicalMemoryMiB:UInt32;
begin
  PhysicalMemoryBytes:=GetPhysicalMemoryByteSize;
  if PhysicalMemoryBytes<High(PhysicalMemoryBytes) - (ONE_MEBI div 2) then Inc(PhysicalMemoryBytes,(ONE_MEBI div 2)); // prepare to round up
  if PhysicalMemoryBytes>Cardinal(MaxInt) then PhysicalMemoryBytes:=Cardinal(MaxInt); // limit the memory byte size to an unsigned integer
  PhysicalMemoryMiB:=PhysicalMemoryBytes div ONE_MEBI;
  if   PhysicalMemoryMiB<>0 then
       Result:=Min(High(Result) div ONE_MEBI,Max(0,Succ(PhysicalMemoryMiB) div 2))*ONE_MEBI // 'div 2': only use half of the physical memory
  else Result:=DEFAULT_MEMORY_BYTE_SIZE;
end;

function  CharToDirection(Ch__:Char; var Direction__:TDirection):Boolean;
var Dir:TDirection;
begin
  Result:=False; Ch__:=LoCase(Ch__);
  for Dir:=Low(Dir) to High(Dir) do
      if Ch__=DIRECTION_TO_CHAR[Dir] then begin {caution: 'DIRECTION_CHAR' must be lowercase characters}
         Direction__:=Dir; Result:=True; break;
         end;
end;

function  ColRowToSquare(Col__,Row__:Integer):Integer;
begin
  ColRowToSquare:=Row__ * (Game.BoardWidth+2) + Col__;
end;

function  DxDyToDirection(Dx__,Dy__:Integer):TDirection;
begin {precondition: either 'Dx__' or 'Dy__' is 0}
  if        Dx__=0 then
            if   Dy__<=0 then Result:=dUp
            else              Result:=dDown
  else if   Dx__<0       then Result:=dLeft
            else              Result:=dRight;
end;

procedure DirectionToDxDy(Direction__:TDirection; var Dx__,Dy__:Integer);
begin
  Dx__:=0; Dy__:=0;
  case Direction__ of
    dUp   : Dy__:=-1;
    dLeft : Dx__:=-1;
    dDown : Dy__:= 1;
    dRight: Dx__:= 1;
    else    Msg('DirectionToDxDy',TEXT_INTERNAL_ERROR);
  end; {case}
end;

function  GameHistoryMovesAsText:String;
var PushNo:Integer; MoveAsText:String;
begin {note that this destroys calculations done by 'InitializeGame', hence, don't call it before the search is over}
  {initialize the game before replaying the moves}
  Game.Board:=Game.OriginalBoard; {note that this destroys the calculations performed by 'InitializeGame'}
  Game.BoxPos:=Game.OriginalBoxPos; Game.PlayerPos:=Game.OriginalPlayerPos;
  with Solver.SearchStates[0].PlayersReachableSquares do TimeStamp:=High(TimeStamp); {initialize the square timestamps for 'CalculatePlayerPath'; tubefilled squares, if any, may need new initialization after the original board has been reloaded}
  with Solver.SearchStates[SEARCH_STATE_INDEX_DO_PUSH].PlayersReachableSquares do TimeStamp:=High(TimeStamp); {ditto}

  Result:='';
  if FirstPushToText(PushNo,MoveAsText) then
     repeat Result:=Result+MoveAsText;
     until  not NextPushToText(PushNo,MoveAsText);
end;

function  GoalNoAtSquare(SquareNo__:Integer):Integer;
var GoalNo:Integer;
begin // returns the number of the goal at the square 'SquareNo__', if any
  Result:=0;
  for GoalNo:=1 to Game.GoalCount do
      if Game.GoalPos[GoalNo]=SquareNo__ then begin
         Result:=GoalNo; break;
         end;
end;

function  IsABlackSquareOnAChessBoard(Square__:Integer):Boolean;
var Col,Row:Integer;
begin
  SquareToColRow(Square__,Col,Row);
  Result:=(Odd(Col) and Odd(Row)) or ((not Odd(Col)) and (not Odd(Row)));
end;

function  IsABlockedBoxSquareAlongAxis(Square__:Integer; Direction__:TDirection):Boolean; {considering walls only, i.e., boxes on the board are not taken into account}
var Neighbor1,Neighbor2:Integer;
begin
  with Game do begin
    Neighbor1 := Board [ Square__ + SquareOffsetForward [ Direction__ ] ];      {note that 'Neighbor1' and 'Neighbor2' hold the contents of the squares, not the square numbers}
    Neighbor2 := Board [ Square__ - SquareOffsetForward [ Direction__ ] ];
    Result:= (( Neighbor1 and WALL           ) <> 0 )                           {is there a wall on any of the neighbor squares?}
             or
             (( Neighbor2 and WALL           ) <> 0 )
             or
             ((( Neighbor1 and FLAG_ILLEGAL_BOX_SQUARE ) <> 0 )                 {are both neighbors illegal squares?}
              and
              (( Neighbor2 and FLAG_ILLEGAL_BOX_SQUARE ) <> 0 )
             );
    end;
end;

function  IsABoxReachableSquare(Square__:Integer):Boolean;
begin
  Result:=(Game.Board[Square__] and FLAG_BOX_REACHABLE_SQUARE)<>0;
end;

function  IsABoxSquare(Square__:Integer):Boolean;
begin
  Result:=(Game.Board[Square__] and BOX)<>0;
end;

function  IsABoxStartSquare(Square__:Integer):Boolean;
begin {precondition: 'Game.DistanceToNearestBoxStartPosition'  has been calculated}
  Result:=Game.DistanceToNearestBoxStartPosition[Square__]=0;
end;

function  IsAFloorSquare(Square__:Integer):Boolean;
begin
  Result:=(Game.Board[Square__] and FLOOR)<>0;
end;

function  IsAGateSquare(Square__:Integer):Boolean;
begin
  Result:=(Game.Board[Square__] and FLAG_GATE_SQUARE)<>0;
end;

function  IsAGoalSquare(Square__:Integer):Boolean;
begin
  Result:=(Game.Board[Square__] and GOAL)<>0;
end;

function  IsALegalBoxSquare(Square__:Integer):Boolean;
begin
  Result:=(Game.Board[Square__] and (WALL+FLAG_ILLEGAL_BOX_SQUARE))=0;
end;

function  IsALegalAndBoxReachableSquare(Square__:Integer):Boolean;
begin
  Result:=(Game.Board[Square__] and (WALL+FLAG_ILLEGAL_BOX_SQUARE+FLAG_BOX_REACHABLE_SQUARE+FLOOR))=FLAG_BOX_REACHABLE_SQUARE+FLOOR;
end;

function  IsAnEmptyFloorSquare(Square__:Integer):Boolean;
begin
  Result:=(Game.Board[Square__] and (FLOOR+BOX))=FLOOR;
end;

function  IsAPlayerSquare(Square__:Integer):Boolean;
begin
  Result:=(Game.Board[Square__] and PLAYER)<>0;
end;

function  IsAWallSquare(Square__:Integer):Boolean;
begin
  Result:=(Game.Board[Square__] and WALL)<>0;
end;

function  IsSquareAMemberOfDeadlockSet(SquareNo__,DeadlockSetNo__:Integer):Boolean;
var Index:Integer;
begin
  Result:=True;
  with Game.DeadlockSets do
    for Index:=1 to SquareSetCount[SquareNo__] do
        if SquareSetNumbers[SquareNo__]^[Index]=DeadlockSetNo__ then exit; {quick-and-dirty exit when the square number has been found}
  Result:=False;
end;

function  IsOnPath(Position__:PPosition):Boolean;
begin
  with Position__^.Move do Result:=(Ord(Direction) and POSITION_PATH_TAG)<>0;
end;

function  LoadOptimizationMethodSettingsFromString(Str__:String; var MethodEnabled__:TOptimizationMethodEnabled; var MethodOrder__:TOptimizationMethodOrder):Boolean;
var i,j:Integer; Method:TOptimizationMethod;
    NewMethodEnabled:TOptimizationMethodEnabled; NewMethodOrder:TOptimizationMethodOrder;
begin
  Result:=True;
  for Method:=Low(NewMethodEnabled) to High(NewMethodEnabled) do NewMethodEnabled[Method]:=False;
  NewMethodEnabled[Low(NewMethodEnabled)]:=DEFAULT_OPTIMIZER_FALLBACK_STRATEGY_ENABLED; {the first element is the fallback strategy}
  for i:=Low(NewMethodOrder) to High(NewMethodOrder) do NewMethodOrder[i]:=Low(TOptimizationMethod); {initialize the new method order with the default method only}

  for i:=1 to Min(Length(Str__),High(MethodOrder__)) do
      if Result then begin
         Result:=False;
         for Method:=Succ(Low(Method)) to High(Method) do                       {'Succ': element 0 is the fixed fallback stragegy}
             if OPTIMIZATION_METHOD_TO_CHAR[Method]=UpCase(Str__[i]) then begin
                Result:=True;
                for j:=Succ(Low(NewMethodOrder)) to Pred(i) do                  {check for duplicates}
                    if NewMethodOrder[j]=Method then Result:=False;             {'=': duplicate found}
                NewMethodEnabled[Method]:=True; NewMethodOrder[i]:=Method;
                end;
         end;
  if  Result then begin
      MethodEnabled__:=NewMethodEnabled;
      MethodOrder__  :=NewMethodOrder;
      end;
end;

function  ManhattanDistance(Square1__,Square2__:Integer):Integer;
var Col1,Col2,Row1,Row2:Integer;
begin {returns the 'Manhattan distance' between two squares on the board}
  SquareToColRow(Square1__,Col1,Row1);
  SquareToColRow(Square2__,Col2,Row2);
  Result:=Abs(Col1-Col2)+Abs(Row1-Row2);
end;

function  MinimumDistanceToSquare(Square__:Integer; const Distances__:TSquareDirectionArrayOfInteger):Integer;
var Direction:TDirection;
begin {returns the minimum distance to the square, given the distances from each direction}
  Result:=INFINITY;
  for Direction:=Low(Direction) to High(Direction) do
      if (Abs(Distances__[Square__,Direction])<>INFINITY) and
         (    Distances__[Square__,Direction] < Result)   then
         Result:=Distances__[Square__,Direction];
end; {MinimumDistanceToSquare}

function  OptimizerImprovementAsText(Position__:PPosition):String;
begin
  if   Position__<>nil then with POptimizerPosition(Position__)^ do with Position do
       Result:=IntToStr(MoveCount      -Optimizer.OriginalMetrics.MoveCount      )+SLASH+
               IntToStr(PushCount      -Optimizer.OriginalMetrics.PushCount      )+SLASH+
               IntToStr(BoxLines       -Optimizer.OriginalMetrics.BoxLines       )+SLASH+
               IntToStr(BoxChanges     -Optimizer.OriginalMetrics.BoxChanges     )+SLASH+
               IntToStr(PushingSessions-Optimizer.OriginalMetrics.PushingSessions)+SLASH+
               IntToStr(PlayerLines    -Optimizer.OriginalMetrics.PlayerLines    )
  else Result:='0/0/0/0/0/0';
end;

function  OptimizationMethodOrderToString(const OptimizationMethodOrder__:TOptimizationMethodOrder):String;
var i:Integer;
begin
  Result:='';
  for i:=Succ(Low(OptimizationMethodOrder__)) to High(OptimizationMethodOrder__) do {'Succ(Low(...))': element 0 is the fixed fallback strategy}
      Result:=Result+OPTIMIZATION_METHOD_TO_CHAR[OptimizationMethodOrder__[i]];
end;

function  OptimizerMetricsAsText(Position__:PPosition):String;
begin
  with POptimizerPosition(Position__)^ do with Position do
    Result:=IntToStr(MoveCount      )+SLASH+
            IntToStr(PushCount      )+SLASH+
            IntToStr(BoxLines       )+SLASH+
            IntToStr(BoxChanges     )+SLASH+
            IntToStr(PushingSessions)+SLASH+
            IntToStr(PlayerLines    );
end;

function  PerformSokobanCallBackFunction:Integer;
begin {returns a non-zero value if the solver should terminate}
  if   Assigned(Solver.SokobanCallBackFunction) then with Solver.SokobanStatusPointer^ do begin
       MovesGenerated :=Solver.MoveCount;
       PushesGenerated:=Solver.PushCount;
       StatesGenerated:=Int64(YASS.Positions.Count)+YASS.Positions.SearchStatistics.DroppedCount;
       TimeMS:=UInt32(Game.InitializationTimeMS+Solver.TimeMS+Optimizer.TimeMS);
       Result:=Solver.SokobanCallBackFunction();
       end
  else Result:=0;
end;

procedure SetSokobanStatusText(const Text__:String);
{$IFNDEF CONSOLE_APPLICATION}
  var CharCount:Integer;
{$ENDIF}
begin
  with Solver.SokobanStatusPointer^ do begin
    {$IFDEF CONSOLE_APPLICATION}
      StatusText:=Text__;
      Writeln(StatusText);
    {$ELSE}
      CharCount:=Min(Length(Text__),(SizeOf(StatusText)-SizeOf(Char)) div SizeOf(Char));
      if CharCount<>0 then System.Move(PChar(Addr(Text__[1]))^,PChar(Addr(StatusText))^,CharCount*SizeOf(Char));
      StatusText[Low(StatusText)+CharCount]:=NULL_CHAR; // add null-terminator
    {$ENDIF}
    end;
end;

function  SokobanCallBackFunction:Integer; stdcall;
begin // test function only; not in production
  with Solver.SokobanStatusPointer^ do begin
    {$IFDEF CONSOLE_APPLICATION}
      Writeln('Pushes: ',PushesGenerated,' Positions: ',StatesGenerated,' Time (ms): ',TimeMS);
      Readln;
    {$ENDIF}
    Result:=0; {'0': continue search; anything else terminates the search}
    end;
end;

function  SquareToChar(Square__:Integer):Char;
var Col,Row:Integer;
begin
  case Game.Board[Square__] and (PLAYER+BOX+GOAL+WALL) of
    PLAYER     : if   Legend.XSBNotation then
                      Result:=CH_PLAYER_XSB
                 else Result:=CH_PLAYER;
    PLAYER+GOAL: if   Legend.XSBNotation then
                      Result:=CH_PLAYER_ON_GOAL_XSB
                 else Result:=CH_PLAYER_ON_GOAL;
    PLAYER+BOX, {can happen for deadlock sets}
    BOX        : if   Legend.XSBNotation then
                      Result:=CH_BOX_XSB
                 else Result:=CH_BOX;
    PLAYER+BOX+GOAL, {can happen for deadlock sets}
    BOX+GOAL   : if   Legend.XSBNotation then
                      Result:=CH_BOX_ON_GOAL_XSB
                 else Result:=CH_BOX_ON_GOAL;
    GOAL       : Result:=CH_GOAL;
    WALL       : Result:=CH_WALL;
//  else         Result:=UNDERSCORE;
    else         Result:=CH_FLOOR;
  end;
  if Game.Board[Square__]=FLAG_SQUARE_SET then Result:=CH_SQUARE_SET;
  if ((Game.Board[Square__] and WALL)<>0) and (Game.Board[Square__]<>WALL) then
     if   Game.DeadlockSets.ControllerAndFreezeSetPairsEnabled then begin
          SquareToColRow(Square__,Col,Row);
          Msg(TEXT_INTERNAL_ERROR+': "SquareToChar"'+SPACE+IntToStr(Square__)+' = ['+IntToStr(Col)+','+IntToStr(Row)+'] : '+IntToStr(Game.Board[Square__]),TEXT_APPLICATION_TITLE);
          Result:='?'; {error}
          end
     else {kludge: during calculation of deadlock sets, there are sometimes boxes on walls, e.g., during creation of controller/freeze-set deadlock pairs}
          Result:=CH_WALL;
end;

procedure SquareToColRow(Square__:Integer; var Col__,Row__:Integer);
begin
  Row__:=Square__   div   (Game.BoardWidth+2);
  Col__:=Square__ - Row__*(Game.BoardWidth+2);
end;

function  SquareToColRowAsText(Square__:Integer):String;
var Col,Row:Integer;
begin
  SquareToColRow(Square__,Col,Row);
  Result:=IntToStr(Col)+COMMA+IntToStr(Row);
end;

function  StraightLineVisibility(Square__,Distance__:Integer; Direction__:TDirection):Boolean;
begin {Returns 'True' if the line of sight on the board in the given direction isn't blocked by walls or boxes; 'Square__' is the starting point but it isn't itself a part of the line of sight, i.e., it may be a wall or a box square}
  with Game do begin
    Inc(Square__,SquareOffsetForward[Direction__]);
    while (Distance__>0) and
          ((Board[Square__] and (WALL+BOX))=0) do begin
          Inc(Square__,SquareOffsetForward[Direction__]);
          Dec(Distance__);
          end;
    Result:=Distance__<=0;
    end;
end;

{-----------------------------------------------------------------------------}

{Console}

function  GetCommandLineParameters(var InputFileName__:String;
                                   var FirstLevelNo__,
                                       LastLevelNo__,
                                       MemoryByteSize__:Cardinal;
                                   var PushCountLimit__:Int64;
                                   var DepthLimit__,
                                       BackwardSearchDepthLimit__:Cardinal;
                                   var OptimizerPushCountLimit__:Int64;
                                   var OptimizerDepthLimit__,
                                       DeadlockSetsAdjacentOpenSquaresLimit__,
                                       DeadlockSetsBoxLimitForDynamicSets__,
                                       DeadlockSetsBoxLimitForPrecalculatedSets__:Cardinal;
                                   var SearchMethod__:TSearchMethod;
                                   var SolverEnabled__,
                                       OptimizerEnabled__,
                                       OptimizerQuickVicinitySearchEnabled__,
                                       ShowBestPosition__,
                                       StopWhenSolved__,
                                       Prompt__,
                                       ReuseNodesEnabled__,
                                       LogFileEnabled__,
                                       PackingOrderEnabled__:Boolean;
                                   var PackingOrderBoxCountThreshold__:Cardinal;
                                   var TimeLimitMS__,
                                       OptimizerTimeLimitMS__,
                                       BoxPermutationsSearchTimeLimitMS__:TTimeMS;
                                   var OptimizationMethodEnabled__:TOptimizationMethodEnabled;
                                   var OptimizationMethodOrder__  :TOptimizationMethodOrder;
                                   var Optimization__:TOptimization;
                                   var VicinitySettings__:TVicinitySettings):Boolean;
var i,j,ItemIndex:Integer; c:Cardinal; b:Boolean; sm:TSearchMethod; om:TOptimizationMethod; s:String;

  function  GetParameter(var Value__:Cardinal; Min__,Max__,Scale__:Cardinal; var ItemIndex__:Integer):Boolean;
  begin
    Inc(ItemIndex__); {skip argument name}
    if Scale__<1 then Scale__:=1;
    Result:=(ItemIndex__<=ParamCount) and
            StrToInt(ParamStr(ItemIndex__),Integer(Value__)) and
            (Value__>=Min__ div Scale__) and (Value__<=Max__ div Scale__);
    Value__:=Value__*Scale__;
    Inc(ItemIndex__); {advance to next parameter}
  end;

  function  GetBooleanValue(var Value__:Boolean):Boolean;
  var s:String;
  begin
    Result:=False; Inc(ItemIndex); {advance to next parameter}
    if  ParamCount>=ItemIndex then begin
        s:=ParamStr(ItemIndex); Inc(ItemIndex); {note that 'ItemIndex' now points to the next parameter, if any}
        if   s<>'' then
             if        (s[1]='y') or (s[1]='Y') then begin
                       Value__:=True; Result:=True;
                       end
             else if   (s[1]='n') or (s[1]='N') then begin
                       Value__:=False; Result:=True;
                       end;
        end;
  end;

begin {a simple and not fool-proof implementation}
  Result:= (ParamCount>=1);
  InputFileName__:='';
  FirstLevelNo__:=1;
  LastLevelNo__:=High(LastLevelNo__);
  MemoryByteSize__:=CalculateDefaultMemoryByteSize;
  PushCountLimit__:=DEFAULT_PUSH_COUNT_LIMIT;
  DepthLimit__:=DEFAULT_SEARCH_DEPTH;
  BackwardSearchDepthLimit__:=DepthLimit__;
  OptimizerPushCountLimit__:=PushCountLimit__;
  OptimizerDepthLimit__:=DEFAULT_OPTIMIZER_SEARCH_DEPTH;
  DeadlockSetsAdjacentOpenSquaresLimit__:=DEFAULT_DEADLOCK_SETS_ADJACENT_OPEN_SQUARES_LIMIT;
  DeadlockSetsBoxLimitForDynamicSets__:=DEFAULT_DEADLOCK_SETS_BOX_LIMIT_FOR_DYNAMIC_SETS;
  DeadlockSetsBoxLimitForPrecalculatedSets__:=DEFAULT_DEADLOCK_SETS_BOX_LIMIT_FOR_PRECALCULATED_SETS;
  SearchMethod__:=DEFAULT_SEARCH_METHOD;
  SolverEnabled__:=True;
  OptimizerEnabled__:=DEFAULT_OPTIMIZER_ENABLED;
  OptimizerQuickVicinitySearchEnabled__:=True;
  ShowBestPosition__:=False;
  StopWhenSolved__:=DEFAULT_STOP_WHEN_SOLVED;
  Prompt__:=True;
  ReuseNodesEnabled__:=DEFAULT_REUSE_NODES_ENABLED;
  LogFileEnabled__:=DEFAULT_LOG_FILE_ENABLED;
  PackingOrderEnabled__:=DEFAULT_PACKING_ORDER_ENABLED;
  PackingOrderBoxCountThreshold__:=DEFAULT_PACKING_ORDER_BOX_COUNT_THRESHOLD;
  TimeLimitMS__:=High(TimeLimitMS__); // high-value = unlimited
  OptimizerTimeLimitMS__:=High(OptimizerTimeLimitMS__); // high-value = unlimited
  BoxPermutationsSearchTimeLimitMS__:= DEFAULT_OPTIMIZER_BOX_PERMUTATIONS_SEARCH_TIME_LIMIT_MS;
  for om:=Low(OptimizationMethodEnabled__) to High(OptimizationMethodEnabled__) do OptimizationMethodEnabled__[om]:=True;
  OptimizationMethodEnabled__[Low(OptimizationMethodEnabled__)]:=DEFAULT_OPTIMIZER_FALLBACK_STRATEGY_ENABLED; // 'Low()': fallback strategy is the first one of the methods
  for i :=Low(OptimizationMethodOrder__  ) to High(OptimizationMethodOrder__  ) do OptimizationMethodOrder__  [i ]:=TOptimizationMethod(i); // optimization methods (except the fallback strategy) are invoked in definition order
  Optimization__:=DEFAULT_OPTIMIZATION;
  VicinitySettings__:=DEFAULT_VICINITY_SETTINGS;
  ItemIndex:=1;

  if Result and (ParamCount>=ItemIndex) then begin {get filename, if any}
     s:=ParamStr(ItemIndex);
     if (s<>'') and (s[1]<>HYPHEN) and (s[1]<>SLASH) then begin {not an option}
        InputFileName__:=s;
        {//Result:=FileExists(InputFileName__); // avoid linking 'SysUtils'}
        if not Result then Msg('File not found: '+InputFileName__,TEXT_APPLICATION_TITLE);
        Inc(ItemIndex);
        end;
     end;

  while Result and (ParamCount>=ItemIndex) do begin {get options}
     s:=ParamStr(ItemIndex);
     Result:=(Length(s)>=2) and ((s[1]=HYPHEN) or (s[1]=SLASH));
     if Result then
        case LoCase(s[2]) of
          'b'       : if           HasCharCI(s,'a') then begin {undocumented feature "-backwardsearchlimit": use a special backward search limit instead of 'maxdepth'}
                                   Result:=GetParameter(BackwardSearchDepthLimit__,0,MaxInt,0,ItemIndex);
                                   end
                      else if      HasCharCI(s,'e') then begin {undocumented feature "-bestposition": show best found position when the solver doesn't find a solution}
                                   ShowBestPosition__:=True; Inc(ItemIndex);
                                   end
                           else    Result:=False;
          'c'       : if           HasCharCI(s,'h') then begin {undocumented feature "-check": only check existing solutions, e.g., to verify that the precalculated deadlock patterns are valid}
                                   SolverEnabled__:=False; OptimizerEnabled__:=False;
                                   SearchMethod__:=smForward; Inc(ItemIndex);
                                   end
                      else         Result:=False;

          'd'       : if           HasCharCI(s,'a') then {deadlock sets complexity}
                                   Result:=GetParameter(DeadlockSetsAdjacentOpenSquaresLimit__,0,3,0,ItemIndex)
                      else         Result:=False;
          'f'       : Result:=GetBooleanValue(OptimizationMethodEnabled__[Low(OptimizationMethodEnabled__)]); // optimizer fallback strategy enabled/disabled
          'h','?'   : Result:=False; // force the program to show the help screen
          'l'       : if           HasCharCI(s,'o') then begin {log}
                                   LogFileEnabled__:=True; Inc(ItemIndex);
                                   end
                      else         begin Result:=GetParameter(FirstLevelNo__,0,MaxInt,0,ItemIndex); {level from [ - to]}
                                         if Result and (ItemIndex<=Pred(ParamCount)) and
                                            (ParamStr(ItemIndex)=HYPHEN) then begin
                                            Result:=GetParameter(LastLevelNo__,FirstLevelNo__,MaxInt,0,ItemIndex);
                                            end;
                                   end;
          'm'       : if           HasCharCI(s,'u') then begin {MaxPushes}
                                   Result:=GetParameter(c,0,High(c),ONE_MILLION,ItemIndex);
                                   PushCountLimit__:=c;
                                   if PushCountLimit__=0 then PushCountLimit__:=High(PushCountLimit__); {special: argument=0 -> limit:=none}
                                   OptimizerPushCountLimit__:=PushCountLimit__;
                                   end
                      else if      (Length(s)>=5) and
                                   ((s[5]='d') or (s[5]='D')) {MaxDepth} then
                                   Result:=GetParameter(DepthLimit__,0,MAX_HISTORY_BOX_MOVES,0,ItemIndex)
                           else if (Length(s)>=5) and
                                   ((s[5]='t') or (s[5]='T')) {MaxTime} then begin
                                   Result:=GetParameter(Cardinal(TimeLimitMS__),0,MAX_SEARCH_TIME_LIMIT_MS,1000,ItemIndex);
                                   OptimizerTimeLimitMS__:=TimeLimitMS__;
                                   end
                                else if HasCharCI(s,'h') {Method} then begin
                                        Inc(ItemIndex);
                                        if ParamCount>=ItemIndex then begin
                                           s:=Copy(ParamStr(ItemIndex),1,2); Inc(ItemIndex);
                                           for i:=1 to Length(s) do s[i]:=LoCase(s[i]);
                                           Result:=False;
                                           if Length(s)>=2 then
                                              for sm:=Low(sm) to High(sm) do
                                                  if s=Copy(TEXT_SEARCH_METHOD[sm],1,2) then begin
                                                     SearchMethod__:=sm; Result:=True;
                                                     end;
                                           end
                                        else Result:=False;
                                        end
                                     else if (Length(s)>=4) and
                                             ((s[4]='m') or (s[4]='M')) then begin {Memory}
                                             MemoryByteSize__   :=GetPhysicalMemoryByteSize;
                                             if MemoryByteSize__> Cardinal(MAX_TRANSPOSITION_TABLE_BYTE_SIZE) then
                                                MemoryByteSize__:=Cardinal(MAX_TRANSPOSITION_TABLE_BYTE_SIZE); // limit the transposition table byte size to a signed integer and leave some memory for other purposes
                                             Result:=GetParameter(MemoryByteSize__,
                                                                  0,
                                                                 {$IFDEF WINDOWS}
                                                                   MemoryByteSize__,
                                                                 {$ELSE}
                                                                   MAX_TRANSPOSITION_TABLE_BYTE_SIZE,
                                                                 {$ENDIF}
                                                                  ONE_MEBI,ItemIndex);
                                             if (not Result) and (Pred(ItemIndex)<=ParamCount) then begin
                                                s:=ParamStr(Pred(ItemIndex));
                                                if (s<>'') and ((s[1]='a') or (s[1]='A')) then begin
                                                   {$IFDEF WINDOWS}
                                                     MemoryByteSize__   :=GetAvailablePhysicalMemoryByteSize;
                                                     if MemoryByteSize__> Cardinal(MAX_TRANSPOSITION_TABLE_BYTE_SIZE) then
                                                        MemoryByteSize__:=Cardinal(MAX_TRANSPOSITION_TABLE_BYTE_SIZE); // limit the transposition table byte size to a signed integer and leave some memory for other purposes
                                                     Result:={(MemoryByteSize__>=0) and} (MemoryByteSize__<=MaxInt-ONE_MEBI);
                                                   {$ELSE}
                                                     Msg('"-memory available": This parameter is only implemented in the Windows version.','');
                                                   {$ENDIF}
                                                   end;
                                                end;

                                             end
                                          else {move-optimal solution not implemented...
                                               if (Length(s)>=3) and
                                                  ((s[3]='o') or (s[3]='O')) then  begin //Moves
                                                  FindPushOptimalSolution__:=False; Inc(ItemIndex);
                                                  end
                                               else
                                               }
                                                  Result:=False;
          'o'       : begin Inc(ItemIndex);
                            if ParamCount>=ItemIndex then begin
                               if (Length(s)>=3) and (LoCase(s[3])='r') then begin {-order, i.e., optimization method order}
                                  s:=ParamStr(ItemIndex); Inc(ItemIndex);
                                  b:=OptimizationMethodEnabled__[Low(OptimizationMethodEnabled__)]; // remember the 'fallback strategy enabled' setting
                                  Result:=LoadOptimizationMethodSettingsFromString(s,OptimizationMethodEnabled__,OptimizationMethodOrder__);
                                  OptimizationMethodEnabled__[Low(OptimizationMethodEnabled__)]:=b; // restore the 'fallback strategy enabled' setting
                                  end
                               else begin                                       {-optimize}
                                  s:=ParamStr(ItemIndex); Inc(ItemIndex);
                                  if   s<>'' then
                                       if      (s[1]='y') or (s[1]='Y') then    {-optimize yes}
                                               OptimizerEnabled__:=True
                                       else if (s[1]='n') or (s[1]='N') then    {-optimize no}
                                               OptimizerEnabled__:=False
                                       else if (s[1]='o') or (s[1]='O') then begin {-optimize only, that is, optimize an existing solution}
                                               SolverEnabled__:=False;
                                               OptimizerEnabled__:=True;
                                               end
                                       else if (s[1]='b') or (s[1]='B') then
                                               if   HasCharCI(s,'p') then
                                                    Optimization__:=opBoxLinesPushes {-optimize boxlines/pushes}
                                               else Optimization__:=opBoxLinesMoves  {-optimize boxlines/moves}
                                       else if (s[1]='m') or (s[1]='M') then    {-optimize moves/pushes}
                                               Optimization__:=opMovesPushes
                                       else if (s[1]='p') or (s[1]='P') then    {-optimize pushes/moves or pushes}
                                               if   (Length(s)>=7) and
                                                    ((s[7]='o') or (s[7]='O')) then
                                                    Optimization__:=opPushesOnly  {-optimize pushesonly}
                                               else Optimization__:=opPushesMoves {-optimize pushes/moves}
                                       else if StrToInt(s,i) and
                                               (i>=0) and (i<=MAX_OPTIMIZER_SEARCH_DEPTH) then
                                               OptimizerDepthLimit__:=i
                                       else Result:=False
                                  else Result:=False;
                                  end;
                               end
                            else Result:=False;
                      end;
          'p'       : begin
                        if   Length(s)>=3 then
                             if   (s[3]='a') or (s[3]='A') then {packing order}
                                  Result:=GetParameter(PackingOrderBoxCountThreshold__,0,MaxInt,0,ItemIndex)
                             else if   (s[3]='r') or (s[3]='R') then
                                       if   (Length(s)>=4) and (s[4]='o') or (s[4]='O') then
                                            Result:=GetBooleanValue(Prompt__) {"prompt", i.e., confirm messages yes/no}
                                       else Result:=GetBooleanValue(OptimizerEnabled__) {"pretty" solutions, i.e., do small optimizations after the solver has found a solution}
                                  else Result:=False
                        else Result:=False;
                      end;
          'q'       : begin {optimizer quick vicinity-search enabled}
                            Result:=GetBooleanValue(OptimizerQuickVicinitySearchEnabled__);
                      end;
          'r'       : begin {re-use nodes}
                            Result:=GetBooleanValue(ReuseNodesEnabled__);
                      end;
          's'       : begin
                        if (Length(s)>=3) and (s[3]='t') or (s[3]='T') then {stop when solved, i.e., don't search for shorter solutions}
                           Result:=GetBooleanValue(StopWhenSolved__)
                        else begin {search method}
                           Inc(ItemIndex);
                           if ParamCount>=ItemIndex then begin
                              s:=Copy(ParamStr(ItemIndex),1,2); Inc(ItemIndex);
                              for i:=1 to Length(s) do s[i]:=LoCase(s[i]);
                              Result:=False;
                              if Length(s)>=2 then
                                 for sm:=Low(sm) to High(sm) do
                                     if s=Copy(TEXT_SEARCH_METHOD[sm],1,2) then begin
                                        SearchMethod__:=sm; Result:=True;
                                        if SearchMethod__=smOptimize then begin
                                           SolverEnabled__:=False;
                                           OptimizerEnabled__:=True;
                                           end;
                                        end;
                              end
                           else Result:=False;
                           end;
                      end;
          'v'       : begin Inc(ItemIndex); i:=MAX_VICINITY_BOX_COUNT;          {optimizer: vicinity settings}
                            FillChar(VicinitySettings__,SizeOf(VicinitySettings__),0);
                            while (ParamCount>=ItemIndex) and
                                  (i>Low(VicinitySettings__)) and
                                  StrToInt(ParamStr(ItemIndex),j) and
                                  (j>0) and (j<=MAX_VICINITY_SQUARES) do begin
                                  VicinitySettings__[i]:=j;
                                  Dec(i);
                                  Inc(ItemIndex);
                                  end;
                      end;
          else        Result:=False;
       end; {case}
     end;

  if (not SolverEnabled__) and OptimizerEnabled__ and
     (OptimizerDepthLimit__=DEFAULT_OPTIMIZER_SEARCH_DEPTH) and
     (DepthLimit__<>DEFAULT_SEARCH_DEPTH) then
     OptimizerDepthLimit__:=DepthLimit__; {the user probably wants the manually entered 'DepthLimit' (the "MaxDepth" parameter) as 'OptimizerDepthLimit'}

  Result:=Result and (InputFileName__<>'') and (ItemIndex>ParamCount);
end;

function  Msg(const Text__,Caption__:String):Boolean;
begin
  {$IFDEF CONSOLE_APPLICATION}
    if (Text__<>'') or (Caption__<>'') then begin
       Writeln;
       if Caption__<>'' then Writeln(Caption__);
       if Text__   <>'' then Writeln(Text__);
       end;
    Writeln('');
    if   UserInterface.Prompt or
         StrStartsWith(Text__   ,TEXT_INTERNAL_ERROR) or
         StrStartsWith(Caption__,TEXT_INTERNAL_ERROR) then begin
         Write('Press [Enter]');
         Readln;
         end;
  {$ELSE}
    {$IFDEF WINDOWS}
      if (Text__<>'')
         and
         (UserInterface.Prompt or
          StrStartsWith(Text__   ,TEXT_INTERNAL_ERROR) or
          StrStartsWith(Caption__,TEXT_INTERNAL_ERROR)
         ) then
         Windows.MessageBox(0,PChar(Text__),PChar(Caption__),MB_OK+MB_ICONINFORMATION);
    {$ENDIF}
  {$ENDIF}
  Result:=False; {returns 'False' so 'Msg' conveniently can be used for reporting errors}
end;

procedure ShowHelp;
begin
  Writeln;
  Writeln('Usage: YASS <filename> [options]');
  Writeln('');
  Writeln('Options:');
  Writeln('  -deadlocks <number>          : deadlock sets complexity level 0-3, default ',DEFAULT_DEADLOCK_SETS_ADJACENT_OPEN_SQUARES_LIMIT);
  Writeln('  -help                        : this overview');
  Writeln('  -level     <number> [ - <number> ] : level numbers to process, default "all"');
  Writeln('  -log                         : save search information to a logfile');
  Writeln('  -maxpushes <number> (million): search limit, default none'); // DEFAULT_PUSH_COUNT_LIMIT div ONE_MILLION,' million');
  Writeln('  -maxdepth  <number>          : search limit, default (and max.) ',MAX_HISTORY_BOX_MOVES,' pushes');
  Writeln('  -maxtime   <seconds>         : search limit, default (and max.) 49 days');
  {$IFDEF WINDOWS}
    Writeln
         ('  -memory    <size>|avail (MiB): default ',CalculateDefaultMemoryByteSize div ONE_MEBI,' MiB. Available: physical memory');
  {$ELSE}
    Writeln
         ('  -memory    <size>   (MiB)    : default ',CalculateDefaultMemoryByteSize div ONE_MEBI,' MiB');
  {$ENDIF}
  Writeln('  -optimize  <moves|pushes|pushesonly|boxlines/m|boxlines/p> : default "pushes"');
  Writeln('  -packingorder <number>       : packing order threshold, default ',DEFAULT_PACKING_ORDER_BOX_COUNT_THRESHOLD,' boxes');
  Writeln('  -pretty    <no|yes>          : do small solver optimizations, default "yes"');
  Writeln('  -search    <method>          : backward/forward/optimize/perimeter (def.)');
  Writeln('  -stop      <no|yes>          : stop when solved, default "yes"');
  Writeln('Tip:');
  Writeln('  Solving small goal-room themed levels with ',DEFAULT_PACKING_ORDER_BOX_COUNT_THRESHOLD,' or more boxes may require');
  Writeln('  disabling packing-order search by setting the threshold to a higher value.');
end;

procedure ShowTitle;
begin
  Writeln(TEXT_APPLICATION_TITLE_LONG);
  Writeln(TEXT_VERSION,SPACE,TEXT_APPLICATION_VERSION_NUMBER);
  Writeln(TEXT_APPLICATION_COPYRIGHT);
end;

{-----------------------------------------------------------------------------}

{Log File}

function  CloseLogFile:Boolean;
begin {$I-}
  if   LogFile.FileName<>'' then begin
       CloseFile(LogFile.TextFile); Result:=IOResult=0;
       end
  else Result:=True;
  if   Result then LogFile.FileName:=''
  else Msg('Close Log File: File Error on File: '+LogFile.FileName,TEXT_APPLICATION_TITLE);
end; {$I+}

function  CreateLogFile(const FileName__:String):Boolean;
var i:Integer; s1,s2:String;
begin {$I-}
  Result:=False; i:=-1;
  if CloseLogFile and LogFile.Enabled then with LogFile do begin
     s1:=FileNameWithExtension(FileName__,'');
     repeat Inc(i);
            if   i=0 then s2:=''
            else s2:=SPACE+IntToStr(i);
            FileName:=FileNameWithExtension(s1+s2,LOG_FILE_EXT);
            Assign(TextFile,FileName); Rewrite(TextFile); Result:=IOResult=0;
     until  Result or (i=High(i));
     if not Result then begin
        Msg('Create Log File: Create Error on File: '+FileName,TEXT_APPLICATION_TITLE);
        LogFile.FileName:='';
        end;
     end;
end; {$I+}

function  FlushLogFile:Boolean; {flush the log-file, if any}
var s:String;
begin {$I-}
  Result:=LogFile.FileName='';
  if not Result then begin
     s:=LogFile.FileName;
     Result:=CloseLogFile;
     if Result then begin
        Append(LogFile.TextFile); {re-open the log-file so it's ready for adding more information later}
        Result:=IOResult=0;
        if   Result then LogFile.FileName:=s {restore the file-name}
        else Msg('Append to log file: File error on file: '+s,TEXT_APPLICATION_TITLE);
        end;
     end;
end; {$I+}

function  WriteBoardToLogFile(const Caption__:String):Boolean;
var i:Integer; BoardAsTextLines:TBoardAsTextLines;
begin {$I-}
  Result:=LogFile.FileName<>'';
  if Result then with LogFile do begin
     BoardToTextLines(BoardAsTextLines);
     Writeln(TextFile);
     //if Caption__<>'' then Writeln(TextFile,Caption__);
     for i:=1 to Game.BoardHeight do Writeln(TextFile,BoardAsTextLines[i]);
     if Caption__<>'' then Writeln(TextFile,Caption__);
     Result:=IOResult=0;
     end;
end; {$I+}

function  WritelnToLogFile(const Text__:String):Boolean;
begin {$I-}
  if   LogFile.FileName<>'' then with LogFile do begin
       Writeln(TextFile,Text__);
       Result:=IOResult=0;
       end
  else Result:=False;
end; {$I+}

{-----------------------------------------------------------------------------}

{Graph File}

function  CloseGraphFile:Boolean;
begin {$I-}
  if   GraphFile.FileName<>'' then with GraphFile do begin
       CloseFile(GraphFile); Result:=IOResult=0;
       Erase(GraphFile); if IOResult<>0 then {don't care};
       end
  else Result:=True;
  if   Result then GraphFile.FileName:=''
  else Msg('Close Graph File: Close file failed: '+GraphFile.FileName,TEXT_APPLICATION_TITLE);
end; {$I+}

function  CreateGraphFile(const FileName__:String):Boolean;
begin {$I-}
  Result:=False;
  if CloseGraphFile then with GraphFile do begin
     FileName:=FileNameWithExtension(FileName__,GRAPH_FILE_EXT);
     Assign(GraphFile,FileName); Rewrite(GraphFile);
     Result:=IOResult=0;
     if not Result then begin
        Msg('Create Graph File: Create file failed: '+FileName,TEXT_APPLICATION_TITLE);
        FileName:='';
        end;
     end;
end; {$I+}

{-----------------------------------------------------------------------------}

{Level Statistics}

procedure ClearStatistics;
var p:PLevelStatistics;
begin
 while LevelStatistics<>nil do begin
   p:=LevelStatistics^.Next;
   FreeMem(LevelStatistics,SizeOf(LevelStatistics^));
   LevelStatistics:=p;
   end;
end;

function  MakeLevelStatistics(const Name__:String;
                              Width__,Height__,MoveCount__,PushCount__,LowerBound__,
                              PositionCount__,CorralPositionCount__,CorralPositionBoxCount__,ForwardPositionCount__,GeneratedMovesCount__,GeneratedPushesCount__,
                              DeadlockedOpenPositionsCount__,DeadlockPositionsCount__,
                              PrecalculatedDeadlockSetsCount__,DynamicDeadlockSetsCount__,
                              DeadlockSetsPushCount__,NewPathCount__,RoomPositionCount__:Cardinal;
                              InitializationTimeMS__,DeadlockSetsTimeMS__,PackingOrderTimeMS__,SolverTimeMS__,OptimizerTimeMS__:TTimeMS;
                              Flags__:TLevelStatisticsFlags):PLevelStatistics;
begin
//{$HINTS OFF} Result:=nil; {$HINTS ON} {'nil': in case 'GetMem' fails and returns 'nil' instead of raising an exception}
  GetMem(Result,SizeOf(Result^));
  if Result<>nil then with Result^ do begin
     FillChar(Result^,SizeOf(Result^),0);
     CorralPositionCount           :=CorralPositionCount__;
     CorralPositionBoxCount        :=CorralPositionBoxCount__;
     DeadlockedOpenPositionsCount  :=DeadlockedOpenPositionsCount__;
     DeadlockPositionsCount        :=DeadlockPositionsCount__;
     DeadlockSetsPushCount         :=DeadlockSetsPushCount__;
     DeadlockSetsTimeMS            :=DeadlockSetsTimeMS__;
     DynamicDeadlockSetsCount      :=DynamicDeadlockSetsCount__;
     Flags                         :=Flags__;
     ForwardPositionCount          :=ForwardPositionCount__;
     GeneratedMovesCount           :=GeneratedMovesCount__;
     GeneratedPushesCount          :=GeneratedPushesCount__;
     Height                        :=Height__;
     InitializationTimeMS          :=InitializationTimeMS__;
     LowerBound                    :=LowerBound__;
     MoveCount                     :=MoveCount__;
     Name                          :=Name__;
     NewPathCount                  :=NewPathCount__;
     Next                          :=LevelStatistics;
     OptimizerTimeMS               :=OptimizerTimeMS__;
     PackingOrderTimeMS            :=PackingOrderTimeMS__;
     PrecalculatedDeadlockSetsCount:=PrecalculatedDeadlockSetsCount__;
     PositionCount                 :=PositionCount__;
     PushCount                     :=PushCount__;
     RoomPositionCount             :=RoomPositionCount__;
     SolverTimeMS                  :=SolverTimeMS__;
     Width                         :=Width__;
     LevelStatistics               :=Result; {updates the global list}
     end;
end;

procedure FinalizeStatistics;
begin
  ClearStatistics;
end;

procedure InitializeStatistics;
begin
  LevelStatistics:=nil; ClearStatistics;
end;

function  WriteStatistics(OutputFileName__:String):Boolean;
const SHORT_LINE_LENGTH=80;
var
  i,j,Count,LineLength,SolvedCount,
  NonOptimalSolutionCount,TotalGeneratedPushesCountMillion:Integer;
  UnsignedInteger32:UInt32; Integer64:Int64;
  s:String; Total:TLevelStatistics; This,Next:PLevelStatistics; F:Text;
begin {$I-}
  s:=FileNameWithExtension(OutputFileName__,TEXT_STATISTICS_FILENAME_SUFFIX);
  Assign(F,s); Rewrite(F);
  Result:=IOResult=0;
  if Result then begin
     This:=LevelStatistics; LevelStatistics:=nil; SolvedCount:=0;
     LineLength:=SHORT_LINE_LENGTH;
     if not Solver.FindPushOptimalSolution then Inc(LineLength,8);
     if (not Solver.Enabled) and Optimizer.Enabled then Inc(LineLength,8);
     while This<>nil do begin {reverse the items}
       Next:=This^.Next; This^.Next:=LevelStatistics; LevelStatistics:=This; This:=Next;
       end;
     Count:=0; FillChar(Total,SizeOf(Total),0);
     NonOptimalSolutionCount:=0; TotalGeneratedPushesCountMillion:=0;

     for i:=1 to LineLength do Write(F,HYPHEN); Writeln(F);
     Write(F,TEXT_APPLICATION_TITLE,SPACE,TEXT_APPLICATION_VERSION_NUMBER);
     if Solver.Enabled then Writeln(F,' - Results')
     else Writeln(F,' - Optimizer Results');
     Writeln(F,'File: ',OutputFileName__);
     if      Solver.Enabled then
             Writeln(F,'Method: ',TEXT_SOLUTION_METHOD[Solver.FindPushOptimalSolution],', ',TEXT_SEARCH_METHOD[Solver.SearchMethod],' search')
     else if Optimizer.Enabled then
             if      Optimizer.Optimization=opMovesPushes then Writeln(F,'Optimize: Moves/pushes')
             else if Optimizer.Optimization=opPushesMoves then Writeln(F,'Optimize: Pushes/moves')
             else    Writeln(F,'Optimize: Pushes');

     if Solver.SearchLimits.TimeLimitMS<>High(Solver.SearchLimits.TimeLimitMS) then begin
        UnsignedInteger32:=UInt32(Solver.SearchLimits.TimeLimitMS) div 1000;
        if UnsignedInteger32<UInt32(High(Solver.SearchLimits.TimeLimitMS)) div 1000 then begin
           Write(F,'Maximum search time: ',UnsignedInteger32,' second');
           if   UnsignedInteger32<>1 then Writeln(F,'s') {plural, i.e., 'seconds'}
           else Writeln(F);
           end;
        end;
     if Solver.SearchLimits.PushCountLimit<DEFAULT_PUSH_COUNT_LIMIT then begin
        Integer64:=Solver.SearchLimits.PushCountLimit div ONE_MILLION; {some versions of the FPC compiler requires copying an expression to a variable before writing it to a file}
        Writeln(F,'Maximum generated pushes: ',Integer64,' million');
        end;
     if   Solver.FindPushOptimalSolution then begin
          if Solver.SearchLimits.DepthLimit<MAX_HISTORY_BOX_MOVES then
             if      Solver.Enabled then
                     Writeln(F,'Maximum search depth: ',Solver.SearchLimits.DepthLimit,' pushes')
             else if Optimizer.Enabled then
                     Writeln(F,'Maximum search depth: ',Solver.SearchLimits.DepthLimit,' boxes')
          end
     else if Solver.SearchLimits.DepthLimit<MAX_HISTORY_BOX_MOVES then
             Writeln(F,'Maximum search depth: ',Solver.SearchLimits.DepthLimit,' moves');
     i:=(Positions.MemoryByteSize +(ONE_MEBI div 2)) div ONE_MEBI;
     Write(F,'Transposition table: ',i,' MiB');
     if   Solver.Enabled or Optimizer.Enabled then
          Writeln(F,' (',Positions.Capacity,' positions)')
     else Writeln(F);

     for i:=1 to LineLength do Write(F,HYPHEN); Writeln(F);
     //Write(F,'Level':36,'Minimum':8);
     Write(F,'Level':36);
     if Solver.Enabled then Write(F,'Minimum':8)
     else Write(F,'':8);
     if not Solver.FindPushOptimalSolution then Write(F,'':8);
     if (not Solver.Enabled) and Optimizer.Enabled then Write(F,'':8);

     Writeln(F,'Generated':13,'Generated':13,'Time':10);
     Write(F,'No':4,'W':3,'H':3,'Name':26);
     if not Solver.FindPushOptimalSolution then Write(F,'Moves':8);
     if Solver.Enabled then Write(F,'Pushes':8)
     else if   Optimizer.Enabled then
               Write(F,'Moves':8,'Pushes':8)
          else Write(F,'':8);
     Write(F,'Positions':13);
     if   Solver.FindPushOptimalSolution then Write(F,'Pushes':13)
     else Write(F,'Moves':13);
     Writeln(F,'Seconds':10);
     for i:=1 to LineLength do Write(F,HYPHEN); Writeln(F);

     This:=LevelStatistics;
     while This<>nil do with This^ do begin
       Inc(Count);
       Inc(Total.PositionCount,PositionCount);
       Inc(Total.CorralPositionCount,CorralPositionCount);
       Inc(Total.CorralPositionBoxCount,CorralPositionBoxCount);
       Inc(Total.ForwardPositionCount,ForwardPositionCount);
       Inc(Total.MoveCount,Abs(MoveCount));
       Inc(Total.PushCount,Abs(PushCount));
       Inc(Total.GeneratedMovesCount ,GeneratedMovesCount);
       if        High(Total.GeneratedPushesCount)-GeneratedPushesCount<Total.GeneratedMovesCount then begin
                 Inc(TotalGeneratedPushesCountMillion,Total.GeneratedPushesCount div ONE_MILLION);
                 Inc(TotalGeneratedPushesCountMillion,      GeneratedPushesCount div ONE_MILLION);
                 end
       else if   TotalGeneratedPushesCountMillion=0 then
                 Inc(Total.GeneratedPushesCount,GeneratedPushesCount)
            else Inc(TotalGeneratedPushesCountMillion,      GeneratedPushesCount div ONE_MILLION);

       Inc(Total.InitializationTimeMS,InitializationTimeMS);
       Inc(Total.SolverTimeMS,SolverTimeMS);
       Inc(Total.DeadlockedOpenPositionsCount,DeadlockedOpenPositionsCount);
       Inc(Total.DeadlockPositionsCount,DeadlockPositionsCount);
       Inc(Total.DeadlockSetsPushCount,DeadlockSetsPushCount);
       Inc(Total.DeadlockSetsTimeMS,DeadlockSetsTimeMS);
       Inc(Total.DynamicDeadlockSetsCount,DynamicDeadlockSetsCount);
       Inc(Total.NewPathCount,NewPathCount);
       Inc(Total.PackingOrderTimeMS,PackingOrderTimeMS);
       Inc(Total.PrecalculatedDeadlockSetsCount,PrecalculatedDeadlockSetsCount);
       Inc(Total.OptimizerTimeMS,OptimizerTimeMS);
       Inc(Total.RoomPositionCount,RoomPositionCount);

       if (Solver.Enabled and (PushCount<>0))
          or
          ((not Solver.Enabled)
           and
           Optimizer.Enabled
           and
           ((lsfMovesImproved            in Flags)
            or
            (lsfPushesImproved           in Flags)
            or
            (lsfSecondaryMetricsImproved in Flags)
           )
          ) then begin
          Inc(SolvedCount);
          if not (lsfOptimalSolution in Flags) then Inc(NonOptimalSolutionCount);
          end;

       i:=Pred(Integer(Reader.FirstLevelNo))+Count;
       Write(F,i:4,Width:3,Height:3);

       s:=Name;
       i:=Pos(DOUBLE_QUOTE,s);
       if i<>0 then Delete(s,1,i);
       i:=Pos(DOUBLE_QUOTE,s);
       if i<>0 then Delete(s,i,MaxInt);
       if Length(s)>25 then Delete(s,26,MaxInt);
       Write(F,s:26);


       if   Solver.Enabled and
            (not Solver.FindPushOptimalSolution) then
            if MoveCount>0 then Write(F,MoveCount:8)
            else Write(F,'':8);

       if   MoveCount<>0 then begin
            if Solver.Enabled then Write(F,PushCount:8)
            else if   Optimizer.Enabled then begin
                      Integer64:=Abs(MoveCount);
                      Write(F,Integer64:8);
                      if lsfMovesImproved in Flags then Write(F,ASTERISK)
                      else Write(F,SPACE);
                      Integer64:=Abs(PushCount);
                      Write(F,Integer64:7);
                      if lsfPushesImproved in Flags then Write(F,ASTERISK)
                      else Write(F,SPACE);
                      end
                 else Write(F,'':9);
            if  Solver.Enabled then
                if   lsfOptimalSolution in Flags then Write(F,SPACE)
                else Write(F,ASTERISK);
            end
       else if Solver.Enabled then Write(F,'':9)
            else Write(F,'':17);

       Write(F,PositionCount:12);
       if Solver.FindPushOptimalSolution then Write(F,GeneratedPushesCount:13)
       else Write(F,GeneratedMovesCount:13);
       i:=InitializationTimeMS+SolverTimeMS+OptimizerTimeMS;
       if   i>=500 then begin
            i:=(i+500) div 1000;
            Write(F,i:10);
            end
       else Write(F,'':10);
       //if (LowerBound>=0) and (LowerBound<INFINITY) then begin
       //   Write(F,LowerBound:8); Inc(Total.LowerBound,LowerBound);
       //   end;
       //
       //Integer64:=PrecalculatedDeadlockSetsCount+DynamicDeadlockSetsCount;
       //Write(F,'  ',Integer64:6,DeadlockSetsPushCount:10,DeadlockSetsTimeMS:8);
       //Write(F,'  ',DeadlockSetsSearchCount:10);
       Writeln(F);

       This:=This^.Next;
       end;

     if Count>0 then begin for i:=1 to LineLength do Write(F,HYPHEN); Writeln(F); end;
     with Total do begin
       Write(F,Count:4);
       if Solver.Enabled then begin
          s:=IntToStr(Count-SolvedCount);
          Write(F,SolvedCount:6,' solved, ',s,' failed');
          i:=10-Length(s);
          for  j:=1 to i-5 do Write(F,SPACE);
          if   i>5 then Write(F,'Total')
          else for j:=1 to i do Write(F,SPACE); {drop the 'Total' text when the number of failed levels exceeds 4 digits}
          end
       else if Optimizer.Enabled then Write(F,'Total':32);
       if not Solver.FindPushOptimalSolution then Write(F,MoveCount:8);
       if Solver.Enabled then Write(F,PushCount:8)
       else if   Optimizer.Enabled then begin
                 if MoveCount<>0 then Write(F,MoveCount:8)
                 else Write(F,'':8);
                 if PushCount<>0 then Write(F,PushCount:8)
                 else Write(F,'':8);
                 end
            else Write(F,'':16);
       Write(F,PositionCount:13);

       if Solver.FindPushOptimalSolution then
          if   TotalGeneratedPushesCountMillion=0 then
               Write(F,GeneratedPushesCount:13,'  ')
          else Write(F,TotalGeneratedPushesCountMillion:13,' M')
       else    Write(F,GeneratedMovesCount:13,'  ');

       i:=InitializationTimeMS+SolverTimeMS+OptimizerTimeMS;
       if i>=500 then begin
          i:=(i+500) div 1000;
          Write(F,i:8);

          {$IFDEF DEFINE CONSOLE_APPLICATION}
            s:=IntToStrWithPluralDependentText(i,'second');
            Writeln('Total session time: ',s);
          {$ENDIF}
          end;
       //if LowerBound<>0 then Write(F,LowerBound:8);
       //Write(F,'  ',DeadlockSetsCount:6,DeadlockSetsSearchCount:10,DeadlockSetsTimeMS:8);
       end;
     Writeln(F);

     for i:=1 to LineLength do Write(F,HYPHEN); Writeln(F);

     if Solver.Enabled then begin

        if NonOptimalSolutionCount<>0 then begin
           if NonOptimalSolutionCount<>1 then s:='s'
           else s:='';
           Writeln(F,'  *:',NonOptimalSolutionCount:6,' solution',s,' may not be optimal');
           for i:=1 to LineLength do Write(F,HYPHEN); Writeln(F);
           end;

        Writeln(F,'Time is rounded to nearest second. A blank time denotes less than 0.5 seconds.');
        Writeln(F);
        Writeln(F,'Corrals - added outside boxes              : ',Solver.AddedCorralBoxesCount:12);
        Writeln(F,'Corrals - all boxes                        : ',Solver.ExposedInwardsCorralCount2:12);
        Writeln(F,'Corrals - pruning candidates               : ',Solver.ExposedInwardsCorralCount1:12);
        if   (Total.ForwardPositionCount<>0) and (Solver.ExposedInwardsCorralCount1<>0) then
             i:=(Solver.ExposedInwardsCorralCount1*100) div Total.ForwardPositionCount
        else i:=0;
        Writeln(F,'Corrals - pruning ratio                    : ',i:12,'% forward positions');
        Writeln(F,'Corrals - total                            : ',Solver.CorralCount:12);
        Writeln(F,'Corrals - stored                           : ',Total.CorralPositionCount:12);
        Writeln(F,'Corrals - stored boxes                     : ',Total.CorralPositionBoxCount:12);
        Writeln(F,'Rooms - pruning candidates                 : ',Total.RoomPositionCount:12);
        Writeln(F,'Deadlocks - precalculated                  : ',Total.PrecalculatedDeadlockSetsCount:12);
        Writeln(F,'Deadlocks - dynamic                        : ',Total.DynamicDeadlockSetsCount:12);
        i:=Total.PrecalculatedDeadlockSetsCount+Total.DynamicDeadlockSetsCount;
        Writeln(F,'Deadlocks - total used                     : ',i:12);
        i:=Game.DeadlockSets.SessionDeadlockSetsCount-i;
        Writeln(F,'Deadlocks - redundant                      : ',i:12);
        Writeln(F,'Deadlocks - calculated, saved              : ',Game.DeadlockSets.SessionDeadlockSetsCount:12);
        Writeln(F,'Deadlocks - calculated, table overflow     : ',Game.DeadlockSets.SessionDeadlockSetsTableOverflowCount:12);
        i:=Game.DeadlockSets.SessionDeadlockSetsCount+Game.DeadlockSets.SessionDeadlockSetsTableOverflowCount;
        Writeln(F,'Deadlocks - total calculated               : ',i:12);
        Writeln(F,'Deadlocks - player must be outside set     : ',Game.DeadlockSets.SessionPlayerMustBeOutsideSetCount:12);
        Integer64:=Total.PositionCount-Total.ForwardPositionCount;
        Writeln(F,'Positions - backward search                : ',Integer64:12);
        Writeln(F,'Positions - forward search                 : ',Total.ForwardPositionCount:12);
        Writeln(F,'Positions - revisited                      : ',Total.NewPathCount:12);
        Writeln(F,'Positions - deadends                       : ',Solver.DeadEndCount:12);
        Writeln(F,'Positions - deadlocked open positions      : ',Total.DeadlockedOpenPositionsCount:12);
        Writeln(F,'Positions - total                          : ',Total.PositionCount:12);
        Writeln(F,'Time - deadlock analysis                   : ',Total.DeadlockSetsTimeMS:12,' milliseconds');
        Writeln(F,'Time - packing order                       : ',Total.PackingOrderTimeMS:12,' milliseconds');
        Writeln(F,'Time - small optimizations                 : ',Total.OptimizerTimeMS:12,' milliseconds');
        i:=Total.InitializationTimeMS+Total.SolverTimeMS+Total.OptimizerTimeMS;
        Writeln(F,'Time - total                               : ',i:12,' milliseconds');
        for i:=1 to LineLength do Write(F,HYPHEN); Writeln(F);
        Writeln(F,'Re-use player''s reachable squares? No      : ',Solver.ReusePlayersReachableSquaresFromPredecessorCount[False]:12);
        Writeln(F,'Re-use player''s reachable squares? Yes     : ',Solver.ReusePlayersReachableSquaresFromPredecessorCount[True ]:12);
        end
     else
        if Optimizer.Enabled then begin
           if SolvedCount<>1 then s:='s'
           else s:='';
           Write(F,SolvedCount:4,' Improved level',s);
           if SolvedCount<>0 then Write(F,'  (Improved metrics are marked by "*")');
           Writeln(F);
           for i:=1 to LineLength do Write(F,HYPHEN); Writeln(F);
           end;

     Close(F);

     This:=LevelStatistics; LevelStatistics:=nil;
     while This<>nil do begin {reverse the items again}
       Next:=This^.Next; This^.Next:=LevelStatistics; LevelStatistics:=This; This:=Next;
       end;

     Result:=IOResult=0;
     end
  else begin
     Write('File Creation Error: '+s); Readln;
     end
end; {$I+}

{-----------------------------------------------------------------------------}

{Board}

function  BoardToText(const LineTerminator__:String):String;
var Row:Integer; s:String; BoardAsTextLines:TBoardAsTextLines;
begin
  Result:='';
  BoardToTextLines(BoardAsTextLines);
  for Row:=1 to Game.BoardHeight do begin
      s:=BoardAsTextLines[Row];
      if Length(s)>Game.BoardWidth then s:=Copy(s,1,Game.BoardWidth); {this shouldn't happen}
      while Length(s)<Game.BoardWidth do s:=s+SPACE;
      if   Result<>'' then
           Result:=Result+LineTerminator__+s
      else Result:=s;
      end;

end;

procedure BoardToTextLines(var BoardAsTextLines__:TBoardAsTextLines);
var Col,Row:Integer;
begin
  with Game do begin
    for Row:=1 to BoardHeight do begin
        BoardAsTextLines__[Row]:='';
        for Col:=1 to BoardWidth do
            if   ColRowToSquare(Col,Row)=0 then {'0': fill in a square number to be marked (for testing)}
                 BoardAsTextLines__[Row]:=BoardAsTextLines__[Row]+'!'
            else BoardAsTextLines__[Row]:=BoardAsTextLines__[Row]+
                                          SquareToChar(ColRowToSquare(Col,Row));
        end;
    end;
end;

function  CalculateGateSquares:Integer; {finds all floor squares that split the board in two separate rooms}
var BoxNo,Square,NeighborSquare,OppositeNeighborSquare,OldPlayerPos:Integer; Direction:TDirection;
begin {caution: assumes 4 directions only}
  with Game do begin
    Result:=0;
    OldPlayerPos:=Game.PlayerPos;
    for BoxNo:=1 to BoxCount do Dec(Board[BoxPos[BoxNo]],BOX);                  {remove boxes from the board}

    for Square:=0 to BoardSize do
        if (Board[Square] and {inline 'IsALegalAndBoxReachableSquare' and 'IsAGateSquare'}
            (WALL+FLAG_ILLEGAL_BOX_SQUARE+FLAG_BOX_REACHABLE_SQUARE+FLOOR+FLAG_GATE_SQUARE))
           =
           FLAG_BOX_REACHABLE_SQUARE+FLOOR then
           for Direction:=Low(Direction) to High(Direction) do begin //Succ(Low(Direction)) do begin
               NeighborSquare        :=Square+Game.SquareOffsetForward[Direction];
               OppositeNeighborSquare:=Square-Game.SquareOffsetForward[Direction];
               if IsAFloorSquare(NeighborSquare)
                  and
                  IsAFloorSquare(OppositeNeighborSquare) then begin
                  if not (IsALegalAndBoxReachableSquare(Square+SquareOffsetLeft [Direction])
                          or
                          IsALegalAndBoxReachableSquare(Square+SquareOffsetRight[Direction])
                         )
                     then with Solver.SearchStates[SEARCH_STATE_INDEX_DO_PUSH].PlayersReachableSquares do begin
                     {
                     -W-  'W' = wall or illegal box square;
                     >?>  center square = 'Square'; direction ->
                     -W-
                     }
                     Inc(Board[Square],BOX);
                     MovePlayer(NeighborSquare);
                     CalculatePlayersReachableSquares(SEARCH_STATE_INDEX_DO_PUSH);
                     Dec(Game.Board[Square],BOX);
                     if (Squares[NeighborSquare]<>Squares[OppositeNeighborSquare]) then begin {'True': 'Square' splits the board in 2 separate rooms}
                        Board[Square]:=Board[Square] or FLAG_GATE_SQUARE;
                        Inc(Result);
                        end;
                     end
                  else if
                          (IsAWallSquare(Square+SquareOffsetLeft [Direction])
                           and
                           (IsAWallSquare(NeighborSquare        +SquareOffsetRight[Direction])
                            or
                            IsAWallSquare(OppositeNeighborSquare+SquareOffsetRight[Direction])
                           )
                           {
                             -#-       -#-    '#' = wall
                             >?>  or   >?>    '?' = 'Square'; direction ->
                             --#       #--
                           }
                          )
                          or
                          (IsAWallSquare(NeighborSquare         +SquareOffsetLeft [Direction])
                           and
                           IsAWallSquare(OppositeNeighborSquare +SquareOffsetLeft [Direction])
                           {
                             #-#    '#' = wall
                             >?>    '?' = 'Square'; direction ->
                             ---
                           }
                          )
                          then with Solver.SearchStates[SEARCH_STATE_INDEX_DO_PUSH].PlayersReachableSquares do begin
                          Inc(Board[Square],BOX);
                          MovePlayer(NeighborSquare);
                          CalculatePlayersReachableSquares(SEARCH_STATE_INDEX_DO_PUSH);
                          if (Squares[NeighborSquare]<>Squares[OppositeNeighborSquare]) then begin {'True': 'Square' splits the board in 2 separate rooms when the box moves along the axis given by 'Direction'}
                             NeighborSquare        :=Square+Game.SquareOffsetLeft [Direction];
                             OppositeNeighborSquare:=Square+Game.SquareOffsetRight[Direction];
                             {e.g.,
                                #-#    '#' = wall; middle = new 'NeighborSquare'
                                >?>    '?' = 'Square'; direction ->
                                --#    middle = new 'OppositeNeighborSquare'
                             }
                             if IsAFloorSquare(NeighborSquare) and
                                IsAFloorSquare(OppositeNeighborSquare) then begin
                                MovePlayer(NeighborSquare);
                                CalculatePlayersReachableSquares(SEARCH_STATE_INDEX_DO_PUSH);
                                if (Squares[NeighborSquare]<>Squares[OppositeNeighborSquare]) then begin {'True': 'Square' splits the board in 2 separate rooms}
                                   Board[Square]:=Board[Square] or FLAG_GATE_SQUARE;
                                   Inc(Result);
                                   end;
                                end
                             else begin
                                {'NeighborSquare' or 'OppositeNeighborSquare'
                                 contains a wall, e.g.,
                                  ##-    '#' = wall; middle = new 'NeighborSquare'
                                  >?>    '?' = 'Square'; direction ->
                                  --#    middle = new 'OppositeNeighborSquare'
                                }
                                Board[Square]:=Board[Square] or FLAG_GATE_SQUARE;
                                Inc(Result);
                                end;
                             end;
                          Dec(Game.Board[Square],BOX);
                          end;
                  end;
               end;

    for BoxNo:=1 to Game.BoxCount do Inc(Game.Board[Game.BoxPos[BoxNo]],BOX);   {put boxes and the player back on the board}
    MovePlayer(OldPlayerPos);
    end;
end;

function  CalculateHashValue:THashValue;
var BoxNo,Square:Integer;
begin {only box positions are taken into account; the player position isn't considered, it's saved separately in each node}
  Result:=0;
  for BoxNo:=1 to Game.BoxCount do begin
      Square:=Game.BoxPos[BoxNo];
      if Square<>0 then {'True': the box is on the board, i.e., it hasn't been removed temporarily}
         Result:=Result xor Positions.SquareHashValues[Square];
      end;
end;

function  CalculateSimpleLowerBound:Integer;
var BoxNo,Distance,Square:Integer;
begin {calculates distance to nearest goal for all boxes}
  Result:=0;
  for BoxNo:=1 to Game.BoxCount do begin
      Square:=Game.BoxPos[BoxNo];
      if Square<>0 then begin {'True': the box is on the board, i.e., it hasn't been removed temporarily}
         if   not Game.ReverseMode then
              Distance:=Game.DistanceToNearestGoal            [Square]
         else Distance:=Game.DistanceToNearestBoxStartPosition[Square];
         if   Result<INFINITY then Inc(Result,Distance)
         else Inc(Result); {the result is meaningless if a box cannot reach a target position}
         end;
      end;
end;

procedure CalculateTunnelSquares;
var Square,NextSquare:Integer;
    SquareIsBlockedByTwoWallsAlongTheOtherAxis:Boolean; Direction:TDirection;
begin {caution: assumes 4 directions only}
  with Game do begin
    for Square:=0 to BoardSize do Board[Square]:=Board[Square] and (not DIRECTION_TO_TUNNEL_FLAGS); {clear old flags, if any}
    for Square:=0 to BoardSize do
        if IsALegalAndBoxReachableSquare(Square) then
           for Direction:=Low(Direction) to High(Direction) do begin
               NextSquare:=Square+SquareOffsetForward[Direction];
               if IsALegalAndBoxReachableSquare(NextSquare) then begin
                  SquareIsBlockedByTwoWallsAlongTheOtherAxis:=
                    IsAWallSquare(Square+SquareOffsetLeft [Direction]) and
                    IsAWallSquare(Square+SquareOffsetRight[Direction]);
                  if not ReverseMode then begin
                     if ( (not IsAGoalSquare(NextSquare))
{
                          or
                          {if a packing order is in use, then give goal squares
                           almost the same treatment as regular non-goal tunnel
                           squares; the differences are:
                           * both this square and the next square must be goals;
                           * the packing order must dictate advancement from
                             this square to the next;
                           * not only this square, but also the next square must
                             be blocked by walls along (all) the other axis;
                           * during the search for a solution, pushing a box to
                             a regular non-goal tunnel square always prunes all
                             other box pushes; for a goal tunnel square, this
                             pruning only kicks in if the tunnel isn't blocked
                             by another box;

                          ( ( Solver.PackingOrder.SetCount > 0 )
                            and
                            IsAGoalSquare( Square )
                            and
                            SquareIsBlockedByTwoWallsAlongTheOtherAxis
                            and
                            (       Solver.PackingOrder.GoalSetNo[ Board[ NextSquare ] shr GOAL_BIT_SHIFT_COUNT ]
                              =
                              Succ( Solver.PackingOrder.GoalSetNo[ Board[ Square     ] shr GOAL_BIT_SHIFT_COUNT ] ) )
                            and
                            IsAWallSquare( NextSquare + SquareOffsetLeft [ Direction ] ) and
                            IsAWallSquare( NextSquare + SquareOffsetRight[ Direction ] )
                          )
}
                        )
                        and
                        (
                         ((SquareIsBlockedByTwoWallsAlongTheOtherAxis
                           or
                           IsAGateSquare(NextSquare)
                          )
                          and
                          IsABlockedBoxSquareAlongAxis(NextSquare,NEXT_DIRECTION[Direction]) {caution: 'NEXT_DIRECTION...'): assumes 4 directions only}
                         )
                         or
                         (SquareIsBlockedByTwoWallsAlongTheOtherAxis
                          and
                          IsAGateSquare(Square)
                         )
                        )
                        then begin
                        {a box at 'Square' can only move along the axis given by}
                        {'Direction', and both squares along the other axis     }
                        {contain walls (or 'NextSquare' is a gate square);      }
                        {                                                       }
                        {at 'NextSquare', the box can also only move along the  }
                        {axis given by 'Direction';                             }
                        {therefore, when the box moves in the direction given by}
                        {'Direction' to 'NextSquare', then the box may just as  }
                        {well be pushed one step further at once, instead of    }
                        {"parking" at 'NextSquare';                             }
                        {                                                       }
                        {the following figures depict the situation after the   }
                        {box has been pushed upwards to 'NextSquare';           }
                        {                                                       }
                        { #$#    #$_    _$#    #_$_#    $ = 'NextSquare'        }
                        { #@#    #@#    #@#     #@#     @ = 'Square'            }
                        {                                                       }
                        {if 'NextSquare' is a gate square then 'Square' doesn't }
                        {need to be blocked by walls on both both sides;        }
                        {                                                       }
                        {additionally, if 'Square' is a gate square and has     }
                        {walls on both sides, then "parking" at 'NextSquare' is }
                        {unnecessary too:                                       }
                        {                                                       }
                        { _$_    $ = 'NextSquare'                               }
                        { #@#    @ = 'Square', and 'Square' is a gate square    }
                        {                                                       }
                        Board[NextSquare]:=Board[NextSquare] or DIRECTION_TO_TUNNEL_FLAG[Direction];
                        end;
                     end
                  else begin {reverse mode}
                     if (not IsABoxStartSquare(NextSquare))
                        and
                        (SquareIsBlockedByTwoWallsAlongTheOtherAxis
                         or
                         IsAGateSquare(NextSquare)
                        )
                        and
                        (not IsALegalAndBoxReachableSquare(NextSquare+SquareOffsetRight[Direction])) {caution: '...OffsetLeft' and '...OffsetRight': assumes 4 directions only}
                        and
                        (not IsALegalAndBoxReachableSquare(NextSquare+SquareOffsetLeft [Direction])) {caution: '...OffsetLeft' and '...OffsetRight': assumes 4 directions only}
                        and
                        IsAFloorSquare(NextSquare+SquareOffsetForward[Direction])
                        then begin
                        {the following figures depict the tunnel situations in  }
                        {backward mode before the box is pulled upwards to      }
                        {'NextSquare';                                          }
                        {                                                       }
                        { #@#    #@_#  #_@#   #_@_#    @ = 'NextSquare'         }
                        { #$#    #$#    #$#    #$#     $ = 'Square'             }
                        {                                                       }
                        {if 'NextSquare' is a gate square then 'Square' doesn't }
                        {need to be blocked by walls on both both sides         }
                        {                                                       }
                        Board[NextSquare]:=Board[NextSquare] or DIRECTION_TO_TUNNEL_FLAG[Direction];
                        end;
                     end;
                  end;
               end;
    end;
end;

procedure ClearBoard(BoardWidth__,BoardHeight__:Integer);
var Col,Row,RowOffset:Integer;
begin
  with Game do begin
    InitializeBoard(BoardWidth__,BoardHeight__,True);
    for Row:=2 to Pred(BoardHeight) do begin {2..Pred(Height): leave a wall border}
        RowOffset:=ColRowToSquare(0,Row);
        for Col:=2 to Pred(BoardWidth) do Game.Board[RowOffset+Col]:=FLOOR;
        end;
    PlayerPos:=0; Game.BoxCount:=0; GoalCount:=0;
    HashValue:=CalculateHashValue;
    end;
end;

procedure DumpBoard;
var Col,Row:Integer;
begin
  with Game do begin
    for Row:=1 to BoardHeight do begin
        for Col:=1 to BoardWidth do Write(Board[ColRowToSquare(Col,Row)]:3);
        Writeln;
        end;
    end;
end;

procedure InitializeBoard(BoardWidth__,BoardHeight__:Integer; FillSquares__:Boolean);
var i,RowOffset:Integer; Direction:TDirection;
begin
  with Game do begin
    BoardSize:=(BoardWidth__+2)*(BoardHeight__+2); {the extra 2 is for a wall-filled border}
    SquareOffsetForward[dUp   ]:=-(BoardWidth__+2);
    SquareOffsetForward[dLeft ]:=-1;
    SquareOffsetForward[dDown ]:=+(BoardWidth__+2);
    SquareOffsetForward[dRight]:=+1;

    for Direction:=Low(Direction) to Pred(High(Direction)) do
        SquareOffsetLeft[Direction]:=SquareOffsetForward[Succ(Direction)];
    SquareOffsetLeft[High(Direction)]:=SquareOffsetForward[Low(Direction)];

    for Direction:=Succ(Low(Direction)) to High(Direction) do
        SquareOffsetRight[Direction]:=SquareOffsetForward[Pred(Direction)];
    SquareOffsetRight[Low(Direction)]:=SquareOffsetForward[High(Direction)];

    if FillSquares__ then
       for i:=0 to BoardSize do Board[i]:=WALL
    else
       if (BoardWidth<>BoardWidth__) or (BoardHeight<>BoardHeight__) then begin
          {add a wall-filled border to ensure that the player always is surrounded by walls}
          for i:=0 to BoardWidth__+1 do Board[i]:=WALL; {top row}
          for i:=BoardSize downto BoardSize-BoardWidth__-2 do Board[i]:=WALL; {bottom row}
          RowOffset:=0;
          for i:=1 to BoardHeight__ do begin
              Inc(RowOffset,BoardWidth__+2);
              Board[RowOffset]:=WALL; Board[RowOffset+BoardWidth__+1]:=WALL; {left and right columns}
              end;
          end;
    BoardWidth:=BoardWidth__; BoardHeight:=BoardHeight__;
    end;
end;

procedure SetBoard(PlayerPos__:Integer; BoxPos__:TBoxSquares; ReverseMode__:Boolean;
                   var OldPlayerPos__:Integer; var OldBoxPos__:TBoxSquares;
                   var OldReverseMode__:Boolean);
var BoxNo:Integer;
begin
  OldPlayerPos__:=Game.PlayerPos; OldBoxPos__:=Game.BoxPos;                     {save current state}
  OldReverseMode__:=Game.ReverseMode;

  Game.ReverseMode:=ReverseMode__;
  for BoxNo:=1 to Game.BoxCount do Dec(Game.Board[Game.BoxPos[BoxNo]],BOX);     {remove boxes from the board}
  Game.BoxPos:=BoxPos__;                                                        {put boxes on goal positions}
  for BoxNo:=1 to Game.BoxCount do Inc(Game.Board[Game.BoxPos[BoxNo]],BOX);     {update the board}
  MovePlayer(PlayerPos__);                                                      {put player on the board}
  Game.SimpleLowerBound:=CalculateSimpleLowerBound;                             {calculate game information}
  Game.HashValue:=CalculateHashValue;
end;

procedure ShowBoard;
var Row:Integer; BoardAsTextLines:TBoardAsTextLines;
begin
  FillChar(BoardAsTextLines,SizeOf(BoardAsTextLines),0);
  BoardToTextLines(BoardAsTextLines);
  for Row:=1 to Game.BoardHeight do
      Writeln(BoardAsTextLines[Row]);
end;

procedure ShowBoxDistanceToAllSquares(const Distances__:TBoardOfIntegers);
var Col,Row,Square,Distance:Integer;
begin
  with Game do begin
    for Row:=1 to BoardHeight do begin
        for Col:=1 to BoardWidth do begin
            Square:=ColRowToSquare(Col,Row);
            Distance:=Distances__[Square];
            if (Board[Square] and WALL)<>0 then
               Write('#':2)
            else if   Distance>=BoardSize then Write('_':2)
                 else Write(Distance:2);
            end;
        Writeln;
        end;
    end;
end;

procedure ShowBoxDistanceToNearestGoal;
var Col,Row,Distance:Integer;
begin
  with Game do begin
    for Row:=1 to BoardHeight do begin
        for Col:=1 to BoardWidth do begin
            Distance:=DistanceToNearestGoal[ColRowToSquare(Col,Row)];
            if (Board[ColRowToSquare(Col,Row)] and WALL)<>0 then
               Write('#':2)
            else if   Distance>BoardSize then Write('_':2)
                 else if ((Board[ColRowToSquare(Col,Row)] and GOAL)<>0) and
                         (Distance=0) then Write('.':2)
                         else Write(Distance:2);
            end;
        Writeln;
        end;
    end;
end;

procedure ShowBoxReachableSquaresForAllBoxes;
var i,Col,Row:Integer;
begin
  with Game do begin
    for Row:=1 to BoardHeight do begin
        for Col:=1 to BoardWidth do begin
            i:=Board[ColRowToSquare(Col,Row)];
            if        (i and WALL                     )<>0 then Write('#')
            else if   (i and FLAG_BOX_REACHABLE_SQUARE)<>0 then Write('.')
                 else Write(' ');
            end;
        Writeln;
        end;
    Writeln('Reachable squares for all boxes');
    Readln;
    end;
end;

procedure ShowCorral(Depth__:Integer; TimeStamp__:TTimeStamp);
var BoxNo,Square,Col,Row:Integer; s:String; B:TBoard;
begin
  B:=Game.Board;
  with Solver.SearchStates[Depth__].PlayersReachableSquares do begin
    for BoxNo:=1 to Game.BoxCount do
        if Squares[Game.BoxPos[BoxNo]]>=TimeStamp__ then begin
           SquareToColRow(Game.BoxPos[BoxNo],Col,Row); Write('[',Game.BoxPos[BoxNo],'=',Col,':',Row,SPACE,Squares[Game.BoxPos[BoxNo]],'] ' );
           end;
    Writeln;

    for Square:=0 to Game.BoardSize do
        if   (Squares[Square]>=TimeStamp__) and ((Game.Board[Square] and BOX)<>0) then // and Odd(Squares[Square]) then
             Game.Board[Square]:=FLAG_SQUARE_SET;
    ShowBoard;

    Writeln('Corral: ',Depth__,PERIOD,TimeStamp);
    Readln(s);
    if s<>'' then
       Writeln;
    end;
  Game.Board:=B;
end;

procedure ShowGateSquares; {shows all floors that cut the board in two separate rooms}
var BoxNo,OldPlayerPos,Square:Integer;
begin
  with Game do begin
    OldPlayerPos:=PlayerPos;
    MovePlayer(0);                                                              {remove the player from the board}
    for BoxNo:=1 to BoxCount do Dec(Board[BoxPos[BoxNo]],BOX);                  {remove boxes from the board}
    for Square:=0 to BoardSize do
        if IsAGateSquare(Square) then Inc(Board[Square],BOX);
    ShowBoard;

    Write('Gate squares: ');
    for Square:=0 to BoardSize do
        if (Board[Square] and BOX)<>0 then begin
           Board[Square]:=Board[Square] and (not BOX);
           Write(Square,SPACE);
           end;
    Writeln;

    for BoxNo:=1 to Game.BoxCount do Inc(Game.Board[Game.BoxPos[BoxNo]],BOX);   {put boxes and the player back on the board}
    MovePlayer(OldPlayerPos);                                                   {put the player back on the board}
    end;
end;

procedure ShowIllegalBoxSquares;
var i:Integer; s:String; B:TBoard;
begin
  if Game.ShowDeadlockSetsEnabled or (LogFile.FileName<>'') then
     with Game do with DeadlockSets do begin
       B:=Board;

       if   Game.Title='' then
            s:=''
       else s:=Game.Title+' - ';
       s:=s+'Simple illegal squares';

       for i:=0 to BoardSize do
           if (Board[i] and WALL)=0 then
              if   (Board[i] and FLAG_ILLEGAL_BOX_SQUARE)<>0 then
                   Board[i]:=FLAG_SQUARE_SET
              else Board[i]:=FLOOR;

       if LogFile.FileName<>'' then WriteBoardToLogFile(s);

       {$IFDEF CONSOLE_APPLICATION}
         if Game.ShowDeadlockSetsEnabled then begin
            Writeln; Writeln(s);
            ShowBoard;
            Readln;
            end;
       {$ENDIF}

       Board:=B;
       end;
end;

procedure ShowPlayersDistanceToAllSquares(MinPlayerPos__,Index__:Integer);
var Col,Row,SquareNo:Integer;
begin {precondition: the player's distance to reachable squares have been calculated for index 'Index__'}
  with Game do with Solver.SearchStates[Index__].PlayersReachableSquares do begin
    for Row:=1 to BoardHeight do begin
        for Col:=1 to BoardWidth do begin
            SquareNo:=ColRowToSquare(Col,Row);
            if        (Board[SquareNo] and WALL)<>0 then
                      Write('#':4)
            else if   (Board[SquareNo] and BOX)<>0 then
                      Write('Box':4)
            else if   Squares[SquareNo]>TimeStamp then
                      Write(Pred(Squares[SquareNo]-TimeStamp):4)
                 else Write('_':4);
            end;
        Writeln;
        end;
    if MinPlayerPos__<>0 then begin
       SquareToColRow(MinPlayerPos__,Col,Row);
       Writeln('Min. player position : ',MinPlayerPos__,' [',Col,',',Row,']');
       end;
    end;
end;

procedure ShowPlayersReachableSquares(Index__:Integer);
var Col,Row,SquareNo:Integer; SquareTimeStamp:TTimeStamp;
begin {precondition: the player's distance to reachable squares have been calculated for index 'Index__'}
  with Game do with Solver.SearchStates[Index__].PlayersReachableSquares do begin
    for Row:=1 to BoardHeight do begin
        for Col:=1 to BoardWidth do begin
            SquareNo:=ColRowToSquare(Col,Row);
            SquareTimeStamp:=Squares[SquareNo];
            if        (Board[SquareNo] and WALL)<>0 then
                      Write('#')
            else if   (Board[SquareNo] and BOX)<>0 then
                      if SquareTimeStamp=Succ(TimeStamp) then
                         Write('!')
                      else Write(SquareToChar(SquareNo))
            else if   Squares[SquareNo]=TimeStamp then
                      Write('+')
                 else Write(SPACE);
            end;
        Writeln;
        end;
    if MinPlayerPos<>0 then begin
       SquareToColRow(MinPlayerPos,Col,Row);
       Writeln('Normalized (top-left) player position : ',MinPlayerPos,' [',Col,',',Row,']');
       end;
    end;
end;

procedure ShowDeadlockSet(Index__,CenterSquareNo__:Integer);
var i,j,k,Col,Row:Integer; DeadlockSetHashValue:THashValue;
    s:String; Direction:TDirection; B:TBoard;
begin {$I-}
  if Game.ShowDeadlockSetsEnabled or (LogFile.FileName<>'') then
     with Game do with DeadlockSets do
       if Game.ShowDeadlockSetsEnabled or (LogFile.FileName<>'') then begin
          B:=Board;

          if   Game.Title='' then
               s:=''
          else s:=Game.Title+' - ';
          if   dsfIsANoProgressPattern in Flags[ Index__ ] then
               s:=s+'No-progress-pattern (not necessarily a deadlock) '
          else s:=s+'Deadlock ';
          s:=s+IntToStr(SequenceNumbers[Index__]);

          if Index__<>SequenceNumbers[Index__] then s:=s+' ('+IntToStr(Index__)+')';
          s:=s+'  Capacity: '+IntToStr(Capacity[Index__])+'  Squares:';

          DeadlockSetHashValue:=0;

          for i:=0 to BoardSize do
              if (Board[i] and WALL)=0 then Board[i]:=FLOOR;
          for i:=0 to BoardSize do
              for j:=1 to SquareSetCount[i] do
                  if SquareSetNumbers[i]^[j]=Index__ then begin
                     s:=s+SPACE+IntToStr(i);
                     Board[i]:=FLAG_SQUARE_SET;
                     if ((B[i] and BOX   )<>0)
                        and
                        ((Index__<=Game.DeadlockSets.PrecalculatedSetsCount)
                         or
                         ((dsfControllerSet   in Flags[Index__])
                          //and {the capacity for overflow controller-sets is shown below as '... at the most <nnn> more box(es)', hence, the boxes on the board must be visible}
                          //(dsfIsAnOverflowSet in Flags[Index__])
                         )
                        ) then
                        Inc(Board[i],BOX);
                     if (B[i] and GOAL  )<>0 then Inc(Board[i],GOAL);
                     if (B[i] and PLAYER)<>0 then Inc(Board[i],PLAYER); {the player is back at its starting position also when deadlocks are added dynamically during the search, hence, it's OK to depict the player position}
                     DeadlockSetHashValue:=DeadlockSetHashValue xor Positions.SquareHashValues[i];
                     end;
          if CenterSquareNo__<>0 then begin
             SquareToColRow(CenterSquareNo__,Col,Row);
             s:=s+'  Center: '+IntToStr(CenterSquareNo__)+EQUAL+LEFT_BRACKET+IntToStr(Col)+COMMA+IntToStr(Row)+RIGHT_BRACKET;
             if dsfHasDisconnectedInnerFloors in Flags[Index__] then s:=s+ ' (Some inner floor squares do not belong to the center room)';
             end;
          s:=s+' Hash value: '+Int64ToStr(DeadlockSetHashValue);
          if Flags[Index__]*[dsfPlayerMustBeOutsideSet,dsfControllerSet,dsfFreezeSet]=[dsfPlayerMustBeOutsideSet] then begin
             s:=s+'  The player must be outside the set.';
             i:=0;
             for Direction:=Low(Direction) to High(Direction) do
                 if DIRECTION_TO_DEADLOCK_SET_FLAG[Direction] in Flags[Index__] then
                    Inc(i);

             if i<>0 then begin
                if   CenterSquare[Index__]<>0 then
                     s:=s+' This is guaranteed if the last push direction is:'
                else s:=s+' The last push direction must be:';

                for Direction:=Low(Direction) to High(Direction) do
                    if DIRECTION_TO_DEADLOCK_SET_FLAG[Direction] in Flags[Index__] then begin
                       s:=s+SPACE+DIRECTION_TO_TEXT[Direction];
                       end;
                end;

             if (SquareOutsideFence[Index__]<>0) and (CenterSquare[Index__]<>0) then begin
                if   i=0 then
                     s:=s+' This is guaranteed if'
                else s:=s+', or';
                SquareToColRow(SquareOutsideFence[Index__],Col,Row);
                s:=s+' the player can reach the square ['+IntToStr(Col)+COMMA+IntToStr(Row)+RIGHT_BRACKET;

                i:=SquaresOutsideFenceIndex[Index__];
                if i=0 then begin
                   if dsfIsOnlyADeadlockForListedPlayerAccessAreasOutsideFence in Flags[Index__] then s:=s+' (only this access area)';
                   end
                else begin
                   k:=0;
                   for j:=1 to SquaresOutsideFence[i] do
                       if SquaresOutsideFence[i+j]<>SquareOutsideFence[Index__] then Inc(k);
                   if k<>0 then begin
                      s:=s+' or the squares:';
                      for j:=1 to SquaresOutsideFence[i] do
                          if SquaresOutsideFence[i+j]<>SquareOutsideFence[Index__] then {'True': the 'outside-fence' square from the list is different from the memoized 'outside-fence' square found in 'SquareOutsideFence[]' for this deadlock}
                             s:=s+SPACE+LEFT_BRACKET+SquareToColRowAsText(SquaresOutsideFence[i+j])+RIGHT_BRACKET;
                      end;
                   end;
                end;
             end;
          if (dsfControllerSet         in Flags[Index__]) then begin {and (Index__<Count) and (dsfFreezeSet     in Flags[Succ(Index__)])}
             s:=s+'  This is a controller set for an ';
             if   dsfIsAnOverflowSet in Flags[Index__] then
                  s := s + 'overflow'
             else s := s + 'underflow';
             s:=s+' controller/freeze set pair. The squares in this set must contain ';
             if   dsfIsAnOverflowSet in Flags[Index__] then
                  s:=s+'at the most '+IntToStr(Capacity[Index__])+' more box(es) when'
             else s:=s+'at least '   +IntToStr(Capacity[Index__])+' more box(es) before';
             s:=s+' boxes freeze at the squares in the following set.';
             end;
          if (dsfFreezeSet             in Flags[Index__])  and (Index__>0    ) and (dsfControllerSet in Flags[Pred(Index__)]) then begin
             s:=s+'  This is a freeze set for the preceding controller set. Boxes at squares in this set must not freeze ';
             if   dsfIsAnOverflowSet in Flags[Index__] then
                  s:=s+'if the squares in the preceding controller set contain too many boxes.'
             else s:=s+'before the squares in the preceding controller set contain enough boxes.';
             end;
          //if (dsfTestForFreezingSquare in Flags[Index__])  and (Index__>0    ) and (dsfControllerSet in Flags[Pred(Index__)])  then begin
          //   s:=s+'  This is a freeze set in a controller/freeze set pair. Boxes at these squares must not freeze before the squares in the preceding controller set contain enough boxes.';
          //   end;
          if LogFile.FileName<>'' then begin
             WriteBoardToLogFile(s);
             if (Capacity[Index__]<0) and (Index__<=PrecalculatedSetsCount) and
                ((Flags[Index__]*[dsfControllerSet,dsfFreezeSet,dsfPlayerMustBeOutsideSet,dsfPlayerIsInsideSet])=[]) then
                {some deadlock types are not tested here; the 'if' guard just ensures that no false positives are reported}
                Writeln(LogFile.TextFile,'*** Deadlock ***');
             if IOResult<>0 then;
             end;

          {$IFDEF CONSOLE_APPLICATION}
            if Game.ShowDeadlockSetsEnabled then begin
               Writeln; Writeln(s);
               ShowBoard;
               if (Capacity[Index__]<0) and (Index__<=PrecalculatedSetsCount) and
                  ((Flags[Index__]*[dsfControllerSet,dsfFreezeSet,dsfPlayerMustBeOutsideSet,dsfPlayerIsInsideSet])=[]) then
                  {some deadlock types are not tested here; the 'if' guard just ensures that no false positives are reported}
                  Writeln('*** Deadlock ***');
               //Write(TEXT_PRESS_ENTER); Readln;
               end;
          {$ENDIF}

          Board:=B;
          end;
end; {$I+}

procedure ShowTunnelSquares;
var SquareNo,Col,Row:Integer; Direction:TDirection;
begin
  with Game do
    for Direction:=Low(Direction) to High(Direction) do begin
        Writeln(DIRECTION_TO_TEXT[Direction]);
        for Row:=1 to BoardHeight do begin
            for Col:=1 to BoardWidth do begin
                SquareNo:=ColRowToSquare(Col,Row);
                if         (Board[SquareNo] and WALL)<>0 then
                           Write('#')
                else if    (Board[SquareNo] and DIRECTION_TO_TUNNEL_FLAG[Direction])<>0 then
                           Write(DIRECTION_TO_CHAR[Direction])
                      else Write(UNDERSCORE);
                end;
            Writeln;
            end;
        Writeln;
        end;
end;

{-----------------------------------------------------------------------------}

{Moves}
(*
function  ChangePackingOrderPhase(Progress__:Boolean):Boolean;
var i,j,GoalNo,NewPhase,SquareValue:Integer;
begin {changes the packing order phase one step up or down; 'Progress__' = 'True' means advancing towards the solution (descreasing the phase)}
 with Game do with Solver.PackingOrder do begin
   if   Progress__ then
        NewPhase:=Pred(Phase)                                                   {advance towards a solution}
   else NewPhase:=Succ(Phase);                                                  {retreat}
   Result:=(NewPhase>=0) and (NewPhase<=SetCount);                              {note that phase may be 0 in which case the game state is a solved position (but not necessarily a solution; it can be the initial game state)}

   if Result then begin
      Phase:=NewPhase;

      i:=FirstSetMemberIndex[     Phase ];                                      {the first goal/parking square for the current packing order phase}
      j:=FirstSetMemberIndex[Succ(Phase)];                                      {the first goal/parking square for the next higher packing order phase}
      PhaseSquareCount:=j-i;                                                    {the number of target squares for this packing order phase}
      PhaseSquareCountDown:=PhaseSquareCount;                                   {initialize counting the number of unfilled target squares for this packing order phase}
      if not Progress__ then Dec(CompletedSquaresCount,PhaseSquareCount);       {when retreating, first deduct the number of target squares for the new phase; the loop below counts the filled target squares for the new phase}

      repeat GoalNo:=SetMembers[i];                                             {for each target square in the current phase}
             SquareValue:=Board[Game.GoalPos[GoalNo]];                          {the contents of the target square}

             if (SquareValue and BOX)<>0 then begin                             {'True': the target square contains a box}
                Dec(PhaseSquareCountDown);                                      {one square less to fill during the current phase}
                Inc(CompletedSquaresCount);                                     {update the number of completed target squares for this phase}
                end;

             if (SquareValue shr GOAL_BIT_SHIFT_COUNT)<>GoalNo then             {'True': the goal square is a target square during more than one phase; ensure that the square maps back from the board to the goal number belonging to this phase}
                Inc(Board[Game.GoalPos[GoalNo]],
                          +(GoalNo      shl GOAL_BIT_SHIFT_COUNT)               {add      the new phase goal number}
                          -(SquareValue shr GOAL_BIT_SHIFT_COUNT));             {subtract the old goal number}

             Inc(i);                                                            {advance to the next target square for this phase, if any}
      until  i=j; {until all target squares for the current phase have been examined}
      end;
   end;
end;
*)
function  DoPush(BoxNo__:Integer; Direction__:TDirection; PlayersReachableSquaresIndex__:Integer):Boolean;
var i,j,k,FromSquare,InnerFloorsCount,Square,ToSquare,SquareSetNo:Integer; SetFlags:TDeadlockSetFlagsSet;
begin {precondition: Solver.SearchStates[PlayersReachableSquaresIndex__].PlayersReachableSquares.Calculated'}
      {reflects whether the calculation has been performed for the game state}
      {after (sic) the push; ('IsALegalPush()' may have done it already)}
      {postcondition: '...PlayersReachableSquares.Calculated' reflects whether}
      {the calculation has been performed for the game state after the push;}
      {returns 'False' is the push violates one or more deadlock sets}
  Result:=True;
  if BoxNo__<>0 then with Game do begin {only pushes are handled}
     Inc(PackingOrderPushCount,(Ord(Direction__) and POSITION_PACKING_ORDER_TAG) shr DIRECTION_BIT_COUNT);
     //Inc(DeadlockSets.PathDeadlockCount,(Ord(Direction__) and POSITION_DEADLOCK_TAG) shr (DIRECTION_BIT_COUNT+4));
     Direction__:=TDirection(Ord(Direction__) and DIRECTION_BIT_MASK); {remove flags, if any, from the direction}

     FromSquare :=BoxPos[BoxNo__];
     ToSquare   :=FromSquare+SquareOffsetForward[Direction__];
{
     if (Board[FromSquare] and (BOX))=0 then begin
        ShowBoard;
        Msg(TEXT_INTERNAL_ERROR+' Pushes A: '+IntToStr(Solver.PushCount),'DoPush');
        end;

     if (Board[ToSquare] and (WALL+BOX+FLAG_ILLEGAL_BOX_SQUARE))<>0 then begin
        ShowBoard;
        Msg(TEXT_INTERNAL_ERROR+' Pushes B: '+IntToStr(Solver.PushCount),'DoPush');
        end;
}
     Dec(Board[FromSquare],BOX);
     Inc(Board[ToSquare  ],BOX);
     //Board[ToSquare]:=Cardinal(Board[ToSquare] and (not (BOX_GOAL_BIT_MASK shl BOX_BIT_SHIFT_COUNT))) or Cardinal(BoxNo__ shl BOX_BIT_SHIFT_COUNT) or BOX;
     BoxPos[BoxNo__]:=ToSquare;
     Dec(Board[PlayerPos],PLAYER);
     PlayerPos:=FromSquare;
     Inc(Board[PlayerPos],PLAYER);

     HashValue:=(HashValue xor Positions.SquareHashValues[FromSquare])
                xor
                Positions.SquareHashValues[ToSquare];
     Inc(SimpleLowerBound,DistanceToNearestGoal[ToSquare]-DistanceToNearestGoal[FromSquare]);

     //Dec(Rooms.RoomBoxCount[Rooms.Squares[FromSquare].RoomNo]);
     //Inc(Rooms.RoomBoxCount[Rooms.Squares[ToSquare  ].RoomNo]);

     InnerFloorsCount:=0; {prepare to calculate the inner floor squares in a fenced-in area on the board for the deadlock detection of fenced-in areas where the player must be outside the fence}
     with DeadlockSets do begin
          for i:=1 to SquareSetCount[FromSquare] do Inc(Capacity[SquareSetNumbers[FromSquare]^[i]]); {leaving these deadlock-sets}
          for i:=1 to SquareSetCount[ToSquare  ] do begin {entering these deadlock-sets}
              SquareSetNo:=SquareSetNumbers[ToSquare]^[i];
              Dec(Capacity[SquareSetNo]); {entering this deadlock-set}
              if (Capacity[SquareSetNo]<0) and Result then begin                {'True': the deadlock-set underflows, but further tests are necessary in order to find out whether it's a deadlock}
                 SetFlags:=Flags[SquareSetNo];
                 if   dsfPlayerMustBeOutsideSet in SetFlags then begin
                      if   (DIRECTION_TO_DEADLOCK_SET_FLAG[Direction__] in SetFlags) {'True': the last push direction tells that this is a deadlock}
                           or
                           (Game.PlayerPos=SquareOutsideFence[SquareSetNo]) then {'True': the current player position matches the last found square that has been proved to be outside the fence}
                           Result:=False
                      else if (CenterSquare[SquareSetNo]<>0) then begin         {'True': it's a fenced-in-area type of deadlock}
                              if
//                               (not (dsfHasDisconnectedInnerFloors in SetFlags)) and {'True': all inner floors are connected}
//                               ((Game.Board[CenterSquare[SquareSetNo]] and (WALL+BOX))=0) and {'True': the center square is an empty floor square}
                                 (PlayersReachableSquaresIndex__>=0) then       {'True': calculate the player's reachable squares and check if the player is outside the fence}
                                 with Solver.SearchStates[PlayersReachableSquaresIndex__].PlayersReachableSquares do begin {in order to be a deadlock, the player must be outside the fence formed by the boxes}
                                   if not Calculated then CalculatePlayersReachableSquares(PlayersReachableSquaresIndex__); {calculate the player's reachable squares if it hasn't been done already}
                                   Square:=CenterSquare[SquareSetNo];
                                   if (Squares[Square]<>TimeStamp) then {'True': the player can't reach the center square inside the fenced-in area}
                                      if Squares[SquareOutsideFence[SquareSetNo]]<>TimeStamp then begin {'True': the player can't reach the square which is guaranteed to be outside the fence}
                                         if (([dsfHasDisconnectedInnerFloors,dsfHasUnspecifiedInnerFloors,dsfIsOnlyADeadlockForListedPlayerAccessAreasOutsideFence]
                                              *
                                              SetFlags
                                             )
                                             =
                                             [] {'True': all inner floors are known and connected, and there are no player access areas outside the fence for which the deadlock does not apply}
                                            ) and
                                            ((Game.Board[Square] and (WALL+BOX))=0) then begin {'True': the center square is an empty floor square}
                                            with Solver.SearchStates[SEARCH_STATE_INDEX_DO_PUSH].PlayersReachableSquares do begin
                                              if (InnerFloorsCount=0) or                 {'True': the number of floor squares inside the fenced-in area hasn't been calculated yet}
                                                 (Squares[Square]<>TimeStamp) then begin {'True': the center square for this deadlock set is in a different "pocket" than the most recently calculated "pocket"}
                                                 Game.PlayerPos:=Square;                 {'Game.PlayerPos' is a global input parameter for 'CalculatePlayersReachableSquares()'}
                                                 InnerFloorsCount:=CalculatePlayersReachableSquares(SEARCH_STATE_INDEX_DO_PUSH);
                                                 Game.PlayerPos:=FromSquare;
                                                 end;
                                              if InnerFloorsCount=Game.DeadlockSets.FloorCount[SquareSetNo] then begin
                                                 {there are no boxes inside the corral}
                                                 {which can have blocked the player's access}
                                                 {to the center square, hence, the player}
                                                 {is outside the fence, and the position}
                                                 {is a deadlock}
                                                 Result:=False;
                                                 SquareOutsideFence[SquareSetNo]:=Game.PlayerPos; {remember that most recent square that has been proved to be outside the fence}
{
                                                 ShowBoard;
                                                 Write('Do push: Deadlock ',SequenceNo[SquareSetNo],SPACE,Solver.PushCount,SPACE,Positions.Count,SPACE,InnerFloorsCount);
                                                 Readln;
}
                                                 end;
                                              end;
                                            end;

                                         if Result then begin {'True': the game position hasn't been proved to be a deadlock yet}
                                            j:=SquaresOutsideFenceIndex[SquareSetNo]; {get the index of the 'outside-fence' squares (i.e., player access areas), if any, for this deadlock set}
                                            if j>0 then  {'True': there is a list of 'outside-fence' squares for this deadlock; if the player can reach one or more of them, then the game position is a deadlock}
                                               for k:=1 to SquaresOutsideFence[j] do {the number of 'outside-fence' squares for this deadlock is located at this index; the actual squares follow in items 'index+1' .. 'index+n'}
                                                   if Squares[SquaresOutsideFence[j+k]]=TimeStamp then begin {'True': the player can reach the square outside the fence}
{
                                                      ShowBoard;
                                                      Write('Deadlock? ',SequenceNo[SquareSetNo]);
                                                      Readln;
}
                                                      Result:=False;
                                                      SquareOutsideFence[SquareSetNo]:=FromSquare; {remember that most recent square which is known to be outside the fence}
                                                      break; {quick-and-dirty exit the 'for' loop; pushing the box to 'ToSquare' would overflow the deadlock set}
                                                      end;
                                            end;
                                         end
                                      else begin {the player can reach the square which is guaranteed to be outside the fence}
                                         Result:=False;
                                         SquareOutsideFence[SquareSetNo]:=Game.PlayerPos; {remember that most recent square which is known to be outside the fence}
{
                                         ShowBoard;
                                         Write('Do push: Deadlock ',SequenceNo[SquareSetNo],SPACE,Solver.PushCount,SPACE,Positions.Count,SPACE,InnerFloorsCount,SPACE,Capacity[SquareSetNo]);
                                         Readln;
}
                                         end;
                                   end;
                              end
                           else
                              if (dsfFreezeSet in SetFlags)
                                 and
                                 ControllerAndFreezeSetPairsEnabled
                                 and
                                 (((not (dsfIsAnOverflowSet in SetFlags))       {'True': this in an underflow controller/freeze pair of deadlock sets}
                                   and
                                   (Capacity[Pred(SquareSetNo)]>0)              {'True': the squares in the controller-set don't contain the required number of boxes, hence, it's a deadlock}
                                  )
                                  or
                                  ((dsfIsAnOverflowSet in SetFlags)             {'True': this in an overflow controller/freeze pair of deadlock sets}
                                   and
                                   (Capacity[Pred(SquareSetNo)]<0)              {'True': the squares in the controller-set contain to many boxes, hence, it's a deadlock}
                                  )
                                 )
                                 and
                                 ((not (dsfTestForFreezingSquare in SetFlags))  {'True': it's known from the precalculation, that when the squares in the freeze set have been filled, then the boxes at these squares have frozen}
                                  or
                                  IsAFreezingMove({FromSquare}0,ToSquare,True)  {'True': moving a box to the single square in the freeze set causes the box to freeze; ('0' instead of 'FromSquare' because the box has already been moved)}
                                 ) then begin
                                 Result:=False;
{
                                 ShowBoard;
                                 Write('Do push: freeze deadlock ',SquareSetNo,SPACE,Solver.PushCount);
                                 Readln;
}
                                 end;
                      end
                 else {if (SetFlags*[dsfControllerSet,dsfFreezeSet])=[]) then} {this last test is unnecessary because controller sets and freeze sets "cheat" by having the "dsfPlayerMustBeOutsideSet" flag, but no center square}
                          Result:=False;
                 end;
              end;
          end;
     end;
end;

function  HasALegalPush(Position__:PPosition; var BoxNo__:Integer; var Direction__:TDirection):Boolean;
var Count,SquareNo:Integer; d:TDirection; OldHashValue:THashValue;
begin // returns 'True' if there currently is a move that leads to the position depicted by 'Position__'; see also 'OptimizeGame.WasALegalPush'
  Count:=0; OldHashValue:=Game.HashValue;
  with Position__^ do begin
    {find box number; due to transpositions it might differ from 'Position__^.Move.BoxNo'}
    BoxNo__       :=BoxNoAtSquare(PlayerPos);
    if BoxNo__    <>0 then begin
       SquareNo   :=Game.BoxPos[BoxNo__];
       {find move direction; due to transpositions it might differ from 'Position__^.Move.Direction'}
       Game.HashValue:=Game.HashValue     xor Positions.SquareHashValues[SquareNo];
       for d:=Low(d) to High(d) do begin
           Game.HashValue:=Game.HashValue xor Positions.SquareHashValues[SquareNo+Game.SquareOffsetForward[d]];
           if Game.HashValue=HashValue then begin
              Direction__:=d; Inc(Count);
              end;
           Game.HashValue:=Game.HashValue xor Positions.SquareHashValues[SquareNo+Game.SquareOffsetForward[d]];
           end;
       Game.HashValue:=Game.HashValue     xor Positions.SquareHashValues[SquareNo];
       end;
    end;

  if Game.HashValue<>OldHashValue then
     Msg(TEXT_INTERNAL_ERROR,'HasALegalPush');
  Game.HashValue:=OldHashValue;

  Result:=Count=1; {'1': exactly 1 push direction matches the hashvalue for this position}
end;
(*
procedure InitializePackingOrderPhase;
begin
  with Game do with Solver.PackingOrder do
    if   SetCount>0 then begin {'True': a packing order has been calculated for this level, and the packing order is enabled}
         CompletedSquaresCount:=0;
         Phase:=Succ(SetCount); {'Succ': so the function 'ChangePackingOrderPhase' can be called with an 'advance' (decrease) parameter}
         while ChangePackingOrderPhase(True) {parameter 'True': advance (decrease) to the next phase, towards a solution}
               and
               (PhaseSquareCountDown=0) do begin
               end;
         end
    else Phase:=-1; {'-1': no packing order search}
end;
*)
function  IsAFreezingMove ( FromSquareNo__ , ToSquareNo__ : Integer; ABoxFreezingOnAGoalSquareCountsAsAFreezingMove__ : Boolean ) : Boolean;
{returns 'True' if putting a box on 'ToSquareNo__' creates a frozen position (optionally moving the box from 'FromSquareNo__')}
var OriginalFromSquareValue : Integer; ABoxIsBlockedOnANonGoalSquare : Boolean;

  function  BoxIsBlockedAlongOneAxis( SquareNo__ : Integer; Direction__ : TDirection;
                                      var ABoxIsBlockedOnANonGoalSquare__ : Boolean):Boolean;
  var Neighbor1, Neighbor2, Neighbor1Position , Neighbor2Position : Integer;
  begin
    if   Direction__          = Low(Direction__) then                           {flip horizontal/vertical direction}
         Direction__         := Succ ( Low ( Direction__ ) )                    {caution: 'Succ(Low...'): assumes 4 directions only}
    else Direction__         := Low ( Direction__ );

    if ( Direction__          = Low ( Direction__ ) )
       and
       (Game.FreezeTestTimeStamps.Squares [ SquareNo__ ] >= Game.FreezeTestTimeStamps.TimeStamp) then {'True': use the already calculated value}

       Result                := Game.FreezeTestTimeStamps.Squares [ SquareNo__ ] > Game.FreezeTestTimeStamps.TimeStamp     {relies on Ord ( False , True ) = (0 , 1)}

    else begin
       Neighbor1Position     := SquareNo__ - Game.SquareOffsetForward[ Direction__ ];
       Neighbor1             := Game.Board [ Neighbor1Position ];

       Neighbor2Position     := SquareNo__ + Game.SquareOffsetForward[ Direction__ ];
       Neighbor2             := Game.Board [ Neighbor2Position ];

       Inc ( Game.Board [ SquareNo__ ] , WALL);                                 {temporarily change this square to a wall}

       Result := ((  Neighbor1 and WALL           ) <> 0 )                      {is there a wall on any of the neighbor squares?}
                 or
                 ((  Neighbor2 and WALL           ) <> 0 )
                 or
                 ((( Neighbor1 and FLAG_ILLEGAL_BOX_SQUARE ) <> 0 )             {are both neighbors illegal squares?}
                  and
                  (( Neighbor2 and FLAG_ILLEGAL_BOX_SQUARE ) <> 0 )
                 );

       if (not ( Result and ABoxIsBlockedOnANonGoalSquare__ ))                  {it's not enough to know whether a box is blocked; it's also necessary to know whether a box is blocked on a non-goal square}
          and
          (( Neighbor1 and ( WALL + BOX ) ) = BOX )                             {test if neighbor1 is a blocked box}
          and
          BoxIsBlockedAlongOneAxis( Neighbor1Position , Direction__ , ABoxIsBlockedOnANonGoalSquare__ )
          then Result := True;

       if (not ( Result and ABoxIsBlockedOnANonGoalSquare__ ))                  {it's not enough to know whether a box is blocked; it's also necessary to know whether a box is blocked on a non-goal square}
          and
          (( Neighbor2 and ( WALL + BOX ) ) = BOX )                             {test if neighbor2 is a blocked box}
          and
          BoxIsBlockedAlongOneAxis( Neighbor2Position , Direction__ , ABoxIsBlockedOnANonGoalSquare__ )
          then Result:=True;

       Dec ( Game.Board [ SquareNo__ ] , WALL );                                {remove the wall again}
       end;

    if Result and                                                               {if this box is blocked}
       ( ( Game.Board [ SquareNo__ ] and GOAL ) = 0 ) then                      {and it's not a goal-square}
       ABoxIsBlockedOnANonGoalSquare__ := True;                                 {then set the flag}

    if Direction__ = Low ( Direction__ ) then with Game.FreezeTestTimeStamps do {reduce the exponential growth by storing the results for one axis}
       Squares [ SquareNo__ ] := TimeStamp + TTimeStamp ( Ord ( Result ) );     {relies on Ord ( False , True ) = (0 , 1)}
   end; {BoxIsBlockedAlongOneAxis}

begin {IsAFreezingMove}
  with Game.FreezeTestTimeStamps do
    if TimeStamp < High ( TimeStamp ) - 5 then
       Inc ( TimeStamp , 2 )
    else begin
       FillChar ( Squares , SizeOf ( Squares ) , 0 ); TimeStamp := 2;
       end;

  ABoxIsBlockedOnANonGoalSquare := False;
  OriginalFromSquareValue := Game.Board [ FromSquareNo__ ];
  Game.Board [FromSquareNo__] := Game.Board [ FromSquareNo__ ] and (not BOX);   {remove box, if any ('FromSquareNo__' is optional), from its current position}

  Result := (( Game.Board [ ToSquareNo__ ] and ( WALL + FLAG_ILLEGAL_BOX_SQUARE ) ) <> 0 )   {a wall is considered a deadlocked square}
            or
            (( Game.Board [ ToSquareNo__ ] and   FLAG_BOX_REACHABLE_SQUARE        ) =  0 )   {inlined '(not IsABoxReachableSquare( ToSquareNo__ ))'}
            or
            (( not Game.ReverseMode ) and
             BoxIsBlockedAlongOneAxis( ToSquareNo__ , Low(        TDirection )   , ABoxIsBlockedOnANonGoalSquare ) and
             BoxIsBlockedAlongOneAxis( ToSquareNo__ , Succ( Low ( TDirection ) ) , ABoxIsBlockedOnANonGoalSquare ) and  {caution: 'Succ(Low...'): assumes 4 directions only}
             (ABoxIsBlockedOnANonGoalSquare or ABoxFreezingOnAGoalSquareCountsAsAFreezingMove__)
            );

  Game.Board [FromSquareNo__] := OriginalFromSquareValue;                       {put box, if any, back on the board}
end; {IsAFreezingMove}

function  IsALegalPush(BoxNo__:Integer; Direction__:TDirection; PlayersReachableSquaresIndex__:Integer):Boolean;
var i,j,k,SquareSetNo,FromSquare,InnerFloorsCount,NeighborSquare,OriginalPlayerPos,Square,ToSquare:Integer;
    SetFlags:TDeadlockSetFlagsSet;
    FromSquareSetNumbers,ToSquareSetNumbers : PDeadlockSetNumbers;
begin {precondition: simple constraints, e.g., the move isn't blocked by a wall}
      {or another box, have already been checked;}
      {postcondition: 'Solver.SearchStates[PlayersReachableSquaresIndex__].PlayersReachableSquares.Calculated'}
      {reflects whether the calculation has been performed for the game state}
      {after (sic) the push;}
  with Game do with DeadlockSets do begin
    FromSquare:=BoxPos[BoxNo__];
    ToSquare  :=FromSquare+SquareOffsetForward[Direction__];
    IsALegalPushOverflowingSetsCount:=0; {the count is a global result value}
    if PlayersReachableSquaresIndex__>=0 then
       Solver.SearchStates[PlayersReachableSquaresIndex__].PlayersReachableSquares.Calculated:=False; {initialize the 'has been calculated' state for the player's reachable squares}

    {check for deadlock-set overflows, i.e., pattern matching}
    FromSquareSetNumbers:=SquareSetNumbers[FromSquare];
    ToSquareSetNumbers:=SquareSetNumbers[ ToSquare ];
    for i:=1 to SquareSetCount[ToSquare] do begin {for each deadlock-set that 'ToSquare' is a member of}
        SquareSetNo:=ToSquareSetNumbers^[i]; {get current set number}
        if (Capacity[SquareSetNo]<=0) {can a push cause an overflow?}
           and
           (not (dsfControllerSet in Flags[SquareSetNo])) {for a controller/freeze-set pair, the controller-set is just counting filled squares; a deadlock situation only happens when the freeze-set overflows}
           then begin
           Result:=False;
           for j:=1 to SquareSetCount[FromSquare] do
               if FromSquareSetNumbers^[j]=SquareSetNo then begin
                  {if 'FromSquare' is in the deadlock-set, the push doesn't cause an overflow}
                  Result:=True; break;
                  end;
           if not Result then begin
              SetFlags:=Flags[SquareSetNo];
              if not (dsfPlayerMustBeOutsideSet in SetFlags) then begin {'True': the deadlock-set doesn't require further analysis}
                 {
                 if i<>1 then begin                                    // self-organizing list: doesn't seem to be worthwhile here;
                    j:=SquareSetNumbers[ToSquare]^[Pred(i)];           // shift current deadlock-set one slot left towards the front of the list,
                    SquareSetNumbers[ToSquare]^[Pred(i)]:=SquareSetNo; // i.e., the most popular sets are tested first
                    SquareSetNumbers[ToSquare]^[i]:=j;
                    end;
                 }
                 IsALegalPushOverflowingSets[1]:=SquareSetNo;
                 Inc(Statistics[SquareSetNo]);
                 {when the function returns False', the overflowing set is stored}
                 {in 'IsALegalPushOverflowingSets[1]' but note that 'IsALegalPushOverflowingSetCount' = 0;}
                 {the count is only used for overflowing sets requiring further}
                 {analysis, i.e., after performing the move}
                 exit; {quick-and-dirty exit; pushing the box to 'ToSquare' would overflow the deadlock-set}
                 end
              else begin {the set overflows, but maybe the player must be outside the set, or maybe this deadlock set belongs to a controller/freeze-set pair}
                 if (DIRECTION_TO_DEADLOCK_SET_FLAG[Direction__] in SetFlags)   {'True': when the box is pushed in this direction, then the player is known to be outside the fence, hence, this is a deadlock}
                    or
                    (FromSquare=SquareOutsideFence[SquareSetNo]) then begin     {'True': it has been proved earlier that this square is outside the fence, hence, this push leads to a deadlocked position}
                    IsALegalPushOverflowingSets[1]:=SquareSetNo;
                    Inc(Statistics[SquareSetNo]);
                    {when the function returns False', the overflowing set is stored}
                    {in 'IsALegalPushOverflowingSets[1]' but note that 'IsALegalPushOverflowingSetCount' = 0;}
                    {the count is only used for overflowing sets requiring further}
                    {analysis, e.g., after performing the move}
                    exit; {quick-and-dirty exit; pushing the box to 'ToSquare' would overflow the deadlock-set}
                    end
                 else if (not (dsfFreezeSet in SetFlags)) then begin {'True': this is a normal deadlock-set or a controller set}
                         if not (dsfControllerSet in SetFlags) then begin {'True': it's a normal deadlock-set}
                            {save the overflowing set numbers for later analysis, e.g., after the push has been performed (or at the end of this function - see below)}
                            Inc(IsALegalPushOverflowingSetsCount);
                            IsALegalPushOverflowingSets[IsALegalPushOverflowingSetsCount]:=SquareSetNo;
                            end;
                         end
                      else {this deadlock-set is the freeze-set in a controller/freeze-set pair; the squares in the controller-set must contain enough boxes before the squares in the freeze-set freeze}
                         if ControllerAndFreezeSetPairsEnabled
                            and
                            (((not (dsfIsAnOverflowSet in SetFlags)) {'True': this in an underflow controller/freeze pair of deadlock sets}
                              and
                              (
                               ( Capacity[Pred(SquareSetNo)]>0) {'True': the squares in the controller-set don't contain the required number of boxes, hence, it's a deadlock}
                               or
                               ((Capacity[Pred(SquareSetNo)]=0)
                                and {if the box leaves a square belonging to the controller-set and moves to a square belonging to the freeze-set, then the controller-set must still contain enough boxes}
                                IsSquareAMemberOfDeadlockSet(FromSquare,Pred(SquareSetNo))
                               )
                              )
                             )
                             or
                             ((dsfIsAnOverflowSet in SetFlags) {'True': this in an overflow controller/freeze pair of deadlock sets}
                              and
                              (
                               ( Capacity[Pred(SquareSetNo)]<-1) {'True': the squares in the controller-set contain to many boxes, hence, it's a deadlock}
                               or
                               ((Capacity[Pred(SquareSetNo)]=-1) {}
                                and {if the box leaves a square belonging to the controller-set and moves to a square belonging to the freeze-set, then the controller-set must still not overflow}
                                (not IsSquareAMemberOfDeadlockSet(FromSquare,Pred(SquareSetNo)))
                               )
                              )
                             )
                            )
                            and
                            ((not (dsfTestForFreezingSquare in SetFlags))       {'True': it's known from the precalculation, that when the squares in the freeze set have been filled, then the boxes at these squares have frozen}
                             or
                             IsAFreezingMove(FromSquare,ToSquare,True)          {'True': moving a box to the single square in the freeze set causes the box to freeze}
                            ) then begin
                            IsALegalPushOverflowingSets[1]:=SquareSetNo;
                            Inc(Statistics[SquareSetNo]);
                            {when the function returns False', the overflowing set is stored}
                            {in 'IsALegalPushOverflowingSets[1]' but note that 'IsALegalPushOverflowingSetCount' = 0;}
                            {the count is only used for overflowing sets requiring further}
                            {analysis, i.e., after performing the move}

                            //if dsfTestForFreezingSquare in SetFlags then begin
                            //   ShowBoard;
                            //   Write(Solver.PushCount,SPACE,Positions.Count,' Frozen square deadlock: ',SequenceNo[SquareSetNo]);
                            //   Readln;
                            //   end;
                            exit; {quick-and-dirty exit; pushing the box to 'ToSquare' would overflow the deadlock-set}
                            end;
                 end;
              end;
           end;
        end;

    {check for 4-blocks; this hard-coded test can be substituted by}
    {deadlock-sets with a slightly lower performance}
    NeighborSquare:=ToSquare+SquareOffsetForward[Direction__];
    if (Board[NeighborSquare] and (WALL+BOX))<>0 then begin

       i:=Board[NeighborSquare+SquareOffsetLeft [Direction__]] and (WALL+BOX+GOAL);
       j:=Board[ToSquare      +SquareOffsetLeft [Direction__]] and (WALL+BOX+GOAL);

       if ((i and (WALL+BOX))<>0)
          and
          ((j and (WALL+BOX))<>0)
          and
          ( ((Board[ToSquare] and GOAL)=0)
            or
            ((i and (BOX+GOAL))=BOX)
            or
            ((j and (BOX+GOAL))=BOX)
            or
            ((Board[NeighborSquare] and (BOX+GOAL))=BOX)
          ) then
          Result:=False
       else begin
          i:=Board[NeighborSquare+SquareOffsetRight[Direction__]] and (WALL+BOX+GOAL);
          j:=Board[ToSquare      +SquareOffsetRight[Direction__]] and (WALL+BOX+GOAL);
          if ((i and (WALL+BOX))<>0)
             and
             ((j and (WALL+BOX))<>0)
             and
             ( ((Board[ToSquare] and GOAL)=0)
               or
               ((i and (BOX+GOAL))=BOX)
               or
               ((j and (BOX+GOAL))=BOX)
               or
               ((Board[NeighborSquare] and (BOX+GOAL))=BOX)
             ) then
             Result:=False
           else
             Result:=True;
          end;
       end
    else
       Result:=True;
    end;

  if Result and {'True': the push has not been proved to lead to a deadlock}
     (Game.DeadlockSets.IsALegalPushOverflowingSetsCount<>0) and {'True': one or more deadlock sets requires further analysis before it is known whether the push is a violation }
     (PlayersReachableSquaresIndex__>=0) then {'True': use this index into the global vector with the player's reachable squares}
     {check if the push violates a fence-type deadlock where the player is outside the fence}
     with Game.DeadlockSets do
       with Solver.SearchStates[PlayersReachableSquaresIndex__].PlayersReachableSquares do begin
         OriginalPlayerPos:=Game.PlayerPos;

         Dec(Game.Board[FromSquare],BOX); {do the push on the board}
         Inc(Game.Board[ToSquare  ],BOX);
         Game.PlayerPos:=FromSquare; {'Game.PlayerPos' is as a global input parameter for 'CalculatePlayersReachableSquares()'}

         CalculatePlayersReachableSquares(PlayersReachableSquaresIndex__);

         InnerFloorsCount:=0; {prepare to calculate the inner floor squares in a fenced-in area on the board}
         for i:=1 to IsALegalPushOverflowingSetsCount do begin {check each overflowing set on the list}
             SquareSetNo:=IsALegalPushOverflowingSets[i];
             Square     :=CenterSquare[SquareSetNo];
             SetFlags   :=Flags[SquareSetNo];
             if   (Square<>0) {'True': the deadlock set is a corral, i.e., an area fenced-in by boxes}
                  and
                  (Squares[Square]<>TimeStamp) {'True': the player can't reach the center square inside the corral}
                  and
                  (([dsfPlayerMustBeOutsideSet,dsfControllerSet,dsfFreezeSet] * SetFlags)
                   =
                   [dsfPlayerMustBeOutsideSet]
                  ) then begin
                  if Squares[SquareOutsideFence[SquareSetNo]]<>TimeStamp then begin {'True': the player can't reach the square which is guaranteed to be outside the fence}
                     if (([dsfHasDisconnectedInnerFloors,dsfHasUnspecifiedInnerFloors,dsfIsOnlyADeadlockForListedPlayerAccessAreasOutsideFence]
                          *
                          SetFlags
                         )
                         =
                         []  {'True': all inner floors are known and connected, and there are no player access areas outside the fence for which the deadlock does not apply}
                        )
                        and
                        ((Game.Board[Square] and (WALL+BOX))=0) then begin {'True': the center square is an empty floor square}
                        with Solver.SearchStates[SEARCH_STATE_INDEX_DO_PUSH].PlayersReachableSquares do begin
                          if (InnerFloorsCount=0) or                            {'True': the number of floor squares inside the fenced-in area hasn't been calculated yet}
                             (Squares[Square]<>TimeStamp) then begin            {'True': the center square for this deadlock set is in a different "pocket" than the most recently calculated "pocket"}
                             Game.PlayerPos:=Square;                            {'Game.PlayerPos' is a global input parameter for 'CalculatePlayersReachableSquares()'}
                             InnerFloorsCount:=CalculatePlayersReachableSquares(SEARCH_STATE_INDEX_DO_PUSH);
                             end;
                          if InnerFloorsCount=Game.DeadlockSets.FloorCount[SquareSetNo] then begin
                             {there are no boxes inside the corral which can have blocked}
                             {the player's access to the center square, hence, the player}
                             {is outside the fence, and the position is a deadlock}
                             SquareOutsideFence[SquareSetNo]:=FromSquare;       {remember that most recent square that has been proved to be outside the fence}
{
                             Game.PlayerPos:=OriginalPlayerPos;
                             MovePlayer(FromSquare);
                             ShowBoard;
                             Write('Check push: Deadlock ',SequenceNo[SquareSetNo],SPACE,Solver.PushCount,SPACE,Positions.Count,SPACE,InnerFloorsCount);
                             Readln;
}
                             Result:=False;
                             IsALegalPushOverflowingSets[1]:=SquareSetNo;
                             Inc(Statistics[SquareSetNo]);
                             {when the function returns False', the overflowing set is stored}
                             {in 'IsALegalPushOverflowingSets[1]' but note that 'IsALegalPushOverflowingSetCount' = 0;}
                             {the count is only used for overflowing sets requiring further}
                             {analysis, i.e., after performing the move}
                             break; {quick-and-dirty exit the 'for' loop; pushing the box to 'ToSquare' would overflow the deadlock set}
                             end;
                          end;
                        end;

                     if Result then begin {'True': the game position hasn't been proved to be a deadlock yet}
                        j:=SquaresOutsideFenceIndex[SquareSetNo]; {get the index of the 'outside-fence' squares, if any, for this deadlock set}
                        if j>0 then  {'True': there is a list of 'outside-fence' squares for this deadlock; if the player can reach one or more of them, then the game position is a deadlock}
                           for k:=1 to SquaresOutsideFence[j] do {the number of 'outside-fence' squares for this deadlock is located at this index; the actual squares follow in items 'index+1' .. 'index+n'}
                               if Squares[SquaresOutsideFence[j+k]]=TimeStamp then begin {'True': the player can reach the square outside the fence}
{
                                  Game.PlayerPos:=OriginalPlayerPos;
                                  MovePlayer(FromSquare);
                                  ShowBoard;
                                  MovePlayer(OriginalPlayerPos);
                                  Write('Deadlock? ',SequenceNo[SquareSetNo]);
                                  Readln;
}
                                  SquareOutsideFence[SquareSetNo]:=FromSquare; {remember that most recent square which is known to be outside the fence}

                                  Result:=False;
                                  IsALegalPushOverflowingSets[1]:=SquareSetNo;
                                  Inc(Statistics[SquareSetNo]);
                                  {when the function returns False', the overflowing set is stored}
                                  {in 'IsALegalPushOverflowingSets[1]' but note that 'IsALegalPushOverflowingSetCount' = 0;}
                                  {the count is only used for overflowing sets requiring further}
                                  {analysis, i.e., after performing the move}
                                  break; {quick-and-dirty exit the 'for' loop; pushing the box to 'ToSquare' would overflow the deadlock set}
                                  end;
                        end;
                     end
                  else begin {the player can reach the square which is guaranteed to be outside the fence}
                     SquareOutsideFence[SquareSetNo]:=FromSquare; {remember that most recent square which is known to be outside the fence}

                     Result:=False;
                     IsALegalPushOverflowingSets[1]:=SquareSetNo;
                     Inc(Statistics[SquareSetNo]);
                     {when the function returns False', the overflowing set is stored}
                     {in 'IsALegalPushOverflowingSets[1]' but note that 'IsALegalPushOverflowingSetCount' = 0;}
                     {the count is only used for overflowing sets requiring further}
                     {analysis, i.e., after performing the move}
                     break; {quick-and-dirty exit the 'for' loop; pushing the box to 'ToSquare' would overflow the deadlock set}
{
                     ShowBoard;
                     Write('Illegal push: Deadlock ',SequenceNo[SquareSetNo],SPACE,Solver.PushCount,SPACE,Positions.Count,SPACE,InnerFloorsCount);
                     Readln;
}
                     end;
                  end;
             end;

         Inc(Game.Board[FromSquare],BOX); {undo the push on the board}
         Dec(Game.Board[ToSquare  ],BOX);
         Game.PlayerPos:=OriginalPlayerPos;
       end;
end;

procedure MovePlayer(PlayerPos__:Integer);
begin
  with Game do begin
    Board[PlayerPos]:=Board[PlayerPos] and (not PLAYER); {remove player from the board}
    PlayerPos:=PlayerPos__;                              {update player position}
    if PlayerPos<>0 then Board[PlayerPos]:=Board[PlayerPos] or PLAYER;
    end;
end;

procedure PutBoxOnBoard(BoxNo__,SquareNo__:Integer);
var i:Integer;
begin {puts a box back on the board after it has been removed by calling 'RemoveBoxFromBoard'}
  if SquareNo__<>0 then begin
     Inc(Game.Board[SquareNo__],BOX);
     Game.BoxPos[BoxNo__]:=SquareNo__;
     Game.HashValue:=Game.HashValue xor Positions.SquareHashValues[SquareNo__];
     Inc(Game.SimpleLowerBound,Game.DistanceToNearestGoal[SquareNo__]);
     //Inc(Game.Rooms.RoomBoxCount[Game.Rooms.Squares[SquareNo__].RoomNo]);
     with Game.DeadlockSets do
       for i:=1 to SquareSetCount[SquareNo__] do Dec(Capacity[SquareSetNumbers[SquareNo__]^[i]]); {entering these deadlock-sets}
     end;
end; {PutBoxOnBoard}

procedure RemoveBoxFromBoard(BoxNo__:Integer);
var i,SquareNo:Integer;
begin {removes a box from the board; normally it is put back on the board by calling 'PutBoxOnBoard'}
  SquareNo:=Game.BoxPos[BoxNo__];
  if SquareNo<>0 then begin
     Dec(Game.Board[SquareNo],BOX);
     Game.BoxPos[BoxNo__]:=0; {handle with care; now there is a gap in the box position list}
     Game.HashValue:=Game.HashValue xor Positions.SquareHashValues[SquareNo];
     Dec(Game.SimpleLowerBound,Game.DistanceToNearestGoal[SquareNo]);
     //Dec(Game.Rooms.RoomBoxCount[Game.Rooms.Squares[SquareNo].RoomNo]);
     with Game.DeadlockSets do
       for i:=1 to SquareSetCount[SquareNo] do Inc(Capacity[SquareSetNumbers[SquareNo]^[i]]);     {leaving these deadlock-sets}
     end;
end; {RemoveBoxFromBoard}

procedure ShowPathForwards(Position__:PPosition);
// precondition : the game state has been reset to the starting position
// postcondition: the game state matches 'Position__'

begin
  if Position__<>nil then with Position__^ do begin
     if Parent<>nil then ShowPathForwards(Parent);
     with Move do DoPush(BoxNo,Direction,PushCount);
     ShowBoard;
     Write('Depth: ',PushCount,' Score: ',Score,SPACE,Game.HashValue);
     Readln;
     end;
end;

procedure UndoPush(BoxNo__:Integer; Direction__:TDirection);
var i,FromSquare,ToSquare:Integer;
begin
  if BoxNo__<>0 then with Game do begin {only pushes are handled}
     Dec(PackingOrderPushCount,(Ord(Direction__) and POSITION_PACKING_ORDER_TAG) shr DIRECTION_BIT_COUNT);
     //Dec(DeadlockSets.PathDeadlockCount,(Ord(Direction__) and POSITION_DEADLOCK_TAG) shr (DIRECTION_BIT_COUNT+4));
     Direction__:=TDirection(Ord(Direction__) and DIRECTION_BIT_MASK);

     FromSquare:=BoxPos[BoxNo__];
     ToSquare  :=FromSquare-SquareOffsetForward[Direction__];
{
     if (Board[ToSquare] and (BOX+WALL))<>0 then begin
        ShowBoard;
        Msg(TEXT_INTERNAL_ERROR+' Pushes: '+IntToStr(Solver.PushCount),'UndoPush');
        end;
}
     Dec(Board[FromSquare],BOX);
     Inc(Board[ToSquare  ],BOX);
     //Board[ToSquare]:=Cardinal(Board[ToSquare] and (not (BOX_GOAL_BIT_MASK shl BOX_BIT_SHIFT_COUNT))) or Cardinal(BoxNo__ shl BOX_BIT_SHIFT_COUNT) or BOX;
     BoxPos[BoxNo__]:=ToSquare;
     Dec(Board[PlayerPos],PLAYER);
     PlayerPos:=ToSquare-SquareOffsetForward[Direction__];
     Inc(Board[PlayerPos],PLAYER);

     HashValue:=(HashValue xor Positions.SquareHashValues[FromSquare])
                xor
                Positions.SquareHashValues[ToSquare];
     Inc(SimpleLowerBound,DistanceToNearestGoal[ToSquare]-DistanceToNearestGoal[FromSquare]);

     //Dec(Rooms.RoomBoxCount[Rooms.Squares[FromSquare].RoomNo]);
     //Inc(Rooms.RoomBoxCount[Rooms.Squares[ToSquare  ].RoomNo]);

     with DeadlockSets do begin
       for i:=1 to SquareSetCount[FromSquare] do Inc(Capacity[SquareSetNumbers[FromSquare]^[i]]); {leaving  these deadlock-sets}
       for i:=1 to SquareSetCount[ToSquare  ] do Dec(Capacity[SquareSetNumbers[ToSquare  ]^[i]]); {entering these deadlock-sets}
       end;
     end;
end;

procedure DoPull(BoxNo__:Integer; Direction__:TDirection);   {reverse mode: pulling boxes instead of pushing them}
begin
  UndoPush(BoxNo__,OPPOSITE_DIRECTION[TDirection(Ord(Direction__) and DIRECTION_BIT_MASK)]);
end;

procedure UndoPull(BoxNo__:Integer; Direction__:TDirection); {reverse mode: pulling boxes instead of pushing them}
begin
  DoPush  (BoxNo__,OPPOSITE_DIRECTION[TDirection(Ord(Direction__) and DIRECTION_BIT_MASK)],-1);
end;

{-----------------------------------------------------------------------------}

{Legend}

procedure InitializeLegend(XSBNotation__:Boolean);
var i:Integer;
begin
  with Legend do begin
    FillChar(Legend,SizeOf(Legend),0);
    CharToItem[CH_BOX       ]:=BOX+FLOOR   ; CharToItem[CH_BOX_ON_GOAL       ]:=BOX+GOAL+FLOOR;
    CharToItem[CH_BOX_XSB   ]:=BOX+FLOOR   ; CharToItem[CH_BOX_ON_GOAL_XSB   ]:=BOX+GOAL+FLOOR;
    CharToItem[CH_FLOOR     ]:=FLOOR;
    CharToItem[CH_GOAL      ]:=GOAL+FLOOR  ; CharToItem[CH_WALL              ]:=WALL;
    CharToItem[CH_PLAYER    ]:=PLAYER+FLOOR; CharToItem[CH_PLAYER_ON_GOAL    ]:=PLAYER+GOAL+FLOOR;
    CharToItem[CH_PLAYER_XSB]:=PLAYER+FLOOR; CharToItem[CH_PLAYER_ON_GOAL_XSB]:=PLAYER+GOAL+FLOOR;

    CharToItem[UNDERSCORE   ]:=FLOOR; {extra characters for floor squares}
    CharToItem[HYPHEN       ]:=FLOOR; {extra characters for floor squares}
    for i:=0 to Pred(Ord(SPACE)) do CharToItem[Chr(i)]:=FLOOR; {note: depends on ASCII character set where all characters < SPACE are control characters}
    XSBNotation:=XSBNotation__;
    end;
end;

{-----------------------------------------------------------------------------}

{File Reader}

procedure InitializeReader;
begin
  with Reader do begin
    FillChar(Reader,SizeOf(Reader),0);
    CurrentTextLine:=''; InputFileName:=''; PreviousTextLine:='';
    end;
end;

function  LoadFirstLevelFromFile(const InputFileName__,OutputFileName__:String):Boolean;
var ErrorText:String;
begin {$I-}
  with Reader do begin
    InputFileName:=''; CurrentTextLine:=''; PreviousTextLine:=''; ErrorText:='';
    LevelCount:=0;
    Assign(InputFile,InputFileName__); Reset(InputFile);
    if IOResult=0 then begin
       InputFileName:=InputFileName__;
       Result:=LoadNextLevelFromFile(OutputFileName__);
       if not Result then ErrorText:='No levels found in file: ';
       end
    else ErrorText:='File open error (Check path, maybe file wasn''t found): ';
    Result:=ErrorText='';
    if not Result then Msg(ErrorText+InputFileName__,'Load first level from file');
    end;
end; {$I+}

function  LoadNextLevelFromFile(const OutputFileName__:String):Boolean; {a simple version, parsing board and optional heading titles only}
var i,j,LineLength,BoardWidth,BoardHeight:Integer; ErrorText:String;
    Board:array[0..MAX_BOARD_WIDTH,0..MAX_BOARD_HEIGHT] of UInt8;

  function  ShowError(const ErrorText__:String):Boolean;
  begin // returns 'False' so the return value conveniently can be used to indicate failure
    Result:=Msg(ErrorText__+COLON+SPACE+Reader.InputFileName,'Load level from file');
  end;

  function  IsABoardLine(const TextLine__:String; var Length__: Integer):Boolean;
  var i:Integer;
  begin
    Length__:=Length(TextLine__); i:=1;
    while (Length__>0) and (Legend.CharToItem[TextLine__[Length__]]=FLOOR) do Dec(Length__); {skip trailing spaces and other floor characters, e.g., '_'}
    while (i<=Length__) and (Legend.CharToItem[TextLine__[i]]=FLOOR) do Inc(i); {parse leading floor squares}
    Result:=(i<=Length__)
            and {first and last character in a line belonging to a board must be a wall or a box-on-goal}
            ((Legend.CharToItem[TextLine__[i       ]]=WALL) or (Legend.CharToItem[TextLine__[i       ]]=(BOX+GOAL+FLOOR)))
            and
            ((Legend.CharToItem[TextLine__[Length__]]=WALL) or (Legend.CharToItem[TextLine__[Length__]]=(BOX+GOAL+FLOOR)));
    while Result and (i<Length__) do begin
      Inc(i);
      Result:=Legend.CharToItem[TextLine__[i]]<>0;
      end;
  end;

  function  MakeLevel(var ErrorText__:String):Boolean;
  var Col,Row,RowOffset:Integer; PluginResult:TPluginResult;

    function  LoadSolution(var ErrorText__:String):Boolean;
    const
      LEGAL_MOVE_CHARACTERS ='uUlLdDrR()*';
      MACRO_BEGIN='<#';

      function  IsAMovesLine(const TextLine__:String):Boolean;
      var i:Integer; Ch:Char;
      begin
        Result:=True;
        for i:=1 to Length(TextLine__) do begin
            Ch:=TextLine__[i];
            Result:=Result and (System.Pos(Ch,LEGAL_MOVE_CHARACTERS)>0);
            end;
      end;

    begin {LoadSolution} {$I-}
      with Reader do begin
        Result:=True;
        Game.OriginalSolution:='';
        Game.OriginalSolutionMoveCount:=0; Game.OriginalSolutionPushCount:=0;
        FillChar(Optimizer.OriginalMetrics,SizeOf(Optimizer.OriginalMetrics),0);
        while Result and (ErrorText__='') and
              (not ((Eof(InputFile)) and (CurrentTextLine=''))) do begin
          if  CurrentTextLine='' then Readln(InputFile,CurrentTextLine);
          if  IOResult=0 then begin
              if        CurrentTextLine='' then begin
                        if Game.OriginalSolution<>'' then Result:=False {don't check more lines}
                        end
              else if   (System.Pos(TEXT_SOLUTION,CurrentTextLine)=1) or
                        (System.Pos(MACRO_BEGIN  ,CurrentTextLine)<>0) or
                        (System.Pos(': ',CurrentTextLine)<>0) then begin {': ' is typically part of a key/value line}
                        if   Game.OriginalSolution='' then {'True': no move-lines seen yet}
                             CurrentTextLine:='' {empty the buffer and read next line from the file}
                        else Result:=False; {don't check more lines}
                        end
              else if   IsAMovesLine(CurrentTextLine) then begin
                        Game.OriginalSolution:=Game.OriginalSolution+CurrentTextLine;
                        CurrentTextLine:=''; {empty the buffer and read next line from the file}
                        end
              else if   IsABoardLine(CurrentTextLine,i) then
                        Result:=False {don't check more lines}
                   else begin PreviousTextLine:=CurrentTextLine; {save the line; it might be the title of the next level}
                              CurrentTextLine:=''; {empty the buffer and read next line from the file}
                        end;
              end
          else begin
              Result:=False; ErrorText__:='File read error';
              end;
          end;
        Result:=Game.OriginalSolution<>'';

        if Result then begin
           //Writeln(Game.Title,': Solution: ');
           //Writeln(Game.OriginalSolution);
           //Readln;
           end;
        end;
    end; {$I+}

  begin {MakeLevel}
    Result:=True;

    while (Game.Title<>'')
          and
          ((Game.Title[1]=SEMICOLON)
           or
           (Game.Title[1]<=SPACE))
          do
          Delete(Game.Title,1,1);

    Inc(Reader.LevelCount);
    if Game.Title='' then Game.Title:='Level '+IntToStr(Reader.LevelCount);
    Game.OriginalSolution:='';

    {transfer board to 'Game.Board' in correct left-justified format}
    InitializeBoard(BoardWidth,BoardHeight,False);
    for Row:=1 to Game.BoardHeight do begin
        RowOffset:=ColRowToSquare(0,Row);
        for Col:=1 to Game.BoardWidth do Game.Board[RowOffset+Col]:=Board[Col,Row];
        end;
    LoadSolution(ErrorText__);
    Result:=Result and InitializeGame(PluginResult,ErrorText__);
  end; {MakeLevel}

  procedure TextLineToBoard(const TextLine__:String; Length__:Integer);
  var Col:Integer;
  begin {precondition: 'TextLine__' contains a legal board row}
    Inc(BoardHeight); BoardWidth:=Max(BoardWidth,Length__);
    for Col:=1 to Length__ do
        Board[Col,BoardHeight]:=Legend.CharToItem[TextLine__[Col]];
  end;

begin {LoadNextLevelFromFile} {$I-}
  with Reader do begin
    Result:=InputFileName<>'';
    if Result then
       repeat
         Result:=False; ErrorText:='';
         Game.Title:=PreviousTextLine; PreviousTextLine:='';
         BoardWidth:=0; BoardHeight:=0;
         for i:=0 to MAX_BOARD_WIDTH do
             for j:=0 to MAX_BOARD_HEIGHT do Board[i,j]:=FLOOR;

         while  (not Result) and                                                {not done}
                (ErrorText='') and                                              {no errors}
                (not ((Eof(InputFile)) and (CurrentTextLine=''))) do begin      {not eof}
           if   CurrentTextLine='' then {a line may be left over from one call to the next}
                Readln(InputFile,CurrentTextLine);
           if   IOResult=0 then {did 'Readln' succeed?}
                if   IsABoardLine(CurrentTextLine,LineLength) then begin
                     if BoardHeight<MAX_BOARD_HEIGHT then
                        if LineLength>MAX_BOARD_WIDTH then begin
                           ErrorText:=TEXT_LEVEL_HAS_TOO_MANY_COLUMNS;
                           while (IOResult=0) and (not Eof(InputFile)) and (IsABoardLine(CurrentTextLine,LineLength)) do
                                 Readln(InputFile,CurrentTextLine);
                           PreviousTextLine:=CurrentTextLine;
                           Inc(Reader.LevelCount); {assign a level number to the failed level; that way it's more likely that any following levels are assigned the level numbers expected by the user; it's not fool-proof though}
                           end
                        else
                           TextLineToBoard(CurrentTextLine,LineLength)
                     else begin
                        ErrorText:=TEXT_LEVEL_HAS_TOO_MANY_ROWS;
                        while (IOResult=0) and (not Eof(InputFile)) and (IsABoardLine(CurrentTextLine,LineLength)) do
                              Readln(InputFile,CurrentTextLine);
                        PreviousTextLine:=CurrentTextLine;
                        Inc(Reader.LevelCount); {assign a level number to the failed level; that way it's more likely that any following levels are assigned the level numbers expected by the user; it's not fool-proof though}
                        end;
                     CurrentTextLine:='';
                     end
                else if BoardHeight>=3 then {done}
                        Result:=MakeLevel(ErrorText)
                     else begin
                        if BoardHeight<>0 then begin
                           BoardHeight:=0; BoardWidth:=0;
                           for i:=0 to MAX_BOARD_WIDTH do
                               for j:=0 to MAX_BOARD_HEIGHT do Board[i,j]:=FLOOR;
                           end;
                        if CurrentTextLine<>'' then
                           Game.Title:=CurrentTextLine; {last non-blank line before the board is used as title}
                        CurrentTextLine:='';
                        end
           else ErrorText:=TEXT_FILE_READ_ERROR;
           end;

         if (not Result) and (ErrorText='') and (BoardHeight>=3) then
            Result:=MakeLevel(ErrorText);

         if (not Result) and
            (Game.Title<>'') and
            ((not Eof(InputFile))
             or
             (ErrorText<>'')
            )
            then begin
            Game.History.Count:=0;
            MakeLevelStatistics(
                  Game.Title,Game.BoardWidth,Game.BoardHeight,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,[]);
            WriteStatistics(OutputFileName__);
            end;

         if ErrorText<>'' then Result:=ShowError(ErrorText);
         ErrorText:='';

       until Result or Eof(InputFile) or (ErrorText<>'')
    else ShowError(TEXT_NO_FILE_ERROR);

    if (not Result) and (InputFileName<>'')  then begin
       InputFileName:=''; CloseFile(InputFile); {clean up, i.e., close the file}
       end;
    end;
end; {$I+}

{-----------------------------------------------------------------------------}

{File Writer}

function  AppendLevelToFile(const FileName__,LevelName__:String):Boolean;
var F:Text;
begin {$I-}
  AssignFile(F,FileName__);
  Append(F);
  Result:=IOResult=0;
  if Result then begin
     Result:=WriteLevelToFile(F,LevelName__);
     CloseFile(F);
     Result:=(IOResult=0) and Result;
     end
  else {this is probably the first time; try to save the level in a new file}
    Result:=SaveLevelToFile(FileName__,LevelName__);
end; {$I+}

function  FirstPushToText(var PushNo__:Integer; var Text__:String):Boolean;
begin
  PushNo__:=0;
  Result:=NextPushToText(PushNo__,Text__);
end;

function  NextPushToText(var PushNo__:Integer; var Text__:String):Boolean; {note that 'NextPushToText' replays the game}
var i,PlayerSquare,MoveCount,LineCount{,Col,Row}:Integer; FinalDirection:TDirection; Moves:TSingleStepMoves;
begin {makes a string like 'ddrrU', i.e., intermediate non-pushing player-moves (lower-case) followed by the pushing move (upper-case)}
  Inc(PushNo__); Text__:='';
  Result:=PushNo__<=Min(Game.History.Count,High(Game.History.Moves));
  if Result then with Game.History.Moves[PushNo__] do begin
     PlayerSquare:=Game.BoxPos[BoxNo]-Game.SquareOffsetForward[Direction];
{
     ShowBoard;
     SquareToColRow(Game.PlayerPos,Col,Row); Write('Player: ',Game.PlayerPos,SPACE,Col,SPACE,Row);
     SquareToColRow(PlayerSquare,Col,Row); Write(' => ',PlayerSquare,SPACE,Col,SPACE,Row);
     Readln;
}
     if (BoxNo<>0) and
        CalculatePlayerPath(PlayerSquare,Direction,True,MoveCount,LineCount,FinalDirection,Moves) then begin
        for i:=1 to MoveCount do Text__:=Text__+DIRECTION_TO_CHAR[Moves[i].Direction];
        Text__:=Text__+UpCase(DIRECTION_TO_CHAR[Direction]);
        DoPush(BoxNo,Direction,-1);
        end
     else Result:=False;
     end;
end;

function  PathToText(Position__:PPosition; TextBufferSize__:Integer; MovesAsText__:PChar; var IsASolution__:Boolean; var Result__:TPluginResult):Boolean;
var i,CharCount,MoveCount,LineCount,OldPlayerSquare,PlayerFromSquare:Integer;
    FinalDirection:TDirection; MovesAsText:String;
    Next,This:PPosition; Moves:TSingleStepMoves;
    OldBoard:TBoard; OldBoxPos:TBoxSquares; OldDeadlockSetCapacities:TDeadlockSetCapacities;
begin  {note that this function destroys the transposition table (it uses the 'TPosition.Successor' field), hence, there are some constraints for applying the function}
  OldBoard:=Game.Board; OldPlayerSquare:=Game.PlayerPos; OldBoxPos:=Game.BoxPos;
  OldDeadlockSetCapacities:=Game.DeadlockSets.Capacity;

  {get initial moves and pushes from the tubefilling, if any}
  Game.History.Count:=Game.TubeFillingPushCount;
  MovesAsText:=GameHistoryMovesAsText; i:=Length(MovesAsText); CharCount:=0;
  while (CharCount<TextBufferSize__) and (CharCount<i) do begin
    Inc(CharCount);
    MovesAsText__^:=MovesAsText[CharCount];
    Inc(MovesAsText__);
    end;
  Result:=CharCount=i; {'True': all tubefilling moves were transferred to the textbuffer}
  if   Result then Result__:=prOK
  else Result__:=prGameTooLong;

  {create a forward chain of positions on the path to 'Position__'}
  if Positions.StartPosition<>nil then Positions.StartPosition^.Successor:=nil;
  This:=Position__; Next:=nil;
  while This<>nil do begin
    This^.Successor:=Next; Next:=This; This:=This^.Parent;
    end;

  Game.SimpleLowerBound:=CalculateSimpleLowerBound;
  Game.HashValue:=CalculateHashValue;

  {fill the string buffer with the moves and pushes on the path}
  This:=Positions.StartPosition;
  while (This<>nil) and Result do with This^ do begin
    if Move.BoxNo<>0 then begin
       PlayerFromSquare:=PlayerPos-Game.SquareOffsetForward[TDirection(Ord(Move.Direction) and DIRECTION_BIT_MASK)];
       Result:=CalculatePlayerPath(PlayerFromSquare,TDirection(Ord(Move.Direction) and DIRECTION_BIT_MASK),True,MoveCount,LineCount,FinalDirection,Moves);
       if   Result then begin
            for i:=1 to MoveCount do {non-pushing player-moves}
                if   Result then
                     if CharCount<TextBufferSize__ then begin
                        MovesAsText__^:=DIRECTION_TO_CHAR[Moves[i].Direction];
                        Inc(MovesAsText__); Inc(CharCount);
                        end
                     else begin
                        Result:=False; Result__:=prGameTooLong;
                        end;
            end
       else Result__:=prFailed;
       if   Result then
            if CharCount<TextBufferSize__ then begin {the box-pushing move}
               MovesAsText__^:=UpCase(DIRECTION_TO_CHAR[TDirection(Ord(Move.Direction) and DIRECTION_BIT_MASK)]);
               Inc(MovesAsText__); Inc(CharCount);
               end
            else begin
               Result:=False; Result__:=prGameTooLong;
               end;
       if Result then DoPush(Move.BoxNo,TDirection(Ord(Move.Direction) and DIRECTION_BIT_MASK),-1);
       end;
    if   Result then
         This:=Successor {advance to the next position}
    else This:=Parent; {adjust 'This' so it points to the last performed push}
    end;

  IsASolution__:=Game.SimpleLowerBound=0;

  if Result and (not IsASolution__) and (Game.EndPlayerPos<>0) then begin
     {add moves to get to the original end position}
     if   Position__<>nil then
          Result:=CalculatePlayerPath(Game.EndPlayerPos,TDirection(Ord(Position__^.Move.Direction) and DIRECTION_BIT_MASK),True,MoveCount,LineCount,FinalDirection,Moves)
     else Result:=CalculatePlayerPath(Game.EndPlayerPos,dUp                                                               ,True,MoveCount,LineCount,FinalDirection,Moves);
     if   Result then begin
          for i:=1 to MoveCount do {non-pushing player-moves}
              if   Result then
                   if CharCount<TextBufferSize__ then begin
                      MovesAsText__^:=DIRECTION_TO_CHAR[Moves[i].Direction];
                      Inc(MovesAsText__); Inc(CharCount);
                      end
                   else begin
                      Result:=False; Result__:=prGameTooLong;
                      end;
          end
     else Result__:=prFailed;
     end;

  {undo the performed pushes, i.e., restore the start game state}
  if (This=nil) and (Positions.StartPosition<>nil) then This:=Position__;
  while This<>nil do with This^ do begin
    UndoPush(Move.BoxNo,TDirection(Ord(Move.Direction) and DIRECTION_BIT_MASK));
    This:=Parent; {backtrack to the previous position}
    end;
  if Positions.StartPosition<>nil then MovePlayer(Positions.StartPosition^.PlayerPos);

  if CharCount<TextBufferSize__ then begin {add a null-terminator if there is room for it}
     MovesAsText__^:=NULL_CHAR;
     Inc(MovesAsText__); Inc(CharCount);
     end;
  if CharCount<TextBufferSize__ then MovesAsText__^:=NULL_CHAR; {add an extra null-terminator (if there is room for it) to signal that this solution is the last (the only) one}

  Game.Board:=OldBoard; Game.PlayerPos:=OldPlayerSquare; Game.BoxPos:=OldBoxPos; {restore game state}
  Game.DeadlockSets.Capacity:=OldDeadlockSetCapacities;
  Game.SimpleLowerBound:=CalculateSimpleLowerBound;
  Game.HashValue:=CalculateHashValue;
  Game.History.Count:=0;
  with Solver.SearchStates[0].PlayersReachableSquares do TimeStamp:=High(TimeStamp); {initialize the square timestamps for 'CalculatePlayerPath'; tubefilled squares, if any, may need a new initialization after the tubefilled board has been loaded}
  with Solver.SearchStates[SEARCH_STATE_INDEX_DO_PUSH].PlayersReachableSquares do TimeStamp:=High(TimeStamp); {ditto}
end;

function  SaveLevelToFile(const FileName__,LevelName__:String):Boolean;
var F:Text;
begin {$I-}
  AssignFile(F,FileName__);
  Rewrite(F);
  Result:=WriteLevelToFile(F,LevelName__);
  CloseFile(F);
  Result:=(IOResult=0) and Result;
end; {$I+}

function  WriteLevelToFile({const} var F:Text; const LevelName__:String):Boolean;
var PushNo,Row:Integer; PluginResult:TPluginResult;
    s,s1,s2:String; BoardAsTextLines:TBoardAsTextLines;
begin {$I-}
  Result:=True;

  Game.Board:=Game.OriginalBoard; {note that this destroys calculations done by 'InitializeGame'}
  Game.BoxPos:=Game.OriginalBoxPos; Game.PlayerPos:=Game.OriginalPlayerPos;
  if Game.TubeFillingMoveCount>0 then begin
     with Solver.SearchStates[0].PlayersReachableSquares do TimeStamp:=High(TimeStamp); {initialize the square timestamps for 'CalculatePlayerPath'; tubefilled squares need to initialized again after the original board has been reloaded}
     with Solver.SearchStates[SEARCH_STATE_INDEX_DO_PUSH].PlayersReachableSquares do TimeStamp:=High(TimeStamp); {ditto}
     end;

  Writeln(F);
  Writeln(F);
  Writeln(F,LevelName__);
  Writeln(F);

  BoardToTextLines(BoardAsTextLines);
  for Row:=1 to Game.BoardHeight do Writeln(F,BoardAsTextLines[Row]);
  //Writeln(F);

  //Writeln(F,'Title: ',LevelName__);

  if Game.History.Count>0 then begin
     //Writeln(F,'Pushes: ',Game.History.Count);
     //i:=Positions.Count+Positions.SearchStatistics.DroppedCount;
     //Writeln(F,'Analysed positions: ',i);
     Writeln(F);
     Write(F,'Solution/Pushes');
     if Game.History.Count>High(Game.History.Moves) then Write(F,' (incomplete)');
     if not Game.IsAnOptimalSolution then Write(F,' (may be non-optimal)');
     Writeln(F);

     s:='';
     if FirstPushToText(PushNo,s1) then
        repeat s:=s+s1;
               if Length(s)>=GAME_LINE_LENGTH then begin
                  s2:=Copy(s,1,GAME_LINE_LENGTH);
                  Writeln(F,s2);
                  Delete(s,1,GAME_LINE_LENGTH);
                  end;
        until  not NextPushToText(PushNo,s1);
     if s<>'' then Writeln(F,s);
     end
  else if (not Solver.Enabled) and
          Optimizer.Enabled and
          (Positions.BestPosition<>nil) and
          ((Optimizer.Result=prOK) or (Optimizer.Result=prGameTooLong)) then
          Result:=WritePathToFile(POptimizerPosition(Positions.BestPosition),F,PluginResult);
  Result:=Result and (IOResult=0);
end; {$I+}

function  WritePathToFile(Position__:POptimizerPosition; {const} var F:Text; var PluginResult__:TPluginResult):Boolean; // only implemented for optimizer positions, i.e., positions of type 'TOptimizerPosition'
var i:Integer; IsASolution:Boolean; s,s1:String;
begin {$I-} {precondition: the game has been reset to the starting position}
  Result:=False;
  if Optimizer.Enabled and
     (Position__<>nil) then with Position__^ do with Position do begin
     SetLength(s,MoveCount);
     if PathToText(PPosition(Position__),MoveCount,Addr(s[1]),IsASolution,PluginResult__) then begin
        if   IsASolution then
             s1:=TEXT_SOLUTION
        else s1:=TEXT_SNAPSHOT;

        s1:=s1+SPACE+OptimizerMetricsAsText(PPosition(Position__))+SPACE+
            LEFT_PAREN+OptimizerImprovementAsText(PPosition(Position__))+RIGHT_PAREN;
        s1:=s1+SPACE+LEFT_PAREN+TEXT_APPLICATION_TITLE+SPACE+TEXT_APPLICATION_VERSION_NUMBER+RIGHT_PAREN;
        Writeln(F);
        Writeln(F,s1);
        i:=1;
        while (i<=MoveCount) do begin
          s1:=Copy(s,i,GAME_LINE_LENGTH);
          Writeln(F,s1);
          Inc(i,GAME_LINE_LENGTH);
          end;
        Result:=True;
        end;
     end;
  Result:=Result and (IOResult=0);
end; {$I+}

{-----------------------------------------------------------------------------}

function  TTIsAFreeListMember(Position__:PPosition):Boolean;
var p:PPosition;
begin {returns 'True' if 'Position__' is a member of the transposition table freelist}
  Result:=False;
  p:=Positions.FreeList;
  if p<>nil then
     repeat if p=Position__ then Result:=True
            else p:=p^.HashBucket.Next;
     until  Result or (p=nil) or (p=Positions.FreeList);
end;

function  OPENCheckBucket(BucketIndex__:Integer):Boolean;
var p:PPosition;
begin {for debugging purposes: checks that positions in an open-queue bucket are't on the free-list too}
  with Positions do with OpenPositions do begin
    Result:=True;
    p:=Buckets[BucketIndex__];
    if p<>nil then
       repeat if TTIsAFreeListMember(p) then
                 Result:=False
              else p:=p^.ScoreBucket.Next;
       until  (not Result) or (p=Buckets[BucketIndex__]);
    end;
end;

{-----------------------------------------------------------------------------}

{Open Positions}

function  OPENAdd(Position__:PPosition):Boolean;
var Root:PPosition;
begin {open positions: insert item}
  with Positions.OpenPositions do with Position__^ do begin
    {$WARNINGS OFF}
      {warning: Comparison always evaluates to True}
      Result:=(Score>=Low(Buckets)) and (Score<=High(Buckets));
    {$WARNINGS ON}
    if Result then begin
       Inc(Count);
       if Score<MinValue then MinValue:=Score; {keep track of the minimum score}
       if Score>MaxValue then MaxValue:=Score; {keep track of the maximum score}

       Root:=Buckets[Score];
       if Root<>nil then with ScoreBucket do begin {'<>nil': non-empty list}
          if      (True) or (Position__^.PushCount>=Root^.PushCount) then begin {new first item}
                  Prev:=Root^.ScoreBucket.Prev;
                  Next:=Root;
                  Buckets[Score]:=Position__;  {insert 'Position__' as the first member of the bucket}
                  end
          else if Position__^.PushCount<=Root^.ScoreBucket.Prev^.PushCount then begin {new last item}
                  Prev:=Root^.ScoreBucket.Prev;
                  Next:=Root;
                  end
               else begin {insert item sorted on 'PushCount'}
                  repeat Root:=Root^.ScoreBucket.Next;
                         Inc(SortCount);
                  until  Position__^.PushCount>Root^.PushCount;
                  Prev:=Root^.ScoreBucket.Prev;
                  Next:=Root;
                  end;
          Prev^.ScoreBucket.Next:=Position__;  {update previous item in the list}
          Next^.ScoreBucket.Prev:=Position__;  {update previous item in the list}
          end
       else with ScoreBucket do begin {the bucket is empty; create new circular list with 1 item}
          Prev:=Position__;
          Next:=Position__;
          Buckets[Score]:=Position__;
          end;

       {$IFDEF CONSOLE_APPLICATION}
         //if (Ord(Move.Direction) and POSITION_OPEN_TAG)<>0 then
         //   Msg(TEXT_INTERNAL_ERROR+': "OPENAdd"',TEXT_APPLICATION_TITLE);
       {$ENDIF}

       Inc(UInt8(Move.Direction),POSITION_OPEN_TAG); {flag the position as a member of OPEN}
       end
    else
       {the score exceeds the limit, hence, the position can never be a part of}
       {a solution path}
       if (SuccessorCount=0) and
          ((Ord(Move.Direction) and POSITION_PATH_TAG)=0) then
          TTRemove(Position__);
    end;
end;

procedure OPENAddPartiallyExpandedPositions;
var Position:PPosition;
begin {puts all partially expanded positions on the open-list}
  while Positions.PartiallyExpandedPositionsList<>nil do begin
    Position:=Positions.PartiallyExpandedPositionsList; {get the next/first item from the list}
    Positions.PartiallyExpandedPositionsList:=Position^.NextPartiallyExpandedPosition; {advance to the next item on the list}
    if   (Ord(Position^.Move.Direction) and POSITION_OPEN_TAG)=0 then begin {'True': the position isn't on the open-queue (this must not happen because the open-queue uses overlapping links betweeen the positions)}
         {adjust the successor count back to normal; partially expanded
          positions have an artificially high count to ensure that:
          1. removal of successor positions from the tranposition table doesn't
             trigger putting the partially expanded position back on the
             open-list (see 'TTRemove');
          2. an attempt to add an identical position to the transposition table
             doesn't make 'TTAdd' choose to update the existing position,
             inviting" the search to put the updated position on the open-list;
          both of these operations would corrupt the linked list of partially
          expanded positions; they are linked using the same fields in each
          position as the open-list;
         }
         Dec(Position^.SuccessorCount);
         OPENAdd(Position); {put the partially expanded position on the open-list}
         end
    else Msg('OPENRemove',TEXT_INTERNAL_ERROR);
    end;
end;

function  OPENCheck(const Caption__:String):Boolean;
var BucketNo:Integer; MemberCount:Cardinal;
begin
  with Positions.OpenPositions do begin
    MemberCount:=0;
    //for BucketNo:=Low(Buckets) to High(Buckets) do Inc(MemberCount,OPENListLength(Buckets[BucketNo]));
    for BucketNo:=MinValue to MaxValue do MemberCount:=MemberCount+Cardinal(OPENListLength(Buckets[BucketNo]));
    Result:=MemberCount=Count;
    if not Result then Msg(TEXT_INTERNAL_ERROR+': '+Caption__,TEXT_APPLICATION_TITLE);
    end;
end;

procedure OPENClear;
begin {open positions: clear open-queue}
  with Positions.OpenPositions do begin
    FillChar(Positions.OpenPositions,SizeOf(Positions.OpenPositions),0);
    MaxValue:=Low (Buckets)-1;
    MinValue:=High(Buckets)+1;
    NoProgressRover:=Low(Buckets);
    end;
end;

function  OPENDropPositions(DepthLimit__:Integer):Integer;
var {$IFDEF CONSOLE_APPLICATION}
      OriginalCount:Integer;
    {$ENDIF}
    p:PPosition;
begin {open positions: drop positions with score >= 'DepthLimit__'; the positions are removed from the transposition-table as well}
//Writeln('Drop nodes...');
  Result:=0;;
  with Positions.OpenPositions do begin
    {$IFDEF CONSOLE_APPLICATION}
      OriginalCount:=Count;
    {$ENDIF}
    repeat
      while (DepthLimit__<=MaxValue) and (Buckets[MaxValue]=nil) do Dec(MaxValue);
      if  DepthLimit__<=MaxValue then  {'True': drop all positions in the max-value bucket}
          repeat
            Inc(Result);
            p:=Buckets[MaxValue]^.ScoreBucket.Prev; {drop the items in reverse order in order to avoid updating the bucket-root more than once}
            OPENRemove(p);             {remove the position from the open-queue}
            if (p^.SuccessorCount=0) and ((Ord(p^.Move.Direction) and POSITION_PATH_TAG)=0) then
               TTRemove(p);            {remove the position from the transposition-table}
          until Buckets[MaxValue]=nil; {until all max-value positions have been processed}
    until MaxValue<DepthLimit__;
    {$IFDEF CONSOLE_APPLICATION}
      if Result<>0 then Writeln('Freeing ',Result,'/',OriginalCount,' open position(s)');
      //OPENCheck('OPENDropPositions');
      //Readln;
    {$ENDIF}
    end;
//Msg('',TEXT_APPLICATION_TITLE);
end;

function  OPENIsAMember(Position__:PPosition):Boolean;
var i:Integer; p,Root:PPosition;
begin {open positions: is 'Position__' a member of the open-queue?}
  Result:=False;
  with Positions.OpenPositions do
    for i:=MinValue to MaxValue do begin
        Root:=Buckets[i]; p:=Root;
        if Root<>nil then
           repeat if   p=Position__ then begin
                       Result:=True; exit;
                       end
                  else p:=p^.ScoreBucket.Next;
           until  p=Root;
        end;
end;

function  OPENListLength(Position__:PPosition):Integer;
var BasePosition:PPosition;
begin {open positions: number of nodes in the chain having 'Position__' as a member}
  Result:=0;
  Position__:=PPosition(Cardinal(Position__) {and POSITION_POINTER_MASK});
  if Position__<>nil then begin
     BasePosition:=Position__;
     repeat Inc(Result);
            Position__:=PPosition(Cardinal(Position__^.ScoreBucket.Next) {and POSITION_POINTER_MASK});
            //if Position__<>PPosition(Cardinal(Position__^.ScoreBucket.Prev) {and POSITION_POINTER_MASK})^.ScoreBucket.Next then
            //   Msg(TEXT_INTERNAL_ERROR+': "OPENListLength" (links) '+IntToStr(Solver.PushCount),TEXT_APPLICATION_TITLE);
            //if Position__^.Score<>PPosition(Cardinal(Position__^.ScoreBucket.Prev) {and POSITION_POINTER_MASK})^.Score then
            //   Msg(TEXT_INTERNAL_ERROR+': "OPENListLength" (score) '+IntToStr(Solver.PushCount),TEXT_APPLICATION_TITLE);
            //if (Ord(Position__^.Move.Direction) and POSITION_OPEN_TAG)=0 then
            //   Msg(TEXT_INTERNAL_ERROR+': "OPENListLength" (tag) '+IntToStr(Solver.PushCount),TEXT_APPLICATION_TITLE);
     until  Position__=BasePosition;
     end;
end;

function  OPENListLengthReverse(Position__:PPosition):Integer;
var BasePosition:PPosition;
begin {open positions: number of nodes in the chain having 'Position__' as a member}
  Result:=0;
  if Position__<>nil then begin
     Position__:=PPosition(Cardinal(Position__) {and POSITION_POINTER_MASK});
     BasePosition:=Position__;
     repeat Inc(Result);
            Position__:=PPosition(Cardinal(Position__^.ScoreBucket.Prev) {and POSITION_POINTER_MASK});
     until  Position__=BasePosition;
     end;
end;

procedure OPENRemove(Position__:PPosition);
begin {open positions: remove item}
  with Positions.OpenPositions do with Position__^ do with ScoreBucket do begin
    Prev^.ScoreBucket.Next:=Next;
    Next^.ScoreBucket.Prev:=Prev;
    if Position__=Buckets[Score] then {'True': removing the root item in this bucket}
       if   Next<>Position__ then
            Buckets[Score]:=Next      {promote next item to root item in this bucket}
       else Buckets[Score]:=nil;      {removing the last item in this bucket}
//  Prev:=nil; Next:=nil;             {mark that the position isn't on the open-queue anymore}

//  if (Ord(Move.Direction) and POSITION_OPEN_TAG)=0 then
//     Msg(TEXT_INTERNAL_ERROR,'OPENRemove');

    Dec(UInt8(Move.Direction),POSITION_OPEN_TAG);
    BestForgottenScore:=DEAD_END_SCORE;
    NextPartiallyExpandedPosition:=nil;
    Dec(Count);
    end;
end;

function  OPENRemoveNextPositionSelectedForExpansion(var Position__:PPosition):Boolean;
const NO_PROGRESS_PERIOD=8; {must be a 2^N non-negative integer where N is a non-negative integer}
begin {open positions: remove best item, or in case of packing order search,
       occasionally an inferior item as an attempt to escape from a futile line
       of play; the rationale is that if the solver doesn't make any progress,
       then the evaluation function is obviously not doing a good job, and it
       might be an advantage to try something new;}
  with Positions.OpenPositions do begin
    while (MinValue<=MaxValue) and (Buckets[MinValue]=nil) do Inc(MinValue);
    Result:=MinValue<=MaxValue;
    if Result then begin
       Position__:=Buckets[MinValue];

       if (Solver.PackingOrder.SetCount>0) and {with packing order search, the solver isn't searching for an optimal solutions, hence, it's all right to expand positions in any order}
          ((PInteger(Addr(Solver.PushCount))^ and (NO_PROGRESS_PERIOD-1))=0) then begin {'PInteger': 'Solver.PushCount' is a double integer, but here it's enough to look at its integer part}
          repeat Inc(NoProgressRover);
          until  (NoProgressRover>MaxValue) or (Buckets[NoProgressRover]<>nil);
          if     NoProgressRover<=MaxValue then
                 Position__:=Buckets[NoProgressRover]
          else   NoProgressRover:=MinValue;
          end;

       {$IFDEF CONSOLE_APPLICATION}
         //if Position__^.Score<>MinValue then
         //   Msg(TEXT_INTERNAL_ERROR+': "OPENRemoveBest"',TEXT_APPLICATION_TITLE);
       {$ENDIF}

       OPENRemove(Position__);
       end
    else if (Solver.SearchLimits.DepthLimit>=0) and {'True': the search hasn't been terminated}
            (Positions.PartiallyExpandedPositionsList<>nil) then begin {'True': some positions haven't been fully expanded; revisit them now}
            OPENAddPartiallyExpandedPositions;
            Result:=OPENRemoveNextPositionSelectedForExpansion(Position__);
            end;
    end;
end;

function  OPENRemoveWorst(var Position__:PPosition):Boolean;
begin {open positions: remove worst item}
  with Positions.OpenPositions do begin
    while (MinValue<=MaxValue) and (Buckets[MaxValue]=nil) do Dec(MaxValue);
    Result:=MinValue<=MaxValue;
    if Result then begin
       Position__:=Buckets[MaxValue]^.ScoreBucket.Prev; {'Prev': normally the shallowest item, i.e., the item with lowest search-depth}
       OPENRemove(Position__);
       end;
    end;
end;

function  OPENWorst:PPosition;
begin {open positions: worst item}
  with Positions.OpenPositions do begin
    while (MinValue<=MaxValue) and (Buckets[MaxValue]=nil) do Dec(MaxValue);
    if   MinValue<=MaxValue then
         Result:=Buckets[MaxValue]^.ScoreBucket.Prev {'Prev': normally the shallowest item, i.e., the item with lowest search-depth}
    else Result:=nil;
    end;
end;

function  OPENWorstUnprotected:PPosition;
var RoverValue:Integer; Rover:PPosition;
begin {open positions: worst un-protected item}
  with Positions.OpenPositions do begin
    Result:=nil;
    while (MinValue<=MaxValue) and (Buckets[MaxValue]=nil) do Dec(MaxValue);
    RoverValue:=MaxValue;

    repeat
      while (MinValue<=RoverValue) and (Buckets[RoverValue]=nil) do Dec(RoverValue);
      if MinValue<=RoverValue then begin
         Rover:=Buckets[RoverValue]^.ScoreBucket.Prev;                          {'Prev': last item in the bucket; it's normally the shallowest item, i.e., the item with lowest search-depth}
         repeat
           with Rover^ do
             if ((Parent=nil)                                                   {'nil': a root-item}
                 or
                 ((Ord(Parent^.Move.Direction) and POSITION_PATH_TAG)<>0)       {'<>0': parent-item is on current path}
                 or
                 (SuccessorCount<>0)                                            {'True': the node has successors, i.e., other nodes in the transposition table have this node as parent}
                )
//              and
//              (BestForgottenScore=DEAD_END_SCORE)                             {'True': no successors have been pruned yet, hence, it's an unexpanded node}
                then begin                                                      {'True': it's a protected item; search for another}
                if Rover<>Buckets[Score] then Rover:=ScoreBucket.Prev           {back to previous item in the bucket}
                else begin                                                      {back to a bucket with a lower score}
                   Rover:=nil; Dec(RoverValue);
                   end;
                end
             else begin                                                         {this is an unprotected item; return it}
                Result:=Rover; Rover:=nil;
                end;
         until Rover=nil;                                                       {until done with this bucket}
         end;
    until (Result<>nil) or (MinValue>RoverValue);                               {until found or until all items on the open-queue have been visited}
    end;
end;

{-----------------------------------------------------------------------------}

{Position list}

procedure PLAddToFront(Position__:PPosition; var List__:PPosition; var Count__:Integer); {add item to the front of the list}
begin {position list: add item to the front of the list}
  if List__<>nil then with Position__^.ListLinks do begin                       {'<> nil': non-empty list}
     Prev:=List__^.ListLinks.Prev;                                              {link this position}
     Next:=List__;                                                              {link this position}
     List__:=Position__;                                                        {insert 'Position__' as the first member of the list}
     end
  else with Position__^.ListLinks do begin                                      {create new circular list with 1 item}
     Prev:=Position__;
     Next:=Position__;
     List__:=Position__;
     end;
  Inc(Count__);
end;

procedure PLRemove(Position__:PPosition; var List__:PPosition; var Count__:Cardinal);
begin {position list: remove item}
  with Position__^.ListLinks do begin
    Prev^.ListLinks.Next:=Next;                                                 {unlink this position}
    Next^.ListLinks.Prev:=Prev;                                                 {unlink this position}
    if Position__=List__ then                                                   {'True': removing the root item}
       if   Next<>Position__ then
            List__:=Next                                                        {new root item}
       else List__:=nil;                                                        {empty list}
    Prev:=nil; Next:=nil;                                                       {mark that the position isn't on the list anymore}
    Dec(Count__);
    end;
end;

{-----------------------------------------------------------------------------}

{Transposition Table}

function  TTCheckBucket(const Caption__:String; HashBucket__:Integer):Boolean;
var BasePosition,Position:PPosition;
begin
  Result:=True;
  Write(Caption__,' Bucket: ',HashBucket__,'  Pushes: ',Solver.PushCount,' ... ');
  BasePosition:=Positions.HashBuckets^[HashBucket__];
  if BasePosition<>nil then begin
     Position:=BasePosition;
     repeat //if (Position^.HashBucket.Next<>BasePosition) and
            //   (Position^.HashValue>Position^.HashBucket.Next.HashValue) then
            //   Result:=Msg(TEXT_INTERNAL_ERROR+': Transposition table corrupted. (Items  are not sorted)','TTCheckBucket');
            if (Position^.HashValue and Positions.HashBucketMask)<>HashBucket__ then
               Result:=Msg(TEXT_INTERNAL_ERROR+': Transposition table corrupted. (Item in a wrong bucket)','TTCheckBucket');
            Position:=Position^.HashBucket.Next;
     until  Position=BasePosition;
     end;
  if   Result then Writeln('OK')
  else Writeln;
end;

function  TTReallocateMemoryBlock( var Block__ : Pointer; var ByteSize__ : Integer; NewByteSize__ : Integer ) : Boolean;
var ItemCount : Integer;
    NewBlock : Pointer;

  procedure FreeMemoryBlock( var Block__ : Pointer; var ByteSize__ : Integer );
  var Index : Integer;
  begin // returns the free memory block to the positions free list
    for Index := 0 to Pred( ByteSize__ div SizeOf( TPosition ) ) do begin
        PPosition( Block__ )^.PlayerPos := 0;                                   {marks the item as unused}
        PPosition( Block__ )^.HashBucket.Next := Positions.FreeList;            {return the item to the free-list}
        Positions.FreeList:=PPosition( Block__ );
        Inc( PPosition( Block__ ) );
        end;
    Block__    := nil;
    ByteSize__ := 0;
  end;

begin // 'TTReallocateMemoryBlock' reallocates, allocates, or releases a memory
      // block from the memory originally allocated for the transposition table;
  ByteSize__            := Align( ByteSize__   , SizeOf( TPosition ) );
  NewByteSize__         := Align( NewByteSize__, SizeOf( TPosition ) );
  ItemCount             := NewByteSize__ div SizeOf( TPosition );
  Result                := ( NewByteSize__ >= 0 ) and {'True': valid parameter, e.g., alignment didn't cause a numeric overflow}
                           ( Positions.UninitializedItemCount >= ItemCount );
  if Result then begin {'True': sufficient free memory for the task}
     Dec( Positions.Capacity, ItemCount ); {allocate memory from the end of the transposition table}
     Dec( Positions.UninitializedItemCount, ItemCount );
     NewBlock           := Pointer( Addr( Positions.Positions^[ Positions.Capacity ] ) );
     Move( Block__^, NewBlock^, Min( ByteSize__, NewByteSize__ ) );
     if ( Positions.Count     >  0 ) and {'True': there is a search in progress; recycle the released memory block; memory blocks released before the search starts are left unused}
        ( Cardinal( Block__ ) <  Cardinal( Positions.EndOfPositions ) ) then {'True': the released memory block doesn't belong to the reserved memory at the top of the allocated memory}
        FreeMemoryBlock( Block__, ByteSize__ );
     ByteSize__         := NewByteSize__;
     if   ByteSize__    >  0 then
          Block__       := NewBlock
     else Block__       := nil;
     end;
end;

function  TTAdd(HashValue__:THashValue;
                PlayerPos__,PushCount__,Score__,BoxNo__:Integer;
                Direction__:TDirection;
                Parent__:PPosition;
                var Position__:PPosition):Boolean;
var HashBucketIndex:Integer; NextPosition:PPosition;
begin {transposition table: add new item unless it already is in the table}
  Result:=False; Position__:=nil;
  with Positions do
    if (not TTLookup(HashValue__,PlayerPos__,PushCount__,Position__)) then begin{'True': it's a new item}

       NextPosition:=Position__;                                                {save next position in the hash-chain}
       if Parent__<>nil then Inc(Parent__^.SuccessorCount);                     {update count before any pruning of the items in the transposition table takes place}

       if UninitializedItemCount<=0 then begin                                  {'True': all items in memory are either in use or on the free-list}
          if      FreeList<>nil then begin
                  Position__:=FreeList;                                         {get next free item}
                  FreeList  :=FreeList^.HashBucket.Next;                        {the free-list uses 'HashBucket.Next' for linking}
                  end
          else if PerimeterList<>nil then begin                                 {'True': reuse perimeter-nodes, that is, positions from a previous search in the opposite direction}
                  Position__:=PerimeterList;
                  PLRemove(Position__,PerimeterList,PerimeterListCount);        {remove 'Position__' from the perimeter-list}
                  {having 'TTRemove' in both forks of the following 'if'-statement}
                  {may look strange but the rationale is that since an 'if'}
                  {cannot be avoided here, then the normal case should at least}
                  {'fall through' in order to avoid cpu stalling}
                  if Position__<>NextPosition then                              {'True': 'NextPosition' wasn't the first item on the perimeter-list}
                     TTRemove(Position__)                                       {remove 'Position__' from the transposition-table}
                  else begin                                                    {'NextPosition' will disappear from the transposition-table because it's the first item on the perimeter-list}
                     TTRemove(Position__);                                      {remove 'Position__' from the transposition-table}
                     TTLookup(HashValue__,PlayerPos__,PushCount__,NextPosition);{find new 'NextPosition'}
                     end;
                  Inc(SearchStatistics.ReuseCount);

                  Position__:=FreeList;                                         {get next free item ('TTRemove' may recurse, in effect putting several nodes on the free-list}
                  FreeList  :=FreeList^.HashBucket.Next;                        {the free-list uses 'HashBucket.Next' for linking}
                  end
               else                                                             {transposition-table full}
                  if Solver.ReuseNodesEnabled and
                     (OpenPositions.Count<>0) then begin
                     Position__:=OPENWorstUnprotected;
                     //Position__:=OPENWorst;
                     if (Position__<>nil) and
                        (Score__<=Position__^.Score) then with Position__^ do begin {'True': new position is at least as promising as the worst saved position}
                        OPENRemove(Position__);                                 {remove the worst position from the open-queue}

                        if Position__<>NextPosition then                        {'True': 'NextPosition' wasn't the worst item on the item-queue}
                           TTRemove(Position__)                                 {remove 'Position__' from the transposition-table}
                        else begin                                              {'NextPosition' will disappear from the transposition-table because it was the worst item on the open-queue}
                           TTRemove(Position__);                                {remove 'Position__' from the transposition-table}
                           TTLookup(HashValue__,PlayerPos__,PushCount__,NextPosition);{find new 'NextPosition'}
                           end;
                        Inc(SearchStatistics.ReuseCount);

                        Position__:=FreeList;                                   {get next free item}
                        FreeList  :=FreeList^.HashBucket.Next;                  {the free-list uses 'HashBucket.Next' for linking}
                        end
                     else Position__:=nil;                                      {new position isn't better than the worst saved position; drop the new position}
                     end
                  else
                     Position__:=nil;                                           {transposition-table full}
          end
       else begin {not all items have been used yet, hence, get the next free item in memory}
          Position__:=PPosition(Addr(Positions^[Capacity-Cardinal(UninitializedItemCount)]));
          Dec(UninitializedItemCount);
          end;

       if Position__<>nil then with Position__^ do begin                        {'True': got a free slot: save the new item}
          HashBucketIndex    :=HashValue__ and HashBucketMask;
          if    NextPosition<>nil then begin                                    {'True': insert the new position before 'NextPosition'}
                HashBucket.Prev :=NextPosition^.HashBucket.Prev;
                HashBucket.Next :=NextPosition;
                HashBucket.Prev^.HashBucket.Next:=Position__;
                NextPosition^.HashBucket.Prev:=Position__;
                if HashBuckets^[HashBucketIndex]=NextPosition then              {'True': 'NextPosition' is the first item in its bucket}
                   HashBuckets^[HashBucketIndex]:=Position__;                   {set the new item to be the first item in its bucket}
                end
          else
             if HashBuckets^[HashBucketIndex]=nil then begin                    {'True': the bucket is empty}
                HashBuckets^[HashBucketIndex]:=Position__;                      {put this item in the bucket}
                HashBucket.Prev :=Position__;                                   {make single-item circular list}
                HashBucket.Next :=Position__;
                end
             else begin                                                         {insert as last item in this bucket}
                HashBucket.Next :=HashBuckets^[HashBucketIndex];
                HashBucket.Prev :=HashBucket.Next^.HashBucket.Prev;
                HashBucket.Prev^.HashBucket.Next:=Position__;
                HashBucket.Next^.HashBucket.Prev:=Position__;
                end;

          HashValue                     :=HashValue__;
          Move.BoxNo                    :=BoxNo__;
          Move.Direction                :=Direction__;
          Parent                        :=Parent__;
          PlayerPos                     :=PlayerPos__;
          PushCount                     :=PushCount__;
          Score                         :=Score__;
          BestForgottenScore            :=DEAD_END_SCORE;
          NextPartiallyExpandedPosition :=nil;
          PackingOrderAndSuccessorCount :=0; {clear both fields with one 4-byte instruction instead of two 2-byte instructions}
          Result                        :=True;

          if   PlayerPos__<=MAX_BOARD_SIZE then begin {'True': this is a normal game state position}
               Inc(Count);
               if   not Game.ReverseMode then Inc(SearchStatistics.ForwardPositionCount);
               if   BestPosition<>nil then begin
                    if   Score<=BestScore then begin
                         if ((Score<BestScore) or (PushCount>BestPosition^.PushCount)) and {'PushCount>': positions closer to the solution (nodes deeper in the tree) are considered better positions than shallow nodes}
                            (Position__^.PackingOrder.SetNo<>0) then begin {packing order search updates the best position back in the 'Search' function after changing the score to a more accurate estimate than the score available at this time}
                            BestScore:=Score;
                            BestPosition:=Position__;
                            Inc(SearchStatistics.NewBestPositionCount);
                            end;
                         end;
                    end
               else begin BestScore:=Score;
                          BestPosition:=Position__;
                          Inc(SearchStatistics.NewBestPositionCount);
                    end;
               end
          else Inc(SearchStatistics.CorralPositionsCount); {this is a corral position or a "no progress" deadlock stored in the transpostion table together with the normal game state positions}
          end
       else
          if Parent__<>nil then Dec(Parent__^.SuccessorCount);                  {undo the premature update}
       end
    else with Position__^ do {the position already exists in the transposition-table}
       if (PushCount__>=PushCount)
          or
          ((SuccessorCount<>0) {'True': either the position really has immediate successors in the transposition table, or the position is a member of the partially expanded positions list (the count has an artificially high value in that case)}
           and
           (Solver.PackingOrder.SetCount>0) {'PackingOrder.SetCount': with packing-order search, the path to a node cannot change}
          )
          or
          (Score>=DEAD_END_SCORE) {'True': the position is a deadlock or a dead-end}
          or
          (PlayerPos>MAX_BOARD_SIZE) {'True': it's a corral box configuration and not a normal game position}
          then begin
          Inc(SearchStatistics.DuplicatesCount);
          end
       else begin {cheaper path to this position: change path to it}
//{
          if (DebugPosition<>nil) and
             TTIsOnPath(Position__,DebugPosition) then begin
             ShowBoard;
             Writeln('New path: Pushes: ',PushCount__,SLASH,PushCount,' Score: ',Score__,SLASH,Score,SPACE,Game.SimpleLowerBound);
             Readln;
             end;
//}
          if Score<>0 then begin {'True': not a perimeter-node from a search in the opposite direction}
             if (Ord(Move.Direction) and POSITION_OPEN_TAG)<>0 then
                OPENRemove(Position__); {remove the position from the open-queue; the caller is expected to insert it at its new position}
             Score              :=Score__;
             if Parent<>nil then Dec(Parent^.SuccessorCount);
             end
          else {a perimeter-node from a search in the opposite direction, in effect a solution}
             if ListLinks.Prev<>nil then PLRemove(Position__,PerimeterList,PerimeterListCount);

          Move.BoxNo            :=BoxNo__;
          Move.Direction        :=Direction__;
          if Solver.PackingOrder.SetCount<=0 then {'True': it's not a packing-order search, i.e., it's an A*-search (with a depth-first search added as a twist if this is the forward search)}
             {mark the node for revisiting, in case it hasn't been expanded yet;

              nodes marked for revisiting are not subject to filters like the
              corral pruning in the forward search;

              searching for push-optimal solutions is an A*-search with the
              twist that for efficiency, some promising paths are expanded using
              a depth-first search;

              A clean A*-search has a so-called admissible evaluation function
              (it never overestimates the true cheapest cost to reach the
              solution), and consequently an A*-search never needs to revisit
              nodes;

              the depth-first search, however, may discover nodes which later
              turn out to be reachable via shorter paths found later, either by
              the mainline A*-search or by a different depth-first search;

              for completeness, these nodes must be fully expanded; otherwise,
              there is no push-optimality guarantee for the first found
              solution, which terminates the search;
             }
             UInt8(Move.Direction):=UInt8(Move.Direction) or POSITION_REVISIT_TAG;

          Parent                :=Parent__;
          PlayerPos             :=PlayerPos__;
          PushCount             :=PushCount__;
          Result                :=True;
          Inc(SearchStatistics.NewPathCount);
          if Parent__<>nil then Inc(Parent__^.SuccessorCount);

          if (BestPosition<>nil) and (Score<=BestScore) and
             (((Score<BestScore) or (PushCount>BestPosition^.PushCount))) and {'PushCount>': positions closer to the solution (nodes deeper in the tree) is considered better positions than shallow nodes}
             (Position__^.PackingOrder.SetNo<>0) then begin {packing order search updates the best position back in the 'Search' function after changing the score to a more accurate estimate than the score available at this time}
             BestScore:=Score;
             BestPosition:=Position__;
             Inc(SearchStatistics.NewBestPositionCount);
             end;
          end;
end;

function  TTIndexOf(Position__:PPosition):Integer; forward;

function  TTCalculatePerimeter:Integer;
const BUFFER_BYTE_SIZE=8*ONE_KIBI;
var i,HashBucketIndex,LastItemIndex,BufferItemCount:Integer; InteriorNodesCount:Cardinal;
    {$IFDEF CONSOLE_APPLICATION}
      TimeMS:TTimeMS; s:String;
    {$ENDIF}
    p,q,Last,Root:PPosition;
    GraphFileItems:array[0..(BUFFER_BYTE_SIZE div SizeOf(TGraphFileItem))-1] of TGraphFileItem;
begin {$I-}
  {transposition table: save all positions on disk and only keep the perimeter-positions (fringe-positions) in memory;}
  {precondition: there are no corral positions in the transposition table (they are identified by having 'Position^.PlayerPos>MAX_BOARD_SIZE')}
  //Write('Calculate perimeter...');
  Result:=0;
  {$IFDEF CONSOLE_APPLICATION}
    TimeMS:=GetTimeMS;
  {$ENDIF}
  InteriorNodesCount:=0; OPENClear;

  if Positions.Count<>0 then with Positions do begin
     {$IFDEF CONSOLE_APPLICATION}
       Write(TEXT_SAVE_POSITIONS_TO_DISK);
     {$ELSE}
       SetSokobanStatusText(TEXT_SAVE_POSITIONS_TO_DISK);
       Solver.LastCallBackTimeMS:=0;                                            {'0': force 'TimeCheck()' to update the screen, provided the backward search has been running for more than a few seconds}
       TimeCheck;
     {$ENDIF}
     FreeList:=nil; PerimeterList:=nil; PerimeterListCount:=0; BufferItemCount:=0;
     if (Positions<>nil)
        and
        ((GraphFile.FileName<>'')                                               {'<>': the file is already open}
         or
         CreateGraphFile(TEXT_APPLICATION_TITLE+GRAPH_FILE_EXT)
        ) then begin
        LastItemIndex:=Integer(Pred(Capacity-Cardinal(UninitializedItemCount)));

        Seek(GraphFile.GraphFile,Succ(LastItemIndex)*SizeOf(GraphFileItems[0]));{reserve diskspace in one operation instead of extending the file with one buffer block at a time}
        FillChar(GraphFileItems[0],SizeOf(GraphFileItems[0]),0);                {initalize the record so the compiler doesn't complain about an un-initialized variable}
        BlockWrite(GraphFile.GraphFile,GraphFileItems[0],SizeOf(GraphFileItems[0]));
        Seek(GraphFile.GraphFile,0);                                            {start writing sequentially from the beginning of the file}
        for i:=0 to LastItemIndex do with Positions^[i] do SuccessorCount:=0;   {later in the calculation, a non-zero value indicates an interior node, as opposed to a perimeter-node}
        for i:=0 to LastItemIndex do with Positions^[i] do
            if (PlayerPos<>0) and (Parent<>nil) then Inc(Parent^.SuccessorCount);{'SuccessorCount<>0': an interior node}

        for i:=0 to LastItemIndex do begin
            p:=PPosition(Addr(Positions^[i]));

            if not Solver.Terminated then begin                                 {'True': the user hasn't terminated the task; write the node to disk}
               if BufferItemCount>High(GraphFileItems) then begin               {'True': the write buffer is full; write it to disk and clear the buffer}
                  BlockWrite(GraphFile.GraphFile,PByte(Addr(GraphFileItems[0]))^,SizeOf(GraphFileItems[0])*BufferItemCount);
                  BufferItemCount:=0;
                  end;
               GraphFileItems[BufferItemCount].Move     :=p^.Move;
               GraphFileItems[BufferItemCount].PushCount:=p^.PushCount;
               GraphFileItems[BufferItemCount].Parent   :=p^.Parent;
               Inc(BufferItemCount);
               end;

            if p^.PlayerPos<>0 then with p^ do                                  {'True': a used node}
               if SuccessorCount=0 then begin                                   {'True': a perimeter-node}
                  Inc(Result);
                  while p^.HashBucket.Next^.SuccessorCount<>0 do                {unlink interior nodes from the hash-bucket chain}
                    p^.HashBucket.Next:=p^.HashBucket.Next^.HashBucket.Next;
                  p^.HashBucket.Next^.HashBucket.Prev:=p;                       {update link back to current node 'p'}
                  end
               else begin                                                       {an interior node}
                  Inc(InteriorNodesCount);
                  HashBucketIndex:=HashValue and HashBucketMask;
                  if HashBuckets^[HashBucketIndex]=p then begin                 {'p' is root in its hash-bucket}
                     q:=p;
                     repeat p:=p^.HashBucket.Next;                              {search for a perimeter-position in this bucket}
                     until  (p=q) or (p^.SuccessorCount=0);
                     if   p<>q then HashBuckets^[HashBucketIndex]:=p            {ensure that the hash-bucket links perimeter-nodes only}
                     else HashBuckets^[HashBucketIndex]:=nil;                   {no perimeter-nodes in this bucket}
                     end;
                  end;
            end;

        if (not Solver.Terminated) and (BufferItemCount>0) then                 {'True': the user hasn't terminated the task, and the write buffer isn't empty; write it to disk}
           BlockWrite(GraphFile.GraphFile,PByte(Addr(GraphFileItems[0]))^,SizeOf(GraphFileItems[0])*BufferItemCount);

        for i:=LastItemIndex downto 0 do begin                                  {build free-list and sort perimeter-positions}
            p:=PPosition(Addr(Positions^[i]));
            if (p^.PlayerPos=0) or (p^.SuccessorCount<>0) then begin            {'True': an unused node or an interior node:}
               p^.HashBucket.Next:=FreeList; FreeList:=p;                       {add it to the free-list}
               end
            else begin                                                          {a perimeter-node}
               if p^.Score >High(OpenPositions.Buckets) then begin
                  p^.Score:=High(OpenPositions.Buckets);
                  end;
               with p^.Move do Direction:=TDirection(Ord(Direction) and (not POSITION_OPEN_TAG)); {remove the existing 'open' tag, if any}
               q:=p^.Parent; p^.Parent:=nil; OPENAdd(p); p^.Parent:=q;          {use the open-queue to sort the perimeter-nodes}
               end;
            end;

        for i:=OpenPositions.MinValue to OpenPositions.MaxValue do              {update perimeter-positions and build a list of perimeter-positions}
            if OpenPositions.Buckets[i]<>nil then begin
               Root:=OpenPositions.Buckets[i]; p:=Root;
               repeat with p^ do begin
                        PathLengthToSolution:=PushCount;                        {save the distance to the goal-position}
                        PushCount:=High(PushCount);                             {this makes 'TTAdd' "think" that it finds cheaper paths to this position during the search from the opposite direction}
                        Parent:=nil;
                        Score:=0;                                               {'0' marks the position as a perimeter-node, in effect a solution}
                        SuccessorCount:=0;
                        p:=ScoreBucket.Next;                                    {next position in this bucket}
                        end;
               until  p=Root;

               if   PerimeterList<>nil then begin                               {'True': prepend current score-bucket to the existing perimeter-list}
                    Last:=PerimeterList^.ListLinks.Prev;                        {save last item before changing any the links}
                    Root^.ListLinks.Prev^.ScoreBucket.Next:=PerimeterList;      {bucket-last         ==> perimeter-list-first}
                    PerimeterList^.ListLinks.Prev:=Root^.ListLinks.Prev;        {bucket-last         <== perimeter-list-first}
                    Last^.ListLinks.Next:=Root;                                 {perimeter-list-last ==> bucket-first}
                    Root^.ListLinks.Prev:=Last;                                 {perimeter-list-last <== bucket-first}
                    end;
               PerimeterList:=Root;
               end;
        end
     else
        {something is wrong, e.g., creating the temporary disk file failed;}
        {drop all existing positions by treating them as interior nodes}
        InteriorNodesCount:=Count;

     {$IFDEF CONSOLE_APPLICATION}
       TimeMS:=CalculateElapsedTimeMS(TimeMS,GetTimeMS);

       if TimeMS>=500 then begin
          s:=IntToStrWithPluralDependentText((TimeMS+500) div 1000,'second');
          Write(' Time: ',s);
          end;
       Writeln;

       Writeln('Perimeter: Positions: ',Result,'/',Count);

       //Writeln('Deadend positions: ',DeadEndCount);
       //Writeln('TT Lookup: ',SearchStatistics.Lookup1Count,'/',SearchStatistics.Lookup2Count);

     {$ELSE}
       SetSokobanStatusText('');
       Solver.LastCallBackTimeMS:=0;                                            {'0': force 'TimeCheck()' to update the screen, provided it took more than a few seconds to save the nodes to disk}
       TimeCheck;
     {$ENDIF}

     if Cardinal(Result)+InteriorNodesCount<>Count then
        Msg(TEXT_INTERNAL_ERROR+SPACE+LEFT_PAREN+IntToStr(Cardinal(Result)+InteriorNodesCount-Count)+RIGHT_PAREN,'TTCalculatePerimeter');

     Count:=Result; PerimeterListCount:=Result;
     SearchStatistics.DroppedCount:=SearchStatistics.DroppedCount+InteriorNodesCount;

     if IOResult<>0 then begin
        Msg(TEXT_FILE_IO_ERROR,GraphFile.FileName);
        Result:=-1;
        end;

{
     for i:=0 to Pred(Capacity) do with Positions[i] do begin
         if (PlayerPos<>0) and (SuccessorCount=0) then
            if not TTLookup(HashValue,PlayerPos,p) then begin
               Msg(TEXT_INTERNAL_ERROR+' 02 '+IntToStr(i),'TTCalculatePerimeter');
               end;
         end;
}
{
     i:=OPENListLength(PerimeterList);
     if (i<>PerimeterListCount) or (i<>OPENListLengthReverse(PerimeterList)) then
        Msg(TEXT_INTERNAL_ERROR+' 03 '+IntToStr(i)+'/'+IntToStr(Count),'TTCalculatePerimeter');

     i:=TTListLength(FreeList);
     if PerimeterListCount+i<>Capacity then
        Msg(TEXT_INTERNAL_ERROR+' 04 '+IntToStr(i)+'/'+IntToStr(Count),'TTCalculatePerimeter');
}
{
     for i:=0 to Pred(HashBucketCount) do begin
         p:=HashBuckets^[i];
         if p<>nil then
            repeat if (p^.HashValue and HashBucketMask)<>i then
                      Writeln;
                   p:=p^.HashBucket.Next;
            until  p=HashBuckets^[i];
         end;
}
     end;
end; {$I+}

procedure TTClear;
var SquareNo : Integer; //Position:PPosition;
begin {transposition table: clear table, keeping precalculated deadlock sets, if any}
  with Positions do begin
    Count                         :=0;
    FreeList                      :=nil;
    UninitializedItemCount        :=0;   SearchStatistics.DroppedCount:=0;
    PerimeterList                 :=nil; PerimeterListCount           :=0;
    BackwardPositionsList         :=nil; BackwardPositionsListCount   :=0;
    CurrentPosition               :=nil; BestPosition                 :=nil;
    StartPosition                 :=nil; SolutionPosition             :=nil;
    PartiallyExpandedPositionsList:=nil; DebugPosition                :=nil;
    BestScore                     := High( BestScore );
    Capacity                      := ( Cardinal( EndOfPositions ) - Cardinal( Positions ) ) div SizeOf( TPosition );
    if Positions<>nil then begin
       UninitializedItemCount     := Integer(Capacity); {add one item at a time to the transposition-table instead of building a free-list with all the items in memory}
(*
       for i:=Pred(Capacity) downto 0 do begin  {build a free-list with all the items in memory}
           Position:=Addr(Positions^[i]);       {current item}
           Position^.PlayerPos:=0;              {'0': unused item}
           Position^.HashBucket.Next:=FreeList; {the free-list uses 'HashBucket.Next' for linking}
           FreeList:=Position;
           end;
*)
       if HashBuckets<>nil then FillChar(HashBuckets^,HashBucketCount*SizeOf(HashBuckets^[Low(HashBuckets^)]),0);
       end;

    FillChar(CorralBoxSquares,SizeOf(CorralBoxSquares),0);
    FillChar(SearchStatistics,SizeOf(SearchStatistics),0);

    with Game.DeadlockSets do begin
      if Count >  PrecalculatedSetsCount then begin {'True': dynamically calculated deadlock sets were found during a previous search; drop all of them before a new search is launched}
         Count := PrecalculatedSetsCount;
         for SquareNo := 0 to Game.BoardSize do {restore the per square deadlock set number counts so only the precalculated deadlock sets are included}
             if Assigned( SquareSetNumbers[ SquareNo ] ) then
                while (                            SquareSetCount[ SquareNo ]   > 0     ) and
                      (SquareSetNumbers[SquareNo]^[SquareSetCount[ SquareNo ] ] > Count ) do
                      Dec(                         SquareSetCount[ SquareNo ] );
         SquareSetNumbers := PrecalculatedSquareSetNumbers; {restore the per square deadlock set numbers to the precalculated deadlock sets, i.e., drop all dynamically created deadlocks found during a previous search}
         end;

      PathDeadlockCount:=0; NewDynamicDeadlockSets:=False; {initalize path information for a depth-first search}
      end;
    end;
end;

procedure TTFinalize;
begin
  with Positions do begin
    if Positions<>nil then FreeMem(Positions);
    Positions:=nil; EndOfPositions:=nil;
    Game.DeadlockSets.Count:=0; {don't restore precalculated deadlock sets from the last processed level}
    TTClear;
    end;
end;

function  TTIndexOf(Position__:PPosition):Integer;
begin {transposition table: returns vector index for the item at 'Position__'}
  Result:=(UInt(Position__)-UInt(Positions.Positions)) div SizeOf(Position__^);
end;

function  TTIsOnPath(Position__,Path__:PPosition):Boolean;
begin //transposition table: returns 'True' if 'Position__' is on the path leading to 'Path__'
  Result:=False;
  while (Path__<>nil) and (not Result) do
    if   Path__<>Position__ then Path__:=Path__^.Parent
    else Result:=True;
end;

function  TTInitialize(MemoryByteSize__:Cardinal):Boolean;
var i,j:Integer; PositionSize,HashBucketVectorSize,HashBucketItemSize:Cardinal;
begin
//MemoryByteSize__:=256*ONE_MEBI;
  Result                    :=False;
  FillChar(Positions,SizeOf(Positions),0);
//MemoryByteSize__          :=Min(MemoryByteSize__,High(Positions.MemoryByteSize));
  MemoryByteSize__          :=Min(MemoryByteSize__,MaxInt);
  PositionSize              :=SizeOf(Positions.Positions^[Low(Positions.Positions^)]);
  HashBucketItemSize        :=SizeOf(Positions.HashBuckets^[Low(Positions.HashBuckets^)]);

  if MemoryByteSize__>=PositionSize+HashBucketItemSize then with Positions do begin
     {$IFDEF PLUGIN_MODULE}
       {$IFDEF WINDOWS}
         GetAsMuchMemoryAsPossible(Pointer(Positions),MemoryByteSize__,ONE_MEBI);
       {$ELSE}
         GetMem(Positions,MemoryByteSize__);
       {$ENDIF}
     {$ELSE}
       GetMem(Positions,MemoryByteSize__);
       {'GetMem()' can fail, even if the user specified 'available memory' in}
       {the command line parameters;}
       {the rationale for not protecting against memory overflow here by using}
       {'GetAsMuchMemoryAsPossible()' is that it entails linking 'SysUtils' to}
       {the application for exception-handling, adding so much extra baggage to}
       {the exe-file that it doesn't seem worth it}
     {$ENDIF}

     if Positions<>nil then begin
        MemoryByteSize:=MemoryByteSize__;

        {calculate the size of the memory to reserve for the hash-buckets}
        HashBucketCount:=1; Capacity:=0;
        repeat i:=HashBucketCount shl 1;
               HashBucketVectorSize:=Cardinal(i)*HashBucketItemSize;
               if   MemoryByteSize>=HashBucketVectorSize then begin
                    j:=(MemoryByteSize-HashBucketVectorSize) div PositionSize;  // calculate the number of positions after reservation of 'i' buckets
                    if j>0 then begin
                       HashBucketCount:=i; Capacity:=j;
                       end;
                    end
               else j:=0;
        until  ((j div HashBucketCount)<=TT_AVERAGE_BUCKET_SIZE)
               or
               (i>=High(HashBucketCount) div 2);

        HashBucketMask:=Pred(HashBucketCount); {masking a hash-value with 'HashBucketMask' produces a proper hash-bucket index}
        HashBuckets   :=PPositionPointersVector(UInt(Positions)+UInt(Capacity*PositionSize)); {reserve the upper part of the allocated memory for the hash-buckets}
        EndOfPositions:=HashBuckets; {start of the reserved area; later, during processing of a level, its precalculated deadlock sets are added to the reserved area}
        Result        :=Capacity<>0;
        end;
     end;

  InitializeRandomState(0);
  for i:=0 to 255 do if Random(MaxInt)=0 then;                                  {warm up the random number generator}

  with Positions do
    for i:=Low(SquareHashValues) to High(SquareHashValues) do                   {initialize the hash square values used for calculating Zobrist hash-keys}
        repeat
          SquareHashValues[i]:=
            Abs(Abs((THashValue(Random(MaxInt)) shl 48))+
                Abs((THashValue(Random(MaxInt)) shl 32))+
                Abs((THashValue(Random(MaxInt)) shl 16))+
                Abs((THashValue(Random(MaxInt)) shl 8 ))+
                Abs((THashValue(Random(MaxInt)))));
          for j:=0 to Pred(i) do                                                {avoid duplicates}
              if SquareHashValues[j]=SquareHashValues[i] then
                 SquareHashValues[i]:=0;
        until SquareHashValues[i]>MaxInt;
end;

function  TTListLength(Position__:PPosition):Integer;
var BasePosition:PPosition;
begin {transposition table: number of nodes in the chain having 'Position__' as a member}
  Result:=0;
  if Position__<>nil then begin
     Position__:=PPosition(Cardinal(Position__) {and POSITION_POINTER_MASK});
     BasePosition:=Position__;
     repeat Inc(Result);
            Position__:=PPosition(Cardinal(Position__^.HashBucket.Next) {and POSITION_POINTER_MASK});
     until  (Position__=nil) or (Position__=BasePosition);
     end;
end;

function  TTLookup(HashValue__:THashValue; PlayerPos__,SearchDepth__:Integer;
                   var Position__:PPosition):Boolean;
var HashBucketIndex:Integer; BasePosition:PPosition;
begin {transposition table: test if a key already exists;}
      {precondition: 'PlayerPos__' = 'Game.PlayerPos' for real positions, and 'PlayerPos__' < MAX_BOARD_WIDTH for pseudo positions like deadlock sets}
  Result:=False;
  //if (PlayerPos__<>Game.PlayerPos) and (PlayerPos__>MAX_BOARD_WIDTH) and (Positions.Count<>0) then
  //   Msg(TEXT_INTERNAL_ERROR+': TTLookup: Unexpected player position',TEXT_APPLICATION_TITLE);
  with Positions do begin
    HashBucketIndex:=HashValue__ and HashBucketMask;
    Position__:=HashBuckets^[HashBucketIndex];
    if Position__<>nil then begin
       BasePosition:=Position__;
       Inc(SearchStatistics.Lookup1Count);
       repeat Inc(SearchStatistics.Lookup2Count);

//            lookup algorithm when the player-position isn't fixed, i.e., search the player's access area for a match
              if        HashValue__=Position__^.HashValue then
                        if (Position__^.PlayerPos=PlayerPos__) or (PlayerPos__=0) then begin {'0': don't care}
                           Result:=True; exit;                                  {found: quick-and-dirty exit}
                           end
                        else
                           if (PlayerPos__          <=MAX_BOARD_SIZE) and       {'True': the lookup is a search for a normal game position and not a deadlock set}
                              (Position__^.PlayerPos<=MAX_BOARD_SIZE) then      {'True': the position is a game position and not a deadlock set}
                              with Solver.SearchStates[SearchDepth__].PlayersReachableSquares do begin
                                if not Calculated then
                                   CalculatePlayersReachableSquares(SearchDepth__); {note that the calculation is for the current game state, i.e., 'Game.PlayerPos' and not the function parameter 'PlayerPos__'}
                                if (Squares[Position__^.PlayerPos]=TimeStamp)   {'True': the position's player-position is in the current player access area}
                                   {
                                   // quick-and-dirty:
                                   // when 'PlayerPos__' <=MAX_BOARD_SIZE then
                                   // 'TTLookup' is always called with
                                   // 'PlayerPos__' = 'Game.PlayerPos',
                                   // hence, there is no need to check that
                                   // 'Squares[PlayerPos__] = TimeStamp'
                                   and
                                   (Squares[PlayerPos__]=TimeStamp)
                                   }
                                   then begin
                                   //if PlayerPos__<>Game.PlayerPos then Msg(TEXT_INTERNAL_ERROR+': TTLookup',TEXT_APPLICATION_TITLE);
                                   Result:=True; exit;                          {found: quick-and-dirty exit}
                                   end;
                                end;

//            lookup algorithm when the player-position is fixed, i.e, it's always a normalized (typically top-left) position:
//            if        ( Position__^.HashValue=HashValue__) and
//                      ((Position__^.PlayerPos=PlayerPos__) or (PlayerPos__=0)) then begin {'0': don't care}
//                      Result:=True; exit;                                     {found: quick-and-dirty exit}
//                      end
//            else
                   if   HashValue__>=Position__^.HashValue then begin
//                 if   Game.HashValue>=Position__^.HashValue then begin
                        Position__:=Position__^.HashBucket.Next;                {try next item in this bucket}
                        if Position__=BasePosition then begin                   {'True': all items in the chain has been tested}
                           Position__:=nil;                                     {'Position__' = nil: either means "key >= all keys in this bucket" or "empty bucket"}
                           exit;
                           end;
                        end
                   else exit;                                                   {stop searching; the items are sorted in ascending order on keys}
       until  False;                                                            {loops forever; see the body of the loop for quick-and-dirty exit-statements}
       end
    else begin {empty slot}
       end;
    end;
end;

procedure TTRemove(Position__:PPosition);
var HashBucketIndex:Integer;
begin {transposition table: remove item; precondition: 'Position__' is a fringe-node, i.e., not an interior node (no 'Parent' pointers back to this item)}
//if Position__=Positions.CurrentPosition then
//   Msg(TEXT_INTERNAL_ERROR,'TTRemove - current position');

  if Position__<>nil then with Position__^ do with HashBucket do begin
     Prev^.HashBucket.Next:=Next;
     Next^.HashBucket.Prev:=Prev;
     HashBucketIndex:=HashValue and Positions.HashBucketMask;
     if Position__=Positions.HashBuckets^[HashBucketIndex] then                 {'True': removing the bucket root item}
        if   Next<>Position__ then
             Positions.HashBuckets^[HashBucketIndex]:=Next                      {promote the next item to root}
        else Positions.HashBuckets^[HashBucketIndex]:=nil;                      {empty bucket}

     PlayerPos:=0;                                                              {marks the item as unused}

     Position__^.HashBucket.Next:=Positions.FreeList;                           {return the item to the free-list}
     Positions.FreeList:=Position__;

     Dec(Positions.Count); Inc(Positions.SearchStatistics.DroppedCount);          {update counts and statistics}

     if Parent<>nil then with Parent^ do begin
        Dec(SuccessorCount);
        if (Ord(Move.Direction) and (POSITION_OPEN_TAG+POSITION_PATH_TAG))=0 then begin  {'True': the parent isn't on the open-list, and it isn't a member of the currently investigated path}
           if Position__^.Score<BestForgottenScore then
              BestForgottenScore:=Score;                                        {save the best forgotten score; note that due to overlapping bytes, it only exists for closed positions}

           if SuccessorCount=0 then begin                                       {'True': the last successor has been removed}
              Score:=BestForgottenScore;
              OPENAdd(Position__^.Parent);                                      {put the parent back on the open-queue}
              end;
           end;
        end;
     end;
end;

{-----------------------------------------------------------------------------}

{Pathfinding}

procedure CalculateBoxPullOrPushDistances(BoxSquare__,PlayersReachableSquaresIndex__:Integer; PushBox__,UsePlayerPosition__,ContinueCalculation__:Boolean; var Distances__:TSquareDirectionArrayOfInteger);
type TQueueItem=record BoxPos,PlayerPos,Distance:Integer; end;
var  BoxPosition,BoxToSquare,Distance,DistanceInitializationValue,
     LastBoxPosition,NeighborSquare,
     OldBoxSquareValue,OldPlayerPosition,PlayerFromSquare,PlayerToSquare,Square:Integer;
     Direction:TDirection;
     QueueBottom,QueueTop:^TQueueItem;
     QueueItems:array[0..MAX_BOARD_SIZE*DIRECTION_COUNT] of TQueueItem;
begin {calculates the distance to all reachable squares by pulling or pushing a box around on the board, starting from 'BoxSquare__'}
  with Game do with Solver.SearchStates[PlayersReachableSquaresIndex__] do begin
    OldPlayerPosition:=PlayerPos; OldBoxSquareValue:=Board[BoxSquare__];
    Board[BoxSquare__]:=Board[BoxSquare__] and (not BOX); {remove the box, if any, from the board}

    DistanceInitializationValue:=0;
    if not ContinueCalculation__ then begin {otherwise, the calculation continues with the existing distances in 'Distances__'}
       for Square:=0 to BoardSize do
           if   (Board[Square] and WALL)<>0 then
                for Direction:=Low(Direction) to High(Direction) do
                    Distances__[Square,Direction]:=-INFINITY  {wall square : '-infinity' : the search cannot find a better path to the square}
           else for Direction:=Low(Direction) to High(Direction) do
                    Distances__[Square,Direction]:=+INFINITY; {floor square: '+infinity' : the search might  find a better path to the square}
       end
    else for Direction:=Low(Direction) to High(Direction) do
             if (Abs(Distances__[BoxSquare__,Direction])<>INFINITY) then
                {when the calculation continues, it taints reachable squares; it
                doesn't treat each continuation square as a new 0-distance
                starting point;
                }
                DistanceInitializationValue:=Max(DistanceInitializationValue,Distances__[BoxSquare__,Direction]);

    LastBoxPosition:=0;
    QueueBottom:=Addr(QueueItems[Low(QueueItems)]); QueueTop:=QueueBottom;

    if  UsePlayerPosition__ then begin
        Inc(Board[BoxSquare__],BOX);
        CalculatePlayersReachableSquares(PlayersReachableSquaresIndex__);
        Dec(Board[BoxSquare__],BOX);
        end;

    for Direction:=Low(Direction) to High(Direction) do begin
        NeighborSquare:=BoxSquare__+SquareOffsetForward[Direction];
        if      ((Board[NeighborSquare] and WALL)=0)
                and
                ((not UsePlayerPosition__)
                 or
                 (PlayersReachableSquares.Squares[NeighborSquare]=PlayersReachableSquares.TimeStamp)
                ) then begin
                Inc(QueueTop);
                QueueTop^.BoxPos   :=BoxSquare__;
                QueueTop^.PlayerPos:=NeighborSquare;
                QueueTop^.Distance :=0;
                if   PushBox__ then                                             {'True': push the box around on the board, as opposed to pulling it around on the board}
                     Distances__[BoxSquare__,OPPOSITE_DIRECTION[Direction]]:=DistanceInitializationValue  {'OPPOSITE_DIRECTION': e.g., after pushing the box to the left, the player is on the right side of the box}
                else Distances__[BoxSquare__,Direction]:=DistanceInitializationValue;
                end
        else if not UsePlayerPosition__ then
                if   PushBox__ then
                     Distances__[BoxSquare__,OPPOSITE_DIRECTION[Direction]]:=DistanceInitializationValue  {'OPPOSITE_DIRECTION': e.g., after pushing the box to the left, the player is on the right side of the box}
                else Distances__[BoxSquare__,Direction]:=DistanceInitializationValue;
        end;

    while QueueBottom<>QueueTop do begin {breadth-first search}
          Inc(QueueBottom);
          BoxPosition   :=QueueBottom^.BoxPos;
          Game.PlayerPos:=QueueBottom^.PlayerPos;
          Distance      :=Succ(QueueBottom^.Distance); {distance after pushing a box in the current position}

          Inc(Game.Board[BoxPosition],BOX); {put the box on the board}

          if  (BoxPosition<>LastBoxPosition) or
              (PlayersReachableSquares.Squares[Game.PlayerPos]<>PlayersReachableSquares.TimeStamp) then begin
              {the current set of player's reachable squares isn't valid anymore; recalculate the set}
              LastBoxPosition:=BoxPosition;
              CalculatePlayersReachableSquares(PlayersReachableSquaresIndex__); {calculate player's reachable squares to see which sides of the box the player can reach}
              end;

          for Direction:=Low(Direction) to High(Direction) do begin
              BoxToSquare   :=BoxPosition+Game.SquareOffsetForward[Direction];
              if PushBox__ then begin                                           {'True': push the box around on the board}
                 PlayerFromSquare:=BoxPosition-Game.SquareOffsetForward[Direction];

                 if (Distances__[BoxToSquare,Direction]>Distance) and           {'True': the existing distance to the square is bigger than the distance via the currently investigated path}
                    (PlayersReachableSquares.Squares[PlayerFromSquare]=PlayersReachableSquares.TimeStamp) and
                    ((Game.Board[BoxToSquare] and (WALL+BOX+FLAG_ILLEGAL_BOX_SQUARE))=0) then begin
                    Distances__[BoxToSquare,Direction]:=Distance;
                    Inc(QueueTop);
                    QueueTop^.BoxPos   :=BoxToSquare;
                    QueueTop^.PlayerPos:=BoxPosition;
                    QueueTop^.Distance :=Distance;
                    end;
                 end
              else begin                                                        {pull the box around on the board}
                 PlayerToSquare:=BoxToSquare+Game.SquareOffsetForward[Direction];

                 if (Distances__[BoxToSquare,Direction]>Distance) and
                    (PlayersReachableSquares.Squares[BoxToSquare]=PlayersReachableSquares.TimeStamp) and
                    ((Game.Board[PlayerToSquare] and (WALL+BOX))=0) and
                    ((Game.Board[BoxToSquare   ] and (WALL+BOX+FLAG_ILLEGAL_BOX_SQUARE))=0) and
                    {caution: the following check for the pusher painting itself into a corner assumes 4 directions only}
                    ((not ( ((Game.Board[PlayerToSquare+Game.SquareOffsetForward[Direction]] and WALL)<>0)
                            and
                            ((Game.Board[PlayerToSquare+Game.SquareOffsetLeft   [Direction]] and WALL)<>0)
                            and
                            ((Game.Board[PlayerToSquare+Game.SquareOffsetRight  [Direction]] and WALL)<>0)
                          )
                     )
                     or
                     (PlayerToSquare=StartPlayerPos) {'=': if the player after the pull ends at its starting position in the game, then the square is all right}
                    ) then begin
                    Distances__[BoxToSquare,Direction]:=Distance;
                    Inc(QueueTop);
                    QueueTop^.BoxPos   :=BoxToSquare;
                    QueueTop^.PlayerPos:=PlayerToSquare;
                    QueueTop^.Distance :=Distance;
                    end;
                 end;
              end;

          Dec(Game.Board[BoxPosition],BOX); {remove the box from the board again}
          end;

    Board[BoxSquare__]:=OldBoxSquareValue; {restore box square value}
    PlayerPos:=OldPlayerPosition; {restore player position}
    end;
end; {CalculateBoxPullOrPushDistances}

procedure CalculateDistanceToNearestBoxStartPositionForAllSquares(FirstBoxNo__,LastBoxNo__:Integer; UsePlayerStartPosition__:Boolean; var Distances__:TBoardOfIntegers);
type TQueueItem=record BoxPos,PlayerPos,Distance:Integer; end;
var  BoxNo,BoxPosition,BoxToSquare,Distance,LastBoxPosition,
     NeighborSquare,OldPlayerPosition,PlayerFromSquare,Square:Integer;
     Direction:TDirection;
     Distances:TSquareDirectionArrayOfInteger;
     QueueBottom,QueueTop:^TQueueItem;
     QueueItems:array[0..MAX_BOARD_SIZE*DIRECTION_COUNT] of TQueueItem;
begin {calculates - for all squares on the (empty) board - the distance to the nearest ['FirstBoxNo .. 'LastBoxNo'] box start positions}
  with Game do begin
    OldPlayerPosition:=PlayerPos;
    for BoxNo:=1 to Game.BoxCount do Board[BoxPos[BoxNo]]:=Board[BoxPos[BoxNo]] and (not BOX); {remove all boxes from the board}

    for Square:=0 to BoardSize do
        if   IsAWallSquare(Square) then
             for Direction:=Low(Direction) to High(Direction) do
                 Distances[Square,Direction]:=-INFINITY {wall square}
        else for Direction:=Low(Direction) to High(Direction) do
                 Distances[Square,Direction]:=+INFINITY; {floor square}

    LastBoxPosition:=0;
    QueueBottom:=Addr(QueueItems[Low(QueueItems)]); QueueTop:=QueueBottom;

    for BoxNo:=FirstBoxNo__ to LastBoxNo__ do begin
        Square:=StartBoxPos[BoxNo]; {note it's the start positions, not the box positions for the current game state}
        if (Board[Square] and WALL)=0 then begin {'True': the box square hasn't been temporarily disabled}
           if  UsePlayerStartPosition__ then begin
               Inc(Board[Square],BOX);
               CalculatePlayersReachableSquares(SEARCH_STATE_INDEX_DO_PUSH);
               Dec(Board[Square],BOX);
               end;
           for Direction:=Low(Direction) to High(Direction) do begin
               NeighborSquare:=Square+SquareOffsetForward[Direction];
               if      (not IsAWallSquare(NeighborSquare))
                       and
                       ((not UsePlayerStartPosition__)
                        or
                        (Solver.SearchStates[SEARCH_STATE_INDEX_DO_PUSH].PlayersReachableSquares.Squares[NeighborSquare]
                         =
                         Solver.SearchStates[SEARCH_STATE_INDEX_DO_PUSH].PlayersReachableSquares.TimeStamp)
                       ) then begin
                       Inc(QueueTop);
                       QueueTop^.BoxPos   :=Square;
                       QueueTop^.PlayerPos:=NeighborSquare;
                       QueueTop^.Distance :=0;
                       Distances[Square,OPPOSITE_DIRECTION[Direction]]:=0;      {'OPPOSITE_DIRECTION': e.g., after pushing the box to the left, the player is on the right side of the box}
                       end
               else if not UsePlayerStartPosition__ then
                       Distances[Square,Direction]:=0;
               end;
           end;
        end;

    while (QueueBottom<>QueueTop) do with Solver.SearchStates[SEARCH_STATE_INDEX_DO_PUSH] do begin {breadth-first search}
      Inc(QueueBottom);
      BoxPosition   :=QueueBottom^.BoxPos;
      Game.PlayerPos:=QueueBottom^.PlayerPos;
      Distance      :=Succ(QueueBottom^.Distance); {distance after pushing a box in current position}

      Inc(Game.Board[BoxPosition],BOX); {put the box on the board}

      if  (BoxPosition<>LastBoxPosition) or
          (PlayersReachableSquares.Squares[Game.PlayerPos]<>PlayersReachableSquares.TimeStamp) then begin
          {the current set of player's reachable squares isn't valid anymore; recalculate the set}
          LastBoxPosition:=BoxPosition;
          CalculatePlayersReachableSquares(SEARCH_STATE_INDEX_DO_PUSH); {calculate player's reachable squares to see which sides of the box the player can reach}
          end;

      for Direction:=Low(Direction) to High(Direction) do begin
          BoxToSquare     :=BoxPosition+Game.SquareOffsetForward[Direction];
          PlayerFromSquare:=BoxPosition-Game.SquareOffsetForward[Direction];

          if (Distances[BoxToSquare,Direction]>Distance) and
             (PlayersReachableSquares.Squares[PlayerFromSquare]=PlayersReachableSquares.TimeStamp) and
             ((Game.Board[BoxToSquare] and (WALL+BOX+FLAG_ILLEGAL_BOX_SQUARE))=0) then begin
             Distances[BoxToSquare,Direction]:=Distance;
             Inc(QueueTop);
             QueueTop^.BoxPos   :=BoxToSquare;
             QueueTop^.PlayerPos:=BoxPosition;
             QueueTop^.Distance :=Distance;
             end;
          end;

      Dec(Game.Board[BoxPosition],BOX); {remove the box from the board again}
      end;

    for Square:=0 to BoardSize do begin
        Distances__[Square]:=INFINITY;
        if not IsAWallSquare(Square) then
           for Direction:=Low(Direction) to High(Direction) do
               Distances__[Square]:=Min(Distances__[Square],Distances[Square,Direction]);
        end;
    {ensure that the distance is zero for the selected box starting positions;
     otherwise, this is not guaranteed for isolated boxes when the player's
     starting position is taken into account
    }
    for BoxNo:=FirstBoxNo__ to LastBoxNo__ do Distances__[BoxPos[BoxNo]]:=0;

    for BoxNo:=1 to Game.BoxCount do Inc(Board[BoxPos[BoxNo]],BOX); {put all boxes back on the board}
    PlayerPos:=OldPlayerPosition; {restore the player position}
    end;
end; {CalculateDistanceToNearestBoxStartPositionForAllSquares}

procedure CalculateDistanceToNearestGoalForAllSquares(MarkIllegalBoxSquares__:Boolean; var Distances__:TBoardOfIntegers);
type TQueueItem=record BoxPos,PlayerPos,Distance:Integer; end;
var  BoxNo,BoxPosition,BoxToSquare,Distance,GoalNo,GoalSquare,LastBoxPosition,
     OldPlayerPosition,PlayerToSquare,Square:Integer;
     Direction:TDirection;
     Distances:TSquareDirectionArrayOfInteger;
     QueueBottom,QueueTop:^TQueueItem;
     QueueItems:array[0..MAX_BOARD_SIZE*DIRECTION_COUNT] of TQueueItem;
begin
  with Game do begin
    OldPlayerPosition:=PlayerPos;
    for BoxNo:=1 to Game.BoxCount do Board[BoxPos[BoxNo]]:=Board[BoxPos[BoxNo]] and (not BOX); {remove all boxes from the board}

    for Square:=0 to BoardSize do
        if   IsAWallSquare(Square) then
             for Direction:=Low(Direction) to High(Direction) do
                 Distances[Square,Direction]:=-INFINITY {wall square}
        else for Direction:=Low(Direction) to High(Direction) do
                 Distances[Square,Direction]:=INFINITY; {floor square}

    LastBoxPosition:=0;
    QueueBottom:=Addr(QueueItems[Low(QueueItems)]); QueueTop:=QueueBottom;

    for GoalNo:=1 to GoalCount do begin
        GoalSquare:=GoalPos[GoalNo];
        if (Board[GoalSquare] and GOAL)<>0 then {'True': the goal square hasn't been temporarily disabled}
           for Direction:=Low(Direction) to High(Direction) do begin
               Distances[GoalSquare,Direction]:=0;
               Square:=GoalSquare+SquareOffsetForward[Direction];
               if not IsAWallSquare(Square) then begin
                  Inc(QueueTop);
                  QueueTop^.BoxPos   :=GoalSquare;
                  QueueTop^.PlayerPos:=Square;
                  QueueTop^.Distance :=0;
                  end;
               end;
        end;

    while (QueueBottom<>QueueTop) do with Solver.SearchStates[SEARCH_STATE_INDEX_DO_PUSH] do begin
      Inc(QueueBottom);
      BoxPosition   :=QueueBottom^.BoxPos;
      Game.PlayerPos:=QueueBottom^.PlayerPos;
      Distance      :=Succ(QueueBottom^.Distance); {distance after pushing a box in current position}

      Inc(Game.Board[BoxPosition],BOX); {put the box on the board}

      if  (BoxPosition<>LastBoxPosition) or
          (PlayersReachableSquares.Squares[Game.PlayerPos]<>PlayersReachableSquares.TimeStamp) then begin
          {the current set of player's reachable squares isn't valid anymore; recalculate the set}
          LastBoxPosition:=BoxPosition;
          CalculatePlayersReachableSquares(SEARCH_STATE_INDEX_DO_PUSH); {calculate player's reachable squares to see which sides of the box the player can reach}
          end;

      for Direction:=Low(Direction) to High(Direction) do begin
          BoxToSquare   :=BoxPosition+  Game.SquareOffsetForward[Direction];
          PlayerToSquare:=BoxPosition+2*Game.SquareOffsetForward[Direction];

          if (Distances[BoxToSquare,Direction]>Distance) and
             (PlayersReachableSquares.Squares[BoxToSquare]=PlayersReachableSquares.TimeStamp) and
             ((Game.Board[BoxToSquare   ] and (WALL+BOX+FLAG_ILLEGAL_BOX_SQUARE))=0) and
             ((Game.Board[PlayerToSquare] and (WALL+BOX                        ))=0) and
             {caution: the following check for the pusher painting itself into a corner assumes 4 directions only}
             ((not ( ((Game.Board[PlayerToSquare+Game.SquareOffsetForward[Direction]] and WALL)<>0)
                     and
                     ((Game.Board[PlayerToSquare+Game.SquareOffsetLeft   [Direction]] and WALL)<>0)
                     and
                     ((Game.Board[PlayerToSquare+Game.SquareOffsetRight  [Direction]] and WALL)<>0)
                   )
              )
              or
              (PlayerToSquare=StartPlayerPos)
             ) then begin
             Distances[BoxToSquare,Direction]:=Distance;
             Inc(QueueTop);
             QueueTop^.BoxPos   :=BoxToSquare;
             QueueTop^.PlayerPos:=PlayerToSquare;
             QueueTop^.Distance :=Distance;
             end;
          end;

      Dec(Game.Board[BoxPosition],BOX); {remove the box from the board again}
      end;

    for Square:=0 to BoardSize do begin
        Distances__[Square]:=INFINITY;
        if not IsAWallSquare(Square) then
           for Direction:=Low(Direction) to High(Direction) do
               Distances__[Square]:=Min(Distances__[Square],Distances[Square,Direction]);
        if (Distances__[Square]=INFINITY) and IsAFloorSquare(Square) and MarkIllegalBoxSquares__ then
           Board[Square]:=Board[Square] or FLAG_ILLEGAL_BOX_SQUARE; {mark unreachable squares as illegal squares}
        end;

    for BoxNo:=1 to Game.BoxCount do Inc(Board[BoxPos[BoxNo]],BOX); {put all boxes back on the board}
    PlayerPos:=OldPlayerPosition; {restore player position}
    end;
end; {CalculateDistanceToNearestGoalForAllSquares}

procedure CalculateBoxReachableSquaresForAllBoxes;
var Square:Integer; Distances:TBoardOfIntegers;
begin {note that the player's start position does matter, but otherwise each box is calculated individually with all other boxes removed from the board}
  with Game do begin
    CalculateDistanceToNearestBoxStartPositionForAllSquares(1,BoxCount,True,Distances);
    {ShowBoxDistanceToAllSquares(Distances); Readln;}

    for Square:=0 to BoardSize do {for each square...}
        if   Distances[Square]=INFINITY then
             Board[Square]:=Board[Square] and (not FLAG_BOX_REACHABLE_SQUARE)
        else Board[Square]:=Board[Square] or       FLAG_BOX_REACHABLE_SQUARE;

    {ShowBoxReachableSquaresForAllBoxes;}
    end;
end;

(* calculation of a player path optimizing moves only, i.e., no secondary optimization of player lines
function  CalculatePlayerPath(FromSquare__,ToSquare__:Integer; MakeMoves__:Boolean; var MoveCount__:Integer; var Moves__:TSingleStepMoves):Boolean;
var
  Square,FromSquare__,SuccessorDistance:Integer; QueueBottom,QueueTop:^Integer; Direction:TDirection;
  Distances,ParentSquares,QueueItems:TBoardOfIntegers; Directions:array[0..MAX_BOARD_SIZE] of TDirection;
begin
  FromSquare__:=Game.PlayerPos;
  for Square:=0 to Game.BoardSize do
      if   (Game.Board[Square] and (WALL+BOX))=0 then
           Distances[Square]:= INFINITY  {open squares}
      else Distances[Square]:=-INFINITY; {occupied squares, i.e., walls and boxes; a path length is always >= 0, so an occupied square with the value '-INFINITY' can never be on a best path}

  QueueBottom:=Addr(QueueItems[Low(QueueItems)]); QueueTop:=QueueBottom; {clear the queue for the breadth first search (BFS)}

  if Distances[FromSquare__]<>-INFINITY then begin {'True': 'from-position' is either an empty floor or the player's current position}
     Inc(QueueTop); QueueTop^:=FromSquare__; {put 'from-position' on the queue as the root position for the breadth-first search}
     Distances[FromSquare__]:=0; {the distance to the starting position is 0}
     end;

  {breadth first search (BFS), starting from 'from-position'; a FIFO (first-in-first-out) queue ensures that the reachable squares are visited in breadth-first order}
  while QueueBottom<>QueueTop do begin {while there are more un-expanded squares}
    Inc(QueueBottom); Square:=QueueBottom^; {advance to the next square on the queue}
    SuccessorDistance:=Succ(Distances[Square]); {if the best path to a neighbor square goes through 'Square' then the distance to the neighbor will be one higher than the distance to 'Square'}
    for Direction:=High(Direction) downto (Low(Direction)) do begin {try walking in each direction (the reverse order happens to produce better looking paths according to the writer's taste)}
        Inc(QueueTop); {prepare to put the neighbor square on the queue}
        QueueTop^:=Square+Game.SquareOffsetForward[Direction]; {tentatively put the neighbor square on the queue, no matter if it's a legal move or not}
        if   SuccessorDistance<Distances[QueueTop^] then begin {'True': the neighbor square isn't occupied by a wall or a box, and a best path to the neighbor square goes through the current square}
             Distances[QueueTop^]:=SuccessorDistance; {save the best-path distance to the neighbor square}
             ParentSquares[QueueTop^]:=Square; {save the parent square for the path construction in case the best path goes through the neighbor square}
             Directions[QueueTop^]:=Direction; {save the direction for this move}
             if QueueTop^=ToSquare__ then {'True': this is the target square; stop the search}
                QueueTop:=QueueBottom; {terminate the 'while' loop; the breadth-first search ensures that the first found path to the target square is optimal}
             end
        else Dec(QueueTop); {decrease the queue top pointer, thereby removing the neighbor square that tentatively was put on the queue}
        end;
    end;

  MoveCount__:=Abs(Distances[ToSquare__]); {return the number of moves on the best path, if any}
  Result:=MoveCount__<>INFINITY; {'True': there is a path from the start position to the target square; a legal 0-move path is returned if the start position and the target position are identical}

  if Result and MakeMoves__ then
     while ToSquare__<>FromSquare__ do begin {construct the path backwards from the target position to the starting position}
       Moves__[Distances[ToSquare__]].BoxNo:=0;
       Moves__[Distances[ToSquare__]].Direction:=Directions[ToSquare__];
       ToSquare__:=ParentSquares[ToSquare__]; {backtrack to the previous square on the best path}
       end;
end;
*)

function  CalculatePlayerPath(ToSquare__:Integer;
                              PreferredFinalDirection__:TDirection;
                              MakeMoves__:Boolean;
                              var MoveCount__,LineCount__:Integer;
                              var FinalDirection__:TDirection;
                              var Moves__:TSingleStepMoves):Boolean;
const BITS_PER_PLAYER_LINE_LENGTH=8; {each player line has this number of  bits to represent its length; precondition: remainder(BITS_PER_UNSIGNED_INTEGER div BITS_PER_PLAYER_LINE_LENGTH) = 0}
var   Distance,StopIndex,Square,NeighborSquare:Integer;
      LineCount,LineLength,NeighborLineCount,NeighborLineLength:UInt;
      NeighborTimeStamp,NextTimeStamp:TTimeStamp;
      Direction,LineDirection,NextLineDirection:TDirection;
      Directions:TDirectionSet;
      QueueBottom,QueueTop:^Integer; Queue:TBoardOfIntegers;
      LineCounts,LineLengths:TBoardOfUnsignedIntegers;
      ParentDirections:TBoardOfDirectionSets;
begin {Calculates a moves/lines optimal path from the current player position to the square 'ToSquare__', using the most recent player line lengths for tiebreaking}
      {Precondition: 'Solver.SearchStates[0]' is free to use}
  with Solver.SearchStates[0].PlayersReachableSquares do begin
    if TimeStamp>=High(TimeStamp)-MAX_BOARD_SIZE-100 then ClearPlayersReachableSquares(0); {'100' (and '50' in the next line): ensure that 'TimeStamp-1' cannot occur as a leftover from the previous calculation}
    TimeStamp:=(TimeStamp+Cardinal(Game.BoardSize)+50) and (not 1); {'not 1': enforce even parity for compatibility with 'CalculatePlayersReachableSquares'}
    Result:=False; Calculated:=True; MinPlayerPos:=Game.PlayerPos;
    {calculated square values: reachable empty floors = timestamp + distance + 1; reachable boxes = timestamp}

    if Game.PlayerPos<>0 then begin
       QueueBottom:=Addr(Queue[Low(Queue)]);
       QueueTop:=QueueBottom; Inc(QueueTop); QueueTop^:=Game.PlayerPos;

       Squares          [Game.PlayerPos]:=Succ(TimeStamp); {'Succ': the distance to a square S is 'Squares[S] - TimeStamp - 1'; this convention is practical because it makes room for tagging squares with reachable boxes with the value 'Timestamp'}
       LineCounts       [Game.PlayerPos]:=0;  {the number of lines (almost the same as turns) it takes to get to the square via a moves/lines optimal path}
       LineLengths      [Game.PlayerPos]:=0;
       ParentDirections [Game.PlayerPos]:=[];

       while QueueBottom<>QueueTop do begin
         Inc(QueueBottom);                                {advance to the next item on the queue}
         Square          :=QueueBottom^;                  {get next square from the queue}

         if Square<>ToSquare__ then begin                 {'True': this isn't the target square; the breadth-first search ensures that all paths to the target square have been explored at the time the target square is selected for expansion}
            NextTimeStamp   :=Succ(Squares     [Square]); {the next higher timestamp value, i.e., if the best path to a neighbor square goes through the current square, then this is the timestamp value for the neighbor square}
            Directions      :=ParentDirections [Square];  {directions from parent squares to the square currently being expanded}
            LineCount       :=LineCounts       [Square];  {the number of lines to get to this square via a moves/lines optimal path}
            LineLength      :=LineLengths      [Square];  {length of the most recent player lines on a moves/lines optimal path to this square}

            for Direction:=Low(Direction) to High(Direction) do begin {examine neighbors to this square}
                NeighborSquare:=Square+Game.SquareOffsetForward[Direction];
                if (Game.Board[NeighborSquare] and (WALL+BOX))=0 then begin {'True': the neighbor square in this direction doesn't contain a wall or a box}
                   NeighborTimeStamp:=Squares[NeighborSquare]; {the timestamp for the neighbor square}

                   if  NeighborTimestamp                                 <   Timestamp then begin {'True': this is the first time this neighbor square is visited}
                       Inc(QueueTop); QueueTop^                          := NeighborSquare; {put the neighbor square on the queue}
                       if NeighborSquare<MinPlayerPos then MinPlayerPos  := NeighborSquare; {update the normalized (top-left) player position}
                       Squares                          [NeighborSquare] := NextTimeStamp; {update the number of moves it takes to get to this neighbor square}
                       ParentDirections                 [NeighborSquare] := [Direction]; {the current direction is at the moment the only member of the set of directions leading to this neighbor square via a moves/lines optimal path}
                       if Direction                                      in Directions then begin {'True': the move is a continuation of an existing player player line}
                          LineCounts                    [NeighborSquare] := LineCount;
                          LineLengths                   [NeighborSquare] := Succ(LineLength);
                          end
                       else begin
                          LineCounts                    [NeighborSquare] := Succ(LineCount); {'Succ': it takes a turn to get to this neighbor square from the current parent square}
                          LineLengths                   [NeighborSquare] := Succ(LineLength shl BITS_PER_PLAYER_LINE_LENGTH); {'shl': each player line has 'BITS_PER_PLAYER_LINE_LENGTH' bits to represent its length}
                          end;
                       end
                    else
                       if   NeighborTimestamp                            =  NextTimestamp then begin {'True': this is a visit from another direction than the first one, but with the same number of moves}
                            if   Direction                               in Directions then begin {'True': the move is a continuation of an existing player player line}
                                 NeighborLineCount                       := LineCount;
                                 NeighborLineLength                      := Succ(LineLength);
                                 end
                            else begin
                                   NeighborLineCount                     := Succ(LineCount); {'Succ': it takes a turn to get to this neighbor square from the current parent square}
                                   NeighborLineLength                    := Succ(LineLength shl BITS_PER_PLAYER_LINE_LENGTH); {'shl': each player line has 'BITS_PER_PLAYER_LINE_LENGTH' bits to represent its length}
                                 end;
                            if   NeighborLineCount                       <  LineCounts[NeighborSquare] then begin {'True': this is a new best moves/lines path to this neighbor square}
                                 LineCounts             [NeighborSquare] := NeighborLineCount; {update the number of lines it takes to get to this neighbor square via a moves/lines optimal path}
                                 ParentDirections       [NeighborSquare] := [Direction]; {the current direction is at the moment the only member of the set of directions leading to this neighbor square via a moves/lines optimal path}
                                 LineLengths            [NeighborSquare] := NeighborLineLength;
                                 end
                            else if   NeighborLineCount                  =  LineCounts[NeighborSquare] then begin {'True': this is another moves/lines optimal path to this neighbor square}
                                      Include(ParentDirections[NeighborSquare],Direction); {update the set of directions from parent squares to this neighbor square via a moves optimal path}
                                      if LineLengths    [NeighborSquare] <  NeighborLineLength then {'True': the new path to the neighbor square has a better line length score}
                                         LineLengths    [NeighborSquare] := NeighborLineLength; {save the best line length score (for the most recent lines); it's used as a tiebreaker between equal moves/lines paths to a square}
                                      end;
                            end;
                   end;
                end;
            end
         else begin {this is the target square; update the return values and construct the path if it has been requested}
           QueueBottom:=QueueTop; {exit the 'while' loop, i.e., stop the search; the breadth-first search ensures that all paths to the target square have been explored at the time the target square is selected for expansion}

           Result          :=True; {'True': there is a path from the current player position to the target square}
           MoveCount__     :=Pred(Integer(Squares[Square]-TimeStamp)); {return the number of pushes it takes to get to the target square}
           LineCount__     :=LineCounts[Square]; {return the number of lines it takes to get to the target square}

           FinalDirection__:=PreferredFinalDirection__; {initialize the final direction}
           if   MakeMoves__ then {'True': create the path from the current player position to the target square}
                StopIndex  :=1 {backtrack all the way back to the first move}
           else StopIndex  :=MoveCount__; {only backtrack a single move in order to find the final player direction}

           {construct the path backwards from the target square to the starting position, using the parent square directions}
           LineDirection:=PreferredFinalDirection__;                                    {first check if there is a moves/lines optimal path ending with the specified final direction}
           for  Distance:=MoveCount__ downto StopIndex do begin
                NextLineDirection:=LineDirection;                                       {continue backtracking in the current direction if there is a moves/lines optimal path going through the neighbor square in this direction}

                if not (LineDirection in ParentDirections[ToSquare__]) then begin       {'True': the player changes direction}
                   LineLength:=0;                                                       {initialize the search for the parent square with the highest line length, i.e., the one with the longest preceding lines}
                   for Direction:=Low(Direction) to High(Direction) do                  {find the direction to a parent square on a best path to the current square}
                       if Direction in ParentDirections[ToSquare__] then begin          {'True': there is a parent square in this direction which belongs to an optimal moves/lines path to the current square}
                          Square:=ToSquare__-Game.SquareOffsetForward[Direction];
                          NeighborLineLength:=LineLengths[Square];
                          if not (Direction in ParentDirections[Square]) then           {'True': it requires a turn (on a moves/lines optimal path) to get from this neighbor square to the currently investigated square on the path}
                             NeighborLineLength:=NeighborLineLength shl BITS_PER_PLAYER_LINE_LENGTH; {'shl': for comparing line lengths, the extra turn to get from the neighbor square to the current square must be taken into account}
                          if LineLength<=NeighborLineLength then begin                  {'<=': not '<' because the starting position has line length = '0', and 'LineLength' is an unsigned integer which also was initialized to '0'}
                             LineLength:=NeighborLineLength;
                             NextLineDirection:=Direction;
                             end;
                          end;
                   if  (not (LineDirection in ParentDirections[ToSquare__])) and (Distance<>MoveCount__) then begin {'True': the current direction isn't a member of the optimal parent directions for the current square}
                       {check if it possible to continue in the current direction instead of making a turn now}
                       Square:=ToSquare__-Game.SquareOffsetForward[LineDirection];
                       NeighborTimestamp:=Pred(Squares[ToSquare__]);                    {timestamp for a neighboring square if there is a move-optimal to the current square via the neighbor square}
                       NeighborLineLength:=0;                                           {calculate the line length to the square next to the current square, moving on the line in the current direction, i.e., 'LineDirection'}
                       while (Squares[Square]=NeighborTimeStamp)                        {while the next square in this direction is on a move-optimal path to the current position ...}
                             and
                             (not (LineDirection in ParentDirections[Square])) do begin {... and while it requires a turn to reach the next square in this direction}
                             Dec(Square,Game.SquareOffsetForward[LineDirection]);       {backtrack to the next square in this direction}
                             Dec(NeighborTimeStamp);                                    {timestamp for a neighboring square if there is a move-optimal path to the current square via the neighbor square}
                             Inc(NeighborLineLength);                                   {calculate the line length to the square which is the neighbor of the current square on the path being produced}
                             end;
                       if    (Squares[Square]=NeighborTimeStamp)                        {'True': there is a move-optimal path via 'Square' which doesn't require a turn now, but if may not be moves/lines optimal}
                             and
                             (Pred(LineCounts[Square])=LineCounts[ToSquare__]) then begin {'True': there is a moves/lines optimal path which doesn't require a turn now; ('Pred': it saves one turn not making a turn now)}
                             {$IFDEF FPC}
                               NeighborLineLength:=NeighborLineLength+LineLengths[Square]; {in some versions of the FPC compiler, the built-in function 'Inc()' extends unsigned integers to long integers}
                             {$ELSE}
                               Inc(NeighborLineLength,LineLengths[Square]);             {calculate the line length to the square which is the neighbor of the current square on the path}
                             {$ENDIF}
                             if LineLength shl BITS_PER_PLAYER_LINE_LENGTH              {'shl': the best line length from the other directions stems from an 'n' lines path while this line length refers to an 'n+1' lines path on the forward path}
                                <=NeighborLineLength then begin                         {'<=': not '<' because the starting position has line length = '0', and 'LineLength' is an unsigned integer which also has been initialized to '0'}
                                NextLineDirection:=LineDirection;
                                end;
                             end;
                       end;
                   if  Distance=MoveCount__ then FinalDirection__:=NextLineDirection;   {update the final direction}
                   end;

                LineDirection:=NextLineDirection;                                       {update the current direction}
                Moves__[Distance].BoxNo:=0;
                Moves__[Distance].Direction:=LineDirection;                             {store the move direction before backtracking}
                Dec(ToSquare__,Game.SquareOffsetForward[LineDirection]);                {backtrack to the parent position given by the current direction; 'ToSquare__' now contains the previous square on the path}
                end;
           end;
         end;
       end;
    end;
end; {CalculatePlayerPath}

procedure ClearPlayersReachableSquares(Index__:Integer);
var i:Integer;
begin {a complete reset of the square timestamps is only necessary on initialization and when the timestamp overflows}
  with Solver.SearchStates[Index__].PlayersReachableSquares do begin
    TimeStamp:=0; Calculated:=False;
    //FillChar(Squares,SizeOf(Squares[0])*Succ(Game.BoardSize),0);
    for i:=0 to Game.BoardSize do
        if   (Game.Board[i] and WALL)=0 then Squares[i]:=0 {'True': the square is a floor, not a wall}
        else Squares[i]:=High(TimeStamp) and (not 1);      {marking walls with high-value makes the time-critical 'CalculatePlayersReachableSquares' more efficient because a single '<TimeStamp' test suffices for finding unvisited floor squares}
    end;
end;

(*
function  CanUsePlayersReachableSquaresFromPredecessor(PredecessorDepth__,BoxNo__:Integer; Direction__:TDirection):Boolean;
var BoxSquare,Mask:Integer; NeighborSquares:array[0..5] of Integer;
{
Legend:
|             : unspecified
_             : empty square
@             : player
$             : box
X             : non-empty square, i.e., a box or a wall
?             : a square that needs further analysis
1..4          : |@|   the 4 squares around the box; left-side = 1,3, right side = 2,4;
                1$2   when the numbers  are referred to in the figures below,
                3_4   they are empty squares
CONTINUE      : start with the player's currently reachable squares and continue calculation
COPY          : re-use the player's currently reachable squares, with small modifications
FULL          : full calculation required for finding the player's reachable squares
isReachable   : if TRUE, then the square is reachable before the push

The figures show the position BEFORE the box is pushed 1 square downwards

|@|      00: ____?
_$_      if isReachable(?) then FULL else CONTINUE
___
|?|

|@|      01: X___
X$_      if isReachable(3) then FULL else CONTINUE
3__


|@|      02: _X__
_$X      if isReachable(4) then FULL else CONTINUE
__4


|@|      03: XX__
X$X      if isReachable(3) then FULL else COPY
3__


|@|      04: __X_?
_$_      if isReachable(?) then FULL else CONTINUE
X__
|?|


|@|      05: X_X_?
X$_      if isReachable(?) then FULL else CONTINUE
X__
|?|


|@|      06: _XX_?
_$X      if isReachable(?) then FULL else CONTINUE
X__
|?|


|@|      07: XXX_?
X$X      if isReachable(?) then FULL else COPY
X__
|?|


|@|      08: ___X?
_$_      if isReachable(?) then FULL else CONTINUE
__X
|?|


|@|      09: X__X?
X$_      if isReachable(?) then FULL else CONTINUE
__X
|?|


|@|      10: _X_X?
_$X      if isReachable(?) then FULL else CONTINUE
__X
|?|


|@|      11: XX_X?
X$X      if isReachable(?) then FULL else COPY
__X
|?|


|@|      12: __XX
_$_      CONTINUE
X_X


|@|      13: X_XX
X$_      CONTINUE
X_X


|@|      14: _XXX
_$X      CONTINUE
X_X


|@|      15: XXXX
X$X      COPY
X_X

}
begin {CanUsePlayersReachableSquaresFromPredecessor}
  with Game do with Solver.SearchStates[PredecessorDepth__].PlayersReachableSquares do begin
    Result:=False; BoxSquare:=BoxPos[BoxNo__];
    NeighborSquares[3]:=BoxSquare+SquareOffsetRight[Direction__];
    NeighborSquares[4]:=BoxSquare+SquareOffsetLeft [Direction__];
    NeighborSquares[1]:=NeighborSquares[3]-SquareOffsetForward[Direction__];
    NeighborSquares[2]:=NeighborSquares[4]-SquareOffsetForward[Direction__];
    NeighborSquares[5]:=BoxSquare+SquareOffsetForward[Direction__]; // '5': the square in front of the box, using 'Direction__'

    Mask:=0;
    Inc(Mask,NonEmptySquareFlags[Board[NeighborSquares[1]] and (WALL+BOX)]);
    Inc(Mask,NonEmptySquareFlags[Board[NeighborSquares[2]] and (WALL+BOX)] shl 1);
    Inc(Mask,NonEmptySquareFlags[Board[NeighborSquares[3]] and (WALL+BOX)] shl 2);
    Inc(Mask,NonEmptySquareFlags[Board[NeighborSquares[4]] and (WALL+BOX)] shl 3);

    case Mask of
      00: Result:=False;
      01: Result:=False;
      02: Result:=False;
      03: Result:=False;
      04: Result:=False;
      05: Result:=False;
      06: Result:=False;
      07: Result:=False;
      08: Result:=False;
      09: Result:=False;
      10: Result:=False;
      11: Result:=False;
      12: Result:=False;
      13: Result:=False;
      14: Result:=False;
      15: Result:=False;
    end; // case


    end;
end; {CanUsePlayersReachableSquaresFromPredecessor}
*)

function  CanUsePlayersReachableSquaresFromPredecessor(PredecessorDepth__,BoxNo__:Integer; Direction__:TDirection):Boolean;
var BoxToSquare:Integer;
begin {CanUsePlayersReachableSquaresFromPredecessor}
  with Game do with Solver.SearchStates[PredecessorDepth__].PlayersReachableSquares do begin
    BoxToSquare:=BoxPos[BoxNo__]+SquareOffsetForward[Direction__];
    Result:=(((Board[BoxToSquare+SquareOffsetRight[Direction__]] and (WALL+BOX))<>0)
             and
             ((Board[BoxToSquare+SquareOffsetLeft [Direction__]] and (WALL+BOX))<>0)
            )
            or
            (Squares[BoxToSquare]<>TimeStamp); // '<>': in the current position, the player cannot reach the other side of the box
    end;
end; {CanUsePlayersReachableSquaresFromPredecessor}

function  CalculatePlayersDistanceToReachableSquares(Index__:Integer):Integer;
var Square,NeighborSquare,NeighborSquareTimeStamp:Integer; Direction:TDirection;
    QueueBottom,QueueTop:^Integer; Queue:array[0..MAX_BOARD_SIZE] of Integer;
begin {Returns player's distance to reachable squares in the global value 'Solver.SearchStates[Index__].PlayersReachableSquares'}
  with Solver.SearchStates[Index__].PlayersReachableSquares do begin
    if TimeStamp>=PLAYERS_REACHABLE_SQUARES_TIMESTAMP_UPPER_BOUND then ClearPlayersReachableSquares(Index__);
    TimeStamp:=(TimeStamp+Cardinal(Game.BoardSize)+4) and (not 1); {'not 1': enforce even parity for compatibility with 'CalculatePlayersReachableSquares'}
    Result:=0; Calculated:=True; MinPlayerPos:=Game.PlayerPos;
    {calculated square values: reachable empty floors = timestamp + distance + 1; reachable boxes = timestamp}

    if Game.PlayerPos<>0 then begin
       Result:=1;
       QueueBottom:=Addr(Queue[Low(Queue)]);
       QueueTop:=QueueBottom; Inc(QueueTop); QueueTop^:=Game.PlayerPos;
       Squares[Game.PlayerPos]:=Succ(TimeStamp);
       while QueueBottom<>QueueTop do begin
         Inc(QueueBottom); Square:=QueueBottom^; {get next square from the queue}
         NeighborSquareTimeStamp:=Succ(Squares[Square]); {the next higher timestamp value, i.e., if the best path to a neighbor square goes through the current square, then this is the timestamp value for the neighbor square}

         for Direction:=Low(Direction) to High(Direction) do begin {examine neighbors to this square}
             NeighborSquare:=Square+Game.SquareOffsetForward[Direction];
             if //(Board[NeighborSquare] and (WALL)=0) and {check for walls and visited squares}
                //(Squares[NeighborSquare]<>TimeStamp) then
                Squares[NeighborSquare]<TimeStamp then {'True': an unvisited floor, possibly with a box (walls contain high-value)}
                if (Game.Board[NeighborSquare] and BOX)=0 then begin {not a box}
                   Inc(Result); Inc(QueueTop); QueueTop^:=NeighborSquare;
                   Squares[NeighborSquare]:=NeighborSquareTimeStamp;
                   if NeighborSquare<MinPlayerPos then MinPlayerPos:=NeighborSquare; {update the normalized (top-left) player position}
                   end
                else {a neighbor box}
                   Squares[NeighborSquare]:=TimeStamp;
             end;
         end;
       end;
    end;
end; {CalculatePlayersDistanceToReachableSquares}

function  CalculatePlayersReachableSquares(Index__:Integer):Integer;
var {Index,}Square,NeighborSquare:Integer; Direction:TDirection;
    StackTop:^Integer; Stack:array[0..MAX_BOARD_SIZE] of Integer;
begin {Returns result in the global value 'Solver.SearchStates[Index__].PlayersReachableSquares'}
  with Solver.SearchStates[Index__].PlayersReachableSquares do begin
    if False and {'False': re-using the player's reachable squares isn't fully implemented, hence it's disabled here}
       UsePlayersReachableSquaresFromPredecessor and
       (Index__>Low(Solver.SearchStates)) then begin
       UsePlayersReachableSquaresFromPredecessor:=False;
       MinPlayerPos:=Min(Game.PlayerPos,Solver.SearchStates[Pred(Index__)].PlayersReachableSquares.MinPlayerPos);
       TimeStamp:=Solver.SearchStates[Pred(Index__)].PlayersReachableSquares.TimeStamp;
       System.Move(Pointer(Addr(Solver.SearchStates[Pred(Index__)].PlayersReachableSquares.Squares))^,Pointer(Addr(Squares))^,Succ(Game.BoardSize)*SizeOf(Squares[0]));

       if Game.PlayerPos<>0 then
          for Direction:=Low(Direction) to High(Direction) do begin {examine neighbors to the player position}
               NeighborSquare:=Game.PlayerPos+Game.SquareOffsetForward[Direction];
               if (Game.Board[NeighborSquare] and BOX)<>0 then {'True': a neighbor box: ensure that its square has the correct timestamp}
                  Squares[NeighborSquare]:=Succ(TimeStamp);
               end;
       end
    else begin
       if TimeStamp>=PLAYERS_REACHABLE_SQUARES_TIMESTAMP_UPPER_BOUND then ClearPlayersReachableSquares(Index__);
       Inc(TimeStamp,2); {reachable empty floors = timestamp; reachable boxes = timestamp + 1}
       end;

    Result:=0; Calculated:=True; MinPlayerPos:=Game.PlayerPos;

    if Game.PlayerPos<>0 then begin
       Result:=1; StackTop:=Addr(Stack[1]); StackTop^:=Game.PlayerPos;
       Squares[Game.PlayerPos]:=TimeStamp;
       while StackTop<>Addr(Stack[0]) do begin
         {the program spends most of its time in this loop;}
         {using an explicit stack makes the program run at least 10% faster}
         {than a version using recursion}
         Square:=StackTop^; Dec(StackTop); {get next square from the stack}
         for Direction:=Low(Direction) to High(Direction) do begin {examine neighbors to this square}
             NeighborSquare:=Square+Game.SquareOffsetForward[Direction];
             if //(Board[NeighborSquare] and (WALL)=0) and {check for walls and visited squares}
                //(Squares[NeighborSquare]<>TimeStamp) then
                Squares[NeighborSquare]<TimeStamp then begin {'True': an unvisited floor, possibly with a box (walls contain high-value)}
                if (Game.Board[NeighborSquare] and BOX)=0 then begin {not a box}
                   Inc(Result); Inc(StackTop); StackTop^:=NeighborSquare;
                   Squares[NeighborSquare]:=TimeStamp;
                   if NeighborSquare<MinPlayerPos then MinPlayerPos:=NeighborSquare; {update the normalized (top-left) player position}
                   end
                else {a neighbor box}
                   Squares[NeighborSquare]:=Succ(TimeStamp);
                end;
             end;
         end;
       end;
    end;
end; {CalculatePlayersReachableSquares}

function  CalculateReachableGoalsForAllSquares(var SquaresGoalSet__:TBoardOfGoalSets):Boolean;
var Count,GoalNo,Square:Integer; Direction:TDirection;
    Distances:TSquareDirectionArrayOfInteger;
begin {returns 'True' if the calculation runs to its completion; a time limit or the user may terminate the task during the calculation}
  with Game do begin
    FillChar(SquaresGoalSet__,SizeOf(SquaresGoalSet__),0);
    Count:=0;
    for GoalNo:=1 to GoalCount do
        if (Solver.SearchLimits.DepthLimit>=0) then begin {'True': the solver hasn't been terminated}
           Inc(Count);
           Square:=GoalPos[GoalNo];
           if (Board[Square] and (WALL+GOAL))=GOAL then begin {'True': the goal square hasn't been temporarily disabled}
              CalculateBoxPullOrPushDistances(Square,SEARCH_STATE_INDEX_DO_PUSH,False,False,False,Distances);
              for Square:=0 to BoardSize do
                  if (Board[Square] and WALL)=0 then
                     for Direction:=Low(Direction) to High(Direction) do
                         if Abs(Distances[Square,Direction])<>INFINITY then begin
                            Include(SquaresGoalSet__[Square],GoalNo);
                            break; {quick-and-dirty exit the 'for' loop when a path has been found from the square to the currently investigated goal}
                            end;
              TimeCheck; {the calculation of the reachable goals for each square can be a time consuming task if it's a large and open board; the task may be terminated by a time limit or by the user}
              end;
           end;
    Result:=Count=GoalCount; {'True': the calculation has run to its completion}
    end;
end;

procedure CalculateSquareGoalDistances(FirstGoalNo__,LastGoalNo__,DestinationOffset__:Integer;
                                       UsePackingOrder__:Boolean;
                                       var SquareGoalDistance__:TSquareGoalDistance;
                                       var GoalBoxSets__:TBoxGoalSets);
type TQueueItem=record BoxPos,PlayerPos,Distance:Integer; end;
var  BoxNo,GoalNo,Index,OldPlayerPosition,Square:Integer;
     Direction:TDirection;
     Distances:TSquareDirectionArrayOfInteger;

  procedure ShowSquareGoalDistance(GoalNo__:Integer; const SquareGoalDistance__:TSquareGoalDistance);
  var Col,Row,Square,Distance:Integer;
  begin
    Writeln('Goal: ',GoalNo__);
    with Game do
      for Row:=1 to BoardHeight do begin
          for Col:=1 to BoardWidth do begin
              Square:=ColRowToSquare(Col,Row);
              Distance:=SquareGoalDistance__[Square,DestinationOffset__+GoalNo__];
              if (Board[Square] and WALL)<>0 then
                 Write('#':3)
              else if   Distance>=High(SquareGoalDistance__[Square,GoalNo__]) then Write('_':3)
                   else Write(Distance:3);
              end;
          Writeln;
          end;
    Writeln; Readln;
  end;

begin {CalculateSquareGoalDistances}
  with Game do begin
    OldPlayerPosition:=PlayerPos;
    for BoxNo:=1 to Game.BoxCount do Dec(Board[BoxPos[BoxNo]],BOX); {remove all boxes from the board}
    for GoalNo:=FirstGoalNo__ to LastGoalNo__ do
        if Solver.SearchLimits.DepthLimit>=0 then begin {'True': the solver hasn't been terminated}

           if UsePackingOrder__ then with Solver.PackingOrder do begin {put the boxes on the board which will be filled according to the packing order at the time when 'GoalNo' should be filled}
              for Index:=1 to GoalCount do  {'GoalCount': only consider real goal squares, not parking squares because boxes at parking squares can move; that's the point in having parking spaces;}
                  if (GoalSetNo[Index] > GoalSetNo[GoalNo]) and
                     (ParkedBoxDestinationGoalSetNo[Index]<=GoalSetNo[GoalNo]) then
                     Board[GoalPos[Index]]:=Board[GoalPos[Index]] or BOX;
              for Index:=1 to GoalCount do {remove non-freezing boxes again, so the calculation finds all squares which possibly can be reached by pulling a box around on the board, starting from 'GoalNo'}
                  if ((Board[GoalPos[Index]] and BOX)<>0) and
                     (not IsAFreezingMove(0,GoalPos[Index],True )) then
                     Board[GoalPos[Index]]:=Board[GoalPos[Index]] and (not BOX);
              end;

           CalculateBoxPullOrPushDistances(GoalPos[GoalNo],SEARCH_STATE_INDEX_DO_PUSH,False,False,False,Distances);

           if UsePackingOrder__ then with Solver.PackingOrder do
              for Index:=1 to GoalAndParkingSquareCount do
                  Board[GoalPos[Index]]:=Board[GoalPos[Index]] and (not BOX);

           for Square:=0 to BoardSize do begin
               SquareGoalDistance__[Square,DestinationOffset__+GoalNo]:=
                 High(SquareGoalDistance__[Square,DestinationOffset__+GoalNo]); {'High': means no path from the square to the goal; note the difference between the defined integer constant 'INFINITY' and the byte-sized high value}
               if not IsAWallSquare(Square) then
                  for Direction:=Low(Direction) to High(Direction) do
                      if Abs(Distances[Square,Direction])<>INFINITY then
                         SquareGoalDistance__[Square,DestinationOffset__+GoalNo]:=
                           Min(SquareGoalDistance__[Square,DestinationOffset__+GoalNo],
                               Min(Distances[Square,Direction],
                                   High(SquareGoalDistance__[Square,DestinationOffset__+GoalNo])-1 {'High()-1': reserves 'High()' so it means 'unreachable'}
                                  )
                              );
               end;

           {calculate for each goal, the box starting positions that are reachable by pulling a box from the goal square to the box starting position, as if playing the game in reverse mode}
           with GoalBoxSets__[DestinationOffset__+GoalNo] do begin
             Count:=0; BoxSet:=[];
              for BoxNo:=1 to BoxCount do
                  if SquareGoalDistance__[StartBoxPos[BoxNo],DestinationOffset__+GoalNo]<
                     High(SquareGoalDistance__[StartBoxPos[BoxNo],DestinationOffset__+GoalNo]) then begin {'True': a box can be pulled from the goal 'GoalNo' to the box starting position with index 'BoxNo'}
                     Inc(Count); Include(BoxSet,BoxNo); {a box can be pulled from the goal 'GoalNo' to the box starting position 'BoxNo'}
                     end;
              end;

           TimeCheck; {the calculation of the reachable goals for each square can be a time consuming task if it's a large and open board; the task may be terminated by a time limit or by the user}
           end;

    for BoxNo:=1 to Game.BoxCount do Inc(Board[BoxPos[BoxNo]],BOX); {put all boxes back on the board}
    PlayerPos:=OldPlayerPosition; {restore player position}

{
    if UsePackingOrder__ then
       for GoalNo:=1 to GoalCount do ShowSquareGoalDistance(GoalNo,SquareGoalDistance__);
}
    end;
end; {CalculateSquareGoalDistances}

procedure ShowPlayersReachableSquaresB; {for test only}
var i,Col,Row:Integer;
begin
  Write('Player''s Reachable Squares (Col,Row): ');
  if CalculatePlayersReachableSquares(SEARCH_STATE_INDEX_DO_PUSH)>0 then
     with Solver.SearchStates[SEARCH_STATE_INDEX_DO_PUSH].PlayersReachableSquares do begin
       for i:=0 to Game.BoardSize do
           if Squares[i]=TimeStamp then begin
              SquareToColRow(i,Col,Row);
              Write(i,'=[',Col,',',Row,'] ');
              end;
       SquareToColRow(MinPlayerPos,Col,Row);
       Write(' Min: ',MinPlayerPos,'=[',Col,',',Row,']');
       end;
  Writeln;
end;

{=============================================================================}

{Deadlock Sets}

function  ShowDeadlockSetNumbers : Integer;
var Index, SquareNo : Integer;
begin
  Result := 0;
  for SquareNo := 0 to Game.BoardSize do with Game.DeadlockSets do
      if SquareSetCount[ SquareNo ] > 0 then begin
         Inc( Result );
         Write( SquareNo, ': ' );
         for Index := 1 to SquareSetCount[ SquareNo ] do // if SquareSetNumbers[ SquareNo ]^[ Index ] <= PrecalculatedSetsCount then
             Write( SquareSetNumbers[ SquareNo ]^[ Index ], SPACE );
         Writeln;
         end;
  Readln;
end;

function  CalculateDeadlockSets(Position__:PPosition; var DeadlockSetCandidate__:TDeadlockSetCandidate):Boolean;
  {'Position__' =  nil : precalculate deadlock sets (called once during level initialization);}
  {'Position__' <> nil : check if 'DeadlockSetCandidate__' is a valid deadlock set; 'Position__' is the current position in the search, in particular, it's 'PushCount' must contain the highest used index for 'CalculatePlayersReachableSquares'}

  {this somewhat awkward interface to the deadlock sets calculation}
  {is the result of the way the program has grown; first it handled}
  {precalculated deadlock sets only, and the support for dynamically}
  {adding more deadlock sets during the search was added later}

  {doing it this way makes it possible to keep many of the shared supporting}
  {functions local instead of promoting them to toplevel functions where they}
  {would require more parameter passing or a memory-consuming global deadlock}
  {set candidate ('TDeadlockSetCandidate')}

  {the function returns 'False' if the starting position is a deadlock}

{
Deadlock Sets

--------
Legend:
--------
# :	A wall
- :	A 'simple-illegal-box-square'.
	They are marked directly in the board squares because
	this is faster than using deadlock-sets.
% :	A square in the set, it may or may not be a goal square.
? :     A square in the set unless the square is a wall.
$ :     A box
. :     A goal square
* :     A box at a goal square
X :	A non-empty square
--------

Deadlock sets come in two flavors:

* the deadlock is independent of the player position

* it's only a deadlock if the player is outside the area fenced in by the
  boxes in the set

During the solver search, the second deadlock type uses two methods to detect
whether the player is inside or outside the fence:

* for some deadlocks and for some push directions, it can be deduced from the
  direction of the last push that the player is outside the fence

* when the direction of the last push isn't enough, a more thorough test is
  called for, calculating the player's reachable squares to check if the player
  can reach the stored inner square representative for the fenced-in area; this
  check is only possible for deadlocks where the fenced-in area consists of a
  single "pocket" only


--------
01              Non-goal corner
                ===============
 #              A non-goal corner square is an illegal square.
#-

--------
02              3-block
                =======
  #
 %%             At least one of the squares is not a goal-square.
#%

--------
03              4-Block/A
                =========
XX              Each 'X' is a non-empty square, and at least one
XX              of them is a box on a non-goal square. The non-wall
                squares in the block form a set.

--------
04              4-Block/B
                =========
 #              At least one of the squares is not a goal-square.
%%
#               The 'capacity' of a set is the number of boxes
                that can be added before the set overflows,
                hence, the capacity is calculated as:

                squares - 1 - number of boxes on the squares.

                This applies to all deadlock sets, except for
                type 08 and 09.

                4-block/B's are actually slightly more general
                than depicted: The '#''s aren't required, it
                suffices that the boxes can't move to any of
                these 2 neighbor squares.


--------
05              Double-L
                ========
??              The central floor square must be a non-goal square,
? ?             or each "L" (upper-left, down-right) must
 ??             contain at least one non-goal floor square.

--------
06              Blocked tunnel
                ==============
 #              The central floor square must be a non-goal square.
% %
%##

----------
07              Closed edge without goals
                =========================
 # ##~~# #      A closed edge is a line from which a box cannot
#----~~---#     escape. If there aren't any goals then all
  #     #       squares on the line are illegal.

---------
08              Closed edge with goals
                ======================
 # ##~~# #      The capacity of the set is the number of boxes
#%%%%~~%%%#     that can be added before the line overflows,
  #	#         hence, capacity = goals - boxes.

---------
09              Closed edges sharing a goal corner
                ==================================
 # ##~~~##      2 closed edges sharing a goal corner form
#%%%%~~%%%#     a union of the squares along the edges.
  #      %#     Capacity = goals - boxes.
         %#
         #

----------
10              Closed edge fence
                =================
 #%##~~#%#      The capacity and topology of the fence and the
#         #     enclosed floor squares must make it impossible
 %#%#~~%#%      to break the fence.

----------
11              Semi-closed line
                ================
(Example)
# % % % #       The line between two corner squares is
####%####       almost a closed edge; the gaps in the wall
                are only one square wide. The line and the
                filled holes in the wall must not contain
                any goals.

----------
12              1-square gate
                =============
#####           A single square splits the board in 2
#   #           separate rooms. The deadlock consists
# @ #           of 2 boxes where at least one of them
##%##           isn't a goal, and the last pushed box
# % #           must be the one that blocks the gate.
#   #
#####

#####           The second variant has the additional
#   #           constraint that the floor between the
# @ #           2 boxes is not a goal square, in other
##%##           words that the first variant is valid.
#   #
# % #
#   #
#####

#####           The third variant consists of 2 boxes
#   #           inside the room, next to the gate
#   #           square. At least one of the squares
##@##           is not a goal square.
# % #
# % #
#   #
#####

 #%#            In this fourth variant, the central
# % #           box does not split the board in 2
                separate rooms.


----------
13              1-way tunnel
                ============
#   #           A single square splits the board in 2
#   #           separate rooms. When the box enters
# @ #           the tunnel from one side, the tunnel
##%##           gets blocked. None of the squares
 # ###          in the tunnel may be goal squares.
 #   #
 #   #
 #####


----------
14              Frozen goals block access to other goals
                ========================================
(Example)
#######         Controller-set
#  %% #         At least one of the squares in the set is
#  ## #         a goal. The number of goals in the set is
                "G".

#######         Freeze-set
#*    #         All squares in the set are goals. If all
#  ## #         of them are filled, their boxes freeze
                and cannot move anymore. In that case it
                is a deadlock unless the squares in the
                controller-set contains at least "G"
                boxes.


----------
15              Frozen goals block paths from squares to goals
                ==============================================
(Example)
####            Example: the box "$" cannot reach the goal
#. #            square "." because of the frozen  box at the
#  #            the corner goal square "*".
# $##
#  *#
# # #
#   #
#   #
#####


----------
16              Overflow areas
                ==============
(Example)
#############   Boxes at the squares depicted by "%" and "*"
#######     #   cannot reach the goals depicted by ".". These
# %%%%%%%%%%#   squares form a deadlock set with capacity =
#     #%%%%*#   total number of goals - number of unreachable
#  .. # %%**#   goals (7 - 4 = 3 in this example).
#  .. #######
#############


----------
17              Fenced in area
                ==============
                A fenced in area is rooted in a corner square or
                the center of a 'double-L'. Using these sets as
                base, a generator builds new fenced in areas by
                moving and adding boxes one at a time, taking
                the level topology into account.


---------
18              Fence around the player in the starting position
                ================================================
(Example)
###             The boxes around the player's access area in the
#@$             starting position may be a deadlocked fence if
# $             only the player was outside the fence. This is
#$              not handled by the other pattern types, hence,
                this extra "pseudo-pattern".

}

  type TCornerType   =(ctTopLeft,ctTopRight,ctBottomLeft,ctBottomRight);
       TCornerTypeSet=set of TCornerType;
       TCorner       =record EdgeLengths:TDirectionArrayOfIntegers; SquareNo:Integer; Types:TCornerTypeSet;
                      end;
  var  i,j,CornerCount:Integer; TimeMS:TTimeMS;
       Corners:array[0..MAX_BOARD_SIZE] of TCorner;

    function  AddSquareToDeadlockSet(SquareNo__:Integer):Boolean; forward;
    function  CommitDeadlockSet(Search__,ExpandSet__,AcceptPseudoLegalSets__:Boolean; var StartPositionIsOK__:Boolean):Boolean; forward;
    function  TrySquare(SquareNo__:Integer; Direction__:TDirection):Boolean; forward;

    procedure CountBoxesAndGoalsAndPlayer(SquareNo__:Integer; var BoxCount__,GoalCount__,PlayerCount__:Integer);
    begin
      if (Game.Board[SquareNo__] and BOX   )<>0 then Inc(BoxCount__   );
      if (Game.Board[SquareNo__] and GOAL  )<>0 then Inc(GoalCount__  );
      if (Game.Board[SquareNo__] and PLAYER)<>0 then Inc(PlayerCount__);
    end;

    procedure InitializeSquareColors;
    var i:Integer;
    begin
      with DeadlockSetCandidate__ do begin
        PaintedFloorCount:=0;
        for i:=0 to Game.BoardSize do
            if   (Game.Board[i] and WALL)<>0 then SquareColors[i]:=scBlack
            else SquareColors[i]:=scWhite;
        end;
    end;

    function  CalculateNeighborsWithColor(SquareNo__:Integer; Color__:TSquareColor; LegalSquaresOnly__:Boolean):Integer;
    var Neighbor:Integer; Dir:TDirection;
    begin
      Result:=0;
      for Dir:=Low(Dir) to High(Dir) do begin
          Neighbor:=SquareNo__+Game.SquareOffsetForward[Dir];
          if  (DeadlockSetCandidate__.SquareColors[Neighbor]=Color__)
              and
              ((not LegalSquaresOnly__)
               or
               (IsALegalBoxSquare    (Neighbor) and
                IsABoxReachableSquare(Neighbor))
              ) then
              Inc(Result);
          end;
    end;

    function  TryBox(SquareNo__:Integer):Boolean;
    begin
      Result:=IsALegalBoxSquare     (SquareNo__) and
              IsABoxReachableSquare (SquareNo__) and
              AddSquareToDeadlockSet(SquareNo__);
      if Result then begin
         DeadlockSetCandidate__.SquareColors[SquareNo__]:=scDarkGray; {mark the square for containing a box}
         if not IsABoxSquare(SquareNo__) then Inc(DeadlockSetCandidate__.Capacity);
         end;
    end;

    procedure AddFloor(SquareNo__:Integer);
    begin {precondition: the square is not already a member of the deadlock set}
      DeadlockSetCandidate__.SquareColors[SquareNo__]:=scLightGray;
      Inc(DeadlockSetCandidate__.PaintedFloorCount);
      Inc(DeadlockSetCandidate__.Floors.Count);
      DeadlockSetCandidate__.Floors.Squares[DeadlockSetCandidate__.Floors.Count]:=SquareNo__;
      if (Game.Board[SquareNo__] and GOAL)<>0 then Inc(DeadlockSetCandidate__.GoalCount);
    end;

    function  TryFloor(SquareNo__:Integer):Boolean;
    var i,OldBoxCount,OldFloorCount,OldPaintedFloorCount,OldGoalCount,OldCapacity,OldSquareOutsideFence:Integer;
        OldDeadlockSetCandidateFlags:TDeadlockSetFlagsSet; Dir:TDirection;
    begin {tries to add a floor to the deadlock set}
      Result:=(DeadlockSetCandidate__.SquareColors[SquareNo__]=scWhite) and
              ((Game.Board[SquareNo__] and (PLAYER{+BOX+GOAL}))=0) and
              (DeadlockSetCandidate__.GoalCount<=Game.BoxCount);
      if Result then begin
         OldBoxCount:=DeadlockSetCandidate__.Boxes.Count;
         OldFloorCount:=DeadlockSetCandidate__.Floors.Count;
         OldPaintedFloorCount:=DeadlockSetCandidate__.PaintedFloorCount;
         OldGoalCount:=DeadlockSetCandidate__.GoalCount; OldCapacity:=DeadlockSetCandidate__.Capacity;
         OldDeadlockSetCandidateFlags:=DeadlockSetCandidate__.Flags;
         OldSquareOutsideFence:=DeadlockSetCandidate__.SquareOutsideFence;

         AddFloor(SquareNo__);

         for Dir:=Low(Dir) to High(Dir) do
             Result:=Result and TrySquare(SquareNo__+Game.SquareOffsetForward[Dir],Dir);

         if not Result then begin {undo added boxes and floors}
            for i:=Succ(OldBoxCount  ) to DeadlockSetCandidate__.Boxes .Count do DeadlockSetCandidate__.SquareColors[DeadlockSetCandidate__.Boxes .Squares[i]]:=scWhite;
            for i:=Succ(OldFloorCount) to DeadlockSetCandidate__.Floors.Count do DeadlockSetCandidate__.SquareColors[DeadlockSetCandidate__.Floors.Squares[i]]:=scWhite;
            DeadlockSetCandidate__.Boxes .Count      :=OldBoxCount;
            DeadlockSetCandidate__.Floors.Count      :=OldFloorCount;
            DeadlockSetCandidate__.PaintedFloorCount :=OldPaintedFloorCount;
            DeadlockSetCandidate__.GoalCount         :=OldGoalCount;
            DeadlockSetCandidate__.Capacity          :=OldCapacity;
            DeadlockSetCandidate__.Flags             :=OldDeadlockSetCandidateFlags;
            DeadlockSetCandidate__.SquareOutsideFence:=OldSquareOutsideFence;
            end;
         end;
    end;

    function  TrySquare(SquareNo__:Integer; Direction__:TDirection):Boolean;
    begin
      Result:=DeadlockSetCandidate__.SquareColors[SquareNo__]<>scWhite;         {non-white: square is already OK}
      if not Result then {white square, i.e., a non-visited square}
         case CalculateNeighborsWithColor(SquareNo__,scWhite,False) of

{$IFDEF LIGHTWEIGHT_DEADLOCK_GENERATION}
{   generates a reasonable number of deadlocks and works pretty fast.
}
           0   : Result:=TryFloor(SquareNo__) or TryBox  (SquareNo__);
           1   : Result:=TryFloor(SquareNo__) or TryBox  (SquareNo__);
           2   : Result:=(DeadlockSetCandidate__.SquareColors[SquareNo__+Game.SquareOffsetForward[Direction__]]=scWhite) {left or right adjacent square is blocked}
                         and
                         (TryBox(SquareNo__)
                          or
                          (
                           ((not IsALegalBoxSquare    (SquareNo__))
                            or
                            (not IsABoxReachableSquare(SquareNo__))
                           )
                           and
                           TryFloor(SquareNo__)
                          ));
           else  Result:=False;
{$ELSE}
{  generates deadlocks more thoroughly, but the exponential growth in
   the number of candidates can make the program useless.
}
           0   : Result:=TryBox  (SquareNo__) or TryFloor(SquareNo__);
           1   : Result:=TryBox  (SquareNo__) or TryFloor(SquareNo__);
           2   : Result:=((DeadlockSetCandidate__.SquareColors[SquareNo__+Game.SquareOffsetForward[Direction__]]=scWhite) {left or right adjacent square is blocked}
                          or
                          (
                           ((DeadlockSetCandidate__.SquareColors[SquareNo__+Game.SquareOffsetLeft[Direction__]]=scWhite)
                            and
                            TryBox(SquareNo__+Game.SquareOffsetLeft[Direction__])
                           )
                           or
                           ((DeadlockSetCandidate__.SquareColors[SquareNo__+Game.SquareOffsetRight[Direction__]]=scWhite)
                            and
                            TryBox(SquareNo__+Game.SquareOffsetRight[Direction__])
                           )
                          )
                         )
                         and
                         (TryBox(SquareNo__)
                          or
                          (
                           ((not IsALegalBoxSquare    (SquareNo__))
                            or
                            (not IsABoxReachableSquare(SquareNo__))
                           )
                           and
                           TryFloor(SquareNo__)
                          ));
           else  Result:=(TryBox(SquareNo__+Game.SquareOffsetLeft[Direction__])
                          or
                          TryBox(SquareNo__+Game.SquareOffsetRight[Direction__])
                         )
                         and
                         TrySquare(SquareNo__,Direction__);
{$ENDIF}
         end; {case}
    end;

    function  InitializeDeadlockSetCandidate(Capacity__,CenterSquare__,MaxBoxCount__{,EscapedBoxesCountDown__}:Integer):Boolean;
    begin
      Result:=Game.DeadlockSets.Count<MAX_DEADLOCK_SETS;
      if Result then begin
         DeadlockSetCandidate__.Capacity                 :=Capacity__;
         DeadlockSetCandidate__.CenterSquare             :=CenterSquare__;
         DeadlockSetCandidate__.EscapedBoxesCountDown    :=1; {EscapedBoxesCountDown__;}
         DeadlockSetCandidate__.Flags                    :=[];
         DeadlockSetCandidate__.MaxBoxCount              :=Min(MaxBoxCount__,Game.BoardSize);
         DeadlockSetCandidate__.Boxes.Count              :=0;
         DeadlockSetCandidate__.Floors.Count             :=0;
         DeadlockSetCandidate__.PaintedFloorCount        :=0;
         DeadlockSetCandidate__.GoalCount                :=0;
         DeadlockSetCandidate__.SquareOutsideFence       :=0;
         DeadlockSetCandidate__.SquaresOutsideFence.Count:=0;
         end
      else begin
         {$IFDEF CONSOLE_APPLICATION}
           if Position__=nil then Writeln('Note: Table full (deadlock sets); not all detected sets are in use.');
         {$ENDIF}
         DeadlockSetCandidate__.GoalCount:=Succ(Game.BoxCount); {mark current set as invalid}
         end;
    end;

    procedure DeleteDeadlockSet(SetNo__:Integer);
    var i,j,k,SquareNo,SquaresOutsideFenceItemCount:Integer;
    begin
      with Game.DeadlockSets do begin
        Dec(Count);
        if   SetNo__<=PrecalculatedSetsCount then Dec(PrecalculatedSetsCount)
        else Dec(DynamicSetsCount);
        if   (Flags[SetNo__]*[dsfPlayerMustBeOutsideSet,dsfControllerSet,dsfFreezeSet])=[dsfPlayerMustBeOutsideSet] then
             Dec(SessionPlayerMustBeOutsideSetCount);

        k:=SquaresOutsideFenceIndex[SetNo__];
        if k=0 then {'True': there are no squares outside the fence for this deadlock set}
           SquaresOutsideFenceItemCount:=0
        else begin {compress the 'squares outside fence' vector}
           SquaresOutsideFenceItemCount:=Succ(SquaresOutsideFence[k]); {'Succ': the number (n) of outside squares for the set in stored in the vector, and the squares (1..n) follow}
           Dec(SquaresOutsideFenceTop,SquaresOutsideFenceItemCount);
           for i:=SquaresOutsideFenceIndex[SetNo__] to SquaresOutsideFenceTop do
               SquaresOutsideFence   [i]:=SquaresOutsideFence[i+SquaresOutsideFenceItemCount];
           end;

        for  i:=SetNo__ to Count do begin {compress the deadlock sets table}
             Capacity                [i]:=Capacity                [Succ(i)];
             CenterSquare            [i]:=CenterSquare            [Succ(i)];
             Flags                   [i]:=Flags                   [Succ(i)];
             FloorCount              [i]:=FloorCount              [Succ(i)];
             HashKey                 [i]:=HashKey                 [Succ(i)];
             SequenceNumbers         [i]:=SequenceNumbers         [Succ(i)];
             SquaresCount            [i]:=SquaresCount            [Succ(i)];
             SquareOutsideFence      [i]:=SquareOutsideFence      [Succ(i)]; {for corral-type deadlocks, the most recent player position which has been proved to be outside the fence}
             SquaresOutsideFenceIndex[i]:=SquaresOutsideFenceIndex[Succ(i)];
             if SquaresOutsideFenceIndex[i]>0 then {'True': there are listed squares outside the fence for this deadlock}
                Dec(SquaresOutsideFenceIndex[i],SquaresOutsideFenceItemCount); {adjust the index into the vector after the squares belonging to the deleted deadlock set have been removed}
             end;

        for  SquareNo:=0 to Game.BoardSize do {for each square, remove the reference to the set, if any}
             for i:=SquareSetCount[SquareNo] downto 1 do begin
                 j:=SquareSetNumbers[SquareNo]^[i];
                 if   j=SetNo__ then begin {reference to the deleted set: remove it}
                      Dec(SquareSetCount[SquareNo]);
                      for k:=i to SquareSetCount[SquareNo] do
                          SquareSetNumbers  [SquareNo]^[k]:=
                            SquareSetNumbers[SquareNo]^[Succ(k)];
                      end
                 else if j>SetNo__ then {reference to a number above the removed set: decrease the number}
                         Dec(SquareSetNumbers[SquareNo]^[i]);
                 end;
        end;
    end; {DeleteDeadlockSet}

    function  EnsureSetNumbersCapacityForSquare( Capacity__, SquareNo__ : Integer ): Boolean;
    var OldByteSize, OldCapacity, NewByteSize : Integer;
    begin {returns 'True' if the square has at least the given capacity, possibly after reallocating the existing set numbers vector}
      with Game.DeadlockSets do begin
        if   SquareSetCount[ SquareNo__ ] > 0 then
             OldCapacity     := SquareSetNumbers[ SquareNo__ ]^[ 0 ]
        else OldCapacity     := 0;
        Result               := Capacity__ <= OldCapacity;
        if ( not Result ) and ( Capacity__ <= MAX_DEADLOCK_SETS_PER_SQUARE ) then begin
           Capacity__        := Min( MAX_DEADLOCK_SETS,
                                     Max( MIN_DEADLOCK_SETS_PER_SQUARE,
                                          Max( Capacity__,
                                               ( OldCapacity * 5 ) div 4 ) ) );
           if   OldCapacity  >  0 then
                OldByteSize  := Succ( OldCapacity ) * SizeOf( TDeadlockSetNo )
           else OldByteSize  := 0;
           NewByteSize       := Succ( Capacity__  ) * SizeOf( TDeadlockSetNo );
           Result            := TTReallocateMemoryBlock( Pointer( SquareSetNumbers[ SquareNo__ ] ), OldByteSize, NewByteSize ); {after the call, the new actual byte size is in 'OldByteSize'}
           if Result then
              SquareSetNumbers[ SquareNo__ ]^[ 0 ] := Pred( OldByteSize div SizeOf( TDeadlockSetNo ) ); {save the vector capacity in vector element 0}
           end;
        end;
    end;

    function  AddSquareToDeadlockSet(SquareNo__:Integer):Boolean;
    begin {precondition: no square is added more than once}
      Result:=(DeadlockSetCandidate__.Boxes.Count< DeadlockSetCandidate__.MaxBoxCount) and
              (DeadlockSetCandidate__.GoalCount  <=Game.BoxCount);
      if Result then begin
         //Result:= EnsureSetNumbersCapacityForSquare( Succ( Game.DeadlockSets.SquareSetCount[SquareNo__] ), SquareNo__ );
         if Result then begin
            Inc(DeadlockSetCandidate__.Boxes.Count);
            DeadlockSetCandidate__.Boxes.Squares[DeadlockSetCandidate__.Boxes.Count]:=SquareNo__; {save the square-numbers for 'CommitDeadlockSet'}
            if IsAGoalSquare(SquareNo__) then Inc(DeadlockSetCandidate__.GoalCount);
            end
         else begin
            {$IFDEF CONSOLE_APPLICATION}
              if Position__=nil then
                 Writeln('Note: Table full (squares in a deadlock set); not all detected sets are in use.');
            {$ENDIF}
            DeadlockSetCandidate__.GoalCount:=Succ(Game.BoxCount); {mark current set as invalid}
            end;
         end
      else
         DeadlockSetCandidate__.GoalCount:=Succ(Game.BoxCount); {mark current set as invalid}
    end;

    function  RemoveSquareFromDeadlockSet(SquareNo__:Integer):Boolean;
    var i,j:Integer;
    begin
      Result:=False;
      with DeadlockSetCandidate__ do
        for i:=Boxes.Count downto 1 do
            if (not Result) then
               if Boxes.Squares[i]=SquareNo__ then begin
                  Result:=True; Dec(Boxes.Count);
                  for j:=i to Boxes.Count do Boxes.Squares[j]:=Boxes.Squares[Succ(j)];
                  if IsAGoalSquare(SquareNo__) then Dec(DeadlockSetCandidate__.GoalCount);
                  end;
    end;

    function  CalculateDeadlockSetCandidateInfo(RejectIfGoalsAtBoxSquaresAndInnerFloorSquaresCanAccommodateTheBoxes__:Boolean):Boolean;
    {call parameter 'False': returns 'False' if all boxes are located at goal squares
     call parameter 'True ': returns 'False' if the number of boxes <= number of goals at box squares and inner floor squares
    }
    var i,BoxesAtGoalsCount,CenterSquareRoomSquareCount,SquareNo,Step:Integer;

      procedure VisitFloor(SquareNo__:Integer; FloodFill__:Boolean); {marks floor-squares surrounded by boxes and walls}
      var Direction:TDirection;
      begin
        if DeadlockSetCandidate__.SquareColors[SquareNo__]=scWhite then begin
           DeadlockSetCandidate__.SquareColors[SquareNo__]:=scLightGray; {light-grey: floor-squares inside the fence}
           Inc(DeadlockSetCandidate__.PaintedFloorCount);
           if  (Game.Board[SquareNo__] and GOAL  )<>0 then Inc(DeadlockSetCandidate__.GoalCount);
           if  (Game.Board[SquareNo__] and PLAYER)<>0 then Include(DeadlockSetCandidate__.Flags,dsfPlayerIsInsideSet);
           if  FloodFill__ then
               for Direction:=Low(Direction) to High(Direction) do
                   VisitFloor(SquareNo__+Game.SquareOffsetForward[Direction],True);
           end;
      end;

    begin {CalculateDeadlockSetCandidateInfo}
      {initialize square-colours, (re)calculate capacity and number of goals,}
      {and check if player in the start position is inside the deadlock set}
      InitializeSquareColors;
      DeadlockSetCandidate__.GoalCount:=0;

      if   DeadlockSetCandidate__.SquareOutsideFence>=0 then {'True': reset the existing value; this is the normal case where the square outside the fence only is calculated and valid during the call to 'CommitDeadlockSet'}
           DeadlockSetCandidate__.SquareOutsideFence:=0
      else DeadlockSetCandidate__.SquareOutsideFence:=Abs(DeadlockSetCandidate__.SquareOutsideFence); {use the existing absolute value}
      if   DeadlockSetCandidate__.SquaresOutsideFence.Count>=0 then {'True': reset the existing value; this is the normal case where squares outside a fenced-in area only are calculated and valid during the call to 'CommitDeadlockSet'}
           DeadlockSetCandidate__.SquaresOutsideFence.Count:=0
      else DeadlockSetCandidate__.SquaresOutsideFence.Count:=Abs(DeadlockSetCandidate__.SquaresOutsideFence.Count); {use the existing absolute value, and the stored square numbers in 'DeadlockSetCandidate__.SquaresOutsideFence.Squares'}

      if   DeadlockSetCandidate__.CenterSquare<>0 then {'True': only recalculate capacity for sets with a central floor square}
           DeadlockSetCandidate__.Capacity:=Pred(DeadlockSetCandidate__.Boxes.Count);

      for  i:=1 to DeadlockSetCandidate__.Boxes.Count do begin
           SquareNo:=DeadlockSetCandidate__.Boxes.Squares[i];
           DeadlockSetCandidate__.SquareColors[SquareNo]:=scDarkGray; {dark-grey: mark box-squares}
           if (DeadlockSetCandidate__.CenterSquare<>0) and IsABoxSquare(SquareNo) then
              Dec(DeadlockSetCandidate__.Capacity);
           if IsAGoalSquare  (SquareNo) then Inc(DeadlockSetCandidate__.GoalCount);
           if IsAPlayerSquare(SquareNo) then Include(DeadlockSetCandidate__.Flags,dsfPlayerIsInsideSet); {it's necessary to assume the player starts inside the set in this situation}
           end;

      BoxesAtGoalsCount:=DeadlockSetCandidate__.GoalCount;

      VisitFloor(DeadlockSetCandidate__.CenterSquare,not (dsfHasOnlyListedFloors in DeadlockSetCandidate__.Flags));
      CenterSquareRoomSquareCount:=DeadlockSetCandidate__.PaintedFloorCount;
      if   not (dsfHasOnlyListedFloors in DeadlockSetCandidate__.Flags) then
           for i:=1 to DeadlockSetCandidate__.Floors.Count do VisitFloor(DeadlockSetCandidate__.Floors.Squares[i],True)
      else for i:=1 to DeadlockSetCandidate__.Floors.Count do VisitFloor(DeadlockSetCandidate__.Floors.Squares[i],False);

      if dsfDiagonalCenterSquares in DeadlockSetCandidate__.Flags then with DeadlockSetCandidate__ do begin
         {precondition: the center square is a corner}
         if        SquareColors[Pred(CenterSquare)]=scBlack then
                   if   SquareColors[Succ(CenterSquare)]<>scBlack then {'True': the center square hasn't walls both left and right}
                        if   SquareColors[CenterSquare+Game.BoardWidth+2]=scBlack then
                             Step:=Game.BoardWidth+2+1 {"\" diagonal}
                        else Step:=Game.BoardWidth+2-1 {"/" diagonal}
                   else Step:=0 {not enough information to indentify which diagonal to use; drop the extra internal floors and treat them as external floors}
         else if   SquareColors[Succ(CenterSquare)]=scBlack then
                   if   SquareColors[CenterSquare+Game.BoardWidth+2]=scBlack then
                        Step:=Game.BoardWidth+2-1 {"/" diagonal}
                   else Step:=Game.BoardWidth+2+1 {"\" diagonal}
              else Step:=0;
         SquareNo:=CenterSquare+Step;
         while SquareColors[SquareNo]=scWhite do begin
               VisitFloor(SquareNo,True); Inc(SquareNo,Step);
               end;
         end;

      Exclude(DeadlockSetCandidate__.Flags,dsfHasDisconnectedInnerFloors);
      Exclude(DeadlockSetCandidate__.Flags,dsfHasUnspecifiedInnerFloors); {the caller is expected to pass all inner floor squares, or raising this flag later, e.g., see 'LoadCandidateFromSet()'}
      if        DeadlockSetCandidate__.CenterSquare<>0 then begin
                if CenterSquareRoomSquareCount<>DeadlockSetCandidate__.PaintedFloorCount then {'True': some inner floor squares don't belong to the room with the center square}
                   Include(DeadlockSetCandidate__.Flags,dsfHasDisconnectedInnerFloors);
                end
      else if   dsfIsANoProgressDeadlockCandidate in DeadlockSetCandidate__.Flags then
                for SquareNo := 0 to Game.BoardSize do
                    if DeadlockSetCandidate__.SquareColors[ SquareNo ] =  scWhite then
                       DeadlockSetCandidate__.SquareColors[ SquareNo ] := scLightGray; {a "no progress" deadlock encompasses the entire board when the deadlock candidate hasn't a center square, i.e., when its isn't a corral-type deadlock candidate}

      if        (DeadlockSetCandidate__.Flags*[dsfControllerSet,dsfIsADeadlock,dsfFreezeSet,dsfIsANoProgressDeadlockCandidate])<>[] then {'True': the calculated deadlock set information is valid; this doesn't imply that the candidate really is a deadlock}
                Result:=True
      else if   DeadlockSetCandidate__.PaintedFloorCount+DeadlockSetCandidate__.Boxes.Count<Game.FloorCount then {'True': the candidate doesn't encompass the entire board}
                if   BoxesAtGoalsCount<DeadlockSetCandidate__.Boxes.Count then {'True': some boxes are not located at goal squares}
                     if   RejectIfGoalsAtBoxSquaresAndInnerFloorSquaresCanAccommodateTheBoxes__ then
                          {there is not necessarily any further validation of the deadlock candidate; in order to guarantee correctness, reject it if its box squares and inner floor squares contain enough goals to accommodate all the boxes}
                          Result:=DeadlockSetCandidate__.GoalCount<DeadlockSetCandidate__.Boxes.Count {'True': the box squares + inner floor squares contains fewer goal squares than than the number of boxes in the candidate set}
                     else Result:=True // return 'True' and leave it to 'Search()' to check whether the candidate is legal
                else      Result:=False {all boxes are located at goal squares}
           else Result:=False; {the deadlock set candidate encompass the entire board; this is normally caused by a fence-type deadlock candidate where the fence is broken from the beginning}
    end; {CalculateDeadlockSetCandidateInfo}

    procedure LoadCandidateFromSet(SetNo__:Integer);
    var i,j:Integer;
    begin  {copies set to 'DeadlockSetCandidate__'}
      with Game.DeadlockSets do begin
        DeadlockSetCandidate__.Capacity                 :=Capacity    [SetNo__];
        DeadlockSetCandidate__.CenterSquare             :=CenterSquare[SetNo__];
        DeadlockSetCandidate__.Flags                    :=Flags       [SetNo__];
        DeadlockSetCandidate__.Boxes.Count              :=0;
        DeadlockSetCandidate__.Floors.Count             :=0; {*not* Game.DeadlockSets.FloorCount[SetNo__]}
        DeadlockSetCandidate__.GoalCount                :=0;
        DeadlockSetCandidate__.SquareOutsideFence       :=0;
        DeadlockSetCandidate__.SquaresOutsideFence.Count:=0;

        for i:=0 to Game.BoardSize do
            for j:=1 to SquareSetCount[i] do
                if SquareSetNumbers[i]^[j]=SetNo__ then begin
                   Inc(DeadlockSetCandidate__.Boxes.Count);
                   DeadlockSetCandidate__.Boxes.Squares[DeadlockSetCandidate__.Boxes.Count]:=i;
                   end;

        CalculateDeadlockSetCandidateInfo(False);

        DeadlockSetCandidate__.SquareOutsideFence:=SquareOutsideFence[SetNo__]; {'CalculateDeadlockSetCandidateInfo' resets the outer square, hence, it must be loaded here after the calculation}
        if SquaresOutsideFenceIndex[SetNo__]>0 then begin {'CalculateDeadlockSetCandidateInfo' resets the outer squares, hence, they must be loaded here after the calculation}
           j:=SquaresOutsideFenceIndex[SetNo__];
           DeadlockSetCandidate__.SquaresOutsideFence.Count:=SquaresOutsideFence[j];
           for i:=1 to DeadlockSetCandidate__.SquaresOutsideFence.Count do
               DeadlockSetCandidate__.SquaresOutsideFence.Squares[i]:=SquaresOutsideFence[i+j];
           end;

        if FloorCount[SetNo__]<>DeadlockSetCandidate__.PaintedFloorCount then begin
           {some inner floors aren't connected to the central square;}
           {therefore, derived deadlocksets cannot depend on the player}
           {being outside the set (a calculation that requires all inner floors)}
           Include(DeadlockSetCandidate__.Flags,dsfHasDisconnectedInnerFloors);
           Include(DeadlockSetCandidate__.Flags,dsfHasUnspecifiedInnerFloors);
           end;
        end;
    end; {LoadCandidateFromSet}

    function  IsARedundantDeadlockSet(SetNo__:Integer):Boolean;
    var i,j,SetNo,SquareNo,CommonSquaresCount:Integer;
    begin
      Result:=False;
      if ((SetNo__<>0) and (Game.DeadlockSets     .CenterSquare[SetNo__]<>0))
         or
         ((SetNo__= 0) and (DeadlockSetCandidate__.CenterSquare         <>0)) then with Game.DeadlockSets do begin
         if SetNo__<>0 then LoadCandidateFromSet(SetNo__);
         for SetNo:=1 to Count do
             if (CenterSquare[SetNo]<>0) and (SetNo<>SetNo__) then begin
                CommonSquaresCount:=0;
                for i:=1 to DeadlockSetCandidate__.Boxes.Count do begin {for each square in the new set}
                    SquareNo:=DeadlockSetCandidate__.Boxes.Squares[i];
                    for j:=1 to Game.DeadlockSets.SquareSetCount[SquareNo] do {for each set having this square as a member}
                        if SquareSetNumbers[SquareNo]^[j]=SetNo then
                           Inc(CommonSquaresCount);
                    end;
                if (CommonSquaresCount=SquaresCount[SetNo])
                   and
                   (
                    ((SetNo__<>0)
                     and
                     ((Flags[SetNo__]              -[dsfPlayerIsInsideSet])=(Flags[SetNo]-[dsfPlayerIsInsideSet]))
                    )
                    or
                    ((SetNo__=0)
                     and
                     ((DeadlockSetCandidate__.Flags-[dsfPlayerIsInsideSet])=(Flags[SetNo]-[dsfPlayerIsInsideSet]))
                    )
                   )
                   then begin
                   Result:=True; break;
                   end;
                end;
         end;
    end; {IsARedundantDeadlockSet}

    function  ExpandDeadlockSet(BoxIndex__:Integer; ExpandSet__,AcceptPseudoLegalSets__:Boolean; var ParentDeadlockSetNo__:Integer; var StartPositionIsOK__:Boolean):Boolean;
    var i,ExtraBoxSquareNo,
        OldBoxCount,OldCapacity,OldFloorCount,OldGoalCount,OldPaintedFloorCount,OldSquareOutsideFence,
        NeighborSquareNo,SquareNo,WhiteNeighborCount:Integer;
        Direction:TDirection;
        OldDeadlockSetCandidateFlags:TDeadlockSetFlagsSet;

      function  ExpandDeadlockSet__:Boolean;
      var i,BoxOnIllegalSquareIndex:Integer;
      begin {ExpandDeadlockSet.ExpandDeadlockSet__}
        BoxOnIllegalSquareIndex:=0;
        if   DeadlockSetCandidate__.CenterSquare<>0 then
             for i:=1 to DeadlockSetCandidate__.Boxes.Count do
                 if not (IsALegalBoxSquare(DeadlockSetCandidate__.Boxes.Squares[i]) and
                         IsABoxReachableSquare(DeadlockSetCandidate__.Boxes.Squares[i])
                        ) then begin {simple illegal squares}
                    BoxOnIllegalSquareIndex:=i; break;
                    end;

        if   BoxOnIllegalSquareIndex=0 then begin
             Result:=CommitDeadlockSet(True,ExpandSet__,AcceptPseudoLegalSets__,StartPositionIsOK__); {commit new set}
             if Result and (WhiteNeighborCount=0) and {'0': the deadlock set is the result of deleting a box inside a fenced-in area}
                (ParentDeadlockSetNo__>0) and
                (Game.DeadlockSets.Flags[ParentDeadlockSetNo__]=Game.DeadlockSets.Flags[Game.DeadlockSets.Count]) then begin
                {the box at 'SquareNo' could be deleted and still produce a deadlock situation, hence, the parent deadlock set is redundant}
                //ShowDeadlockSet(ParentDeadlockSetNo__,Game.DeadlockSets.CenterSquare[ParentDeadlockSetNo__]);
                if LogFile.Enabled then begin
                   WritelnToLogFile('');
                   WritelnToLogFile('Deadlock set '+IntToStr(Game.DeadlockSets.SequenceNumbers[ParentDeadlockSetNo__])+' is redundant. Active deadlock sets: '+IntToStr(Game.DeadlockSets.Count));
                   end;
                if True {'True': delete all redundant deadlocks, including deadlocks created dynamically during the search}
                   or
                   (Position__=nil)
                   or
                   (not (dsfPlayerMustBeOutSideSet in Game.DeadlockSets.Flags[Game.DeadlockSets.Count]))
                   then begin
                   DeleteDeadlockSet(ParentDeadlockSetNo__); Inc(Game.DeadlockSets.RedundantSetsCount);
                   ParentDeadlockSetNo__:=-ParentDeadlockSetNo__; {mark that the parent deadlock set has disappeared}
                   end
                else begin
                   {redundant deadlocks created dynamically during the search are
                    not deleted if they depend on the player being outside the
                    set;
                    there may be existing game positions which only can be
                    recognized as deadlocks if all the boxes are present;
                    otherwise, the number of inner floors (inside the fenced-in
                    area) stored for each deadlock cannot contribute to detecting
                    whether the player is inside or outside the set;
                   }
                   end;
                end;
             end
        else Result:=ExpandDeadlockSet(BoxOnIllegalSquareIndex,
                                       ExpandSet__,AcceptPseudoLegalSets__,ParentDeadlockSetNo__,StartPositionIsOK__); {try to get the box away from the illegal square}
      end; {ExpandDeadlockSet.ExpandDeadlockSet__}

      function  TryToAddExtraBox(SquareNo__,ExtraBoxSquareNo__:Integer):Boolean;
      begin {ExpandDeadlockSet.TryToAddExtraBox}
        Inc(DeadlockSetCandidate__.Boxes.Count);
        DeadlockSetCandidate__.Boxes.Squares[DeadlockSetCandidate__.Boxes.Count]:=ExtraBoxSquareNo__;
        if not IsABoxSquare (ExtraBoxSquareNo__) then Inc(DeadlockSetCandidate__.Capacity);
        if     IsAGoalSquare(ExtraBoxSquareNo__) then Inc(DeadlockSetCandidate__.GoalCount);
        DeadlockSetCandidate__.SquareColors[ExtraBoxSquareNo__]:=scDarkGray;

        Result:=TryFloor(SquareNo__) and ExpandDeadlockSet__;

        Dec(DeadlockSetCandidate__.Boxes.Count);
        if not IsABoxSquare (ExtraBoxSquareNo__) then Dec(DeadlockSetCandidate__.Capacity);
        if     IsAGoalSquare(ExtraBoxSquareNo__) then Dec(DeadlockSetCandidate__.GoalCount);
        DeadlockSetCandidate__.SquareColors[ExtraBoxSquareNo__]:=scWhite;
      end; {ExpandDeadlockSet.TryToAddExtraBox}

    begin {'ExpandDeadlockSet'}
          {in : 'ParentDeadlockSetNo__<>0': the current candidate set gave rise to a deadlock set; if the number if positive it still exists;}
          {out: 'ParentDeadlockSetNo__< 0': the original parent deadlock set has been deleted because it has been superseded by a new one where a redundant box has been removed}
{
      if (ParentDeadlockSetNo__>0) and (Game.DeadlockSets.SequenceNo[ParentDeadlockSetNo__]=248) then begin
         ShowBoard;
         end;
}
      if not (dsfIsANoProgressDeadlockCandidate in DeadlockSetCandidate__.Flags) then begin
         Result:=(DeadlockSetCandidate__.CenterSquare<>0) and
                 (DeadlockSetCandidate__.Boxes.Count<=DeadlockSetCandidate__.MaxBoxCount);
         if Result then begin
            if   BoxIndex__>0 then
                 SquareNo:=DeadlockSetCandidate__.Boxes.Squares[BoxIndex__]
            else SquareNo:=DeadlockSetCandidate__.CenterSquare; {special: try to find a fenced-in area around the square number currently registered as 'CenterSquare'}

            WhiteNeighborCount:=CalculateNeighborsWithColor(SquareNo,scWhite,False);

            if ((WhiteNeighborCount>0)
                and
                (Position__= nil)
                and
                (WhiteNeighborCount<=Game.DeadlockSets.AdjacentOpenSquaresLimit) {'True': the box is a part of the fence around the corral, the number of outer neighbors doesn't exceed the limit, and it's a precalculated deadlock}
                {'AdjacentOpenSquaresLimit': should preferably be '1';}
                {allowing 2 or 3 outside neighbors finds more deadlock sets, but it}
                {can easily take too much time}
                and
                (Solver.SearchLimits.DepthLimit>=0)) {'>=0': the search hasn't been terminated}
               or
               ((WhiteNeighborCount=0)
                and
                (Position__<>nil)
                and
                (ParentDeadlockSetNo__<>0)
                and
                ((CalculateNeighborsWithColor(SquareNo,scDarkGray,False)=0)        {'True': an isolated box inside the corral}
                 or
                 (CalculateNeighborsWithColor(SquareNo,scLightGray,False)=DIRECTION_COUNT-1) {'True': a box inside the corral with a single neighbor box, and where all the other neighbor squares are empty}
                ) {'True': the box is isolated inside the corral; test if the box can be omitted}
               ) then begin
               if BoxIndex__>0 then begin
                  Dec(DeadlockSetCandidate__.Boxes.Count); {remove the box from the candidate set}
                  for i:=BoxIndex__ to DeadlockSetCandidate__.Boxes.Count do
                      DeadlockSetCandidate__.Boxes.Squares[i]:=DeadlockSetCandidate__.Boxes.Squares[Succ(i)];
                  end;
               DeadlockSetCandidate__.SquareColors[SquareNo]:=scWhite;
               {save current set data}
               OldBoxCount:=DeadlockSetCandidate__.Boxes.Count;
               OldFloorCount:=DeadlockSetCandidate__.Floors.Count;
               OldPaintedFloorCount:=DeadlockSetCandidate__.PaintedFloorCount;
               OldGoalCount:=DeadlockSetCandidate__.GoalCount;
               OldCapacity:=DeadlockSetCandidate__.Capacity;
               OldDeadlockSetCandidateFlags:=DeadlockSetCandidate__.Flags;
               OldSquareOutsideFence:=DeadlockSetCandidate__.SquareOutsideFence;

               DeadlockSetCandidate__.Flags:=OldDeadlockSetCandidateFlags * [dsfDiagonalCenterSquares,dsfPlayerIsInsideSet,dsfHasDisconnectedInnerFloors,dsfHasUnspecifiedInnerFloors];

               if BoxIndex__>0 then begin
                  if not IsABoxSquare (SquareNo) then Dec(DeadlockSetCandidate__.Capacity);
                  if     IsAGoalSquare(SquareNo) then Dec(DeadlockSetCandidate__.GoalCount);
                  end;

               Result:=TryFloor(SquareNo); {try to fence-in this square}

               if Result then
                  Result:=ExpandDeadlockSet__
               else
                  if (WhiteNeighborCount=1) and
                     (Game.DeadlockSets.AdjacentOpenSquaresLimit=1) and
                     (DeadlockSetCandidate__.CenterSquare<>0) and
                     (DeadlockSetCandidate__.Boxes.Count<DeadlockSetCandidate__.MaxBoxCount) then
                     {try to find additional deadlocks by adding an extra box to close a gap;
                      example:
                      ####
                      %  % <- the rightmost "%" is the box square, having 1 white (outside) floor neighbor
                      ####

                      ####
                      %   % <- moving the rightmost box one square to the right has failed creating a new deadlock; (the 'Result:=TryFloor()' statement above
                      ####

                      ####% <- put an extra box here;
                      %   % <- when the rightmost box is moved to the right, to the depicted square, the creation of a new deadlock succeeds unless it violates some other contraints, such as search depth
                      ####
                     }
                     for Direction:=Low(Direction) to High(Direction) do begin
                         NeighborSquareNo:=SquareNo+Game.SquareOffsetForward[Direction];
                         if DeadlockSetCandidate__.SquareColors[NeighborSquareNo]=scWhite then begin
                            if IsALegalAndBoxReachableSquare(NeighborSquareNo) then begin
                               {try to add a box to the left}
                               ExtraBoxSquareNo:=NeighborSquareNo+Game.SquareOffsetLeft[Direction]; {caution: assumes 4 directions only}
                               if (DeadlockSetCandidate__.SquareColors[ExtraBoxSquareNo]=scWhite)
                                  and
                                  IsALegalAndBoxReachableSquare(ExtraBoxSquareNo)
                                  and
                                  TryToAddExtraBox(SquareNo,ExtraBoxSquareNo)
                                  then
                                  Result:=True;
                               {try to add a box to the right}
                               ExtraBoxSquareNo:=NeighborSquareNo+Game.SquareOffsetRight[Direction]; {caution: assumes 4 directions only}
                               if (DeadlockSetCandidate__.SquareColors[ExtraBoxSquareNo]=scWhite)
                                  and
                                  IsALegalAndBoxReachableSquare(ExtraBoxSquareNo)
                                  and
                                  TryToAddExtraBox(SquareNo,ExtraBoxSquareNo)
                                  then
                                  Result:=True;
                               end;
                            break; {quick-and-dirty exit the 'for each direction' loop as soon as the outside empty floor square has been found}
                            end;
                         end;

               {restore current set}
               for i:=Succ(OldBoxCount  ) to DeadlockSetCandidate__.Boxes .Count do DeadlockSetCandidate__.SquareColors[DeadlockSetCandidate__.Boxes .Squares[i]]:=scWhite;
               for i:=Succ(OldFloorCount) to DeadlockSetCandidate__.Floors.Count do DeadlockSetCandidate__.SquareColors[DeadlockSetCandidate__.Floors.Squares[i]]:=scWhite;
               DeadlockSetCandidate__.Boxes .Count      :=OldBoxCount;
               DeadlockSetCandidate__.Floors.Count      :=OldFloorCount;
               DeadlockSetCandidate__.PaintedFloorCount :=OldPaintedFloorCount;
               DeadlockSetCandidate__.GoalCount         :=OldGoalCount;
               DeadlockSetCandidate__.Capacity          :=OldCapacity;
               DeadlockSetCandidate__.Flags             :=OldDeadlockSetCandidateFlags;
               DeadlockSetCandidate__.SquareOutsideFence:=OldSquareOutsideFence;

               if BoxIndex__>0 then begin
                  Inc(DeadlockSetCandidate__.Boxes.Count); {put the box back into the current set}
                  for i:=DeadlockSetCandidate__.Boxes.Count downto Succ(BoxIndex__) do
                      DeadlockSetCandidate__.Boxes.Squares[i]:=DeadlockSetCandidate__.Boxes.Squares[Pred(i)];
                  DeadlockSetCandidate__.Boxes.Squares[BoxIndex__]:=SquareNo;
                  end;

               for i:=1 to DeadlockSetCandidate__.Boxes.Count do
                   DeadlockSetCandidate__.SquareColors[DeadlockSetCandidate__.Boxes.Squares[i]]:=scDarkGray;
               end;
            end;
         end
      else begin {a no-progress deadlock set candidate; check if the box is redundant, i.e., if the deadlock candidate set still is a deadlock if the box is omitted}
         Result:=DeadlockSetCandidate__.Boxes.Count>=MIN_NO_PROGRESS_DEADLOCK_SET_CANDIDATE_BOX_COUNT;
         if Result then begin
            SquareNo:=DeadlockSetCandidate__.Boxes.Squares[BoxIndex__];

            Dec(DeadlockSetCandidate__.Boxes.Count); {remove the box from the candidate set}
            for i:=BoxIndex__ to DeadlockSetCandidate__.Boxes.Count do
                DeadlockSetCandidate__.Boxes.Squares[i]:=DeadlockSetCandidate__.Boxes.Squares[Succ(i)];
            DeadlockSetCandidate__.SquareColors[SquareNo]:=scWhite;
            {save current set data}
            OldBoxCount:=DeadlockSetCandidate__.Boxes.Count;
            OldFloorCount:=DeadlockSetCandidate__.Floors.Count;
            OldPaintedFloorCount:=DeadlockSetCandidate__.PaintedFloorCount;
            OldGoalCount:=DeadlockSetCandidate__.GoalCount;
            OldCapacity:=DeadlockSetCandidate__.Capacity;
            OldDeadlockSetCandidateFlags:=DeadlockSetCandidate__.Flags;
            OldSquareOutsideFence:=DeadlockSetCandidate__.SquareOutsideFence;

            DeadlockSetCandidate__.Flags:=OldDeadlockSetCandidateFlags * [dsfDiagonalCenterSquares,dsfPlayerIsInsideSet,dsfHasDisconnectedInnerFloors,dsfHasUnspecifiedInnerFloors,dsfIsANoProgressDeadlockCandidate];
            if IsAGoalSquare(SquareNo) then Dec(DeadlockSetCandidate__.GoalCount);

            Result:=ExpandDeadlockSet__;
{
            if Result then begin
               Game.ShowDeadlockSetsEnabled:=True;
               ShowDeadlockSet(Game.DeadlockSets.Count,Game.DeadlockSets.CenterSquare[Game.DeadlockSets.Count]);
               Game.ShowDeadlockSetsEnabled:=False;
               Write('No-progress deadlock');
               Readln;
               end;
}
            {restore current set}
            for i:=Succ(OldBoxCount  ) to DeadlockSetCandidate__.Boxes .Count do DeadlockSetCandidate__.SquareColors[DeadlockSetCandidate__.Boxes .Squares[i]]:=scWhite;
            for i:=Succ(OldFloorCount) to DeadlockSetCandidate__.Floors.Count do DeadlockSetCandidate__.SquareColors[DeadlockSetCandidate__.Floors.Squares[i]]:=scWhite;
            DeadlockSetCandidate__.Boxes .Count      :=OldBoxCount;
            DeadlockSetCandidate__.Floors.Count      :=OldFloorCount;
            DeadlockSetCandidate__.PaintedFloorCount :=OldPaintedFloorCount;
            DeadlockSetCandidate__.GoalCount         :=OldGoalCount;
            DeadlockSetCandidate__.Capacity          :=OldCapacity;
            DeadlockSetCandidate__.Flags             :=OldDeadlockSetCandidateFlags;
            DeadlockSetCandidate__.SquareOutsideFence:=OldSquareOutsideFence;

            Inc(DeadlockSetCandidate__.Boxes.Count); {put the box back into the current set}
            for i:=DeadlockSetCandidate__.Boxes.Count downto Succ(BoxIndex__) do
                DeadlockSetCandidate__.Boxes.Squares[i]:=DeadlockSetCandidate__.Boxes.Squares[Pred(i)];
            DeadlockSetCandidate__.Boxes.Squares[BoxIndex__]:=SquareNo;

            for i:=1 to DeadlockSetCandidate__.Boxes.Count do
                DeadlockSetCandidate__.SquareColors[DeadlockSetCandidate__.Boxes.Squares[i]]:=scDarkGray;
            end;
         end;
    end; {ExpandDeadlockSet}

    function  CommitDeadlockSet(Search__,ExpandSet__,AcceptPseudoLegalSets__:Boolean; var StartPositionIsOK__:Boolean):Boolean;
    var //OldEscapedBoxesCountDown,
        i,j,SquareNo,NewDeadlockSetNo:Integer;
        IsALegalSetButViolatesCapacityConstraints,TableOverflow:Boolean;
        HashKey:THashValue; BoxSquares:TBoardSquareSet;

      function  CheckSimpleDeadlocks:Boolean;
      var i:Integer;

        function  IsAFrozenSquare ( SquareNo__ : Integer ) : Boolean;
        var ABoxIsBlockedOnANonGoalSquare : Boolean;

          function  BoxIsBlockedAlongOneAxis( SquareNo__ : Integer; Direction__ : TDirection;
                                                var ABoxIsBlockedOnANonGoalSquare__ : Boolean):Boolean;
          var Neighbor1, Neighbor2, Neighbor1Position , Neighbor2Position : Integer;
          begin
            if   Direction__       = Low(Direction__) then           {flip horizontal/vertical direction}
                 Direction__      := Succ ( Low ( Direction__ ) )    {caution: 'Succ(Low...'): assumes 4 directions only}
            else Direction__      := Low ( Direction__ );

            Neighbor1Position     := SquareNo__ - Game.SquareOffsetForward[ Direction__ ];
            Neighbor1             := Game.Board [ Neighbor1Position ];

            Neighbor2Position     := SquareNo__ + Game.SquareOffsetForward[ Direction__ ];
            Neighbor2             := Game.Board [ Neighbor2Position ];

            Inc ( Game.Board [ SquareNo__ ] , WALL);                 {temporarily change this square to a wall}

            Result := ((  Neighbor1 and WALL           ) <> 0 )      {is there a wall on any of the neighbor squares?}
                      or
                      ((  Neighbor2 and WALL           ) <> 0 )
                      or
                      ((( Neighbor1 and FLAG_ILLEGAL_BOX_SQUARE ) <> 0 )        {are both neighbors illegal squares?}
                       and
                       (( Neighbor2 and FLAG_ILLEGAL_BOX_SQUARE ) <> 0 )
                      );

            if (not ( Result and ABoxIsBlockedOnANonGoalSquare__ ))  {it's not enough to know whether a box is blocked; it's also necessary to know whether a box is blocked on a non-goal square}
               and
               (( Neighbor1 and ( WALL + BOX ) ) = BOX )             {test is neighbor1 is a blocked box}
               and
               BoxIsBlockedAlongOneAxis( Neighbor1Position , Direction__ , ABoxIsBlockedOnANonGoalSquare__ )
               then Result := True;

            if (not ( Result and ABoxIsBlockedOnANonGoalSquare__ ))  {it's not enough to know whether a box is blocked; it's also necessary to know whether a box is blocked on a non-goal square}
               and
               (( Neighbor2 and ( WALL + BOX ) ) = BOX )             {test is neighbor2 is a blocked box}
               and
               BoxIsBlockedAlongOneAxis( Neighbor2Position , Direction__ , ABoxIsBlockedOnANonGoalSquare__ )
               then Result:=True;

            Dec ( Game.Board [ SquareNo__ ] , WALL );                {remove the wall again}

            if  Result and                                           {if this box is blocked}
                ( ( Game.Board [ SquareNo__ ] and GOAL ) = 0 ) then  {and it's not a goal-square}
                ABoxIsBlockedOnANonGoalSquare__ := True;             {then set the flag}

            end; {BoxIsBlockedAlongOneAxis}

        begin {IsAFrozenSquare}
          ABoxIsBlockedOnANonGoalSquare := False;

          Result := (( Game.Board [ SquareNo__ ] and ( WALL + FLAG_ILLEGAL_BOX_SQUARE ) ) <> 0 )   {a wall is considered a deadlocked square}
                    or
                    (not IsABoxReachableSquare(SquareNo__))
                    or
                    (//( not ReverseMode ) and
                     BoxIsBlockedAlongOneAxis( SquareNo__ , Low(        TDirection )   , ABoxIsBlockedOnANonGoalSquare )
                     and
                     BoxIsBlockedAlongOneAxis( SquareNo__ , Succ( Low ( TDirection ) ) , ABoxIsBlockedOnANonGoalSquare ) {caution: 'Succ(Low...'): assumes 4 directions only}
                     and
                     ABoxIsBlockedOnANonGoalSquare
                    );
        end; {IsAFrozenSquare}

      begin {CheckSimpleDeadlocks}
        Result:=True;

        for i:=1 to Game.DeadlockSets.Count do with Game.DeadlockSets do        {check if the candidate set violates existing deadlock-sets}
            if   Result then
                 Result:=(Capacity[i]>=0)
                         or
                         ((Flags[i]*[dsfPlayerIsInsideSet,dsfPlayerMustBeOutsideSet,dsfControllerSet,dsfFreezeSet])<>[])
            else break;

        if  ((DeadlockSetCandidate__.CenterSquare<>0) or (DeadlockSetCandidate__.Floors.Count<>0)) then
            for i:=1 to DeadlockSetCandidate__.Boxes.Count do
                if   Result then
                     Result:=(not IsAFrozenSquare(DeadlockSetCandidate__.Boxes.Squares[i])) {simple freeze-type deadlocks are handled here by code instead of sets}
                else break;
      end; {CheckSimpleDeadlocks}

      function  CheckDeadlockSetCandidate(var IsALegalSetButViolatesCapacityConstraints__:Boolean):Boolean;
      const
        MAX_BOX_COUNT_FOR_TRANSPOSITION_TABLE_POSITIONS = 5; {reserve the transposition table for positions with few boxes; there are more likely to be subsets of other box constellations}
        NORMAL_DEADLOCK_SEARCH_DEPTH = 20; {search depth used by all deadlock candidates except "no-progress" candidates, which uses the maximum search depth}
      type
        TCheckType             = (ctCheckPushes,ctCheckPulls,ctCheckPullsPaintThePlayerIntoACorner);
        TTranspositionTableItemTimeStamp = Byte; {only byte-sized, for fast initialization}
      var
        i,j,BoxesOnBoardCount,GameBoxCount,GamePlayerPos,NeighborSquare,Square:Integer;
        //S : String;
        Direction:TDirection;
        PushesFromTheOutsideOnlyDirectionSet:TDirectionSet;
        GameBoxPos:TBoxSquares;
        TranspositionTableTimeStamp  : TTranspositionTableItemTimeStamp;
        TranspositionTableTimeStamps : array[ Low( TDeadlockSearchTranspositionTable ) .. High( TDeadlockSearchTranspositionTable ) ] of TTranspositionTableItemTimeStamp; {timestamp for each item in the transposition table}

        function  CalculateOutsideOnlyPushDirections(var PushesFromTheOutsideOnlyDirectionSet__:TDirectionSet; var SquaresOutsideFence__:TBoardSquareSet):Boolean;
        var BoxNo,NeighborSquareNo,{SquareIndex,}SquareNo:Integer; Direction{,d}:TDirection;
            PushesFromTheOutsideDirectionSet:TDirectionSet;
            SquaresOutsideFenceForEachDirection:TDirectionArrayOfIntegers;
            {SquareSet:TBoardSquareSet;}
        begin
          PushesFromTheOutsideOnlyDirectionSet__:=ALL_DIRECTIONS_SET;
          PushesFromTheOutsideDirectionSet:=[];
          FillChar(SquaresOutsideFenceForEachDirection,SizeOf(SquaresOutsideFenceForEachDirection),0);
          for BoxNo:=1 to Game.BoxCount do begin
              SquareNo:=Game.BoxPos[BoxNo];
              for Direction:=Low(Direction) to High(Direction) do begin
                  NeighborSquareNo:=SquareNo+Game.SquareOffsetForward[Direction];
                  if ((Game.Board[NeighborSquareNo]                                     and (WALL+BOX+FLOOR))=FLOOR)
                     and
                     ((Game.Board[NeighborSquareNo+Game.SquareOffsetForward[Direction]] and (WALL+BOX+FLOOR))=FLOOR) then begin
                     {the box can be pulled away, i.e., the position can occur}
                     {after pushing the box in the opposite direction}
                     if (DeadlockSetCandidate__.SquareColors[NeighborSquareNo]=scLightGray) then {with SquareSet do} begin
                        {the neighbor square is an empty floor inside the set}

                        if (OPPOSITE_DIRECTION[Direction] in PushesFromTheOutsideOnlyDirectionSet__) {'True': the opposite direction still has a chance to be a member of the set}
                           and
                           (
                            (CalculateNeighborsWithColor(NeighborSquareNo+Game.SquareOffsetForward[Direction],scLightGray,False)>1)
                            {'>1': pulling the box doesn't fence in the player}
                            or
                            (NeighborSquareNo+Game.SquareOffsetForward[Direction]=GamePlayerPos)
                            {'=' after pulling the box, the player is located at its starting position}
                           ) then
                           {pushing the box in the opposite direction cannot be guaranteed}
                           {to have the player outside the set}
                           Exclude(PushesFromTheOutsideOnlyDirectionSet__,OPPOSITE_DIRECTION[Direction]);
                        end
                     else begin
                        {the neighbor square is an empty floor outside the set;}
                        {remember the legal push-directions from the outside}
                        Include(PushesFromTheOutsideDirectionSet,OPPOSITE_DIRECTION[Direction]);
                        SquaresOutsideFenceForEachDirection[Direction]:=NeighborSquareNo; {remember there is a square outside the fence in this direction}
                        end;
                     end;
                  end;
              end;

          PushesFromTheOutsideOnlyDirectionSet__ := PushesFromTheOutsideOnlyDirectionSet__ * PushesFromTheOutsideDirectionSet; { '*': intersects the guaranteed outside-directions and the possible outside-directions}
          Result:=PushesFromTheOutsideOnlyDirectionSet__<>[];

          {if one or more boxes have neighboring floor squares outside the fence
           which aren't covered by the push directions guaranteed to be pushes
           from the outside, then return these neighboring floor squares in
           'SquaresOutsideFence__'
          }

          SquaresOutsideFence__.Count:=0;
          for Direction:=Low(Direction) to High(Direction) do begin
              SquareNo:=SquaresOutsideFenceForEachDirection[Direction];
              if (SquareNo<>0) and
                 (not (OPPOSITE_DIRECTION[Direction] in PushesFromTheOutsideOnlyDirectionSet__)) and
                 (SquaresOutsideFence__.Count<High(SquaresOutsideFence__.Squares)) then begin
                 SquaresOutsideFence__.Squares[Succ(SquaresOutSideFence__.Count)]:=SquareNo; {tentatively add the outer square to the end of the list (as a sentinel)}
                 i:=0; {locate the square in the list; it may already be a member}
                 repeat Inc(i);
                 until  SquaresOutsideFence__.Squares[i]=SquareNo;
                 if     i>SquaresOutsideFence__.Count then SquaresOutsideFence__.Count:=i; {'True': the square wasn't a member of the list; make it a member be increasing the list member count}
                 end;
              end;
        end; {CalculateOutsideOnlyPushDirections}

        procedure ClearBoard; {remove boxes and player from the board}
        var i,j,SquareNo:Integer;
        begin
          for i:=1 to Game.BoxCount do with Game.DeadlockSets do begin
              SquareNo:=Game.BoxPos[i];
              if SquareNo<>0 then begin {'True': the box hasn't been removed from the board by the caller}
                 Dec(Game.Board[SquareNo],BOX); {remove the box from the board}
                 for j:=1 to SquareSetCount[SquareNo] do Inc(Capacity[SquareSetNumbers[SquareNo]^[j]]); {update deadlock set capacities}
                 end;
              end;
          Game.BoxCount:=0; MovePlayer(0); Game.HashValue:=0; Game.SimpleLowerBound:=0;
          BoxesOnBoardCount := 0;
        end;

        procedure InitializeBoard; {update board and deadlock capacities, using 'Game.BoxPos' and 'Game.PlayerPos'}
        var i,j,SquareNo:Integer;
        begin
          BoxesOnBoardCount := 0;
          for i:=1 to Game.BoxCount do with Game.DeadlockSets do begin
              SquareNo:=Game.BoxPos[i];
              if SquareNo<>0 then begin {'True': the box hasn't been removed from the board by the caller}
                 Inc(Game.Board[SquareNo],BOX); {put the box on the board}
                 for j:=1 to SquareSetCount[SquareNo] do Dec(Capacity[SquareSetNumbers[SquareNo]^[j]]); {update deadlock set capacities}
                 Inc( BoxesOnBoardCount );
                 end;
              end;
          MovePlayer(Game.PlayerPos);
          Game.SimpleLowerBound:=CalculateSimpleLowerBound;
          Game.HashValue:=CalculateHashValue;
        end;

        function  Check(CheckType__:TCheckType; var SquareOutsideFence__:Integer):Boolean;
        {the deadlock candidate is invalid in 4 cases:}
        {1: if the player starting from the outside can push a box to a square outside the set;   }
        {2: if the player starting from the inside can escape the fenced-in area by pulling boxes;}
        {   (in this case, the candidate position could arise after pushing the boxes from a      }
        {    position where the player started from outside the fenced-in area)                   }
        {3: if the player in the game starting position is inside the fenced-in area and any of   }
        {   the boxes can be pulled, meaning the candidate position could arise after a push;     }
        {4: pushing boxes from the outside or pulling boxes from the inside leads to a position   }
        {   where all boxes are located at goal-positions;                                        }
        const PLAYER_START_SQUARE_COLORS:array[TCheckType] of TSquareColor =(scWhite,scLightGray,scWhite); {'white': outside floor; 'light gray': inner floor}
              SMALL_PLAYER_ACCESS_AREA_LIMIT=8;
        var   i,j,BackJumpDepth,DepthOffset,MaximumSearchDepth,
              PlayerReachableSquaresCount,PlayerOutsideFenceReachableSquaresCount:Integer;
              Frontier:TBoardSquareSet;

          procedure InitializeTranspositionTable;
          begin
            if TranspositionTableTimeStamp = High( TranspositionTableTimeStamp ) then begin {'True': wrap around; reset all table items}
               FillChar( TranspositionTableTimeStamps, SizeOf( TranspositionTableTimeStamps ), 0 );
               TranspositionTableTimeStamp := 0;
               end;
            Inc( TranspositionTableTimeStamp ); {advance to next timestamp}
          end;

          procedure CalculateFrontierSquares;
          var i,SquareNo:Integer; Dir:TDirection;
          begin  {finds exterior floor squares (white squares) adjacent to the boxes}
            Frontier.Count:=0;
            for i:=1 to DeadlockSetCandidate__.Boxes.Count do
                for Dir:=Low(Dir) to High(Dir) do begin
                    SquareNo:=DeadlockSetCandidate__.Boxes.Squares[i]+Game.SquareOffsetForward[Dir];
                    if DeadlockSetCandidate__.SquareColors[SquareNo]=scWhite then begin
                       Inc(Frontier.Count); Frontier.Squares[Frontier.Count]:=SquareNo;
                       DeadlockSetCandidate__.SquareColors[SquareNo]:=scLightGray; {temporarily mark the square as visited}
                       end;
                    end;
            for i:=1 to Frontier.Count do
                DeadlockSetCandidate__.SquareColors[Frontier.Squares[i]]:=scWhite; {reset colors to white, i.e., an outside square}
          end;

          function  PlayerHasAccessToAnOuterSquare(Depth__:Integer):Boolean;
          {this function belongs inside the following 'Search()' function,
           but that exceeds the maximum nesting level for (some versions of)
           the FPC Pascal compiler;
          }
          var i:Integer;
          begin {precondition: player's reachable squares have been calculated}
            Result:=False;
            for i:=1 to Frontier.Count do
                if   not Result then with Solver.SearchStates[Depth__].PlayersReachableSquares do
                     Result:=Squares[Frontier.Squares[i]]=TimeStamp
                else break;
          end;

          function  PlayerHasAccessToAnInnerSquare(Depth__:Integer):Boolean;
          {this function belongs inside the following 'Search()' function,
           but that exceeds the maximum nesting level for the FPC Pascal
           compiler;
          }
          var i:Integer;
          begin {precondition: player's reachable squares have been calculated}
            Result:=False;
            for i:=1 to DeadlockSetCandidate__.Boxes.Count do
                if   not Result then with Solver.SearchStates[Depth__].PlayersReachableSquares do
                     Result:=Squares[DeadlockSetCandidate__.Boxes.Squares[i]]=TimeStamp
                else break;
          end;

          function  Search(Depth__:Integer; var BackJumpDepth__:Integer):Boolean;
          var i,j,BoxNo,BoxToSquareNo,LastPushedBoxNo,SquareNo,StartCandidatePushCount,SuccessorDepth:Integer;
              Direction:TDirection;

            function  IsADuplicatePosition(Depth__,PlayerPos__:Integer):Boolean;
            var i,j,k:Integer;
            begin {protects against loops in the depth-first search by comparing the current position with all positions along the current path;
                   additionally, a little forward checking is performed by consulting the transposition table with known deadlocks;}
              Result:=False;
              for i:=1 to Pred(Depth__) do {search through the positions on the path leading to the current position}
                  if not Result then begin
                     Result:=(PlayerPos__      =Game.DeadlockSets.History[i].PlayerPos) and
                             (Game.HashValue   =Game.DeadlockSets.History[i].HashValue);
                     {a hash-value is not 100% safe, hence, the exact game state must match}
                     for j:=1 to Game.BoxCount do begin {try to match each box}
                         if   Result then
                              if Game.BoxPos[j]<>Game.DeadlockSets.History[i].BoxPos[j] then begin {'<>': no simple match; try harder}
                                 Result:=False;
                                 for k:=1 to Game.BoxCount do {search for another box at the same position as Box[j]}
                                     if   not Result then
                                          Result:=Game.BoxPos[j]=Game.DeadlockSets.History[i].BoxPos[k]
                                     else break; {done, i.e., there is another box at the same position as Box[j]}
                                 end
                              else {Box[j] found at the same index in the table, or it has been removed from the board}
                         else break; {fail, i.e., not a duplicate position}
                         end;
                     end
                  else break; {done, i.e., found a duplicate position}

               {check if the position is one of the deadlock positions registered in the transposition table}
               if ( not Result ) then begin
                  i := Game.HashValue and High( Game.DeadlockSets.TranspositionTable );
                  with Game.DeadlockSets.TranspositionTable[ i ] do begin
                       Result:=(PlayerPos__      =PlayerPos) and
                               (Game.HashValue   =HashValue) and
                               ( TranspositionTableTimeStamp = TranspositionTableTimeStamps[ i ] );
                       {a hash-value is not 100% safe, hence, the exact game state must match}
                       for j:=1 to Game.BoxCount do begin {try to match each box}
                           if   Result then
                                if Game.BoxPos[j]<>BoxPos[j] then begin {'<>': no simple match; try harder}
                                   Result:=False;
                                   for k:=1 to Game.BoxCount do {search for another box at the same position as Box[j]}
                                       if   not Result then
                                            Result:=Game.BoxPos[j]=BoxPos[k]
                                       else break; {done, i.e., there is another box at the same position as Box[j]}
                                   end
                                else {Box[j] found at the same index in the table, or it has been removed from the board}
                           else break; {fail, i.e., not a duplicate position}
                           end;
                       end;

                  {check if the current box constellation is a superset of one
                   of the deadlocks registered in the transposition table; in
                   that case, and if the current position also has the same
                   normalized player position as the deadlock, then the current
                   game state is also a deadlock, and further analysis is
                   unnecessary}
                  if BoxesOnBoardCount >= MAX_BOX_COUNT_FOR_TRANSPOSITION_TABLE_POSITIONS then
                     for i := Low( Game.DeadlockSets.TranspositionTable ) to High( Game.DeadlockSets.TranspositionTable ) do
                         if   not Result then with Game.DeadlockSets.TranspositionTable[ i ] do begin
                              Result:=( PlayerPos__ = PlayerPos ) and
                                      ( TranspositionTableTimeStamp = TranspositionTableTimeStamps[ i ] );
                              for j:=1 to Game.BoxCount do begin {try to match each box in the registered deadlock with boxes on the board in the current game state}
                                  if   Result then begin
                                       if (BoxPos[j]<>0) and {'<>': the box is on the board in the deadlocked position}
                                          (Game.BoxPos[j]<>BoxPos[j]) then begin {'<>': no simple match; try harder}
                                          Result:=False;
                                          for k:=1 to Game.BoxCount do {search for another box at the same position as Deadlock.BoxPos[j]}
                                              if   not Result then
                                                   Result:=Game.BoxPos[k]=BoxPos[j]
                                              else break; {done, i.e., there is another box at the same position as Deadlock.BoxPos[j]}
                                          end
                                       else; {Box[j] found at the same index in the table, or it has been removed from the board}
                                       end
                                  else break; {fail, i.e., not a duplicate position}
                                  end;
                              end
                         else break; {done, i.e., found a duplicate position}
                  end;
            end;

          begin {Search; precondition: player's reachable squares have been calculated for this depth}
{
            if Game.Board[MAX_BOARD_SIZE]=FLOOR then begin
               ShowBoard;
               Write(Depth__,SLASH,MAX_SEARCH_DEPTH,SPACE,SPACE,TEXT_PUSH_PULL[CheckType__=ctCheckPulls],SPACE,SPACE,Game.PlayerPos,SPACE,SPACE,Game.DeadlockSets.CandidatePushCount);
               Readln;
               end;
}
            Inc(Game.DeadlockSets.CandidatePushCount);
            Result:=(Game.SimpleLowerBound<>0) and {'0': all boxes are located at goals}
                    (Depth__<MaximumSearchDepth) and {if the search goes to deep, then be conservative and reject the deadlock-set}
                    (Depth__+DepthOffset<MAX_HISTORY_BOX_MOVES) and {range check for calculating the player's reachable squares}
                    (Game.DeadlockSets.CandidatePushCount<=MAX_DEADLOCK_SET_CANDIDATE_PUSH_COUNT) and {fallback stop criteria}
                    (not Solver.Terminated);
{
//                  if Solver.PushCount=755 then if (Game.DeadlockSets.CandidatePushCount mod 10000) = 0 then begin
//                  if (Game.DeadlockSets.SequenceNo>=318) then begin
//                  if True then begin
                    if Game.Board[MAX_BOARD_SIZE]=FLOOR //then
                       //if ((Game.DeadlockSets.CandidatePushCount mod 1000000) = 0) or (Depth__ >= MaximumSearchDepth) or (Game.DeadlockSets.CandidatePushCount > MAX_DEADLOCK_SET_CANDIDATE_PUSH_COUNT)
                          then begin
                          ShowBoard;
                          if   CheckType__=ctCheckPushes then
                               Write('Forwards ')
                          else Write('Backwards ');
                          Write(Depth__,SPACE,BackJumpDepth__,SPACE,Game.DeadlockSets.CandidatePushCount,SPACE,Solver.PushCount);
                          Readln;
                          end;
}
            if Result then begin
               SuccessorDepth          := Succ( Depth__ );
               BackJumpDepth__         := MAX_DEADLOCK_SEARCH_DEPTH + 1;        {initialize to chronological backtracking}
               StartCandidatePushCount := Game.DeadlockSets.CandidatePushCount; {remember the number of pushed before expanding this position}
               LastPushedBoxNo         := Game.DeadlockSets.History[ Depth__ ].BoxNo;
               if   LastPushedBoxNo    <> 0 then {'True': first expand the last pushed box to increase the chances of finding an early escape for it}
                    BoxNo              := LastPushedBoxNo
               else BoxNo              := 1;
               while BoxNo<=Game.BoxCount do
                   if Result then begin
                      SquareNo:=Game.BoxPos[BoxNo];

                      for Direction:=Low(Direction) to High(Direction) do
                          if Result and (BackJumpDepth__>Depth__) then begin
                             with Solver.SearchStates[Depth__+DepthOffset].PlayersReachableSquares do
                               if CheckType__=ctCheckPushes then begin {pushes: try proving the set invalid by pushing a box outside the area}
                                  if SquareNo<>0 then begin                     {'True': the box hasn't been removed from the board}
                                     BoxToSquareNo:=SquareNo+Game.SquareOffsetForward[Direction];
                                     {inline simple checks for legal moves}
                                     if (Squares[SquareNo-Game.SquareOffsetForward[Direction]]=TimeStamp)
                                        and
                                        ((Game.Board[BoxToSquareNo] and (BOX+WALL+FLAG_ILLEGAL_BOX_SQUARE))=0)
                                        and
                                        {extended checks for legal moves}
                                        IsALegalPush(BoxNo,Direction,SuccessorDepth+DepthOffset) then begin

                                        if ( DeadlockSetCandidate__.SquareColors[ BoxToSquareNo ] = scWhite ) or  {'True': the box escapes from the fenced-in area}
                                           ( SuccessorDepth = MaximumSearchDepth ) then begin {'True': the maximum search depth has been reached; remove the box and check if the remaining boxes are deadlocked}
                                           Result:=DeadlockSetCandidate__.EscapedBoxesCountDown>1; {'True': continue the search, i.e., the candidate is considered a deadlock until it has been proved that enough boxes can escape}
                                           {jump back to the point where the box began its current
                                            sequence of moves toward the escape square; remove the
                                            box at that point and then continue the search with the
                                            remaining boxes on the board;
                                            the alternative would be to continue the search normally,
                                            using a recursive call with the next higher depth, but
                                            that would waste search depths if the search in reality
                                            just peels off loosely attached boxes from a core of
                                            deadlocked boxes;
                                           }
                                           BackJumpDepth__:=Depth__;
                                           if    (BackJumpDepth__>0) and
                                                 (Game.DeadlockSets.History[Pred(BackJumpDepth__)].BoxNo=BoxNo) then
                                                 {the next to last push was a push of the escaping box E;
                                                  discard the last push of box X even if X<>E; for instance,
                                                  with topmost pushes EEEX and X<>E, X can always make at least
                                                  the same pushes again when E has been removed from the board, so
                                                  the search is still exhaustive after discarding the topmost push
                                                  of the X box here;}
                                                  Dec(BackJumpDepth__);
                                           while Game.DeadlockSets.History[BackJumpDepth__].BoxNo=BoxNo do
                                                 Dec(BackJumpDepth__);
                                           end;

                                        if Result and (BackJumpDepth__>Depth__) then begin {'True': try the push}
                                           DoPush(BoxNo,Direction,SuccessorDepth+DepthOffset); {do the move, i.e., update the board}

                                           CalculatePlayersReachableSquares(SuccessorDepth+DepthOffset); {note that the results from this calculation are passed on to the recursive call}

                                           if not IsADuplicatePosition(SuccessorDepth,Solver.SearchStates[SuccessorDepth+DepthOffset].PlayersReachableSquares.MinPlayerPos) then begin
                                              {update the game history, i.e., the current path}
                                              Game.DeadlockSets.History[SuccessorDepth].BoxNo:=BoxNo;
                                              for i:=1 to Game.BoxCount do Game.DeadlockSets.History[SuccessorDepth].BoxPos[i]:=Game.BoxPos[i];
                                              Game.DeadlockSets.History[SuccessorDepth].HashValue:=Game.HashValue;
                                              Game.DeadlockSets.History[SuccessorDepth].PlayerPos:=Solver.SearchStates[SuccessorDepth+DepthOffset].PlayersReachableSquares.MinPlayerPos;

                                              Result:=Search(SuccessorDepth,BackJumpDepth__); {recursive step: explore the new position}
                                              end;

                                           UndoPush(BoxNo,Direction);           {take back the move, i.e., update the board}
                                           end;

                                        if Result and (BackJumpDepth__=Depth__) then begin {'True': the box can escape the fenced-in area after zero or more pushes starting from its current position}
                                           {remove the box from the board and try a search with the remaining boxes}

                                           RemoveBoxFromBoard(BoxNo);           {remove the box from the board}
                                           Dec(DeadlockSetCandidate__.EscapedBoxesCountDown); {update the number of escaped boxes}
                                           Dec( BoxesOnBoardCount );            {update the number of boxes on the board}

                                           CalculatePlayersReachableSquares(SuccessorDepth+DepthOffset); {note that the results from this calculation are passed on to the recursive call}

                                           Game.DeadlockSets.History[SuccessorDepth].BoxNo:=0;    {removing the box from the board is a "null-move"}
                                           Game.DeadlockSets.History[SuccessorDepth].BoxPos[BoxNo]:=0;
                                           Game.DeadlockSets.History[SuccessorDepth].HashValue:=Game.HashValue;
                                           Game.DeadlockSets.History[SuccessorDepth].PlayerPos:=
                                             Solver.SearchStates[SuccessorDepth+DepthOffset].PlayersReachableSquares.MinPlayerPos; {update the normalized player position now that the box has been removed from the board}
{
                                           if Game.Board[MAX_BOARD_SIZE]=FLOOR then begin
                                              ShowBoard;
                                              Writeln( 'Box removed from the board' );
                                              end;
}
                                           Result:=Search(SuccessorDepth,BackJumpDepth__); {recursive step: explore the new position; note that if 'Result' is 'True' then 'BackJumpDepth__' is guaranteed to have a proper value upon return}

                                           PutBoxOnBoard(BoxNo,SquareNo);       {put the box back on the board}
                                           Inc(DeadlockSetCandidate__.EscapedBoxesCountDown); {restore the number of escaped boxes}
                                           Inc( BoxesOnBoardCount );            {restore the number of boxes on the board}
                                           if BackJumpDepth__ = -Depth__  then  {'True': at a higher search depth, it turned out that this push deadlocked a set of boxes; continue the search from here}
                                              BackJumpDepth__ := MAX_DEADLOCK_SEARCH_DEPTH + 1;
                                           break;                               {quick-and-dirty: exit the 'for each direction' loop for the current box; there is no need to enumerate all directions after a search with the box removed from the board}
                                           end
                                        else if BackJumpDepth__ = -Depth__  then {'True': at a higher search depth, it turned out that this push deadlocked a set of boxes; continue the search from here}
                                                BackJumpDepth__ := MAX_DEADLOCK_SEARCH_DEPTH + 1;
                                        end
                                     else; {no push in this direction}
                                     end;
                                  end
                               else {pulls: try proving the set invalid by pulling boxes so the player can escape the fenced-in area}
                                  if (Squares[SquareNo+  Game.SquareOffsetForward[Direction]]=TimeStamp)
                                     and
                                     (Squares[SquareNo+2*Game.SquareOffsetForward[Direction]]=TimeStamp)
                                     and
                                     ((Game.Board[SquareNo+Game.SquareOffsetForward[Direction]] and (BOX+WALL+FLAG_ILLEGAL_BOX_SQUARE))=0) then begin

                                     DoPull(BoxNo,Direction);                   {do the move, i.e., update the board}

                                     CalculatePlayersReachableSquares(SuccessorDepth+DepthOffset); {note that the results from this calculation are passed on to the recursive call}

                                     if not IsADuplicatePosition(SuccessorDepth,Solver.SearchStates[SuccessorDepth+DepthOffset].PlayersReachableSquares.MinPlayerPos) then begin
                                        if   CheckType__=ctCheckPulls then
                                             Result:=(not (dsfPlayerIsInsideSet in DeadlockSetCandidate__.Flags)) and
                                                     (not PlayerHasAccessToAnOuterSquare(SuccessorDepth+DepthOffset))
                                        else {CheckType__ is 'ctCheckPullsPaintThePlayerIntoACorner'}
                                             Result:=(not (dsfPlayerIsInsideSet in DeadlockSetCandidate__.Flags)) and
                                                     (not PlayerHasAccessToAnInnerSquare(SuccessorDepth+DepthOffset));

                                        if Result then begin
                                           {update game history}
                                           Game.DeadlockSets.History[SuccessorDepth].BoxNo:=BoxNo;
                                           for i:=1 to Game.BoxCount do Game.DeadlockSets.History[SuccessorDepth].BoxPos[i]:=Game.BoxPos[i];
                                           Game.DeadlockSets.History[SuccessorDepth].HashValue:=Game.HashValue;
                                           Game.DeadlockSets.History[SuccessorDepth].PlayerPos:=Solver.SearchStates[SuccessorDepth+DepthOffset].PlayersReachableSquares.MinPlayerPos;
                                           Result:=Search(SuccessorDepth,BackJumpDepth__); {recursive step: explore the new position}
                                           end;
                                        end;

                                     UndoPull(BoxNo,Direction);                 {take back the move, i.e., update the board}
                                     end;
                             end
                          else break;                                           {(Result = False) or (BackJumpDepth__<=Depth__)}

                      if   BoxNo<>LastPushedBoxNo then Inc(BoxNo)
                      else BoxNo:=1;                                            {first time through the loop}
                      if   BoxNo= LastPushedBoxNo then Inc(BoxNo);              {skip last pushed box when seeing it for the second time}
                      end
                   else break;

               if  ( StartCandidatePushCount    =  Game.DeadlockSets.CandidatePushCount ) and
                   ( CheckType__                =  ctCheckPushes ) and
                   ( BackJumpDepth__            >  Depth__ ) and
                   ( Game.DeadlockSets.History[ Depth__ ].BoxNo
                                                =  0 ) and
                   Result then begin {the current position is a deadlock; backtrack to the point where the last of the remaining boxes on the board was pushed}
                   while ( Depth__              >  0 ) and
                         ( Game.BoxPos[ Game.DeadlockSets.History[ Depth__ ].BoxNo ] = 0 ) do {'=0': the box has been removed from the board}
                         Dec( Depth__ );
                   if Depth__                   >  0 then
                      BackJumpDepth__           := -Depth__;
                   end;

               if  Result and
                   ( Abs( BackJumpDepth__ )     >= Depth__ ) and
                   ( ( BoxesOnBoardCount        <= MAX_BOX_COUNT_FOR_TRANSPOSITION_TABLE_POSITIONS ) {'1..MAX': reserve the transposition table for positions with few boxes; they are more likely to be subsets of other box constellations}
                     or
                     ( StartCandidatePushCount  =  Game.DeadlockSets.CandidatePushCount ) ) then begin {'=': add dead-end positions to the transposition table no matter how many boxes the position has}
                   i := Game.HashValue and High( Game.DeadlockSets.TranspositionTable );
                   with Game.DeadlockSets.TranspositionTable[ i ] do begin
                     PlayerPos                  := Game.DeadlockSets.History[ Depth__ ].PlayerPos;
                     HashValue                  := Game.HashValue;
                     for j                      := 0 to Game.BoxCount do
                         BoxPos[ j ]            := Game.BoxPos[ j ];
                     end;
                   TranspositionTableTimeStamps[ i ] := TranspositionTableTimeStamp;
                   end;
               end;
          end; {Search}

        begin {Check}
          Result:=Game.SimpleLowerBound<>0;
          with Solver.SearchStates[ SEARCH_STATE_INDEX_VISITED_ACCESS_AREA_FOR_CHECKING_DEADLOCK_CANDIDATE_SEARCH ].PlayersReachableSquares do begin {initialize visited access areas}
            if TimeStamp>=PLAYERS_REACHABLE_SQUARES_TIMESTAMP_UPPER_BOUND then
               ClearPlayersReachableSquares( SEARCH_STATE_INDEX_VISITED_ACCESS_AREA_FOR_CHECKING_DEADLOCK_CANDIDATE_SEARCH );
            Inc(TimeStamp,2);
            end;
          SquareOutsideFence__:=0; PlayerOutsideFenceReachableSquaresCount:=0;
          Game.DeadlockSets.CandidatePushCount:=0;
          Game.DeadlockSets.History[0].BoxNo:=0; {backjumping sentinel for the search}
          if   not ( dsfIsANoProgressDeadlockCandidate in DeadlockSetCandidate__.Flags ) then
               MaximumSearchDepth := NORMAL_DEADLOCK_SEARCH_DEPTH
          else MaximumSearchDepth := MAX_DEADLOCK_SEARCH_DEPTH;
          if Position__=nil then
             DepthOffset:=0
          else begin
             DepthOffset:=Succ(Position__^.PushCount);
             Result:=Result and (DepthOffset<=MAX_HISTORY_BOX_MOVES); {range check for calculating the player's reachable squares}
             end;

          if   CheckType__=ctCheckPulls then
               CalculateFrontierSquares {'frontier squares' are used to speed up detection of the player's access to the outside area}
          else if Result and
                  (dsfPlayerIsInsideSet in DeadlockSetCandidate__.Flags) and
                  ((Game.Board[GamePlayerPos] and (WALL+BOX+FLOOR))=FLOOR) then begin
                  {note: 'GamePlayerPos', not 'Game.PlayerPos', i.e., the real}
                  {player position is an empty floor inside the set}
                  MovePlayer(GamePlayerPos); CalculatePlayersReachableSquares(DepthOffset);
                  with Solver.SearchStates[DepthOffset].PlayersReachableSquares do
                    if Squares[DeadlockSetCandidate__.CenterSquare]<>TimeStamp then begin
                       {if the player is inside the set, but not in the same access area}
                       {as the center square, then check that the player cannot push the boxes outside the area;}
                       {maybe this check isn't necessary, but it won't hurt to throw away a few deadlock-sets}
                       InitializeTranspositionTable;
                       Result:=Search(0,BackJumpDepth);
                       end;
                  end;

          if Result then begin
             i:=GamePlayerPos;
             repeat   {for each player access area, starting with the player's current position}
                      if ((Game.Board[i] and (WALL+BOX+FLOOR))=FLOOR) and
                         (Solver.SearchStates[ SEARCH_STATE_INDEX_VISITED_ACCESS_AREA_FOR_CHECKING_DEADLOCK_CANDIDATE_SEARCH ].PlayersReachableSquares.TimeStamp <>
                          Solver.SearchStates[ SEARCH_STATE_INDEX_VISITED_ACCESS_AREA_FOR_CHECKING_DEADLOCK_CANDIDATE_SEARCH ].PlayersReachableSquares.Squares[ i ]) then
                         with Solver.SearchStates[DepthOffset].PlayersReachableSquares do begin
                           MovePlayer(i);
                           PlayerReachableSquaresCount:=CalculatePlayersReachableSquares(DepthOffset);

                           for j:=0 to Game.BoardSize do
                               if  Squares[j]=TimeStamp then
                                   Solver.SearchStates[ SEARCH_STATE_INDEX_VISITED_ACCESS_AREA_FOR_CHECKING_DEADLOCK_CANDIDATE_SEARCH ].PlayersReachableSquares.Squares[ j ] :=
                                   Solver.SearchStates[ SEARCH_STATE_INDEX_VISITED_ACCESS_AREA_FOR_CHECKING_DEADLOCK_CANDIDATE_SEARCH ].PlayersReachableSquares.TimeStamp; {mark floor squares in access area as visited}

                           if ( ( PlayerReachableSquaresCount + DeadlockSetCandidate__.Boxes.Count ) >= Pred( Game.FloorCount ) ) and
                              ( DeadlockSetCandidate__.CenterSquare <> 0 ) and
                              ( DeadlockSetCandidate__.SquareColors[ i ] <> PLAYER_START_SQUARE_COLORS[ CheckType__ ] ) and
                              ( CheckType__ = ctCheckPushes ) then
                              Result := False                                   {the corral encompasses almost the entire board; drop the deadlock candidate}
                           else
                              if (DeadlockSetCandidate__.SquareColors[i]=PLAYER_START_SQUARE_COLORS[CheckType__])
                                 or
                                 ( {a "no progress" deadlock candidate encompasses the entire board, unless it has a center square;
                                   only corral-type deadlock candidates have a center square;}
                                   ( dsfIsANoProgressDeadlockCandidate in DeadlockSetCandidate__.Flags )
                                   and
                                   ( DeadlockSetCandidate__.CenterSquare = 0 )
                                   and
                                   ( CheckType__ = ctCheckPushes )
                                 ) then begin
                                 if ( PlayerReachableSquaresCount =  1 ) and
                                    ( CheckType__                 =  ctCheckPushes ) and
                                    ( GamePlayerPos               <> i ) and
                                    ( Game.StartPlayerPos         <> i ) then begin {'True': this is an isolated square, and it isn't the player start position, so this state cannot appear in normal gameplay}
                                    end
                                 else begin
                                    InitializeTranspositionTable;
                                    Result:=Search(0,BackJumpDepth);            {use the recursive search procedure to explore the possible moves}
                                    end;

                                 if (Position__<>nil) and
                                    (CheckType__=ctCheckPushes) then
                                    if   Result then begin
                                         if (Squares[GamePlayerPos]=TimeStamp)  {note it's 'GamePlayerPos' and not 'Game.PlayerPos'; the former contains the player's position in the game, the latter the player position during the deadlock-set analysis}
                                            and
                                            (DeadlockSetCandidate__.CenterSquare<>0)
                                            and
                                            (Game.SimpleLowerBound<>0)
                                            and
                                            ((DeadlockSetCandidate__.Flags * [dsfHasUnspecifiedInnerFloors,dsfHasDisconnectedInnerFloors,dsfIsOnlyADeadlockForListedPlayerAccessAreasOutsideFence])
                                             =
                                             []
                                            )
                                            then begin
                                            {in the current game state, the player is
                                             outside the fence and cannot break it, so
                                             seen from that particular player access
                                             area, the fence is a deadlock;
                                            }
                                            if PlayerReachableSquaresCount>PlayerOutsideFenceReachableSquaresCount then begin {select the largest player access area}
                                               SquareOutsideFence__:=GamePlayerPos;
                                               PlayerOutsideFenceReachableSquaresCount:=PlayerReachableSquaresCount;
                                               end;
                                            end;
                                         end
                                    else if (Squares[GamePlayerPos]<>TimeStamp) and {'True': in the current game state, the player is in a different access area}
                                            (Squares[Game.StartPlayerPos]<>TimeStamp) and {'True': in the game starting position, the player isn't inside the currently investigated player access area}
                                            (PlayerReachableSquaresCount<=SMALL_PLAYER_ACCESS_AREA_LIMIT) and {'True': the currently investigated access area is small; maybe the player never can get into this "pocket"}
                                            (DeadlockSetCandidate__.GoalCount<DeadlockSetCandidate__.Boxes.Count)
                                            then begin
                                            {starting from the current access area,
                                             the player can break the fence and get
                                             boxes out (or at least the program could
                                             not prove that the fence is unbreakable);
                                             however, there is a chance that the
                                             player never can be in the current access
                                             area; this is the case if pulls paint the
                                             player into a corner, and the player
                                             isn't in this access area from the
                                             beginning - the latter was a part of the
                                             'if' filter for getting here;
                                            }
                                            MovePlayer(i); {put the player back at the correct square}
                                            CheckType__:=ctCheckPullsPaintThePlayerIntoACorner;
                                            InitializeTranspositionTable;
                                            Result:=Search(0,BackJumpDepth);
                                            CheckType__:=ctCheckPushes;
{
                                            if Result then begin
                                               ShowBoard;
                                               Write('OK? ',Solver.PushCount,SPACE,Positions.Count);
                                               Readln;
                                               end;
}
                                    end;
                                 end;
                           end;

                      if   i<Game.BoardSize then
                           Inc(i) {advance to next square}
                      else i:=0;  {wrap around}

             until (not Result) or (i=GamePlayerPos); {until proving the candidate to be a deadlock failed, or until all board squares have been examined}
             end;

          Inc(Game.DeadlockSets.LevelTotalPushCount,Game.DeadlockSets.CandidatePushCount);
        end; {Check}

      begin {CheckDeadlockSetCandidate}
        {initialization}
        //MaxSearchDepth:=Min(MAX_SEARCH_DEPTH,MIN_SEARCH_DEPTH+(DeadlockSetCandidate__.PaintedFloorCount div 4));
{
        if Game.Board[MAX_BOARD_SIZE]=FLOOR then begin
           ShowBoard;
           Write('Check deadlock set candidate ',Solver.PushCount,SPACE,Positions.Count);
           Readln;
           end;
}
        GamePlayerPos:=Game.PlayerPos; GameBoxCount:=Game.BoxCount; {save game state}
        for i:=1 to Game.BoxCount do GameBoxPos[i]:=Game.BoxPos[i];
        ClearBoard; {remove boxes and player from the board}

        Game.BoxCount:=DeadlockSetCandidate__.Boxes.Count; {put boxes from current deadlock-set on the board}
        for i:=1 to DeadlockSetCandidate__.Boxes.Count do Game.BoxPos[i]:=DeadlockSetCandidate__.Boxes.Squares[i];
        InitializeBoard; {update board and existing deadlock-set capacities}
        TranspositionTableTimeStamp := High( TranspositionTableTimeStamp ); {'High': clear the transposition table the first time 'Check()' is called}

        //WriteBoardToLogFile('Deadlock candidate (Boxes only, goal squares are not part of the set)')

        {checking}
{
//      if Solver.PushCount>=173555 then begin
        if Game.HashValue=7423206488411940475 then begin
//      if ( DeadlockSetCandidate__.Boxes.Count = 11 ) and ( Solver.PushCount > 0 ) then begin
//      if Game.DeadlockSets.SequenceNo>=1580 then if DeadlockSetCandidate__.Boxes.Count = 2 then begin
//      if Game.DeadlockSets.SequenceNo>=185 then if DeadlockSetCandidate__.PaintedFloorCount=17 then begin
//      if Position__<>nil then begin
//      if Game.BoxCount=10 then if Solver.PushCount >= 482 then begin
//      if dsfIsANoProgressDeadlockCandidate in DeadlockSetCandidate__.Flags then begin
           ShowBoard;
           Writeln('Center: ',DeadlockSetCandidate__.CenterSquare,'=',SquareToColRowAsText(DeadlockSetCandidate__.CenterSquare),
                   SPACE,SPACE,DeadlockSetCandidate__.PaintedFloorCount,
                   '  Pushes: ', Solver.PushCount );
           Writeln(Game.HashValue,SPACE,Solver.PushCount,SPACE,Positions.Count,SPACE,DeadlockSetCandidate__.Capacity);
           Write('Check candidate - Y/N? ');
           Readln( S );
           if ( S <> '' ) and ( UpCase( S[ 1 ] ) ='Y' ) then
              Game.Board[MAX_BOARD_SIZE]:=FLOOR;
           end
        else begin
           Game.Board[MAX_BOARD_SIZE]:=WALL;
           S := '';
           end;
}
        Result:=Check(ctCheckPushes,DeadlockSetCandidate__.SquareOutsideFence);
        if Result                                                               {'True': the player cannot break the fence from the outside, no matter which player access area the player starts from}
           or
           (DeadlockSetCandidate__.SquareOutsideFence<>0) then                  {'True': the candidate is a deadlock if the player starts from its current access area (from the 'SquareOutsideFence' square)}
           if   Check(ctCheckPulls,i) then begin                                {'True': the player cannot break the fence by pulling boxes from the inside}
                if not Result then begin                                        {'True': the candidate has only been proven to be a deadlock when the player is in the current player access area}
                   Include(DeadlockSetCandidate__.Flags,dsfPlayerMustBeOutsideSet);
                   Include(DeadlockSetCandidate__.Flags,dsfIsOnlyADeadlockForListedPlayerAccessAreasOutsideFence); {it's only a deadlock when the player is in the access area represented by 'SquareOutsideFence'}

                   {find all the squares just outside the fence (i.e., neighbors
                    of the fence boxes) which the player can reach from
                    'SquareOutsideFence';
                   }
                   DeadlockSetCandidate__.SquaresOutsideFence.Count:=0;
                   {deadlock detection can work both with and without the list
                   of squares just outside the fence; without a list, there is
                   still the representative, 'SquareOutsideFence', which can
                   cover one access area;
                   }

                   if        Position__=nil then i:=0
                   else if   Position__^.PushCount<MAX_HISTORY_BOX_MOVES-1 then i:=Succ(Position__^.PushCount)
                        else i:=-1;
                   if   i>=0 then with DeadlockSetCandidate__ do with Solver.SearchStates[i] do begin
                        MovePlayer(SquareOutsideFence);
                        CalculatePlayersReachableSquares(i);

                        for j:=1 to Boxes.Count do begin
                            Square:=Boxes.Squares[j];
                            if PlayersReachableSquares.Squares[Square]=Succ(PlayersReachableSquares.TimeStamp) then begin {'True': the player can reach the box}
                               for Direction:=Low(Direction) to High(Direction) do begin
                                   NeighborSquare:=Square+Game.SquareOffsetForward[Direction];
                                   if PlayersReachableSquares.Squares[NeighborSquare]=PlayersReachableSquares.TimeStamp then begin {'True': the player can reach the neighbor square, and the neighbor square hasn't been visited before}
                                      Inc(SquaresOutsideFence.Count);
                                      SquaresOutsideFence.Squares[SquaresOutsideFence.Count]:=NeighborSquare;
                                      PlayersReachableSquares.Squares[NeighborSquare]:=0; {mark the neighbor square as 'visited'}
                                      end;
                                   end;
                               end;
                            end;
                        end;
                   end;
                Result:=True;
                end
           else {the player can break the fence by pulling boxes from the inside}
                if   Result {'True': the player cannot break the fence from the outside, no matter which player access area the player starts from}
                     and
                     (DeadlockSetCandidate__.CenterSquare<>0)
                     and
                     (Game.SimpleLowerBound<>0)
                     and
                     (not (dsfHasUnspecifiedInnerFloors in DeadlockSetCandidate__.Flags)) then begin {'True': the program has information about all inner floor squares at this time}
                     CalculateOutsideOnlyPushDirections(PushesFromTheOutsideOnlyDirectionSet,DeadlockSetCandidate__.SquaresOutsideFence);
                     if   DeadlockSetCandidate__.SquaresOutsideFence.Count>0 then {'True': the candidate is a a deadlock when the player can reach one of these squares}
                          DeadlockSetCandidate__.SquareOutsideFence:=DeadlockSetCandidate__.SquaresOutsideFence.Squares[1] {elevate one of the squares outside the fence to be the representative}
                     else DeadlockSetCandidate__.SquareOutsideFence:=0;

                     {if there are disconnected inner floors, then the deadlock
                      is only usable if there are directions or known squares
                      which guarantee that the player it outside the fence
                     }
                     Result:=(not (dsfHasDisconnectedInnerFloors in DeadlockSetCandidate__.Flags))
                             or
                             (DeadlockSetCandidate__.SquaresOutsideFence.Count>0);
                     for Direction:=Low(Direction) to High(Direction) do
                         if Direction in PushesFromTheOutsideOnlyDirectionSet then begin
                            Include(DeadlockSetCandidate__.Flags,DIRECTION_TO_DEADLOCK_SET_FLAG[Direction]);
                            Result:=True; {'True': there is at least one direction which guarantees that that the player is outside the fence}
                            end;
                     if   Result then begin {'True': the deadlock set is usable}
                          Include(DeadlockSetCandidate__.Flags,dsfPlayerMustBeOutsideSet);
                          if DeadlockSetCandidate__.SquaresOutsideFence.Count>0 then begin
                             Include(DeadlockSetCandidate__.Flags,dsfIsOnlyADeadlockForListedPlayerAccessAreasOutsideFence);
                             end;
                          end
                     else begin end; {the deadlock set is unusable; it has disconnected inner floors, and no push directions or squares guarantee that the player is outside the fence}
                     end
                else if   Result and
                          (dsfIsANoProgressDeadlockCandidate in DeadlockSetCandidate__.Flags) and
                          (DeadlockSetCandidate__.CenterSquare=0) and
                          (Game.SimpleLowerBound<>0) then begin {a "no progress" deadlocks encompass the entire board, hence this deadlock candidate is a deadlock because its boxes cannot be pushed to goal squares}
                          end
                     else Result:=False;

        IsALegalSetButViolatesCapacityConstraints__:=Result and (not CheckSimpleDeadlocks);
{
        if ( ( Game.Board[MAX_BOARD_SIZE]=FLOOR ) and ( not Result ) )
           or
           ( ( dsfIsANoProgressDeadlockCandidate in DeadlockSetCandidate__.Flags ) and Result ) then begin
           MovePlayer( 0 );
           ShowBoard;
           Write('Deadlock: ',TEXT_NO_YES[ Result ], SPACE, Succ( Game.DeadlockSets.SequenceNo ), SPACE, Game.HashValue );
           Readln;
           end;
}
        {finalization}
        ClearBoard; {remove deadlock-set from the board}
        Game.BoxCount:=GameBoxCount; Game.PlayerPos:=GamePlayerPos; {restore game state}
        for i:=1 to Game.BoxCount do Game.BoxPos[i]:=GameBoxPos[i];
        InitializeBoard;

      end; {CheckDeadlockSetCandidate}

      procedure PruneDeadlockSets;
      var i,j,SetNo,SquareNo:Integer; CommonSquaresCount:array[0..MAX_DEADLOCK_SETS] of integer;
      begin {precondition: the candidate set is legal and has been stored as the newest deadlock set}
        FillChar(CommonSquaresCount,SizeOf(CommonSquaresCount),0);

        for i:=1 to DeadlockSetCandidate__.Boxes.Count do begin {for each square in the new set}
            SquareNo:=DeadlockSetCandidate__.Boxes.Squares[i];
            for j:=1 to Game.DeadlockSets.SquareSetCount[SquareNo] do {for each set having this this square as a member}
                Inc(CommonSquaresCount[Game.DeadlockSets.SquareSetNumbers[SquareNo]^[j]]); {count number of squares in common with the candidate set}
            end;

        for SetNo:=Pred(Game.DeadlockSets.Count) downto 1 do with Game.DeadlockSets do {'Pred': the candidate was stored as the newest deadlock set}
            if (CommonSquaresCount[SetNo]=DeadlockSetCandidate__.Boxes.Count) and
               ((Flags[SetNo]-[dsfPlayerIsInsideSet])=(DeadlockSetCandidate__.Flags-[dsfPlayerIsInsideSet])) and
               (not (dsfControllerSet in Flags[SetNo])) and
               (not (dsfFreezeSet     in Flags[SetNo])) then begin
               DeleteDeadlockSet(SetNo); Inc(RedundantSetsCount); {the new candidate makes the set numbered 'SetNo' superflous, hence, remove it}
               end;
      end; {PruneDeadlockSets}

    begin {CommitDeadlockSet}
      Exclude(DeadlockSetCandidate__.Flags,dsfIsADeadlockButTableOverflow);
      IsALegalSetButViolatesCapacityConstraints:=False; HashKey:=0; NewDeadlockSetNo:=0; TableOverflow:=False;

      //OldEscapedBoxesCountDown:=DeadlockSetCandidate__.EscapedBoxesCountDown;
      //DeadlockSetCandidate__.EscapedBoxesCountDown:=DeadlockSetCandidate__.Boxes.Count; {all boxes must escape the fenced-in area; otherwise it's a deadlock}

      Result:=(DeadlockSetCandidate__.Boxes.Count> 0) and
              (DeadlockSetCandidate__.Boxes.Count<=DeadlockSetCandidate__.MaxBoxCount) and
              (DeadlockSetCandidate__.GoalCount  <=Game.BoxCount) and
              //(Game.DeadlockSets.Count<MAX_DEADLOCK_SETS) and
              (CalculateElapsedTimeMS(TimeMS,GetTimeMS)<=Game.DeadlockSets.TimeLimitMS);

      if   Result then begin
           TableOverflow:=Game.DeadlockSets.Count>=MAX_DEADLOCK_SETS;

           //for  i:=1 to DeadlockSetCandidate__.Boxes.Count do {check for overflowing number of sets for each square}
           //     if   not TableOverflow then begin
           //          SquareNo:=DeadlockSetCandidate__.Boxes.Squares[i];
           //          TableOverflow:= //Game.DeadlockSets.SquareSetCount[DeadlockSetCandidate__.Boxes.Squares[i]]>=MAX_DEADLOCK_SETS_PER_SQUARE;
           //                          not EnsureSetNumbersCapacityForSquare( Succ(Game.DeadlockSets.SquareSetCount[SquareNo]),SquareNo);
           //          {$IFDEF CONSOLE_APPLICATION}
           //             if TableOverflow and (Position__=nil) then {nil': precalculating deadlocks when the level has been loaded}
           //                Writeln('Note: Table full (squares in a deadlock set); not all detected sets are in use.');
           //          {$ENDIF}
           //          end
           //     else break; {quick-and-dirty exit the 'for' loop when a table overflow has been found}

           if   TableOverflow
                and
                (True {'True': drop all deadlock set candidates which cause table overflows}
                 or
                 (Position__=nil) {nil': precalculating deadlocks when the level has been loaded}
                 or
                 (DeadlockSetCandidate__.Flags*[dsfControllerSet,dsfFreezeSet,dsfTestFrozenGoalsSet]<>[]) {'True': a controller/freze-set candidate or a frozen-goals candidate}
                 or
                 (Solver.PackingOrder.SetCount<=0) {if it isn't a packing order search then it's not OK to ignore the risk of hash-key collisions in the transposition table, so corrals in the transposition table cannot be assumed to be deadlocks}
                ) then
                Result:=False; {drop the deadlock set candidate when a table overflow has been found}
           end;

      if   Result and (Position__=nil) then begin                               {check that the candidate set isn't a duplicate}
           BoxSquares.Squares[0]:=0;
           for i:=1 to DeadlockSetCandidate__.Boxes.Count do begin              {sort the squares using insertion sort (sorting is required for calculating a stable hashkey)}
               SquareNo:=DeadlockSetCandidate__.Boxes.Squares[i]; j:=Pred(i);
               while SquareNo<BoxSquares.Squares[j] do begin
                 BoxSquares.Squares[Succ(j)]:=BoxSquares.Squares[j]; Dec(j);    {move bigger numbers to the right}
                 end;
               BoxSquares.Squares[Succ(j)]:=SquareNo;                           {insert new item}
               end;

           for i:=1 to DeadlockSetCandidate__.Boxes.Count do                    {calculate hash-key, using sorted square-numbers}
               HashKey:=HashKey xor Positions.SquareHashValues[BoxSquares.Squares[i]];

           if  (DeadlockSetCandidate__.Flags * [dsfControllerSet,dsfFreezeSet])=[] then { '[]': allow controller/freeze-set pairs to have identical controller sets and freeze sets}
               for i:=1 to Game.DeadlockSets.Count do                           {sequential search for an identical set}
                   if   Result then
                        Result:=(HashKey<>Game.DeadlockSets.HashKey[i])
                   else break;
           end;

      Result:=Result and CalculateDeadlockSetCandidateInfo(not Search__);       {'not Search__': if no search is performed, there is no further validation of the deadlock set candidate}

      if   Result then begin
           if   Search__ then
                Result:=CheckDeadlockSetCandidate(IsALegalSetButViolatesCapacityConstraints) {check that the candidate set is legal}
           else IsALegalSetButViolatesCapacityConstraints:=not CheckSimpleDeadlocks; {simple checks only}
           end;

      if   Result then begin
           {the set is pseudo-legal, i.e., it is valid but it may violate capacity constraints imposed by other deadlock sets}
           if Result and
              ((DeadlockSetCandidate__.Flags*[dsfPlayerIsInsideSet,dsfPlayerMustBeOutsideSet,dsfControllerSet,dsfFreezeSet])=[]) and
              (DeadlockSetCandidate__.Capacity<0) then
              StartPositionIsOK__:=False;                                       {start position is a deadlock}

           Result:=(not IsALegalSetButViolatesCapacityConstraints) or           {is the set really legal?}
                   AcceptPseudoLegalSets__;

           if Result and (Position__<>nil) then                                 {check whether the new dynamically created deadlock set candidate is redundant}
              Result:=not IsARedundantDeadlockSet(0);

           if Result then begin                                                 {'True': the candidate is a a new deadlock}
              for  i:=1 to DeadlockSetCandidate__.Boxes.Count do {check for set number overflows for each square}
                   if   not TableOverflow then begin
                        SquareNo:=DeadlockSetCandidate__.Boxes.Squares[i];
                        TableOverflow:= not EnsureSetNumbersCapacityForSquare( Succ(Game.DeadlockSets.SquareSetCount[SquareNo]),SquareNo);
                        {$IFDEF CONSOLE_APPLICATION}
                           if TableOverflow and (Position__=nil) then {nil': precalculating deadlocks when the level has been loaded}
                              Writeln('Note: Table full (squares in a deadlock set); not all detected sets are in use.');
                        {$ENDIF}
                        end
                   else break; {quick-and-dirty exit the 'for' loop when a table overflow has been found}

              if not TableOverflow then begin                                   {commit this deadlock set}
                 Inc(Game.DeadlockSets.Count);                                  {update number of sets}
                 NewDeadlockSetNo:=Game.DeadlockSets.Count;
                 if   Position__=nil then Inc(Game.DeadlockSets.PrecalculatedSetsCount)
                 else Inc(Game.DeadlockSets.DynamicSetsCount);
                 if   (DeadlockSetCandidate__.Flags*[dsfPlayerMustBeOutsideSet,dsfControllerSet,dsfFreezeSet])=[dsfPlayerMustBeOutsideSet] then
                      Inc(Game.DeadlockSets.SessionPlayerMustBeOutsideSetCount);
                 Inc(Game.DeadlockSets.SessionDeadlockSetsCount);

                 Inc(Game.DeadlockSets.SequenceNo);
                 Game.DeadlockSets.Capacity                [Game.DeadlockSets.Count]    :=DeadlockSetCandidate__.Capacity;
                 Game.DeadlockSets.CenterSquare            [Game.DeadlockSets.Count]    :=DeadlockSetCandidate__.CenterSquare;
                 Game.DeadlockSets.HashKey                 [Game.DeadlockSets.Count]    :=HashKey;
                 Game.DeadlockSets.Flags                   [Game.DeadlockSets.Count]    :=DeadlockSetCandidate__.Flags;
                 Game.DeadlockSets.FloorCount              [Game.DeadlockSets.Count]    :=DeadlockSetCandidate__.PaintedFloorCount; {'PaintedFloorCount' is the calculated inner floor squares; 'Floors.Count' may only contain representatives}
                 Game.DeadlockSets.SequenceNumbers         [Game.DeadlockSets.Count]    :=Game.DeadlockSets.SequenceNo;
                 Game.DeadlockSets.SquaresCount            [Game.DeadlockSets.Count]    :=DeadlockSetCandidate__.Boxes.Count;
                 for i:=1 to DeadlockSetCandidate__.Boxes.Count do begin           {add this set to the list for each square}
                     SquareNo:=DeadlockSetCandidate__.Boxes.Squares[i];
                     Inc(Game.DeadlockSets.SquareSetCount  [SquareNo]);
                     Game.DeadlockSets.SquareSetNumbers    [SquareNo]^[Game.DeadlockSets.SquareSetCount[SquareNo]]:=Game.DeadlockSets.Count;
                     end;
                 Game.DeadlockSets.SquareOutsideFence      [Game.DeadlockSets.Count]    :=DeadlockSetCandidate__.SquareOutsideFence;
                 Game.DeadlockSets.SquaresOutsideFenceIndex[Game.DeadlockSets.Count]    :=0;

                 if (DeadlockSetCandidate__.SquaresOutsideFence.Count>0) and
                    (Game.DeadlockSets.SquaresOutsideFenceTop+Succ(DeadlockSetCandidate__.SquaresOutsideFence.Count)
                     <=
                     High(Game.DeadlockSets.SquaresOutsideFence)
                    ) then with Game.DeadlockSets do begin
                    {store the player-reachable squares just outside the fence for
                     this deadlock set;
                    }
                    Inc(SquaresOutsideFenceTop);
                    Game.DeadlockSets.SquaresOutsideFenceIndex[Game.DeadlockSets.Count]:=SquaresOutsideFenceTop;

                    SquaresOutsideFence[SquaresOutsideFenceTop]:=DeadlockSetCandidate__.SquaresOutsideFence.Count; {first store the square count; the actual squares follow}

                    for i:=1 to DeadlockSetCandidate__.SquaresOutsideFence.Count do begin
                        Inc(SquaresOutsideFenceTop);
                        SquaresOutsideFence[SquaresOutsideFenceTop]:=DeadlockSetCandidate__.SquaresOutsideFence.Squares[i];
                        end;
                    end;
{
                 if Game.DeadlockSets.SequenceNo=319 then begin
                    ShowBoard;
                    Game.ShowDeadlockSetsEnabled:=True;
                    ShowDeadlockSet(Game.DeadlockSets.Count,DeadlockSetCandidate__.CenterSquare);
                    Game.ShowDeadlockSetsEnabled:=False;
                    Readln;
                    end;
}
                 ShowDeadlockSet(Game.DeadlockSets.Count,DeadlockSetCandidate__.CenterSquare);

                 {$IFDEF CONSOLE_APPLICATION}
                   if (Game.DeadlockSets.AdjacentOpenSquaresLimit>1) and
                      (not Game.ShowDeadlockSetsEnabled) then
                      Write(SPACE,Game.DeadlockSets.Count);
                 {$ENDIF}

                 {PruneDeadlockSets;} {check if the new set makes any of the previously created sets redundant}
                 {this pruning is deferred until all sets have been expanded,}
                 {(see the main body of 'CalculateDeadlockSets');}
                 {the reason is that it seems to be slightly more efficient}
                 end
              else begin {it's a new deadlock, but it cannot be saved because of table overflow}
                 if dsfIsOnlyADeadlockForListedPlayerAccessAreasOutsideFence in DeadlockSetCandidate__.Flags then {'True': whether a game state matches the deadlock set cannot be detected without a list of squares outside the corral}
                    Result:=False {discard the candidate set}
                 else begin
                    Inc(Game.DeadlockSets.SessionDeadlockSetsTableOverflowCount);
                    if   (DeadlockSetCandidate__.Flags*[dsfPlayerMustBeOutsideSet,dsfControllerSet,dsfFreezeSet])=[dsfPlayerMustBeOutsideSet] then
                         Inc(Game.DeadlockSets.SessionPlayerMustBeOutsideSetCount);
                    end;

                 for  i:=1 to DeadlockSetCandidate__.Boxes.Count do begin {drop any newly allocated square set number vectors for the squares which passed the "ensure capacity" initialization before the table overflow occurred}
                      SquareNo:=DeadlockSetCandidate__.Boxes.Squares[i];
                      if Game.DeadlockSets.SquareSetCount  [ SquareNo ] =  0 then
                         Game.DeadlockSets.SquareSetNumbers[ SquareNo ] := nil;
                      end;
                 end;
              end;

           if Position__=nil then begin {'nil': precalculating deadlocks when the level has been loaded}
              if (ExpandSet__
                  or
                  ((not Result)
                   {'(not Result)': expand the set when the deadlock is only pseudo-legal;}
                   {otherwise the chance to do so is lost}
                   and
                   Search__
                  )
                 )
                 and
                 (DeadlockSetCandidate__.MaxBoxCount<=Game.BoxCount) {'MaxBoxCount<=...' don't risk a time-consuming calculation if 'MaxBoxCount' has an artificially high value}
                 and
                 (not TableOverflow)
                 then begin
                 for i:=1 to DeadlockSetCandidate__.Boxes.Count do
                     ExpandDeadlockSet(i,ExpandSet__,AcceptPseudoLegalSets__,NewDeadlockSetNo,StartPositionIsOK__);
                 end;
              end
           else begin {a dynamically created deadlock during the solver search}
              if Search__ and ExpandSet__ and Result and (not TableOverflow) and
                 (DeadlockSetCandidate__.MaxBoxCount<=Game.BoxCount) then
                 for i:=1 to DeadlockSetCandidate__.Boxes.Count do
                     ExpandDeadlockSet(i,ExpandSet__,AcceptPseudoLegalSets__,NewDeadlockSetNo,StartPositionIsOK__);

              if   Result and TableOverflow then begin {'True': the candidate set is a new deadlock, but it hasn't been saved because of table overflow}
                   Result:=False;
                   Include(DeadlockSetCandidate__.Flags,dsfIsADeadlockButTableOverflow);
                   end
              else Exclude(DeadlockSetCandidate__.Flags,dsfIsADeadlockButTableOverflow);
              end;
           end;

      //DeadlockSetCandidate__.EscapedBoxesCountDown:=OldEscapedBoxesCountDown;
    end; {CommitDeadlockSet}

    function  CommitDynamicallyCreatedDeadlockSet(Position__:PPosition):Integer;
    var BoxIndex,MoveCount,OldPlayerPos,NeighborSquare,Square,WhiteNeighborCount:Integer;
        OldHashValue:THashValue;
        b,OK:Boolean;
        Direction:TDirection; OldTimeLimitMS:TTimeMS;
        Moves       :array[0..MAX_HISTORY_BOX_MOVES] of TMove;
        RemovedBoxes:array[0..MAX_HISTORY_BOX_MOVES] of TBoxNo;
    begin {CommitDynamicallyCreatedDeadlockSet}
       Result:=0; MoveCount:=0;
       OldTimeLimitMS:=Game.DeadlockSets.TimeLimitMS; Game.DeadlockSets.TimeLimitMS:=Solver.SearchLimits.TimeLimitMS;
       OldPlayerPos:=Game.PlayerPos; OldHashValue:=Game.HashValue;

       repeat
         MovePlayer(Positions.StartPosition^.PlayerPos); {the player position must be reset to the start position before the deadlock calculation}

         OK:=CommitDeadlockSet(not (dsfIsADeadlock in DeadlockSetCandidate__.Flags),
                               not (dsfIsADeadlock in DeadlockSetCandidate__.Flags),
                               False,b); {commit the new set, i.e., check whether it's legal, and if it is, then add it to the deadlock sets}
         if OK then begin
            Inc(Result); OK:=False;
            Game.DeadlockSets.NewDynamicDeadlockSets:=True; {the solver main loop must backtrack once to the start position, so all deadlock sets are considered when a position is selected for expansion}
{
            if Game.DeadlockSets.SequenceNo[Game.DeadlockSets.Count]>=0 then with Game.DeadlockSets do begin
               ShowBoard;
               Game.ShowDeadlockSetsEnabled:=True;
               ShowDeadlockSet(Count,CenterSquare[Count]);
               Readln;
               end;
}
            if not (dsfIsANoProgressDeadlockCandidate in DeadlockSetCandidate__.Flags) then begin {'True': it's not a no-progress deadlock candidate (they may have box positions not matching the current game state); check for forced pushes}
               while (Position__<>nil) and {search for the push leading to the current deadlock state}
                     (DeadlockSetCandidate__.SquareColors[Game.BoxPos[Position__^.Move.BoxNo]]<>scDarkGray) do
                     Position__:=Position__^.Parent;
               if    Position__<>nil then with Position__^ do begin
                     Square:=Game.BoxPos[Move.BoxNo];
                     Direction:=TDirection(Ord(Move.Direction) and DIRECTION_BIT_MASK);
                     WhiteNeighborCount:=CalculateNeighborsWithColor(Square,scWhite,True);
                     if    ( WhiteNeighborCount=1)
                           or
                           ((WhiteNeighborCount=2)
                            and
                            ( DeadlockSetCandidate__.SquareColors[Square-Game.SquareOffsetForward[Direction]]=scWhite) {'True': the box can be pulled backwards along the axis the box was pushed}
                            and
                            ((DeadlockSetCandidate__.SquareColors[Square+Game.SquareOffsetLeft   [Direction]]=scBlack)
                             or {'True': the box is blocked by a wall along the other axis (than the one the box was pushed); caution: assumes 4 directions only}
                             (DeadlockSetCandidate__.SquareColors[Square+Game.SquareOffsetRight  [Direction]]=scBlack)
                            )
                           ) then begin
//                   if    CalculateNeighborsWithColor(Square,scWhite,True)=1 then begin
                           BoxIndex:=1; {find box index}
                           while (BoxIndex<DeadlockSetCandidate__.Boxes.Count) and
                                 (Square<>DeadlockSetCandidate__.Boxes.Squares[BoxIndex]) do Inc(BoxIndex);
                           if BoxIndex<=DeadlockSetCandidate__.Boxes.Count then
                              {find the direction the box can be pulled}
                              for Direction:=Low(Direction) to High(Direction) do with DeadlockSetCandidate__ do begin
                                  NeighborSquare:=Square-Game.SquareOffsetForward[Direction];
                                  if (SquareColors[NeighborSquare]=scWhite) and
                                     IsALegalAndBoxReachableSquare(NeighborSquare) and
                                     (MoveCount<High(Moves)) then begin
                                     Boxes.Squares[BoxIndex]:=NeighborSquare; {move the box to the outside white square}
                                     SquareColors[Square]:=scWhite; {paint the squares accordingly (the floor is colored white, so the recalculation treat it as a newly added square)}
                                     SquareColors[NeighborSquare]:=scDarkGray;
                                     Inc(Floors.Count); {update the set of floor squares}
                                     Floors.Squares[Floors.Count]:=Square;
                                     Flags:=Flags * [dsfDiagonalCenterSquares,dsfPlayerIsInsideSet,dsfHasDisconnectedInnerFloors,dsfHasUnspecifiedInnerFloors];

                                     Inc(MoveCount);
                                     Moves[MoveCount].BoxNo:=Move.BoxNo;
                                     Moves[MoveCount].Direction:=Direction;

                                     {the box is about to be pulled outwards from
                                      the deadlock pattern; there may be a box at
                                      the new square at this point of time in the
                                      game; in that case the blocking box must be
                                      removed now, before the pull;
                                     }
                                     if (Game.Board[NeighborSquare] and BOX)=0 then
                                        RemovedBoxes[MoveCount]:=0
                                     else begin
                                        RemovedBoxes[MoveCount]:=BoxNoAtSquare(NeighborSquare);
                                        RemoveBoxFromBoard(RemovedBoxes[MoveCount]);
                                        end;

                                     UndoPush(Move.BoxNo,Direction); {update the board by pulling the box back to the outside white square}
                                     OK:=True; {test if this position also is a deadlock}
                                     break; {quick-and-dirty exit the 'for' loop as soon as the pull direction has been found}
                                     end;
                              end;

                           Position__:=Parent; {prepare to backtrack}
                           end;
                     end;
               end;
            end;
       until (not OK); {until the pushes along the current path don't lead to a deadlocked position according to the stored deadlock sets}
{
       if Result>1 then begin
          FlushLogFile;
          ShowBoard;
          Write('New deadlock sets: ',Result);
          Readln;
          end;
}
       while MoveCount<>0 do with Moves[MoveCount] do begin {restore the game state, i.e., box positions and deadlock set capacities}
         Square:=Game.BoxPos[BoxNo]; {remember the 'from' square before the box is pushed}
         DoPush(BoxNo,Direction,-1);
         if RemovedBoxes[MoveCount]<>0 then
            PutBoxOnBoard(RemovedBoxes[MoveCount],Square); {put removed boxes, if any, back on the board}
         Dec(MoveCount);
         end;
       MovePlayer(OldPlayerPos); {restore the player position}

       if Game.HashValue<>OldHashValue then
          Msg(TEXT_INTERNAL_ERROR,'CommitDynamicallyCreatedDeadlockSet');
       Game.HashValue:=OldHashValue;

       Game.DeadlockSets.TimeLimitMS:=OldTimeLimitMS; {restore the time limit for the precalculated deadlocks}
    end;

    function  PatternTypeNonGoalCorner:Boolean; {caution: assumes 4 directions only}
    var i,Item,Col,Row:Integer; WallUp,WallDown,WallLeft,WallRight:Boolean;
    begin {side-effect: finds corners, including interior ones}
      {$IFDEF CONSOLE_APPLICATION}
        if Game.ShowDeadlockSetsEnabled then Writeln('Dead-end corner');
      {$ENDIF}
      Result:=True; CornerCount:=0;
      for i:=0 to Game.BoardSize do with Game do begin                           {check if 'Board[i]' is a corner}
          SquareToColRow(i,Col,Row);
          if (Col>0) and (Col<Game.BoardWidth) and (Row>0) and (Row<Game.BoardHeight) then begin
             Item        := Board[i];
             WallUp      :=(Board[i+SquareOffsetForward[dUp   ]] and WALL)<>0;
             WallDown    :=(Board[i+SquareOffsetForward[dDown ]] and WALL)<>0;
             WallLeft    :=(Board[i+SquareOffsetForward[dLeft ]] and WALL)<>0;;
             WallRight   :=(Board[i+SquareOffsetForward[dRight]] and WALL)<>0;
             if ((Item and WALL)=0)                                              {not a wall}
                and
                (WallUp or WallDown)                                             {vertical   wall-neigbour}
                and
                (WallRight or WallLeft)                                          {horizontal wall-neighbor}
                then begin                                                       {'Board[i]' is a corner}
                if  (Item and GOAL)=0 then begin
                    Inc(Board[i],FLAG_ILLEGAL_BOX_SQUARE);                       {'Board[i]' is an illegal corner}
                    if (Item and BOX)<>0 then
                       Result:=False;                                            {box on illegal square: deadlock}
                    end;

                Inc(CornerCount);
                Corners[CornerCount].SquareNo:=i;
                FillChar(Corners[CornerCount].EdgeLengths,SizeOf(Corners[CornerCount].EdgeLengths),0);
                if WallUp   and WallLeft  then Include(Corners[CornerCount].Types,ctTopLeft    );
                if WallUp   and WallRight then Include(Corners[CornerCount].Types,ctTopRight   );
                if WallDown and WallLeft  then Include(Corners[CornerCount].Types,ctBottomLeft );
                if WallDown and WallRight then Include(Corners[CornerCount].Types,ctBottomRight);
                end;
             end;
          end;
      with Corners[Succ(CornerCount)] do SquareNo:=High(SquareNo);
    end;

    function  PatternType3Block:Boolean;
    var b,g,i,j,k,m,p:Integer; Direction:TDirection;
    begin
      {$IFDEF CONSOLE_APPLICATION}
        if Game.ShowDeadlockSetsEnabled then Writeln('3-Block');
      {$ENDIF}
      Result:=True;
      for i:=1 to Game.BoardSize do
          if IsAWallSquare(i) then
             for Direction:=Low(Direction) to High(Direction) do begin
                 j:=i+Game.SquareOffsetForward[Direction]; {neighbor square}
                 if (j>=0) and (j<=Game.BoardSize) and
                    IsAFloorSquare(j) and IsALegalBoxSquare(j) and IsABoxReachableSquare(j) and
                    IsAFloorSquare(i+Game.SquareOffsetLeft[Direction]) then begin
                    k:=j+Game.SquareOffsetLeft[Direction];
                    if (k>=0) and (k<=Game.BoardSize) and
                       IsAFloorSquare(k) and IsALegalBoxSquare(k) and IsABoxReachableSquare(k) and
                       IsAFloorSquare(k+Game.SquareOffsetLeft[Direction]) then begin
                       m:=k+Game.SquareOffsetForward[Direction];
                       if (m>=0) and (m<=Game.BoardSize) and
                          IsAFloorSquare(m) and IsALegalBoxSquare(m) and IsABoxReachableSquare(m) and
                          IsAWallSquare (m+Game.SquareOffsetLeft [Direction]) and
                          IsAFloorSquare(m+Game.SquareOffsetRight[Direction]) then begin
                          b:=0; g:=0; p:=0;
                          CountBoxesAndGoalsAndPlayer(j,b,g,p);
                          CountBoxesAndGoalsAndPlayer(k,b,g,p);
                          CountBoxesAndGoalsAndPlayer(m,b,g,p);
                          if (g<3) and
                             InitializeDeadlockSetCandidate(2-b,0,Min(Game.BoxCount,Game.DeadlockSets.BoxLimitForPrecalculatedSets)) then begin
                             AddSquareToDeadlockSet(j);
                             AddSquareToDeadlockSet(k);
                             AddSquareToDeadlockSet(m);
                             CommitDeadlockSet(True,False,False,Result);
                             end;
                          end;
                       end;
                    end;
                 end;
    end;

    function  PatternType4BlockA:Boolean;
    var a,b,c,f,g,h,i,j,k:Integer;
    begin {pattern type "4-Block/A" (can be hard-coded with a tiny speed increase (approx. 3%), see 'IsALegalPush'}
      {$IFDEF CONSOLE_APPLICATION}
        if Game.ShowDeadlockSetsEnabled then Writeln('4-Block/A');
      {$ENDIF}
      Result:=True;
      for i:=0 to Game.BoardSize do begin
          f:=0; g:=0; b:=0; c:=0; {floors, goals, boxes, illegal squares}
          for j:=0 to 1 do
              for k:=0 to 1 do  begin
                  h:=i+j+k*Game.SquareOffsetForward[dDown];
                  if h<=Game.BoardSize then begin
                     a:=Game.Board[h];
                     if (a and FLAG_ILLEGAL_BOX_SQUARE)<>0 then Inc(c);
                     if (a and FLOOR                  )<>0 then Inc(f);
                     if (a and GOAL                   )<>0 then Inc(g);
                     if (a and BOX                    )<>0 then Inc(b);
                     end
                  else Inc(c);
                  end;
          if (c=0) and (g<f) then begin
             if f=b then Result:=False;                                          {'False': start position is a deadlock}
{            // hard-coded version is used instead of deadlock-sets
             if InitializeDeadlockSetCandidate(Pred(f-b),0,Min(Game.BoxCount,Game.DeadlockSets.BoxLimitForPrecalculatedSets)) then begin
                for j:=0 to 1 do
                    for k:=0 to 1 do begin
                        h:=i+j+k*Game.SquareOffsetForward[dDown];
                        if (h<=Game.BoardSize) and ((Game.Board[h] and FLOOR)<>0) then
                           AddSquareToDeadlockSet(h);
                        end;
                CommitDeadlockSet(False,False,Result);
                end;
}
             end;
          end;
    end;

    function  PatternType4BlockB:Boolean;
    var b,g,i,j,p,L1,L2,R1,R2:Integer; Direction:TDirection;
    begin {pattern type "4-Block/B"}
      {$IFDEF CONSOLE_APPLICATION}
        if Game.ShowDeadlockSetsEnabled then Writeln('4-Block/B');
      {$ENDIF}
      Result:=True;
      for i:=0 to Game.BoardSize do
          if IsAFloorSquare(i) and IsALegalBoxSquare(i) and IsABoxReachableSquare(i) then
             for Direction:=Low(Direction) to Succ(Low(Direction)) do begin {caution: 'Succ(Low...'): assumes 4 directions only}
                 j:=i+Game.SquareOffsetForward[Direction]; {neighbor square}
                 if IsAFloorSquare(j) and IsALegalBoxSquare(j) and IsABoxReachableSquare(j) then begin
                    L1:=i+Game.SquareOffsetLeft [Direction];
                    R1:=i+Game.SquareoffsetRight[Direction];
                    L2:=j+Game.SquareoffsetLeft [Direction];
                    R2:=j+Game.SquareOffsetRight[Direction];
                    if (IsAFloorSquare(L1) and IsAFloorSquare(R2)) or
                       (IsAFloorSquare(R1) and IsAFloorSquare(L2)) then // avoid repeating 4-block/A by insisting on at least one floor 'diagonal'
                       if ({check if a box at 'i' can move left or right}
                           IsAWallSquare(L1)
                           or
                           IsAWallSquare(R1)
                           or
                           ((not (IsALegalBoxSquare(L1) and IsABoxReachableSquare(L1)))
                            and {the box at 'i' will be stuck if can't move left or right, even if there aren't any wall neighbors}
                            (not (IsALegalBoxSquare(R1) and IsABoxReachableSquare(R1)))
                           )
                          )
                          and
                          ({check if a box at 'j' can move left or right}
                           IsAWallSquare(L2)
                           or
                           IsAWallSquare(R2)
                           or
                           ((not (IsALegalBoxSquare(L2) and IsABoxReachableSquare(L2)))
                            and {the box at 'i' will be stuck if can't move left or right, even if there aren't any wall neighbors}
                            (not (IsALegalBoxSquare(R2) and IsABoxReachableSquare(R2)))
                           )
                          ) then begin // neigher a box at 'i' or 'j' can move left of right, hence, 'i' and 'j' might be a deadlock
                          b:=0; g:=0; p:=0;
                          CountBoxesAndGoalsAndPlayer(i,b,g,p);
                          CountBoxesAndGoalsAndPlayer(j,b,g,p);
                          if (g<2) and InitializeDeadlockSetCandidate(1-b,0,Min(Game.BoxCount,Game.DeadlockSets.BoxLimitForPrecalculatedSets)) then begin
                             AddSquareToDeadlockSet(i); AddSquareToDeadlockSet(j);
                             CommitDeadlockSet(True,False,False,Result);
                             end;
                          end;
                    end;
                 end;
    end;

    function  PatternTypeDoubleL:Boolean;
    var i,SquareNo:Integer; d,Direction:TDirection;

      function  RelativeSquareNo(SquareNo__,DeltaX__,DeltaY__:Integer; Direction__:TDirection):Integer;
      begin {returns a square number relative to 'SquareNo__'; the deltas refer to the relative distance; heading in the specified direction, 'forward' and 'right' are the positive axis}
        case Direction of {caution: assumes 4 directions only}
          dUp   : Result:=SquareNo__+DeltaX__*Game.SquareOffsetForward[dUp   ]+DeltaY__*Game.SquareOffsetForward[dRight];
          dLeft : Result:=SquareNo__+DeltaX__*Game.SquareOffsetForward[dLeft ]+DeltaY__*Game.SquareOffsetForward[dUp   ];
          dDown : Result:=SquareNo__+DeltaX__*Game.SquareOffsetForward[dDown ]+DeltaY__*Game.SquareOffsetForward[dLeft ];
          else    Result:=SquareNo__+DeltaX__*Game.SquareOffsetForward[dRight]+DeltaY__*Game.SquareOffsetForward[dDown ];
        end; // case
      end;

    begin {pattern type "Double-L"}
      {$IFDEF CONSOLE_APPLICATION}
        if Game.ShowDeadlockSetsEnabled then Writeln('Double-L');
      {$ENDIF}
      Result:=True;
      for i:=1 to Game.BoardSize do
          if IsAFloorSquare(i) then
             for Direction:=Low(Direction) to High(Direction) do
                 if InitializeDeadlockSetCandidate(-1,i,Min(Game.BoxCount,Game.DeadlockSets.BoxLimitForPrecalculatedSets)) then begin
                    for d:=Low(d) to High(d) do begin
                        SquareNo:=i+Game.SquareOffsetForward[d];
                        if IsAFloorSquare(SquareNo) then
                           if   IsALegalAndBoxReachableSquare(SquareNo) then
                                AddSquareToDeadlockSet(SquareNo)
                           else {there cannot be a box at the neighboring floor
                                 square, hence, there cannot be a double-L
                                 fenced-in area;
                                 invalidate the deadlock set candidate
                                }
                                DeadlockSetCandidate__.GoalCount:=Game.BoxCount+2; {'+2': so the count still is too high if the call below to 'RemoveSquareFromDeadlockSet()' substracts 1 from the count}
                        end;

                    SquareNo:=i-Game.SquareOffsetForward[Direction]+Game.SquareOffsetLeft [Direction];
                    if IsALegalAndBoxReachableSquare(SquareNo) and
                       (IsAFloorSquare(i-Game.SquareOffsetForward[Direction])
                        or {avoid squares on the other side of a corner}
                        IsAFloorSquare(i+Game.SquareOffsetLeft [Direction])
                       )
                       then
                       AddSquareToDeadlockSet(SquareNo);
                    SquareNo:=i+Game.SquareOffsetForward[Direction]+Game.SquareOffsetRight[Direction];
                    if IsALegalAndBoxReachableSquare(SquareNo) and
                       (IsAFloorSquare(i+Game.SquareOffsetForward[Direction])
                        or {avoid squares on the other side of a corner}
                        IsAFloorSquare(i+Game.SquareOffsetRight[Direction])
                       )
                       then
                       AddSquareToDeadlockSet(SquareNo);

                    if Direction<=Succ(Low(Direction)) then                     {caution: 'Succ(Low...'): assumes 4 directions only}
                       CommitDeadlockSet(True,False,False,Result);

                    if (not IsALegalAndBoxReachableSquare(RelativeSquareNo(i,1,1,Direction)))
                       and
                       IsALegalAndBoxReachableSquare     (RelativeSquareNo(i,1,-1,Direction))
                       and
                       IsALegalAndBoxReachableSquare     (RelativeSquareNo(i,1,-2,Direction))
                       and
                       IsALegalAndBoxReachableSquare     (RelativeSquareNo(i,0,-2,Direction))
                       and
                       IsAWallSquare                     (RelativeSquareNo(i,0,-1,Direction))
                       and
                       IsAFloorSquare                    (RelativeSquareNo(i,1,-3,Direction))
                       and
                       (not IsALegalAndBoxReachableSquare(RelativeSquareNo(i,1,-3,Direction))) then
                       with DeadlockSetCandidate__ do begin
                         RemoveSquareFromDeadlockSet     (RelativeSquareNo(i,1,-1,Direction));
                         AddSquareToDeadlockSet          (RelativeSquareNo(i,1,-2,Direction));
                         AddSquareToDeadlockSet          (RelativeSquareNo(i,0,-2,Direction));
                         EscapedBoxesCountDown:=Boxes.Count; {all boxes must escape the fenced-in area; otherwise it's a deadlock}
                         //Game.Board[MAX_BOARD_SIZE]:=FLOOR; {'FLOOR': debug the search}
                         CommitDeadlockSet(True,False,False,Result);
                         //Game.Board[MAX_BOARD_SIZE]:=WALL;
                         end;
                    end;
    end;

    function  PatternTypeBlockedTunnel:Boolean;
    var i:Integer; Direction:TDirection;
    begin {pattern type "Blocked tunnel"}
      {$IFDEF CONSOLE_APPLICATION}
        if Game.ShowDeadlockSetsEnabled then Writeln('Blocked tunnel');
      {$ENDIF}
      Result:=True;
      for i:=1 to Game.BoardSize do
          if IsAFloorSquare(i) and (not IsAGoalSquare(i)) then
             for Direction:=Low(Direction) to High(Direction) do
                 if IsAWallSquare            (i+Game.SquareOffsetLeft   [Direction]) and
                    IsAWallSquare            (i+Game.SquareOffsetRight  [Direction]) and
                    IsALegalBoxSquare        (i-Game.SquareOffsetForward[Direction]) and
                    IsALegalBoxSquare        (i+Game.SquareOffsetForward[Direction]) and
                    (IsAWallSquare           (i+Game.SquareOffsetForward[Direction]+Game.SquareOffsetLeft [Direction])
                     or
                     IsAWallSquare           (i+Game.SquareOffsetForward[Direction]+Game.SquareOffsetRight[Direction])
                    ) then begin
                    if IsALegalBoxSquare     (i-Game.SquareOffsetForward[Direction]+Game.SquareOffsetRight[Direction]) and
                       InitializeDeadlockSetCandidate (-1,i,Min(Game.BoxCount,Game.DeadlockSets.BoxLimitForPrecalculatedSets)) then begin
                       AddSquareToDeadlockSet(i+Game.SquareOffsetForward[Direction]);
                       AddSquareToDeadlockSet(i-Game.SquareOffsetForward[Direction]);
                       AddSquareToDeadlockSet(i-Game.SquareOffsetForward[Direction]+Game.SquareOffsetRight[Direction]);
                       CommitDeadlockSet(True,False,False,Result);
                       end;
                    if IsALegalBoxSquare     (i-Game.SquareOffsetForward[Direction]+Game.SquareOffsetLeft [Direction]) and
                       InitializeDeadlockSetCandidate (-1,i,Min(Game.BoxCount,Game.DeadlockSets.BoxLimitForPrecalculatedSets)) then begin
                       AddSquareToDeadlockSet(i+Game.SquareOffsetForward[Direction]);
                       AddSquareToDeadlockSet(i-Game.SquareOffsetForward[Direction]);
                       AddSquareToDeadlockSet(i-Game.SquareOffsetForward[Direction]+Game.SquareOffsetLeft [Direction]);
                       CommitDeadlockSet(True,False,False,Result);
                       end;
                    end;
    end;

    function  PatternTypeBlockedGateAndOneWayTunnel:Boolean;
    var BoxNo,g,GoalCount,NeighborSquare,OldPlayerPos,OppositeNeighborSquare,Square,Square2:Integer;
        Direction:TDirection;

      function MakeGateDeadlockCandidate(Square1__,Square2__,Square3__:Integer; Direction__:TDirection):Boolean;
      begin
       {preconditions:
        'Square1__' is the gate square or the square above the gate square (see figures below);
        'Square2__' is the squares inside the deadlocked area;
        'Square3__' (if present) is the neighbor square outside the area in patterns E..G;

        patterns:
                                     %%     %%     %%
         #%#    #%#    #%#    #-#    #-#    #-#    #-#
                 %      -      %             %      -
                        %      %                    %
          A      B      C      D     E       F      G
        }

        if Square2__=0 then Square2__:=Square1__; {this simplifies the following tests}
        if Square3__=0 then Square3__:=Square2__; {this simplifies the following tests}

        Result:=IsALegalAndBoxReachableSquare(Square1__) and
                IsALegalAndBoxReachableSquare(Square2__) and
                IsALegalAndBoxReachableSquare(Square3__) and
                (not (IsAGoalSquare(Square1__) and IsAGoalSquare(Square2__) and IsAGoalSquare(Square3__))) and
                ((Square2__=Square1__) {pattern A or E}
                 or
                 (Square3__=Square2__) {not patterns E,F,G}
                 or
                 ({check patterns F,G}
                  not (IsAGoalSquare(Square1__+Game.SquareOffsetForward[Direction__])
                       and {'True': the floor squares between the two boxes in the same row in pattern F and G aren't goals; that's the easiest check, even though it's bit more strict than it needs to be}
                       IsAGoalSquare(Square2__-Game.SquareOffsetForward[Direction__])
                      )
                 )
                ) and
                (not ((Square2__    =Square1__+Game.SquareOffsetForward[Direction__])
                      and
                      (IsAWallSquare(Square2__+Game.SquareOffsetLeft   [Direction__]) {caution: assumes 4 directions only}
                       or
                       IsAWallSquare(Square2__+Game.SquareOffsetRight  [Direction__])
                      )
                      {the two neighboring bozes freeze at the squares;}
                      {if it's a deadlock, then it's caught during the search by}
                      {'IsALegalPush()'; an example:}
                      {#%# }
                      {#%_#}
                     )
                ) and
                InitializeDeadlockSetCandidate(-1,0,Min(Game.BoxCount,Game.DeadlockSets.BoxLimitForPrecalculatedSets)) and
                AddSquareToDeadlockSet(Square1__) and
                ((Square2__=Square1__) or AddSquareToDeadlockSet(Square2__)) and
                ((Square3__=Square2__) or AddSquareToDeadlockSet(Square3__));
        if      Result then begin
                if                             (Game.Board[Square1__] and BOX)=0  then Inc(DeadlockSetCandidate__.Capacity);
                if (Square2__<>Square1__) and ((Game.Board[Square2__] and BOX)=0) then Inc(DeadlockSetCandidate__.Capacity);
                if (Square3__<>Square2__) and ((Game.Board[Square3__] and BOX)=0) then Inc(DeadlockSetCandidate__.Capacity);

                if (Square2__=Square1__+Game.SquareOffsetForward[Direction__]) and
                   (not IsALegalAndBoxReachableSquare(Square2__+Game.SquareOffsetLeft [Direction__])) and {caution: assumes 4 directions only}
                   (not IsALegalAndBoxReachableSquare(Square2__+Game.SquareOffsetRight[Direction__])) and
                   IsAWallSquare(                     Square1__+Game.SquareOffsetLeft [Direction__])  and
                   IsAWallSquare(                     Square1__+Game.SquareOffsetRight[Direction__])  then begin
                   {a box at the neighbor square cannot move along the other axis,}
                   {hence, the deadlock situation doesn't depend on the push direction;}
                   {an example with push direction 'down':}
                   { #%#}
                   {#_%_#}
                   end
                else begin
                   Include(DeadlockSetCandidate__.Flags,DIRECTION_TO_DEADLOCK_SET_FLAG[Direction__]);
                   Include(DeadlockSetCandidate__.Flags,dsfPlayerMustBeOutsideSet);
                   if Square3__<>Square2__ then begin {'True': patterns E,F,G}
                      Include(DeadlockSetCandidate__.Flags,dsfIsADeadlock); {force 'CommitDeadlockSet()' to accept the deadlock even though the number of inner goal squares may exceed the number of boxes}
                      DeadlockSetCandidate__.CenterSquare:=Square1__+Game.SquareOffsetForward[Direction__];

                      Square3__:=Square1__+(Square1__-Square3__); {the neighbor of 'Square1__' in the opposite direction of 'Square3__'}
                      if   IsAFloorSquare(Square3__) then begin
                           DeadlockSetCandidate__.SquareOutsideFence:=-Square3__; {'-Square3__': the negated value makes 'CommitDeadlockSet()' use the (absolute) value instead of resetting the value}
                           Include(DeadlockSetCandidate__.Flags,dsfIsOnlyADeadlockForListedPlayerAccessAreasOutsideFence);
                           if OldPlayerPos=DeadlockSetCandidate__.CenterSquare then {'True': the player is located at the gate square in the starting position}
                              {if the player is located at the gate square in
                               the starting position, then the push direction
                               cannot guarantee that the player is outside the
                               deadlocked boxes; an example with push direction
                               'left':
                               --#%
                               %-@%
                               --#-
                              }
                              Exclude(DeadlockSetCandidate__.Flags,DIRECTION_TO_DEADLOCK_SET_FLAG[Direction__]); {remove the 'this push direction guarantees it is a deadlock' flag again; the flag was set a few lines above}
                           end
                      else Result:=False; {this should not happen unless the caller passed invalid parameters}
                      end;
                   end;
                end;
      end;

      function  MakeExtendedGateSquareDeadlockSets(Square__,NeighborSquare__:Integer; Direction__:TDirection; var Result__:Boolean):Integer;
      var Square3:Integer;
      begin {produces deadlock patterns E,F,G in the figure above; caution: assumes 4 directions only}
        Result:=0;
        if NeighborSquare__=Square__ then NeighborSquare__:=0; {'True': variant E in the preceding 'MakeGateDeadlockCandidate()' function}
        Dec(Square__,Game.SquareOffsetForward[Direction__]);

        Square3:=Square__+Game.SquareOffsetLeft [Direction__];
        if MakeGateDeadlockCandidate(Square__,NeighborSquare__,Square3,Direction__) and
           CommitDeadlockSet(False,False,True,Result__) then {'AcceptPseudoLegalSets' = 'True': because without search in 'CommitDeadlockSet', the deadlock set candidate is validated for the existing board state}
           Inc(Result);

        Square3:=Square__+Game.SquareOffsetRight[Direction__];
        if MakeGateDeadlockCandidate(Square__,NeighborSquare__,Square3,Direction__) and
           CommitDeadlockSet(False,False,True,Result__) then {'AcceptPseudoLegalSets' = 'True': because without search in 'CommitDeadlockSet', the deadlock set candidate is validated for the existing board state}
           Inc(Result);
      end;

    begin {PatternTypeBlockedGateAndOneWayTunnel}
      {$IFDEF CONSOLE_APPLICATION}
        if Game.ShowDeadlockSetsEnabled then Writeln('Blocked gate');
      {$ENDIF}
      Result:=True;
      OldPlayerPos:=Game.PlayerPos;
      MovePlayer(0);
      for BoxNo:=1 to Game.BoxCount do Dec(Game.Board[Game.BoxPos[BoxNo]],BOX);

      with Solver.SearchStates[0].PlayersReachableSquares do begin
        {find all "#_#" gates on the board}
        for Square:=0 to Game.BoardSize do
            if IsALegalAndBoxReachableSquare(Square)
               and                                                              {caution: assumes 4 directions only}
               (
                (IsAWallSquare(Square+Game.SquareOffsetForward[dUp])
                 and
                 IsAWallSquare(Square+Game.SquareOffsetForward[dDown])
                )
                or
                (IsAWallSquare(Square+Game.SquareOffsetForward[dLeft])
                 and
                 IsAWallSquare(Square+Game.SquareOffsetForward[dRight])
                )
               )
               then {'True': the square is surrounded by walls along at least one axis}
               for Direction:=Low(Direction) to High(Direction) do begin
                   NeighborSquare        :=Square+Game.SquareOffsetForward[Direction];
                   OppositeNeighborSquare:=Square-Game.SquareOffsetForward[Direction];
                   if IsALegalAndBoxReachableSquare(NeighborSquare)
                      and
                      IsALegalAndBoxReachableSquare(OppositeNeighborSquare)
                      then begin
{                     // don't make a freeze-test for the boxes; 'IsALegalPush()' catches simple 4-blocks during the solver search, but for speed it doesn't perform a full freeze-test
                      Inc(Game.Board[Square],BOX); // temporarily put a box at the base square so 'IsAFreezingMove()' can be used
                      if IsAFreezingMove(0,        NeighborSquare) then         NeighborSquare:=0;
                      if IsAFreezingMove(0,OppositeNeighborSquare) then OppositeNeighborSquare:=0;
                      Dec(Game.Board[Square],BOX);
}
                      if IsAGateSquare(Square) then begin                       {'True': this is a gate square that separates the board in 2 separate rooms}
                         for BoxNo:=1 to Game.BoxCount do Inc(Game.Board[Game.BoxPos[BoxNo]],BOX); {put boxes back on the board for correct capacity calculation}

                         if NeighborSquare<>0 then begin
                            GoalCount:=0;
                            if IsAGoalSquare(Square        ) then Inc(GoalCount);
                            if IsAGoalSquare(NeighborSquare) then Inc(GoalCount);

                            Square2:=NeighborSquare; {check if this is a 1-way tunnel}
                            g:=GoalCount;
                            while (g=0) and
                                  IsAWallSquare(Square2+Game.SquareOffsetLeft [Direction]) and {caution: assumes 4 directions only}
                                  IsAWallSquare(Square2+Game.SquareOffsetRight[Direction]) and {caution: assumes 4 directions only}
                                  IsALegalAndBoxReachableSquare(Square2+Game.SquareOffsetForward[Direction]) do begin
                                  Inc(Square2,Game.SquareOffsetForward[Direction]);
                                  if IsAGoalSquare(Square2) then Inc(g);
                                  end;
                            if    (g=0) and
                                  (not IsALegalAndBoxReachableSquare(Square2+Game.SquareOffsetForward[Direction])) then begin
                                  {a 1-way tunnel}
                                  NeighborSquare:=Square;
                                  end;

                            if    MakeGateDeadlockCandidate(Square,NeighborSquare,0,Direction) and
                                  CommitDeadlockSet(False,False,False,Result) then begin
                                  MakeExtendedGateSquareDeadlockSets(Square,NeighborSquare,Direction,Result);

                                  if (NeighborSquare=Square+Game.SquareOffsetForward[Direction]) then begin

                                     {try to make a deadlock set by pushing the secondary}
                                     {box one square further into the room or the tunnel like in this example:}
                                     {#                        }
                                     {%-%  direction is 'right'}
                                     {#                        }
                                     if MakeGateDeadlockCandidate(Square,NeighborSquare+Game.SquareOffsetForward[Direction],0,Direction) then begin
                                        if IsAGoalSquare(NeighborSquare+Game.SquareOffsetForward[Direction]) then Inc(GoalCount);
                                        if (GoalCount<2) and
                                           CommitDeadlockSet(False,False,False,Result) then
                                           MakeExtendedGateSquareDeadlockSets(Square,NeighborSquare+Game.SquareOffsetForward[Direction],Direction,Result);

                                        {try to make a deadlock set by pushing both the primary and the secondary}
                                        {box into the room or the tunnel like in this example:}
                                        {#                        }
                                        {-%%  direction is 'right'}
                                        {#                        }
                                        if IsAFloorSquare(NeighborSquare+Game.SquareOffsetLeft [Direction]) and
                                           IsAFloorSquare(NeighborSquare+Game.SquareOffsetRight[Direction]) and
                                           MakeGateDeadlockCandidate(NeighborSquare,NeighborSquare+Game.SquareOffsetForward[Direction],0,Direction) then
                                           CommitDeadlockSet(False,False,False,Result);
                                        end;
                                     end;
                                  end;
                            end;

                         if OppositeNeighborSquare<>0 then begin
                            GoalCount:=0;
                            if IsAGoalSquare(Square                ) then Inc(GoalCount);
                            if IsAGoalSquare(OppositeNeighborSquare) then Inc(GoalCount);

                            Square2:=OppositeNeighborSquare; {check if this is a 1-way tunnel}
                            g:=GoalCount;
                            while (g=0) and
                                  IsAWallSquare(Square2+Game.SquareOffsetLeft [Direction]) and {caution: assumes 4 directions only}
                                  IsAWallSquare(Square2+Game.SquareOffsetRight[Direction]) and {caution: assumes 4 directions only}
                                  IsALegalAndBoxReachableSquare(Square2-Game.SquareOffsetForward[Direction]) do begin
                                  Dec(Square2,Game.SquareOffsetForward[Direction]);
                                  if IsAGoalSquare(Square2) then Inc(g);
                                  end;
                            if    (g=0) and
                                  (not IsALegalAndBoxReachableSquare(Square2-Game.SquareOffsetForward[Direction])) then begin
                                  {a 1-way tunnel}
                                  OppositeNeighborSquare:=Square;
                                  end;

                            if    MakeGateDeadlockCandidate(Square,OppositeNeighborSquare,0,OPPOSITE_DIRECTION[Direction]) and
                                  CommitDeadlockSet(False,False,False,Result) then begin
                                  MakeExtendedGateSquareDeadlockSets(Square,OppositeNeighborSquare,OPPOSITE_DIRECTION[Direction],Result);

                                  if (OppositeNeighborSquare=Square-Game.SquareOffsetForward[Direction]) then begin

                                     {try to make a deadlock set by pushing the secondary}
                                     {box one square further into the room or the tunnel like in this example:}
                                     {#                        }
                                     {%-%  direction is 'right'}
                                     {#                        }
                                     if MakeGateDeadlockCandidate(Square,OppositeNeighborSquare-Game.SquareOffsetForward[Direction],0,OPPOSITE_DIRECTION[Direction]) then begin
                                        if IsAGoalSquare(OppositeNeighborSquare-Game.SquareOffsetForward[Direction]) then Inc(GoalCount);
                                        if (GoalCount<2) and
                                           CommitDeadlockSet(False,False,False,Result) then
                                           MakeExtendedGateSquareDeadlockSets(Square,OppositeNeighborSquare-Game.SquareOffsetForward[Direction],OPPOSITE_DIRECTION[Direction],Result);

                                        {try to make a deadlock set by pushing both the primary and the secondary}
                                        {box into the room or the tunnel like in this example:}
                                        {#                        }
                                        {-%%  direction is 'right'}
                                        {#                        }
                                        if IsAFloorSquare(OppositeNeighborSquare+Game.SquareOffsetLeft [Direction]) and
                                           IsAFloorSquare(OppositeNeighborSquare+Game.SquareOffsetRight[Direction]) and
                                           MakeGateDeadlockCandidate(OppositeNeighborSquare,OppositeNeighborSquare-Game.SquareOffsetForward[Direction],0,OPPOSITE_DIRECTION[Direction]) then
                                           CommitDeadlockSet(False,False,False,Result);
                                        end;
                                     end;
                                  end;
                            end;

                         for BoxNo:=1 to Game.BoxCount do Dec(Game.Board[Game.BoxPos[BoxNo]],BOX); {remove boxes again}
                         end
                      else begin {the square isn't a gate square, i.e., it doesn't split the board in two separate rooms}
                         if (NeighborSquare<>0)
                            and
                            (not IsAGoalSquare(NeighborSquare))
                            and
                            ((Game.Board[NeighborSquare+Game.SquareOffsetLeft [Direction]] and (WALL+FLOOR+FLAG_ILLEGAL_BOX_SQUARE))=FLOOR+FLAG_ILLEGAL_BOX_SQUARE)
                            and
                            ((Game.Board[NeighborSquare+Game.SquareOffsetRight[Direction]] and (WALL+FLOOR+FLAG_ILLEGAL_BOX_SQUARE))=FLOOR+FLAG_ILLEGAL_BOX_SQUARE) then begin
                            {example:                  }
                            {  #-%-#                   }
                            {  ?#%#?  direction is 'up'}
                            if InitializeDeadlockSetCandidate(1,0,Min(Game.BoxCount,Game.DeadlockSets.BoxLimitForPrecalculatedSets)) and
                               AddSquareToDeadlockSet(Square) and
                               AddSquareToDeadlockSet(NeighborSquare) then begin
                               for BoxNo:=1 to Game.BoxCount do Inc(Game.Board[Game.BoxPos[BoxNo]],BOX); {put boxes back on the board for correct capacity calculation}
                               if (Game.Board[Square        ] and BOX)<>0 then Dec(DeadlockSetCandidate__.Capacity);
                               if (Game.Board[NeighborSquare] and BOX)<>0 then Dec(DeadlockSetCandidate__.Capacity);
                               CommitDeadlockSet(False,False,False,Result);
                               for BoxNo:=1 to Game.BoxCount do Dec(Game.Board[Game.BoxPos[BoxNo]],BOX); {remove boxes again}
                               end;
                            end;
                         end;
                      end;
                   end;
        end;

      for BoxNo:=1 to Game.BoxCount do Inc(Game.Board[Game.BoxPos[BoxNo]],BOX);
      MovePlayer(OldPlayerPos);
      Result:=True;
    end;

    function  PatternTypeClosedEdgeWithoutGoals:Boolean;
    var a,a1,a2,b,c,c1,d,d1,e,g,i,j,k,p,dx,dy,Col1,Row1,Col2,Row2:Integer; Direction:TDirection;
    begin {side-effect: calculates edge-lengths for each corner}
      {$IFDEF CONSOLE_APPLICATION}
        if Game.ShowDeadlockSetsEnabled then Writeln('Closed edge without goals');
      {$ENDIF}
      Result:=True;
      for i:=1 to Pred(CornerCount) do with Corners[i] do begin
          SquareToColRow(SquareNo,Col1,Row1);
          for j:=Succ(i) to CornerCount do begin                                {for each pair of corners...}
              SquareToColRow(Corners[j].SquareNo,Col2,Row2);
              if (Col1=Col2) or (Row1=Row2) then begin                          {corners are on same column or on same row}
                 dx:=Col2-Col1;  dy:=Row2-Row1;
                 k:=Pred(Max(Abs(dx),Abs(dy)));                                 {k = number of squares BETWEEN the endpoints i and j}
                 if dx<>0 then dx:=dx div Abs(dx);                              {make dx,dy to directions, i.e., -1, 0, or 1}
                 if dy<>0 then dy:=dy div Abs(dy);
                 Direction:=DxDyToDirection(dx,dy);
                 a:=SquareNo; c:=0; d:=0; c1:=0; d1:=0; b:=0; g:=0; p:=0;       {b=boxes, g=goals, p=player}

                 for e:=0 to Succ(k) do begin      {for each square from corner 'i' to corner 'j', including the endpoints}
                     if (Game.Board[a] and WALL)=0 then begin
                        CountBoxesAndGoalsAndPlayer(a,b,g,p);
                        a1:=a+Game.SquareOffsetLeft [Direction];
                        a2:=a+Game.SquareOffsetRight[Direction];
                        if      (Game.Board[a1] and FLOOR)= 0 then Inc(c )      {the square on adjacent side 1 is blocked}
                        else if (Game.Board[a2] and FLOOR)= 0 then Inc(c1);     {opposite side is blocked, i.e., side 2}
                        if      (Game.Board[a2] and FLOOR)= 0 then Inc(d )      {the square on adjacent side 2 is blocked}
                        else if (Game.Board[a1] and FLOOR)= 0 then Inc(d1);     {opposite side is blocked, i.e., side 1}
                        Inc(a,Game.SquareOffsetForward[Direction]);
                        end
                     else break; {non-floor square: the direct line between endpoints i and j is broken}
                     end;

                 if (c+c1=k+2) or (d+d1=k+2) then begin
                    {the squares between the end-points are free, and one of the adjacent sides are blocked, or each square is blocked by a wall on either side,}
                    {thus, a box can never get away from the line, i.e., it's a 'closed edge'}

                    Corners[i].EdgeLengths[Direction]:=k+2;                     {save the line for later calculation of adjacent-line patterns ('+2': including endpoints)}

                    if b>g then Result:=False;                                  {more boxes than goals: deadlock}

                    if g=0 then                                                 {no goals between or at the endpoints}
                       for e:=1 to k do                                         {flag squares as simple illegal squares}
                           Game.Board[SquareNo+e*Game.SquareOffsetForward[Direction]]:=Game.Board[SquareNo+e*Game.SquareOffsetForward[Direction]] or FLAG_ILLEGAL_BOX_SQUARE;

                    if IsAGoalSquare(Corners[j].SquareNo) then
                       Corners[j].EdgeLengths[OPPOSITE_DIRECTION[Direction]]:=  {creating union-sets requires that}
                         Corners[i].EdgeLengths[Direction];                     {the other corner knows about this edge}
                    end
                 else {the line between the corners 'i' and 'j' isn't a closed edge}
                    if a=Corners[j].SquareNo+Game.SquareOffsetForward[Direction] then begin {'True': there is an open line between the corner 'i' and 'j'; it's just not a closed edge but an "open edge" from which boxes can escape}
                       Corners[i].EdgeLengths[Direction]:=-(k+2);               {save the line for later calculation of open line patterns ('+2': including endpoints; negated: it's an "open edge" and not a "closed edge")}
{
                       ShowBoard;
                       Write(SquareToColRowAsText(Corners[i].SquareNo),'-->',SquareToColRowAsText(Corners[j].SquareNo));
                       Readln;
}
                       end;
                 end;
              end;
          end;
    end;

    function  PatternTypeClosedEdgeWithGoals:Boolean;
    var a,b,g,i,j,p,NewSetsCount:Integer;
        IsAGoalCorner:Boolean;
        d,Direction:TDirection;
        SetCapacities:TDirectionArrayOfIntegers;
        SetSquares   :array[TDirection] of TBoardSquareSet;
    begin {pattern type "Closed edge with goals"}
      {$IFDEF CONSOLE_APPLICATION}
        if Game.ShowDeadlockSetsEnabled then Writeln('Closed edge with goals');
      {$ENDIF}
      Result:=True;
      for i:=1 to CornerCount do with Corners[i] do begin
          NewSetsCount :=0;                                                      {'0': no deadlock sets created for this corner yet}
          IsAGoalCorner:=(Game.Board[SquareNo] and (GOAL+FLAG_ILLEGAL_BOX_SQUARE+FLAG_BOX_REACHABLE_SQUARE))
                           = GOAL+FLAG_BOX_REACHABLE_SQUARE;

          for Direction:=Low(Direction) to High(Direction) do begin
              SetSquares[Direction].Count:=0;
              if EdgeLengths[Direction]>0 then begin                            {for each closed edge starting from this corner...}
                 a:=SquareNo; b:=0; g:=0; p:=0;                                 {b=boxes, g=goals, p=player}
                 for j:=1 to EdgeLengths[Direction] do begin                    {for each floor-square along the edge}
                     CountBoxesAndGoalsAndPlayer(a,b,g,p);
                     Inc(a,Game.SquareOffsetForward[Direction]);
                     end;

                 if b>g then Result:=False;                                     {more boxes than goals: deadlock}

                 if (g<>0) and                                                  {'g<>0': goals on the closed edge}
                    InitializeDeadlockSetCandidate(g-b,0,Game.BoardSize) then begin {'BoardSize': allow more box-squares than boxes on the board}
                    a:=SquareNo;
                    for j:=1 to EdgeLengths[Direction] do begin                 {add each square in the line to the deadlock-set}
                        if IsALegalBoxSquare(a) and IsABoxReachableSquare(a) then
                           AddSquareToDeadlockSet(a);
                        Inc(a,Game.SquareOffsetForward[Direction]);
                        end;

                    if IsAGoalCorner and
                       (DeadlockSetCandidate__.Boxes.Count>0) and
                       (EdgeLengths[Direction]>2) then begin
                       Inc(NewSetsCount);
                       SetCapacities[Direction]:=DeadlockSetCandidate__.Capacity; {save the set information for later}
                       SetSquares[Direction]   :=DeadlockSetCandidate__.Boxes;
                       end;

                    CommitDeadlockSet(True,False,False,Result);
                    end;
                 end;
              end;

          if NewSetsCount>1 then                                                {'True': make union sets (the sets shares the corner goal square)}
             for Direction:=Low(Direction) to High(Direction) do
                 if (SetSquares[Direction].Count<>0) and
                    InitializeDeadlockSetCandidate(SetCapacities[Direction],0,Game.BoardSize) then begin
                    DeadlockSetCandidate__.Boxes:=SetSquares[Direction];
                    if Direction<High(Direction) then
                       for d:=Succ(Direction) to High(Direction) do
                           if SetSquares[d].Count<>0 then with SetSquares[d] do
                              for j:=1 to Count do begin
                                  a:=Squares[j];
                                  if a<>SquareNo then begin
                                     AddSquareToDeadlockSet(a);                 {add the squares from this set}
                                     if   IsABoxSquare(a) then
                                          if   IsAGoalSquare(a) then {}
                                          else Dec(DeadlockSetCandidate__.Capacity)
                                     else if   IsAGoalSquare(a) then
                                               Inc(DeadlockSetCandidate__.Capacity);
                                     end;
                                  end;
                    if  DeadlockSetCandidate__.Boxes.Count<>SetSquares[Direction].Count then {'True': extra squares were added}
                        CommitDeadlockSet(True,False,True,Result);
                 end;
          end;
    end;

    function  PatternTypeClosedEdgeFence:Boolean;
    var a,b,g,i,j,p,ClosedEdgeCapacity:Integer; Direction:TDirection;
        IsIllegalSquare:TBoardOfBooleans;
    begin {pattern type "Closed edge fence"}
      {$IFDEF CONSOLE_APPLICATION}
        if Game.ShowDeadlockSetsEnabled then Writeln('Closed edge fence');
      {$ENDIF}
      Result:=True;
      for i:=1 to Pred(CornerCount) do with Corners[i] do
          for Direction:=Low(Direction) to High(Direction) do
              if (EdgeLengths[Direction]>0) and                                 {for each closed edge starting from this corner...}
                 InitializeDeadlockSetCandidate(-1,SquareNo,Min(Game.BoxCount,Game.DeadlockSets.BoxLimitForPrecalculatedSets)) then begin
                 InitializeSquareColors;
                 a:=SquareNo; b:=0; g:=0; p:=0;                                 {b=boxes, g=goals, p=player}
                 for j:=0 to Pred(EdgeLengths[Direction]) do begin
                     CountBoxesAndGoalsAndPlayer(a,b,g,p);
                     DeadlockSetCandidate__.SquareColors[a]:=scLightGray;       {mark each square along the edge as visited}
                     Inc(a,Game.SquareOffsetForward[Direction]);                {next square on the closed edge}
                     end;

                 ClosedEdgeCapacity:=g-b; a:=SquareNo;
                 if ClosedEdgeCapacity<=0 then                                  {filled closed edge: no boxes can advance to}
                    for j:=0 to Pred(EdgeLengths[Direction]) do begin           {the center line, hence mark all squares}
                        IsIllegalSquare[a]:=(Game.Board[a] and FLAG_ILLEGAL_BOX_SQUARE)<>0; {along the center line as illegal}
                        Game.Board[a]:=Game.Board[a] or FLAG_ILLEGAL_BOX_SQUARE;
                        Inc(a,Game.SquareOffsetForward[Direction]);             {next square on the closed edge}
                        end;

                 for b:=0 to 1 do {first pass: fill with boxes; second pass: try to fence in any remaining floor-squares}
                     for g:=0 to 1 do                                           {left and right adjacent lines}
                         for j:=0 to Pred(EdgeLengths[Direction]) do            {for each square along the edge}
                             if DeadlockSetCandidate__.GoalCount<=Game.BoxCount then begin
                                a:=SquareNo+j*Game.SquareOffsetForward[Direction];
                                if g=0 then Inc(a,Game.SquareOffsetLeft [Direction])
                                else        Inc(a,Game.SquareOffsetRight[Direction]);
                                if DeadlockSetCandidate__.SquareColors[a]=scWhite then
                                   if b=0 then TryBox(a)                        {first pass: try to fill adjacent lines with boxes}
                                   else if not TryFloor(a) then                 {second pass: try to fence in any remaining floor-squares}
                                           DeadlockSetCandidate__.GoalCount:=Succ(Game.BoxCount); {fail}
                                end;

                 CommitDeadlockSet(True,True,False,Result); {'True': expand sets while goals on the closed edge are initialized as good as possible}

                 a:=SquareNo;
                 if ClosedEdgeCapacity<=0 then                                  {restore board flags}
                    for j:=0 to Pred(EdgeLengths[Direction]) do begin
                        if not IsIllegalSquare[a] then Dec(Game.Board[a],FLAG_ILLEGAL_BOX_SQUARE);
                        Inc(a,Game.SquareOffsetForward[Direction]);             {next square on the closed edge}
                        end;
                 end;
    end;

    function  PatternTypeDiagonalClosedEdgeFence:Boolean;
    var a,i,j,Length,Step:Integer; CornerType:TCornerType; //Direction:TDirection;
    begin {pattern type "Diagonal closed edge fence"}
      {$IFDEF CONSOLE_APPLICATION}
        if Game.ShowDeadlockSetsEnabled then Writeln('Diagonal closed edge fence');
      {$ENDIF}
      Result:=True;
      //Game.ShowDeadlockSetsEnabled:=True;
      for i:=1 to Pred(CornerCount) do with Corners[i] do
          for CornerType:=Low(CornerType) to High(CornerType) do
              if CornerType in Types then begin
                 if   CornerType in [ctTopLeft,ctBottomRight] then
                      Step:=Game.BoardWidth+2-1                                 {"/" diagonal}
                 else Step:=Game.BoardWidth+2+1;                                {"\" diagonal}
                 if (Game.Board[SquareNo-Step] and WALL)<>0 then begin          {'True': the diagonal ends with a wall in the opposite direction of 'Step'}
                    a:=SquareNo; Length:=0; j:=Succ(i);
                    repeat                                                      {walk along the diagonal}
                      Inc(Length); Inc(a,Step);
                      if (Game.Board[a] and WALL)=0 then
                         while Corners[j].SquareNo<a do Inc(j);
                    until Corners[j].SquareNo<>a;                               {until a non-corner square is met}
                    if ((Game.Board[a] and WALL)<>0) and {'True': the diagonal ends with a wall and all of its inner squares are corners}
                       (Length>1) and
                       (Length<=Min(Game.BoxCount,Game.DeadlockSets.BoxLimitForPrecalculatedSets)) and
                       InitializeDeadlockSetCandidate(-1,SquareNo,Min(Game.BoxCount,Game.DeadlockSets.BoxLimitForPrecalculatedSets)) then begin
                       case CornerType of
                         ctTopLeft       : a:=Succ(SquareNo);
                         ctTopRight      : a:=Pred(SquareNo);
                         ctBottomLeft    : a:=SquareNo-Game.BoardWidth-2;
                         else              a:=SquareNo-Game.BoardWidth-2;       {ctBottomRight}
                       end; {case}
                       repeat
                          if (Game.Board[a] and WALL)=0 then AddSquareToDeadlockSet(a);
                          Inc(a,Step); Dec(Length);
                       until Length<0;
                       Include(DeadlockSetCandidate__.Flags,dsfDiagonalCenterSquares);
                       CommitDeadlockSet(True,True,False,Result);
                       end;
                    end;
                 end;
      //Game.ShowDeadlockSetsEnabled:=False;
    end;

    function  PatternTypeSemiClosedLine:Boolean;
    var a,b,g,i,j,k,LineLength:Integer; Direction:TDirection;
        BoxSquaresAtLine,BoxSquaresAtAdjacentLine:TBoxSquareSet;
        SemiClosedLineDeadlock: TDeadlockSetCandidate;
    begin {pattern type "Semi-closed line"}
      {$IFDEF CONSOLE_APPLICATION}
        if Game.ShowDeadlockSetsEnabled then Writeln('Semi-closed line');
      {$ENDIF}
      Result:=True;
      for i:=1 to Pred(CornerCount) do with Corners[i] do
          for Direction:=Low(Direction) to High(Direction) do
              if (EdgeLengths[Direction]<0) then begin                          {for each open edge starting from this corner...}
                 for g:=0 to 1 do                                               {for left and right adjacent lines}
                     if InitializeDeadlockSetCandidate(-1,0,Min(Game.BoxCount,Game.DeadlockSets.BoxLimitForPrecalculatedSets)) then begin
                        LineLength:=Abs(EdgeLengths[Direction]);
                        a:=SquareNo;                                            {get the starting square for the line}
                        k:=a;                                                   {'k' = first/next square on the line which must be filled with a box in order to create a deadlock set}
                        BoxSquaresAtLine.Count:=0;
                        BoxSquaresAtAdjacentLine.Count:=0;

                        for j:=0 to Pred(LineLength) do begin                   {for each square in the adjacent line along the edge}
                            if (a=k) and (not IsALegalAndBoxReachableSquare(a)) then begin {'True': the square cannot accomodate a box}
                               if j=Pred(LineLength) then LineLength:=-Abs(LineLength); {'True': fail; the last box cannot be added to close the deadlock set}
                               Inc(k,Game.SquareOffsetForward[Direction]);      {prepare to put a box at the next square on the line}
                               end;

                            if g=0 then b:=a+Game.SquareOffsetLeft [Direction]
                            else        b:=a+Game.SquareOffsetRight[Direction];
                            if IsAFloorSquare(b) then                           {'True': there is a hole (a floor square) in the adjacent line}
                               if   IsAWallSquare(b-Game.SquareOffsetForward[Direction]) and
                                    IsAWallSquare(b+Game.SquareOffsetForward[Direction]) and {'True': the hole in the adjacent line is only one square wide}
                                    (a=k) then begin                            {'True': the gap is next to the square on the line which also must be filled in order to create a deadlock situation}
                                    if   TryBox(b) then begin                   {'True': the gap in the adjacent line has now been filled with a box}
                                         Inc(BoxSquaresAtAdjacentLine.Count);
                                         BoxSquaresAtAdjacentLine.Squares[BoxSquaresAtAdjacentLine.Count]:=b;
                                         end
                                    else begin LineLength:=-Abs(LineLength); break;{adding the new box square to the deadlock set failed}
                                         end;
                                    end
                               else begin LineLength:=-Abs(LineLength); break;  {the gap in the adjacent line is two or more squares wide, hence the open edge is not a candidate for a deadlock set}
                                    end;

                            if   a=k then begin                                 {'True': this square on the line must be filled in order to create a deadlock set}
                                 if   TryBox(a) then begin                      {'True': the square on the line has now been added to the deadlock}
                                      Inc(BoxSquaresAtLine.Count);
                                      BoxSquaresAtLine.Squares[BoxSquaresAtLine.Count]:=a;
                                      end
                                 else begin LineLength:=-Abs(LineLength); break;{adding the new box square to the deadlock set failed}
                                      end;

                                 {the line must be filled with boxes having one empty floor square between them}
                                 Inc(k,2*Game.SquareOffsetForward[Direction]);  {advance two steps}
                                 end
                            else AddFloor(a); {add floor to the deadlock set}

                            Inc(a,Game.SquareOffsetForward[Direction]);         {advance to the next square along the line}
                            end;

                        if (LineLength>0) and                                   {'True': filling the line and the adjacent gaps with boxes succeeded}
                           (DeadlockSetCandidate__.GoalCount=0) then begin      {'True': there are no goal squares on the line or the adjacent filled gaps; if there are goal squares involved, then it requires more coding to ensure that it's a deadlock}
                           Include(DeadlockSetCandidate__.Flags,dsfHasOnlyListedFloors);
                           if CommitDeadlockSet(False,False,False,Result) and   {'True': registering the semi-closed line deadlock set succeeded}
                              (BoxSquaresAtLine.Count>0) then begin             {try to make a corral deadlock with box at the semi-closed line and with open gaps in the adjacent line}
                              {calculate square colors}
                              for k:=0 to Game.BoardSize do
                                  if   (Game.Board[k] and WALL)<>0 then DeadlockSetCandidate__.SquareColors[k]:=scBlack
                                  else DeadlockSetCandidate__.SquareColors[k]:=scWhite;
                              for k:=1 to BoxSquaresAtLine.Count do
                                  DeadlockSetCandidate__.SquareColors[BoxSquaresAtLine.Squares[k]]:=scDarkGray;
                              for k:=1 to BoxSquaresAtAdjacentLine.Count do
                                  DeadlockSetCandidate__.SquareColors[BoxSquaresAtAdjacentLine.Squares[k]]:=scDarkGray;
                              SemiClosedLineDeadlock:=DeadlockSetCandidate__;      {save a copy of the semi-closed line deadlock}
                              for b:=1 to BoxSquaresAtAdjacentLine.Count do begin
                                  DeadlockSetCandidate__:=SemiClosedLineDeadlock;
                                  {fake a center square even though no fenced-in area has been made yet}
                                  DeadlockSetCandidate__.CenterSquare:=BoxSquaresAtAdjacentLine.Squares[b];
                                  if g=0 then k:=DeadlockSetCandidate__.CenterSquare+Game.SquareOffsetLeft [Direction]
                                  else        k:=DeadlockSetCandidate__.CenterSquare+Game.SquareOffsetRight[Direction];
                                  if IsAFloorSquare(k) and TryFloor(k) then begin
                                     //k:=Game.DeadlockSets.SequenceNo;
                                     RemoveSquareFromDeadlockSet(DeadlockSetCandidate__.CenterSquare);
                                     AddFloor(DeadlockSetCandidate__.CenterSquare);
                                     DeadlockSetCandidate__.EscapedBoxesCountDown:=DeadlockSetCandidate__.Boxes.Count; {all boxes must escape the fenced-in area; otherwise it's a deadlock}
                                     CommitDeadlockSet(True,True,False,Result);
                                     //if k<>Game.DeadlockSets.SequenceNo then begin
                                     //   Game.ShowDeadlockSetsEnabled:=True;
                                     //   ShowDeadlockSet(Game.DeadlockSets.Count,Game.DeadlockSets.CenterSquare[Game.DeadlockSets.Count]);
                                     //   Readln;
                                     //   Game.ShowDeadlockSetsEnabled:=False;
                                     //   end;
                                     end;
                                  end;
                              end;
                           end;
                        end;
                 end;
    end;

    function  PatternTypeCurrentPosition:Boolean; {the current position (e.g., the starting position) may contain a corral deadlock if only the player was outside the corral}
    var BoxNo:Integer;
    begin {pattern type "Current position"}
      {$IFDEF CONSOLE_APPLICATION}
        if Game.ShowDeadlockSetsEnabled then Writeln('Current position');
      {$ENDIF}
      Result:=True;

      if InitializeDeadlockSetCandidate(-1,Game.PlayerPos,Min(Game.BoxCount,Game.DeadlockSets.BoxLimitForPrecalculatedSets)) then begin
         CalculatePlayersReachableSquares(SEARCH_STATE_INDEX_DO_PUSH);
         for BoxNo:=1 to Game.BoxCount do
             with Solver.SearchStates[SEARCH_STATE_INDEX_DO_PUSH].PlayersReachableSquares do
               if Squares[Game.BoxPos[BoxNo]]=Succ(TimeStamp) then
                  AddSquareToDeadlockSet(Game.BoxPos[BoxNo]);
         if DeadlockSetCandidate__.Boxes.Count<>0 then
            CommitDeadlockSet(True,True,False,Result);
         end;
    end;

    function  PatternTypeFrozenGoals:Boolean;
    var BoxNo,GoalNo,GoalSquare,NeighborSquare,OldCount,OldPlayerPosition:Integer;
        IsAFreezingGoalSet:Boolean; Direction:TDirection; GoalSet:TGoalSet;

      function  FindDeadlocks(const GoalSet__:TGoalSet; IsAFreezingGoalSet__:Boolean):Boolean; {'GoalSet__' is the freeze-set goal squares}
      var BoxNo,Distance,GoalNo,GoalSquare,GoalsInSetCount,i,j,NeighborSquare,OldCount,
          Square,UnreachableGoalsCount:Integer;
          Direction:TDirection;
          OldBoard:TBoard; Distances:TBoardOfIntegers;

        function  CreateFreezeSet(GoalsInSetCount__:Integer; const GoalSet__:TGoalSet; IsAFreezingGoalSet__,IsAnOverflowFreezeSet__:Boolean):Boolean;
        var GoalNo:Integer;
        begin {precondition: the preceding deadlock set is the controller-set for the controller/freeze-set pair, where this function creates the freeze-set}
          Result:=False;
          if InitializeDeadlockSetCandidate(Pred(GoalsInSetCount__),0,GoalsInSetCount__) then with Game do begin
             {freeze-sets "cheat" by having the "dsfPlayerMustBeOutsideSet" flag, thereby bypassing legal push tests in 'IsALegalPush' and 'DoPush'}
             if   IsAFreezingGoalSet__ then
                  DeadlockSetCandidate__.Flags:=[dsfFreezeSet                         ,dsfPlayerMustBeOutsideSet]
             else DeadlockSetCandidate__.Flags:=[dsfFreezeSet,dsfTestForFreezingSquare,dsfPlayerMustBeOutsideSet];
             if   IsAnOverFlowFreezeSet__ then Include(DeadlockSetCandidate__.Flags,dsfIsAnOverflowSet);
             for  GoalNo:=1 to GoalCount do
                  if GoalNo in GoalSet__ then {'True': the goal is a member of the "freeze-set"}
                     if AddSquareToDeadlockSet(GoalPos[GoalNo]) then
                        if (Board[GoalPos[GoalNo]] and BOX)<>0 then Dec(DeadlockSetCandidate__.Capacity); {update the deadlock set capacity}

             Result:=(DeadlockSetCandidate__.Boxes.Count=GoalsInSetCount__) and {'True': all goal squares in the "freeze-set" were successfully registered as members of the set}
                     CommitDeadlockSet(False,False,False,Result); {'True': registering the "freeze-set" succeeded}
             end;
          if not Result then begin
             WritelnToLogFile('');
             WritelnToLogFile(TEXT_CREATE_FREEZE_DEADLOCK_SET_FAILED);
             end;
        end; {PatternTypeFrozenGoals.FindDeadlocks.CreateFreezeSet}

        function  CalculateAreaOverflowDeadlocks(GoalsInSetCount__:Integer; const GoalSet__:TGoalSet):Boolean; {with frozen boxes, there may be an area of the board from which only a limited number of goals can be reached}
        var i,BoxNo,GoalNo,OldCount,ReachableSquaresCount,Square:Integer;
            More:Boolean;
            Direction:TDirection;
            ReachableGoalsSet:TBoxSetWithCount;
            Visited:TBoardOfBooleans;
            Distances:TSquareDirectionArrayOfInteger;
        begin {precondition: it's a freezing goal set, i.e., 'IsAFreezingGoalSet__' = 'True', meaning the freeze-set is static and doesn't require a dynamic freeze-test during the game search}
          Result:=True; //exit;
          with Game do begin
            for BoxNo:=1 to BoxCount do Board[BoxPos[BoxNo]]:=Board[BoxPos[BoxNo]] and (not BOX); {remove all boxes from the board}
            for Square:=0 to BoardSize do Visited[Square]:=(Board[Square] and WALL)<>0; {mark floor squares as unvisited}
            for Square:=0 to BoardSize do
                if IsALegalAndBoxReachableSquare(Square) and
                   (not Visited[Square]) then begin
                   {push a box around on the board, starting from 'Square'}
                   ReachableSquaresCount:=0;
                   CalculateBoxPullOrPushDistances(Square,SEARCH_STATE_INDEX_DO_PUSH,True,False,False,Distances);
                   {
                    accumulate the set of box-push-reachable squares from
                    'Square', ensuring that if a square is reachable, then a box
                    at the square is getting pushed from all legal directions;
                   }
                   repeat
                     More:=False;
                     for i:=0 to BoardSize do
                         if (not IsAWallSquare(i)) and
                            (MinimumDistanceToSquare(i,Distances)<>INFINITY) then begin
                            Visited[i]:=True; Inc(ReachableSquaresCount);
                            for Direction:=Low(Direction) to High(Direction) do
                                if (Distances[i,Direction]=INFINITY) and {'True': the box hasn't been pushed to the square 'i' from the direction}
                                   IsAFloorSquare(i-SquareOffsetForward[Direction]) then begin {'True': the player can get 'behind' a box at square 'i', and start pushing the box in this direction}
                                   CalculateBoxPullOrPushDistances(i,SEARCH_STATE_INDEX_DO_PUSH,True,False,True,Distances); {the last 'True' parameter makes the calculation continue with the existing distances}
                                   More:=True;
                                   end;
                            end;
                   until not (More);

                   ReachableGoalsSet.Count:=0; ReachableGoalsSet.BoxSet:=[];
                   for GoalNo:=1 to GoalCount do
                       if (not (GoalNo in GoalSet__)) and {'True': the goal isn't a member of the frozen goals set}
                          (MinimumDistanceToSquare(GoalPos[GoalNo],Distances)<>INFINITY) then begin {'True': the goal is a member of the reachable squares}
                          Inc(ReachableGoalsSet.Count); Include(ReachableGoalsSet.BoxSet,GoalNo);
                          end;

                   if (ReachableGoalsSet.Count>0) and
                      (ReachableGoalsSet.Count<GoalCount-GoalsInSetCount__) and   {'True': with the frozen boxes on the board, only a subset of the goals are reachable from the currently investigated set of squares}
                      (ReachableSquaresCount >ReachableGoalsSet.Count) then begin {'True': there are more squares than reachable goals (avoids small confined areas)}

                      if (DeadlockSets.Count<MAX_DEADLOCK_SETS-2) and
                         InitializeDeadlockSetCandidate(ReachableGoalsSet.Count,0,BoardSize) then begin
                         for BoxNo :=1 to Game.BoxCount do Inc(Board[BoxPos[BoxNo]],BOX); {put all boxes back on the board for correct deadlock set capacity calculation}
                         ReachableSquaresCount:=0; {recalculate the number of reachable squares; the existing count may contain overlaps because of the multiple calls to 'CalculateBoxPullOrPushDistances'}
                         OldCount:=DeadlockSets.Count;
                         DeadlockSetCandidate__.Flags:=[dsfControllerSet,dsfIsAnOverflowSet,dsfPlayerMustBeOutsideSet];  {controller-sets use the "dsfPlayerMustBeOutsideSet" flag to avoid some legal push tests in 'IsALegalPush' and 'DoPush'}
                         for i:=0 to BoardSize do
                             if (not IsAWallSquare(i)) and
                                (MinimumDistanceToSquare(i,Distances)<>INFINITY) then
                                if   AddSquareToDeadlockSet(i) then begin {collect the floor squares from which the reachable goal set can be reached}
                                     Inc(ReachableSquaresCount);
                                     if (Board[i] and BOX)<>0 then Dec(DeadlockSetCandidate__.Capacity); {update the deadlock set capacity}
                                     end
                                else OldCount:=-1; {collecting the squares belonging to the controller-set failed; no new deadlock sets have been registered yet}

                         if   (OldCount=DeadlockSets.Count) and
                              (DeadlockSetCandidate__.GoalCount=ReachableGoalsSet.Count) and
                              (DeadlockSetCandidate__.GoalCount<ReachableSquaresCount) and
                              CommitDeadlockSet(False,False,False,Result) then begin {'True': creating the "controller-set" succeeded}
                              if CreateFreezeSet(GoalsInSetCount__,GoalSet__,True,True) then begin
                                 end
                              else begin {creating the controller/freeze-set pair failed; restore the deadlock sets to the old state}
                                 while DeadlockSets.Count>OldCount do begin
                                   DeleteDeadlockSet(DeadlockSets.Count);
                                   end;
                                 WritelnToLogFile('');
                                 WritelnToLogFile(TEXT_CREATE_FREEZE_DEADLOCK_SET_FAILED);
                                 end;
                              end;

                         for BoxNo:=1 to BoxCount do Board[BoxPos[BoxNo]]:=Board[BoxPos[BoxNo]] and (not BOX); {remove all boxes from the board}
                         end;
                      end;
                   end;
            end;
        end; {PatternTypeFrozenGoals.FindDeadlocks.CalculateAreaOverflowDeadlocks}

        function  CalculateAreaUnderflowDeadlocks(GoalsInSetCount__:Integer; const GoalSet__:TGoalSet):Boolean; {with frozen boxes, there may be an area of the board from which only a limited number of goals can be reached}

          function  IsASubSet(GoalNo1__,GoalNo2__:Integer; const SquaresGoalSet__:TBoardOfGoalSets):Boolean;
          var Square:Integer;
          begin {returns 'True' if the pull-reachable squares from 'GoalNo1__' is a subset of the pull-reachable squares from 'GoalNo2__'}
            {this function treats an empty set as a sub-set of any set;
             that would be a mistake in this underflow calculation, but it
             never happens; the goal 'GoalNo1__' is always reachable from the
             goal square itself;
            }
            Result:=True;
            with Game do
              for Square:=0 to BoardSize do
                  if (     GoalNo1__ in SquaresGoalSet__[Square])  and          {'True': the square 'Square' is     pull-reachable from 'GoalNo1__'}
                     (not (GoalNo2__ in SquaresGoalSet__[Square])) then begin   {'True': the square 'Square' is not pull-reachable from 'GoalNo2__'}
                     Result:=False; break;
                     end;
          end;

        var {'CalculateAreaUnderflowDeadlocks'}
          i,BoxNo,GoalNo,OldCount,ReachableSquaresCount,ReachableSquaresLimit,Square:Integer;
          {TimeMS:TTimeMS;}
          GoalSubSetCount:TBoxArrayOfIntegers;
          SquaresGoalSet:TBoardOfGoalSets;
        begin {'CalculateAreaUnderflowDeadlocks'; precondition: it's a freezing goal set, i.e., 'IsAFreezingGoalSet__' = 'True', meaning the freeze-set is static and doesn't require a dynamic freeze-test during the game search}
          Result:=True; //exit;
          with Game do begin
            {TimeMS:=GetTimeMS;}
            for BoxNo:=1 to BoxCount do Board[BoxPos[BoxNo]]:=Board[BoxPos[BoxNo]] and (not BOX); {remove all boxes from the board}

            if  CalculateReachableGoalsForAllSquares(SquaresGoalSet) then begin
                for GoalNo:=1 to GoalCount do begin {for each goal 'GoalNo', calculate the number of goals with a pull-reachable square-set which is a sub-set of the pull-reachable squares from 'GoalNo'}
                    GoalSubSetCount[GoalNo]:=0;
                    if (not (GoalNo in GoalSet__)) then begin {'True': the goal 'GoalNo' isn't one of the frozen goals}
                       for i:=1 to GoalCount do
                           if (not (i in GoalSet__)) {'True': the goal 'i' isn't one of the frozen goals}
                              and
                              ((i=GoalNo)
                               or
                               IsASubSet(i,GoalNo,SquaresGoalSet) {'True': if a box can be pushed from a square to goal 'i' then it can also be pushed to goal 'GoalNo'}
                              ) then
                              Inc(GoalSubSetCount[GoalNo]);
                       end;
                    end;

                TimeCheck;

                for GoalNo:=1 to GoalCount do
                    if (GoalSubSetCount[GoalNo]>0) and {'True': it's not one of the frozen boxes}
                       (GoalSubSetCount[GoalNo]<GoalCount-GoalsInSetCount__) and {'True': with the frozen boxes on the board, only a subset of the goals are push-reachable from the pull-reachable squares from the goal 'GoalNo'}
                       (Solver.SearchLimits.DepthLimit>=0) and {'True': the solver hasn't been terminated}
                       (DeadlockSets.Count<MAX_DEADLOCK_SETS-2) and
                       InitializeDeadlockSetCandidate(GoalSubSetCount[GoalNo],0,BoardSize) then begin
                       for BoxNo:=1 to Game.BoxCount do Inc(Board[BoxPos[BoxNo]],BOX); {put all boxes back on the board for correct deadlock set capacity calculation}
                       ReachableSquaresCount:=0; {calculate the number of reachable squares}
                       if   GoalSubSetCount[GoalNo]>1 then {heuristic: only create underflow deadlocks for reasonably small areas on the board}
                            ReachableSquaresLimit:=FloorCount div 2
                       else ReachableSquaresLimit:=FloorCount div 4;
                       OldCount:=DeadlockSets.Count;
                       DeadlockSetCandidate__.Flags:=[dsfControllerSet,dsfPlayerMustBeOutsideSet];  {controller-sets use the "dsfPlayerMustBeOutsideSet" flag to avoid some legal push tests in 'IsALegalPush' and 'DoPush'}
                       for Square:=0 to BoardSize do
                           if GoalNo in SquaresGoalSet[Square] then
                              if (ReachableSquaresCount<ReachableSquaresLimit) and {'True': the heuristic area size limit hasn't been exceeded}
                                 AddSquareToDeadlockSet(Square) then begin {collect the floor squares ín the pull-reachable square set from the goal 'GoalNo'}
                                 Inc(ReachableSquaresCount);
                                 if (Board[Square] and BOX)<>0 then Dec(DeadlockSetCandidate__.Capacity); {update the deadlock set capacity}
                                 end
                              else begin  {collecting the squares belonging to the controller-set failed, or the number of squares exceeded the heuristic limit; no new deadlock sets have been registered yet}
                                 OldCount:=-1; break;
                                 end;

                       if   (ReachableSquaresCount<=ReachableSquaresLimit) and {only create small underflow areas}
                            (OldCount=DeadlockSets.Count) and
                            (DeadlockSetCandidate__.GoalCount=GoalSubSetCount[GoalNo]) and
                            //(DeadlockSetCandidate__.GoalCount<GoalSubSetCount[GoalNo]) and
                            CommitDeadlockSet(False,False,False,Result) then begin {'True': creating the "controller-set" succeeded}
                            if CreateFreezeSet(GoalsInSetCount__,GoalSet__,True,False) then begin
                               for i:=Succ(GoalNo) to GoalCount do
                                   if (GoalSubSetCount[i]=GoalSubSetCount[GoalNo]) and
                                      IsASubSet(i,GoalNo,SquaresGoalSet) and
                                      IsASubSet(GoalNo,i,SquaresGoalSet) then
                                      GoalSubSetCount[i]:=0; {don't create duplicates based on goals sharing a common set of pull-reachable squares}
{
                               ShowBoard;
                               Game.ShowDeadlockSetsEnabled:=True;
                               ShowDeadlockSet(Pred(Game.DeadlockSets.Count),0);
                               Write('Frozen goals - underflow deadlock ', Game.DeadlockSets.Count,SPACE,Solver.PushCount);
                               Readln;
                               Game.ShowDeadlockSetsEnabled:=False;
}
                               end
                            else begin {creating the controller/freeze-set pair failed; restore the deadlock sets to the old state}
                               while DeadlockSets.Count>OldCount do begin
                                 DeleteDeadlockSet(DeadlockSets.Count);
                                 end;
                               WritelnToLogFile('');
                               WritelnToLogFile(TEXT_CREATE_FREEZE_DEADLOCK_SET_FAILED);
                               end;
                            end;

                       for BoxNo:=1 to BoxCount do Board[BoxPos[BoxNo]]:=Board[BoxPos[BoxNo]] and (not BOX); {remove all boxes from the board}
                       TimeCheck;
                       end;
                end;
{
            ShowBoard;
            Write('Frozen goals - underflow deadlock calculation ',Solver.PushCount,SPACE,CalculateElapsedTimeMS(TimeMS,GetTimeMS));
            Readln;
}
            end;
        end; {PatternTypeFrozenGoals.FindDeadlocks.CalculateAreaUnderflowDeadlocks}

      begin {'FindDeadlocks'; precondition: if 'IsAFreezingGoalSet__' is 'False' (boxes at the goal squares don't freeze), then the goal set must contain a single goal only}
        with Game do begin
          Result:=False; GoalsInSetCount:=0;
          for GoalNo:=1 to GoalCount do begin
              GoalSquare          :=GoalPos[GoalNo];
              OldBoard[GoalSquare]:=Board[GoalSquare]; {keep the original square value for the goal square}
              if GoalNo in GoalSet__ then begin
                 Board   [GoalSquare]:=WALL; {put a wall at the goal square}
                 with Solver.SearchStates[SEARCH_STATE_INDEX_DO_PUSH].PlayersReachableSquares do {'CalculateDistanceToNearestBoxStartPositionForAllSquares' which is called further down works with 'Solver.SearchStates[SEARCH_STATE_INDEX_DO_PUSH]'}
                   Squares[GoalSquare]:=High(TimeStamp) and (not 1); {temporarily give the goal square the timestamp assigned to walls}
                 Inc(GoalsInSetCount);
                 end;
              end;

          if ((GoalsInSetCount=1) or IsAFreezingGoalSet__) and {the freeze-set deadlock detection only handles A) frozen goal sets, or B) single goal squares requiring a runtime test whether a box at the goal square has frozen}
             (Solver.SearchLimits.DepthLimit>=0) then begin {'>=0': the search hasn't been terminated}
             CalculateDistanceToNearestBoxStartPositionForAllSquares(1,BoxCount,False,Distances); {calculate the set of squares that still are reachable from the starting position, now that frozen boxes (represented by walls) have been added to the board}

             UnreachableGoalsCount:=0;
             for GoalNo:=1 to GoalCount do
                 if not (GoalNo in GoalSet__) then
                    if   Distances[GoalPos[GoalNo]]<>INFINITY then {'True': the goal 'GoalNo' is reachable from the starting position}
                         Dec(Board[GoalPos[GoalNo]],GOAL) {temporarily remove all reachable goals not belonging to the freeze-set}
                    else Inc(UnreachableGoalsCount); {the goal number 'GoalNo' is not reachable from the starting position (anymore) with boxes frozen at the goals in the set 'GoalSet__'}

             if UnreachableGoalsCount<>0 then begin {'True': some goals are not reachable from the starting position with boxes frozen at the goals in the set 'GoalSet__'}
                CalculateDistanceToNearestGoalForAllSquares(False,Distances); {calculate the set of squares (the "controller-set") from which the unreachable goals can be reached}

                if (DeadlockSets.Count<MAX_DEADLOCK_SETS-2) and
                   InitializeDeadlockSetCandidate(UnreachableGoalsCount,0,BoardSize) then begin
                   OldCount:=DeadlockSets.Count;
                   DeadlockSetCandidate__.Flags:=[dsfControllerSet,dsfPlayerMustBeOutsideSet];  {controller-sets "cheat" by having the "dsfPlayerMustBeOutsideSet" flag, thereby bypassing legal push tests in 'IsALegalPush' and 'DoPush'}
                   for Square:=0 to BoardSize do
                       if (not IsAWallSquare(Square)) and (Distances[Square]<>INFINITY) then
                          if   AddSquareToDeadlockSet(Square) then begin {collect the floor squares from which the unreachable goals can be reached}
                               if (Board[Square] and BOX)<>0 then Dec(DeadlockSetCandidate__.Capacity); {update the deadlock set capacity}
                               end
                          else OldCount:=-1; {collecting the squares belonging to the controller-set failed; no new deadlock sets have been registered yet}

                   if   (OldCount=DeadlockSets.Count) and
                        (DeadlockSetCandidate__.GoalCount=UnreachableGoalsCount) and
                        CommitDeadlockSet(False,False,False,Result) then begin {'True': creating the "controller-set" succeeded}
                        if    CreateFreezeSet(GoalsInSetCount,GoalSet__,IsAFreezingGoalSet__,False) then begin {'True': registering the "freeze-set" succeeded}
{
                              for BoxNo:=1 to BoxCount do Board[BoxPos[BoxNo]]:=Board[BoxPos[BoxNo]] and (not BOX); // remove all boxes from the board
                              ShowBoard;
                              for GoalNo:=1 to GoalCount do
                                  if GoalNo in GoalSet__ then Write(GoalPos[GoalNo],SPACE);
                              Write('Frozen goal square set ',DeadlockSets.Count);
                              Readln;
}
                              if (GoalsInSetCount=1) and
                                 IsAFreezingGoalSet__ and
                                 (DeadlockSets.Count<MAX_DEADLOCK_SETS-2) then begin
                                 {the freezing goal square is a corner square like
                                  this:

                                  #. <- freezing goal square
                                  ##

                                  some corner goals have two neighboring floor squares
                                  where at least one of them is a goal, and where
                                  boxes at these squares cannot escape from the
                                  corner, like this example:

                                  #*
                                  #.$ <- goal square surrounded by two boxes
                                  ###

                                  in that case, the two neighboring squares can act as
                                   a freeze-set for the same controller-set as the one
                                  created for the original freezing goal square;

                                  the following code detects the situation, duplicates
                                  the controller-set, and makes a new freeze-set
                                  containing the two neighbor squares;
                                 }
                                 GoalNo:=0;
                                 while (GoalNo<=GoalCount) and (not (GoalNo in GoalSet__)) do Inc(GoalNo); {find the goal number}
                                 if GoalNo<=GoalCount then begin {sanity check; this should always be true}
                                    GoalSquare:=GoalPos[GoalNo];
                                    for Direction:=Low(Direction) to High(Direction) do begin {look for neighboring goal squares}
                                        Square        :=GoalSquare+SquareOffsetForward[Direction];
                                        NeighborSquare:=GoalSquare+SquareOffsetForward[NEXT_DIRECTION[Direction]];
                                        if (((OriginalBoard[Square        ] and GOAL)<>0)
                                            or
                                            ((OriginalBoard[NeighborSquare] and GOAL)<>0) {'True': the freezing corner goal square is surrounded by two neighbors where at least one of them is a goal square; caution: assume 4 directions only}
                                           )
                                           and
                                           ((Board[Square                 ] and (WALL+GOAL))= 0)
                                           and
                                           ((Board[NeighborSquare         ] and (WALL+GOAL))= 0) {'True': the neighboring squares are both floor squares and not members of the unreachable goal squares}
                                           and
                                           IsAWallSquare(GoalSquare       -SquareOffsetForward[Direction])
                                           and
                                           IsAWallSquare(GoalSquare       -SquareOffsetForward[NEXT_DIRECTION[Direction]]) {'True': the goal square is really a corner square (a sanity check; this should always be true)}
                                           and
                                           IsAWallSquare(Square           +SquareOffsetRight[Direction]) {caution: assumes 4 directions only}
                                           and
                                           IsAWallSquare(NeighborSquare   +SquareOffsetLeft[NEXT_DIRECTION[Direction]]) {'True': boxes at the 2 neighboring squares cannot escape from the corner} {caution: assumes 4 directions only}
                                           and
                                           (DeadlockSets.Count<MAX_DEADLOCK_SETS-2)
                                           and
                                           InitializeDeadlockSetCandidate(UnreachableGoalsCount,0,BoardSize) then begin
                                           Board[GoalPos[GoalNo]]:=OldBoard[GoalPos[GoalNo]]; {temporarily restore the original board value for the freezing corner goal square}

                                           i:=GoalNoAtSquare(Square);
                                           j:=GoalNoAtSquare(NeighborSquare);

                                           DeadlockSetCandidate__.Flags:=[dsfControllerSet,dsfPlayerMustBeOutsideSet];  {controller-sets have the "dsfPlayerMustBeOutsideSet" flag to avoid some legal push tests in 'IsALegalPush' and 'DoPush'}
                                           for Square:=0 to BoardSize do
                                               if (not IsAWallSquare(Square)) and (Distances[Square]<>INFINITY) then
                                                  if   AddSquareToDeadlockSet(Square) then begin {collect the floor squares from which the unreachable goals can be reached}
                                                       if (Board[Square] and BOX)<>0 then Dec(DeadlockSetCandidate__.Capacity); {update the deadlock set capacity}
                                                       end
                                                  else i:=-Abs(i); {collecting the squares belonging to the controller-set failed; no new deadlock sets have been registered yet}
                                           if   (i>0) and
                                                (DeadlockSetCandidate__.GoalCount=UnreachableGoalsCount) and
                                                CommitDeadlockSet(False,False,False,Result) then begin {'True': creating the "controller-set" succeeded}

                                                if   InitializeDeadlockSetCandidate(1,0,2) then begin
                                                     DeadlockSetCandidate__.Flags:=[dsfFreezeSet,dsfPlayerMustBeOutsideSet]; {freeze-sets have the "dsfPlayerMustBeOutsideSet" flag to avoid some legal push tests in 'IsALegalPush' and 'DoPush'}
                                                     if   AddSquareToDeadlockSet(GoalPos[i]) and
                                                          AddSquareToDeadlockSet(GoalPos[j]) then begin
                                                          if (Board[GoalPos[i]] and BOX)<>0 then Dec(DeadlockSetCandidate__.Capacity); {update the deadlock set capacity}
                                                          if (Board[GoalPos[j]] and BOX)<>0 then Dec(DeadlockSetCandidate__.Capacity); {update the deadlock set capacity}
                                                          end
                                                     else i:=-Abs(i); {adding the goal squares belonging to the freeze-set failed}
                                                     if   (i>0) and {'True': all goal squares in the "freeze-set" were successfully registered as members of the set}
                                                          CommitDeadlockSet(False,False,False,Result) then begin {'True': registering the "freeze-set" succeeded}
{
                                                          for BoxNo:=1 to BoxCount do Board[BoxPos[BoxNo]]:=Board[BoxPos[BoxNo]] and (not BOX); // remove all boxes from the board
                                                          ShowBoard;
                                                          Write(GoalPos[i],SPACE,GoalPos[j],SPACE);
                                                          Write('Frozen goal square set ',DeadlockSets.Count);
                                                          Readln;
}
                                                          end
                                                     else i:=-Abs(i); {creating the freeze-set failed}
                                                     end
                                                else i:=-Abs(i); {creating the freeze-set failed}

                                                if   i<=0 then begin {emit a message to the log file, so the reader won't be confused by the text accompanying the controller-set which refers to a succeeding freeze-set which isn't there}
                                                     WritelnToLogFile('');
                                                     WritelnToLogFile(TEXT_CREATE_FREEZE_DEADLOCK_SET_FAILED);
                                                     end;
                                                end;

                                           Board[GoalPos[GoalNo]]:=WALL; {put the wall back at the original freezing goal square}
                                           end;
                                        end;
                                    end;
                                 end;
                              end;
                        end;

                   if OldCount>=0 then {'True': an attempt has been made to create at least one of the deadlock sets in the controller/freeze-set pair}
                      if   not (Odd(DeadlockSets.Count-OldCount)) then with DeadlockSets do begin {'True': creating both deadlock sets in the controller/freeze-set pair(s) succeeded}
                           for i:=Succ(OldCount) to DeadlockSets.Count do
                               CenterSquare[i]:=0;                              {ensure that neither controller-sets nor freeze-sets have a center square; that could cause havoc to some of the "is this a deadlocked corral?" tests}
                           end
                      else {creating the controller/freeze-set pair failed; restore the deadlock sets to the old state}
                           while DeadlockSets.Count>OldCount do begin
                             DeleteDeadlockSet(DeadlockSets.Count);
                             end;
                   end;
                end;

             for GoalNo:=1 to GoalCount do
                 if not (GoalNo in GoalSet__) then begin
                    GoalSquare:=GoalPos[GoalNo];
                    Board[GoalSquare]:=Board[GoalSquare] or GOAL; {put goals back on the board, except the ones in the goal freeze-set currently under investigation, i.e., the goals in 'GoalSet__'}
                    end;

             if IsAFreezingGoalSet__ then begin
                CalculateDistanceToNearestGoalForAllSquares(False,Distances); {calculate the set of squares from which the not frozen goals can be reached}

                for Square:=0 to BoardSize do {find floor squares from which it's impossible to reach a goal square with the frozen goals on the board}
                    if IsALegalAndBoxReachableSquare(Square) and {'True': boxes can reach the square on the normal board without the frozen goals}
                       (Distances[Square]=INFINITY) then begin {'True': with the frozen goals on the board it's impossible to get from this square to a goal, i.e., it's a "dead square"}
                       for BoxNo:=1 to BoxCount do Board[BoxPos[BoxNo]]:=Board[BoxPos[BoxNo]] and (not BOX); {remove all boxes from the board so 'IsAFreezingMove' returns the correct result, with only the frozen goals and the "dead square"}
                       if (not IsAFreezingMove(0,Square,False)) and {'True': a box can be put at the square without freezing}
                          InitializeDeadlockSetCandidate(GoalsInSetCount,0,BoardSize) then begin {make a deadlock set consisting of the frozen goals + the "dead square"}
                          for BoxNo :=1 to Game.BoxCount do Inc(Board[BoxPos[BoxNo]],BOX); {put all boxes back on the board for correct deadlock set capacity calculation}
                          for GoalNo:=1 to GoalCount do
                              if GoalNo in GoalSet__ then {'True': the goal is a member of the "controller-set"}
                                 if AddSquareToDeadlockSet(GoalPos[GoalNo]) and
                                    ((Board[GoalPos[GoalNo]] and BOX)<>0) then Dec(DeadlockSetCandidate__.Capacity); {update the deadlock set capacity}
                          if AddSquareToDeadlockSet(Square) and
                             ((Board[Square] and BOX)<>0) then Dec(DeadlockSetCandidate__.Capacity); {update the deadlock set capacity}
                          if (DeadlockSetCandidate__.Boxes.Count=Succ(GoalsInSetCount)) and {'True': all goal squares in the "controller-set" were successfully registered as members of the set, and so was the unreachable square}
                             CommitDeadlockSet(False,False,False,Result) then begin
                             end;
                          end;
                       end;

                CalculateAreaOverflowDeadlocks (GoalsInSetCount,GoalSet__);     {with frozen boxes, there may be areas on the board from where it only is possible to reach a limited number of goals}
                CalculateAreaUnderflowDeadlocks(GoalsInSetCount,GoalSet__);     {with frozen boxes, there may be areas on the board from where it only is possible to reach a limited number of goals}
                end
             else
                if (GoalsInSetCount=1) and (Position__=nil) then
                   {this is a single goal square requiring a runtime freeze
                    test; find deadlocks related to boxes freezing near gate
                    squares (a gate splits the board in two separate areas);

                    an example:
                    ----#
                    --*-- the square between the walls is a gate square
                    ----# which splits the board in two disjoint areas

                    when a box freezes at the goal square "*", then the area
                    to the right of the gate square must at the most contain
                    A+B+C boxes, where
                    A = number of goals to the right of the gate
                    B = 1 if the square to the right of "*" is a goal, otherwise 0
                    C = 1 if the gate square is a goal, otherwise 0
                   }
                   for GoalNo:=1 to GoalCount do {find the goal set member}
                       if GoalNo in GoalSet__ then begin
                          GoalSquare          :=GoalPos[GoalNo];
                          for Direction:=Low(Direction) to High(Direction) do begin
                              Distance:=0; Square:=GoalSquare;
                              DeadlockSetCandidate__.GoalCount:=0;
                              repeat if IsAGoalSquare(Square) then Inc(DeadlockSetCandidate__.GoalCount);
                                     NeighborSquare:=Square+SquareOffsetForward[Direction]; {the next square in this direction}
                                     if   IsAFloorSquare(NeighborSquare) then begin
                                          if IsAGateSquare(Square) and
                                             IsAWallSquare(Square+SquareOffsetLeft [Direction]) {only gate squares with walls on both sides can be used here; the player must not be able to get through the gate after pushing a box through the gate}
                                             and {caution: assumes 4 directions only}
                                             IsAWallSquare(Square+SquareOffsetRight[Direction])
                                             then begin
                                             for BoxNo:=1 to BoxCount do Board[BoxPos[BoxNo]]:=Board[BoxPos[BoxNo]] and (not BOX); {remove all boxes from the board}
                                             Inc(Board[Square],BOX); {put a box at the gate square in order to split the board in two disjoint areas}

                                             PlayerPos:=NeighborSquare; {use 'CalculatePlayersReachableSquares' to find the floor squares on the other side of the gate}
                                             i:=CalculatePlayersReachableSquares(SEARCH_STATE_INDEX_DO_PUSH);

                                             Dec(Board[Square],BOX); {remove the box from the gate square}

                                             if i>4 then begin {'True': the area on the other side of the gate square isn't a small degenerated area (the limit is arbitrary)}
                                                j:=0; {count the number of goal squares on the other side of the gate}
                                                for i:=1 to GoalCount do with Solver.SearchStates[SEARCH_STATE_INDEX_DO_PUSH].PlayersReachableSquares do
                                                    if Squares[GoalPos[i]]=TimeStamp then Inc(j);

                                                if Succ(DeadlockSetCandidate__.GoalCount)+j<GoalCount then begin {'True': there area on the other side of the gate can overflow}
                                                   if (DeadlockSets.Count<MAX_DEADLOCK_SETS-2) and
                                                      InitializeDeadlockSetCandidate(DeadlockSetCandidate__.GoalCount+j,0,BoardSize) then begin
                                                      OldCount:=DeadlockSets.Count;
                                                      {controller-sets have the "dsfPlayerMustBeOutsideSet" flag to avoid some legal push tests in 'IsALegalPush' and 'DoPush'}
                                                      DeadlockSetCandidate__.Flags:=[dsfControllerSet,dsfIsAnOverflowSet,dsfPlayerMustBeOutsideSet];

                                                      for BoxNo:=1 to Game.BoxCount do with Solver.SearchStates[SEARCH_STATE_INDEX_DO_PUSH].PlayersReachableSquares do
                                                          if (Squares[BoxPos[BoxNo]]=TimeStamp) then
                                                             Inc(Board[BoxPos[BoxNo]],BOX); {put boxes belonging to the controller set back on the board for correct deadlock set capacity calculation}
                                                      for i:=0 to BoardSize do with Solver.SearchStates[SEARCH_STATE_INDEX_DO_PUSH].PlayersReachableSquares do
                                                          if (Squares[i]=TimeStamp) and
                                                             IsALegalAndBoxReachableSquare(i) then
                                                             if   AddSquareToDeadlockSet(i) then begin {collect the floor squares on the other side of the gate}
                                                                  if  (Board[i] and BOX)<>0 then Dec(DeadlockSetCandidate__.Capacity); {update the deadlock set capacity}
                                                                       end
                                                                  else OldCount:=-1; {collecting the squares belonging to the controller-set failed; no new deadlock sets have been registered yet}

                                                      if   (OldCount=DeadlockSets.Count) and
                                                           CommitDeadlockSet(False,False,False,Result) then begin {'True': creating the "controller-set" succeeded}
                                                           if    CreateFreezeSet(GoalsInSetCount,GoalSet__,IsAFreezingGoalSet__,True) then begin {'True': registering the "freeze-set" succeeded}
{
                                                                 ShowBoard;
                                                                 Write('New gate square deadlock set: ',DeadlockSets.SequenceNo,' Capacity: ',DeadlockSets.Capacity[Pred(DeadlockSets.Count)]);
                                                                 Readln;
}
                                                                 end
                                                           else {creating the controller/freeze-set pair failed; restore the deadlock sets to the old state}
                                                                while DeadlockSets.Count>OldCount do begin
                                                                      DeleteDeadlockSet(DeadlockSets.Count);
                                                                      end;
                                                           end;
                                                      //for BoxNo:=1 to BoxCount do Board[BoxPos[BoxNo]]:=Board[BoxPos[BoxNo]] and (not BOX); {remove all boxes from the board}
                                                      end;
                                                   end;
                                                end;

                                             Distance:=4; {a gate square has been found; exit the 'repeat' loop}
                                             end
                                          else begin {advance to the next square in this direction}
                                             Inc(Distance); Square:=NeighborSquare;
                                             end;
                                          end
                                     else Distance:=4; {the next neighbor square isn't a floor square; exit the 'repeat' loop}
                              until  Distance>2; {until the distance between the investigated goal square and the searched for gate square exceeds the goal's influence on the gate}
                              end;
                          end;
             end;

          for GoalNo:=1 to GoalCount do
              if GoalNo in GoalSet__ then begin
                 GoalSquare:=GoalPos[GoalNo];
                 Board[GoalSquare]:=OldBoard[GoalSquare]; {restore the board square value for the goals in the goal freeze-set currently under investigation}
                 with Solver.SearchStates[SEARCH_STATE_INDEX_DO_PUSH].PlayersReachableSquares do Squares[GoalSquare]:=0; {remove the temporary 'wall' timestamp from the goal squares in the goal freeze-set currently under investigation}
                 end;

          for BoxNo:=1 to BoxCount do Board[BoxPos[BoxNo]]:=Board[BoxPos[BoxNo]] and (not BOX); {remove all boxes from the board}
          end;

      end; {PatternTypeFrozenGoals.FindDeadlocks}

    begin {pattern types "Frozen goals block access to other goals" and "Frozen goals block paths from squares to goals"}
      with Game do begin
        {$IFDEF CONSOLE_APPLICATION}
          if ShowDeadlockSetsEnabled then Writeln('Frozen goals blocking access to other goals');
        {$ENDIF}
        Result:=True;
        //OldCount:=DeadlockSets.Count;
        //ShowDeadlockSetsEnabled:=True;
        OldPlayerPosition:=PlayerPos; MovePlayer(0); {remove player from the board}
        for BoxNo:=1 to Game.BoxCount do Dec(Board[BoxPos[BoxNo]],BOX); {remove all boxes from the board}

        if Position__=nil then begin {'True': this is the initialization of the game}
           for GoalNo:=1 to GoalCount do begin
               GoalSquare:=GoalPos[GoalNo];
               Dec(Board[GoalSquare],GOAL); {remove the goal from the board}

               {find deadlocks based on this single goal square}
               FindDeadlocks([GoalNo],IsAFreezingMove(0,GoalSquare,False));     {if 'IsAFreezingMove' is 'True' then the goal square is a corner square, i.e., a box freezes at this goal square}

               {find deadlocks based on two freezing neighbor goal squares}
               for Direction:=Low(Direction) to TDirection(Pred(Ord(Low(Direction))+(DIRECTION_COUNT div 2))) do begin {look for neighboring goal squares which freezes when they are filled with boxes}
                   Board[GoalSquare]:=Board[GoalSquare] or BOX;
                   NeighborSquare:=GoalSquare+SquareOffsetForward[Direction];

                   if IsAGoalSquare(NeighborSquare) then
                      if IsAFreezingMove(0,NeighborSquare,False) then           {'True': there are two freezing neighbor goal squares}
                         FindDeadlocks([GoalNo,GoalNoAtSquare(NeighborSquare)],True)
                      else if (Direction=Low(Direction)) and
                              IsAGoalSquare(GoalSquare    +SquareOffsetLeft[Direction]) and
                              IsAGoalSquare(NeighborSquare+SquareOffsetLeft[Direction]) then begin {'True': there is a 2x2 squares goal set on the board; check if freeze-deadlocks can be based on this goal set}
                              Board[NeighborSquare]:=Board[NeighborSquare] or BOX;

                              if (not IsAFreezingMove(0,GoalSquare    +SquareOffsetLeft[Direction],False))
                                 and {'and': reduce the number of redundant 2x2 squares controller/freeze sets by eliminating situations where a single goal is enough to cause a freeze-situation}
                                 (not IsAFreezingMove(0,NeighborSquare+SquareOffsetLeft[Direction],False)) then
                                 FindDeadlocks([GoalNo,
                                                GoalNoAtSquare(NeighborSquare),
                                                GoalNoAtSquare(GoalSquare    +SquareOffsetLeft[Direction]),
                                                GoalNoAtSquare(NeighborSquare+SquareOffsetLeft[Direction])],
                                                True);

                              Board[NeighborSquare]:=Board[NeighborSquare] and (not BOX);
                              end;

                   Board[GoalSquare]:=Board[GoalSquare] and (not BOX);
                   end;

               Inc(Board[GoalSquare],GOAL); {put the goal back on the board}
               end;
           end
        else begin
           {adding frozen goal patterns dynamically during the search}
           GoalSet:=[]; OldCount:=DeadlockSets.Count; IsAFreezingGoalSet:=True;
           for BoxNo:=1 to DeadlockSetCandidate__.Boxes.Count do begin
               GoalNo:=DeadlockSetCandidate__.Boxes.Squares[BoxNo];             {caution: despite the field name 'Squares' they really contain goal numbers and not square numbers here}
               Include(GoalSet,GoalNo);                                         {collect the frozen goal numbers}
               Inc(Board[GoalPos[GoalNo]],BOX);                                 {temporarily put boxes at the listed goal squares so it can be tested whether boxes at this goal square set are frozen, independent of boxes at other squares}
               end;

           for BoxNo:=1 to DeadlockSetCandidate__.Boxes.Count do begin          {test whether boxes at this goal square set are frozen, independent of boxes at other squares}
               GoalNo:=DeadlockSetCandidate__.Boxes.Squares[BoxNo];             {caution: despite the field name 'Squares' they really contain goal numbers and not square numbers here}
               if not IsAFreezingMove(0,GoalPos[GoalNo],True) then begin
                  IsAFreezingGoalSet:=False; break;
                  end;
               end;

           for BoxNo:=1 to DeadlockSetCandidate__.Boxes.Count do begin          {remove the boxes which temporarily have been placed at goal squares in the set}
               GoalNo:=DeadlockSetCandidate__.Boxes.Squares[BoxNo];             {caution: despite the field name 'Squares' they really contain goal numbers and not square numbers here}
               Dec(Board[GoalPos[GoalNo]],BOX);                                 {remove the box from the board}
               end;

           FindDeadlocks(GoalSet,IsAFreezingGoalSet);

           if OldCount<>DeadlockSets.Count then Game.DeadlockSets.NewDynamicDeadlockSets:=True;
           end;

        for BoxNo:=1 to Game.BoxCount do Inc(Board[BoxPos[BoxNo]],BOX); {put all boxes back on the board}
        MovePlayer(OldPlayerPosition); {restore player position}

        //if Game.DeadlockSets.NewDynamicDeadlockSets then begin
        //   ShowBoard;
        //   Write('New frozen goals deadlocks: ',DeadlockSets.Count-OldCount);
        //   Readln;
        //   end;
        end;
    end;

    function  PatternTypeOverflowAreas:Boolean;
    var Col,EmptySquaresCount,GoalNo,Index,Row,Square:Integer;
        OK:Boolean; s:String;
        GoalNumberSet:TBoxNumberSet; Visited:TBoardOfBooleans;
    begin {pattern type "Overflow areas"}
      {$IFDEF CONSOLE_APPLICATION}
        if Game.ShowDeadlockSetsEnabled then Writeln('Overflow areas');
      {$ENDIF}
      Result:=True;
      with Game do with Solver.PackingOrder do begin
        FillChar(Visited,SizeOf(Visited),0);
        for Square:=0 to BoardSize do
            if IsALegalAndBoxReachableSquare(Square) and
               (not Visited[Square]) and
               (Solver.SearchLimits.DepthLimit>=0) then begin
               GoalNumberSet.Count:=0; {collect the goals which cannot be reached from this square}
               for GoalNo:=1 to GoalCount do
                   if SquareGoalDistance[Square,GoalNo]=High(SquareGoalDistance[Square,GoalNo]) then {'High': high-value means 'INFINITY', i.e., there is no path from the square to the goal}
                      with GoalNumberSet do begin
                        Inc(Count); Numbers[Count]:=GoalNo;
                        end;

               if (GoalNumberSet.Count>0) and (GoalNumberSet.Count<GoalCount div 2) and {'div 2': since each square only can be a member of one overflow area, it may be an advantage to focus on small unreachable goal groups}
                  InitializeDeadlockSetCandidate(GoalCount-GoalNumberSet.Count,0,Game.BoardSize) then begin

                  EmptySquaresCount:=0;
                  for Index:=Square to BoardSize do
                      if IsALegalAndBoxReachableSquare(Index) and
                         (not Visited[Index]) then begin
                         OK:=True;
                         for GoalNo:=1 to GoalNumberSet.Count do {check if the unreachable goals from the square number 'Index' is a subset of the unreachable goals from 'Square'}
                             if   OK then
                                  if   SquareGoalDistance[Index,GoalNumberSet.Numbers[GoalNo]]<High(SquareGoalDistance[Index,GoalNumberSet.Numbers[GoalNo]]) then
                                       OK:=False
                                  else
                             else break; {quick-and-dirty exit the 'for' loop as soon as it has been established that the unreachable goals from the square 'Index' isn't a subset of the unreachable goals from 'Square'}
                         if OK then begin {'True': the unreachable goals from the square number 'Index' is a subset of the unreachable goals from 'Square'}
                            if AddSquareToDeadlockSet(Index) then {collect the floor squares having a sub-set or the same set of reachable goals as 'Square'}
                               if   (Board[Index] and BOX)=0 then
                                    Inc(EmptySquaresCount)                {count the number of empty squares in the square set}
                               else Dec(DeadlockSetCandidate__.Capacity); {update the deadlock set capacity}
                            end;
                         end;
                  DeadlockSetCandidate__.Capacity:=Min(DeadlockSetCandidate__.Capacity,EmptySquaresCount); {'Min': the set cannot contain more boxes than the number of squares in the set}

                  if CommitDeadlockSet(False,False,False,Result) then with DeadlockSetCandidate__.Boxes do begin
                     for Index:=1 to Count do Visited[Squares[Index]]:=True; {each square can only be a member of one overflow area}

                     s:='Boxes at these squares cannot reach the goal(s):';
                     for GoalNo:=1 to GoalNumberSet.Count do begin
                         SquareToColRow(Game.GoalPos[GoalNumberSet.Numbers[GoalNo]],Col,Row);
                         s:=s+SPACE+LEFT_BRACKET+IntToStr(Col)+COMMA+IntToStr(Row)+RIGHT_BRACKET;
                         end;
                     WritelnToLogFile(s);
                     end;

                  if (Square and 15)=0 then TimeCheck; {the overflow area calculation may be time-consuming for a large board; keep track of the time and give the user a chance to terminate the task}
                  end;
               end;
        end;
    end;

    function  PatternTypeFencedInArea:Boolean;
    var i,j,SetNo:Integer;
    begin {pattern type "Fenced-in area"}
      {$IFDEF CONSOLE_APPLICATION}
        if Game.ShowDeadlockSetsEnabled then Writeln('Fenced-in area');
      {$ENDIF}
      Result:=True; SetNo:=0;
      while SetNo<Game.DeadlockSets.Count do with Game.DeadlockSets do begin    {for each deadlock set}
        Inc(SetNo);
        if CenterSquare[SetNo]<>0 then begin
           LoadCandidateFromSet(SetNo);
{
           if dsfDisconnectedInnerFloors in DeadlockSetCandidate__.Flags then begin
              Writeln(FloorCount[SetNo],SLASH,DeadlockSetCandidate__.PaintedFloorCount);
              Game.ShowDeadlockSetsEnabled:=True;
              ShowDeadlockSet(SetNo,CenterSquare[SetNo]);
              Game.ShowDeadlockSetsEnabled:=False;
              end;
}
{
           if SequenceNo[SetNo]>=19 then begin
              Writeln;
              Game.ShowDeadlockSetsEnabled:=True;
              ShowDeadlockSet(SetNo,CenterSquare[SetNo]);
              Writeln(Game.DeadlockSets.Count);
              //Readln;
              end;
}
           for i:=1 to DeadlockSetCandidate__.Boxes.Count do begin
               j:=0;
               ExpandDeadlockSet(i,True,False,j,Result);                        {try to expand the deadlock set}
               end;
           end;
        end;
    end;

  begin {CalculateDeadlockSets}
    with Game do begin
      DeadlockSets.ControllerAndFreezeSetPairsEnabled:=False; {'False: 'IsALegalPush' ignores controller/freeze-set deadlock pairs while deadlock sets are being calculated}
      if Position__=nil then begin // precalculate deadlock sets (called once during level initialization);}
         Result:=True;  {if 'Result' is 'False', then the start position is a deadlock}
         TimeMS:=GetTimeMS;
         DeadlockSets.Count:=0;
         DeadlockSets.PrecalculatedSetsCount:=0; DeadlockSets.DynamicSetsCount:=0;
         DeadlockSets.PathDeadlockCount:=0; DeadlockSets.NewDynamicDeadlockSets:=False;
         DeadlockSets.SequenceNo:=0; DeadlockSets.RedundantSetsCount:=0;
         DeadlockSets.SquaresOutsideFenceTop:=0;
         FillChar(DeadlockSets.SquareSetCount,SizeOf(DeadlockSets.SquareSetCount),0);
         FillChar(DeadlockSets.Statistics,SizeOf(DeadlockSets.Statistics),0);
         FillChar(DeadlockSets.SquaresOutsideFence,SizeOf(DeadlockSets.SquaresOutsideFence),0);
         DeadlockSets.Flags[0]:=[]; {so the first deadlock set cannot be mistaken for a freeze-set in a controller/freeze-set pair}
         FillChar(Corners,SizeOf(Corners),0);
         if LogFile.FileName<>'' then WriteBoardToLogFile(Game.Title);
         {initialize memory allocation of per square deadlock set numbers}
         Positions.Count := 0;
         Positions.EndOfPositions := Positions.HashBuckets; {drop precalculated deadlocks from a previouos level, if any}
         Positions.Capacity := ( Cardinal( Positions.EndOfPositions ) - Cardinal( Positions.Positions ) ) div SizeOf( TPosition );
         Positions.UninitializedItemCount := Integer( Positions.Capacity );

//       ShowDeadlockSetsEnabled:=True;

         {$IFDEF CONSOLE_APPLICATION}
           if      Game.ShowDeadlockSetsEnabled then begin
                   Writeln('*** ',Game.Title,' ***');
                   ShowBoard;
                   end
           else if Game.DeadlockSets.AdjacentOpenSquaresLimit>1 then
                   Write('Calculating deadlocks...');
         {$ENDIF}

         {first step is to find corners, including interior ones, and mark non-goal corners as illegal squares}
         Result:=Result and PatternTypeNonGoalCorner;

         {next step is to find closed edges and to mark simple illegal squares on these edges}
         Result:=Result and PatternTypeClosedEdgeWithoutGoals;

         {now that simple illegal squares are marked, it's possible to calculate squares reachable for at least 1 box}
         CalculateBoxReachableSquaresForAllBoxes;

         {gate squares can be calculated now that the reachable squares have been calculated}
         CalculateGateSquares;
         {ShowGateSquares; Readln;}

         {tunnel squares can be calculated now that the reachable squares and the gate squares have been calculated}
         {CalculateTunnelSquares;}

         {calculate distances from each square to each goal}
         if   Solver.PackingOrder.Enabled then with Solver.PackingOrder do
              CalculateSquareGoalDistances(1,Game.GoalCount,0,False,SquareGoalDistance,GoalBoxSets);
//       else FillChar(Solver.PackingOrder.SquareGoalDistance,SizeOf(Solver.PackingOrder.SquareGoalDistance),0);

         {calculate distance to nearest goal for all squares}
         CalculateDistanceToNearestGoalForAllSquares(True,Game.DistanceToNearestGoal);
         {ShowBoxDistanceToNearestGoal; Readln;}
         {ShowBoxDistanceToAllSquares(Game.DistanceToNearestGoal); Readln;}

         ShowIllegalBoxSquares; {actually, this procedure only shows the results if 'ShowDeadlockSetsEnabled' is 'True'}

         {generate deadlocks in an order which limits the number of futile sets}
         Result:=Result and PatternTypeClosedEdgeWithGoals;

         Result:=Result and PatternType4BlockA;

         Result:=Result and PatternType4BlockB;

         Result:=Result and PatternTypeBlockedGateAndOneWayTunnel;

         Result:=Result and PatternTypeDoubleL;

         {there is an overlap between 'Double-L' and '3-Blocks' but the latter}
         {haven't any center-squares and cannot be expanded like 'double-L'}
         {deadlocks; therefore, 'Double-L' deadlocks must be generated first}

         Result:=Result and PatternType3Block;

         Result:=Result and PatternTypeBlockedTunnel;

         Result:=Result and PatternTypeDiagonalClosedEdgeFence;

//       Result:=Result and PatternTypeSemiClosedLine;

         Result:=Result and PatternTypeCurrentPosition;

         Result:=Result and PatternTypeFencedInArea;

         Result:=Result and PatternTypeSemiClosedLine;

         Result:=Result and PatternTypeClosedEdgeFence;                         {do the most complex sets last in order to have simpler sets available for pruning}

         Result:=Result and PatternTypeFrozenGoals;

         if Solver.PackingOrder.Enabled then {calculating overflow area deadlocks requires the squares->goals distances, hence, deadlocks of this type are only made if the distances have been calculated}
            Result:=Result and PatternTypeOverflowAreas;

//
         {$IFDEF CONSOLE_APPLICATION}
           if (Game.DeadlockSets.AdjacentOpenSquaresLimit>1) and
              (not Game.ShowDeadlockSetsEnabled) then
              Writeln;
         {$ENDIF}

         with DeadlockSets do
           for i:=Count downto 1 do
               if (CenterSquare[i]<>0) and IsARedundantDeadlockSet(i) then begin
                  DeleteDeadlockSet(i); Inc(RedundantSetsCount);
                  end;

         {protect the per square deadlock set numbers from overwriting by items in the transposition table by setting the 'EndOfPositions' high water mark}
         Positions.EndOfPositions                   := Pointer( Addr( Positions.Positions^[ Positions.Capacity ] ) );
         {remember the per square deadlock set numbers for the precalculated deadlock sets}
         DeadlockSets.PrecalculatedSquareSetNumbers := DeadlockSets.SquareSetNumbers;

         Game.DeadlockSets.TimeMS:=CalculateElapsedTimeMS(TimeMS,GetTimeMS);

         if DeadlockSets.RedundantSetsCount<>0 then with DeadlockSets do begin
            WritelnToLogFile('');
            WritelnToLogFile('Redundant precalculated deadlock sets:');
            for i:=1 to Pred(Count) do
                for j:=Succ(SequenceNumbers[i]) to Pred(SequenceNumbers[Succ(i)]) do
                    WritelnToLogFile(SPACE+SPACE+IntToStr(j));
            end;

         WritelnToLogFile('');
         WritelnToLogFile('Active precalculated deadlock sets: '+IntToStr(Game.DeadlockSets.Count));
         if Game.DeadlockSets.RedundantSetsCount<>0 then
            WritelnToLogFile('Redundant precalculated deadlock sets: '+IntToStr(Game.DeadlockSets.RedundantSetsCount));
         //WritelnToLogFile('Time: '+IntToStr(Game.DeadlockSets.TimeMS)+' milli seconds');
         WritelnToLogFile('');
         end
      else with DeadlockSetCandidate__ do begin {'Position__<>nil': check if the candidate in 'DeadlockSetCandidate__' is a valid deadlock set}
         TimeMS:=GetTimeMS;

         if   not (dsfTestFrozenGoalsSet in Flags) then
              Result:=CommitDynamicallyCreatedDeadlockSet(Position__)<>0
         else Result:=PatternTypeFrozenGoals;

         TimeMS:=CalculateElapsedTimeMS(TimeMS,GetTimeMS);
         if   Game.DeadlockSets.TimeMS<=High(Game.DeadlockSets.TimeMS)-TimeMS then {in practice, this may be a silly test, but the program strives for correct behavior (in most cases)}
              Game.DeadlockSets.TimeMS:=Game.DeadlockSets.TimeMS+TimeMS
         else Game.DeadlockSets.TimeMS:=High(Game.DeadlockSets.TimeMS);
         end;

      DeadlockSets.ControllerAndFreezeSetPairsEnabled:=True; {'True': 'IsALegalPush' takes controller/freeze-set deadlock pairs into account}
      if (Position__=nil) or Result then FlushLogFile; {flush the log-file, if any}
      end;
end; {CalculateDeadlockSets}

function  CheckDeadlockSetCapacities:Boolean;
var SetNo:Integer;
begin {a sanity check of the capacity calculation; the test is far from being 100% accurate; it's just a simple check that the capacities don't exceed the number of squares}
  Result:=True;
  with Game.DeadlockSets do
    for SetNo:=1 to Count do
        if Result then begin
           Result:=((Capacity[SetNo]>=-1) {for legal positions independent of the player position, capacity >=0, and for a deadlocked position, capacity = -1}
                    or
                    ((Flags[SetNo]*[dsfControllerSet,dsfFreezeSet,dsfPlayerMustBeOutsideSet])<>[]) {special capacity rules apply to controller sets, freeze sets and sets dependent of the player position, hence, these sets are not considered here}
                   )
                   and
                   (Capacity[SetNo]<=SquaresCount[SetNo]);

           if not Result then begin
              {$IFDEF CONSOLE_APPLICATION}
                Writeln('-----');
                Writeln('Set: ',SetNo,' Capacity: ',Capacity[SetNo],' Number of squares: ',SquaresCount[SetNo]);
                ShowBoard;
                Game.ShowDeadlockSetsEnabled:=True;
                ShowDeadlockSet(SetNo,CenterSquare[SetNo]);
                Readln;
              {$ELSE}
                //Msg(TEXT_INTERNAL_ERROR+
                //    ': Deadlock set '+IntToStr(SequenceNo[SetNo])+' ('+IntToStr(SetNo)+
                //    ') Capacity: '+IntToStr(Capacity[SetNo])+' Squares: '+IntToStr(SquaresCount[SetNo]),
                //    TEXT_APPLICATION_TITLE);
              {$ENDIF}
              end;

           end;
end;

{-----------------------------------------------------------------------------}

{Game}

function  InitializeGame(var PluginResult__:TPluginResult; var ErrorText__:String):Boolean;
var BoxNo,SquareNo:Integer; StartTimeMS:TTimeMS;
    OriginalSearchLimits:TSearchLimits;
    DeadlockSetCandidate:TDeadlockSetCandidate;

  function  FindBoxesAndGoalsAndPlayer(var PluginResult__:TPluginResult; var ErrorText__:String):Boolean;
  var i,LoopCount:Integer;

    function  ChangeUnreachableBoxesAndGoalsToWalls:Integer;
    var i,SquareNo:Integer;
    begin
    {any immovable boxes and unreachable boxes and goals are converted to
     walls here, before taking the 'original level' snaphot; otherwise, more
     work would be required at the end of a solver/optimizer search to map box
     numbers back and forth;
    }
      Result:=0;
      if Game.PlayerPos<>0 then with Game do with Solver.SearchStates[0].PlayersReachableSquares do begin
         for i:=1 to BoxCount do Dec(Board[BoxPos[i]],BOX); {remove all boxes from the board}
         ClearPlayersReachableSquares(0); {initialize calculation of the player's reachable squares, using index '0'}
         CalculatePlayersReachableSquares(0); {calculate the player's reachable squares on the empty board}
         for i:=1 to BoxCount do Inc(Board[BoxPos[i]],BOX); {put all boxes back on the board}

         for i:=1 to BoxCount do begin
             SquareNo:=BoxPos[i];
             {the flag 'FLAG_BOX_REACHABLE_SQUARE' hasn't been calculated for the squares yet; 'IsAFreezingMove()' checks this flag; fake that all squares are box-reachable so 'IsAFreezingMove()' can be of some use for detecting immovable boxes}
             Board[SquareNo]:=Board[SquareNo] or FLAG_BOX_REACHABLE_SQUARE;
             if (Squares[SquareNo]<>TimeStamp) or                               {'True': the player can never reach the box  square, hence, the square can just as well be a wall}
                IsAFreezingMove(0,SquareNo,True) then begin                     {'True': the box is immovable, hence, the square can just as well be a wall}
                Board[SquareNo]:=WALL;
                Inc(Result);
                end;
             Board[SquareNo]:=Board[SquareNo] and (not FLAG_BOX_REACHABLE_SQUARE); {remove the artificial 'FLAG_BOX_REACHABLE_SQUARE' flag again}
             end;

         for i:=1 to GoalCount do
             if Squares[GoalPos[i]]<>TimeStamp then begin                       {'True': the player can never reach the goal square, hence, the square can just as well be a wall}
                Board[GoalPos[i]]:=WALL;
                Inc(Result);
                end;
         end;
    end;

  begin {'FindBoxesAndGoalsAndPlayer'; precondition: the board has been initialized by calling 'InitializeBoard'}
    Result:=True;
    LoopCount:=0;
    with Game do begin
      repeat
        PlayerPos:=0; Game.BoxCount:=0; GoalCount:=0;
        for i:=0 to BoardSize do begin
            Board[i]:=Board[i] and BOARD_PIECES; {reset old flags, if any}
            if   (Board[i] and BOX)<>0 then
                 if   Game.BoxCount<MAX_BOX_COUNT then begin
                      Inc(Game.BoxCount);
                      BoxPos[Game.BoxCount]:=i;
                      Inc(Board[i],FLAG_BOX_START_SQUARE);
                      end
                 else begin Dec(Board[i],BOX);
                            Result:=False; PluginResult__:=prConstraintsViolation;
                            ErrorText__:=TEXT_LEVEL_HAS_TOO_MANY_BOXES_AND_GOALS;
                      end;
            if   (Board[i] and GOAL)<>0 then
                 if   GoalCount<MAX_BOX_COUNT then begin
                      Inc(GoalCount);
                      GoalPos[GoalCount]:=i;
                      end
                 else begin Dec(Board[i],GOAL);
                            Result:=False; PluginResult__:=prConstraintsViolation;
                            ErrorText__:=TEXT_LEVEL_HAS_TOO_MANY_BOXES_AND_GOALS
                      end;
            if   (Board[i] and PLAYER)<>0 then
                 if   PlayerPos=0 then
                      PlayerPos:=i
                 else Dec(Board[i],PLAYER);
            end;
        if (Game.BoxCount<>Game.GoalCount) and (LoopCount=0) and Result then begin
           PluginResult__:=prInvalidLevel;
           ErrorText__:=TEXT_LEVEL_HAS_NOT_THE_SAME_NUMBER_OF_BOXES_AND_GOALS;
           Result:=False;
           end;
        Inc(LoopCount);
      until (not Result) or (PlayerPos=0) or (ChangeUnreachableBoxesAndGoalsToWalls=0);

      if  Game.BoxCount<>Game.GoalCount then begin
          for i:=Succ(Min(Game.BoxCount,GoalCount)) to Game.BoxCount  do Dec(Board[BoxPos [i]],BOX+FLAG_BOX_START_SQUARE);
          for i:=Succ(Min(Game.BoxCount,GoalCount)) to GoalCount      do Dec(Board[GoalPos[i]],GOAL);
          Game.BoxCount:=Min(Game.BoxCount,GoalCount); GoalCount:=Game.BoxCount;
          if Result then begin
             PluginResult__:=prUnsolvable;
             ErrorText__:=TEXT_LEVEL_UNSOLVABLE;
             Result:=False;
             end;
          end;

      {insert the goal numbers in the board square values so there is a mapping
       from the board squares back to the goal numbers; note that the mapping
       relies on the goal numbers occupying the high-order bits for each square;
      }
      for i:=1 to GoalCount do
          Board[GoalPos[i]]:=Board[GoalPos[i]]+Cardinal(i shl GOAL_BIT_SHIFT_COUNT);

      if  Result and (PlayerPos=0) then begin
          Result:=False; PluginResult__:=prInvalidLevel;
          ErrorText__:=TEXT_LEVEL_HAS_NO_PLAYER;
          end;
      end;
  end; {FindBoxesAndGoalsAndPlayer}

  procedure FillTubes;
  var i,j,BoxOnGoalCount,NeighborFloorCount,NewBoxPos,NewPlayerPos:Integer;
      DeadEnd,More:Boolean; Dir,Direction:TDirection;
  begin {precondition: positions of player and boxes have been calculated by 'FindBoxesAndGoalsAndPlayer'}
    with Game do begin
      BoxOnGoalCount:=0; Direction:=dUp; History.Moves[0].Direction:=dUp; {the 0-element move contains the last tubefilling player move direction, even if the tubefiller also adds pushes to the history}
      TubeFillingMoveCount:=0; TubeFillingPushCount:=0; TubeFillingPlayerLines:=0; {initialize player moves, player lines, and box pushes}
      for i:=1 to Game.BoxCount do
          if IsAGoalSquare(BoxPos[i]) then Inc(BoxOnGoalCount);

      repeat
        More:=False;
        for i:=0 to BoardSize do
            if (Board[i] and (WALL+BOX+GOAL))=0 then begin {for each non-goal, non-box floor-square...}
               NeighborFloorCount:=0;
               for Dir:=Low(Dir) to High(Dir) do
                   if IsAFloorSquare(i+SquareOffsetForward[Dir]) then begin
                      Inc(NeighborFloorCount); Direction:=Dir;
                      end;
               if NeighborFloorCount<=1 then begin {the floor-square is surrounded by 3 or 4 walls}
                  DeadEnd:=True; NewBoxPos:=0; NewPlayerPos:=0;
                  if i=PlayerPos then
                     if NeighborFloorCount=0 then
                        DeadEnd:=False {the player is on an isolated square, don't change anything}
                     else begin        {try to move the player to the neighbor floor-square}
                        NewPlayerPos:=i+SquareOffsetForward[Direction];
                        if IsABoxSquare(NewPlayerPos) then begin
                           NewBoxPos:=NewPlayerPos+SquareOffsetForward[Direction];
                           DeadEnd:=((Board[NewBoxPos] and (WALL+BOX))=0) and   {the box can be pushed forwards}
                                    (BoxOnGoalCount<Game.BoxCount) and          {the position isn't a solution}
                                    (History.Count<High(History.Moves));        {the game history isn't full}
                           end;
                        end;
                  if DeadEnd then begin {dead-end: place a wall on the square}
                     if NewBoxPos<>0 then begin {move a box}
                        for j:=1 to Game.BoxCount do {find the box number}
                            if BoxPos[j]=NewPlayerPos then begin
                               if IsAGoalSquare(BoxPos[j]) then Dec(BoxOnGoalCount);
                               Dec(Board[BoxPos[j]],BOX); BoxPos[j]:=NewBoxPos;
                               Inc(Board[BoxPos[j]],BOX);
                               if IsAGoalSquare(BoxPos[j]) then Inc(BoxOnGoalCount);
                               Inc(TubeFillingPushCount);
                               Inc(History.Count);
                               History.Moves[History.Count].BoxNo:=j;
                               History.Moves[History.Count].Direction:=Direction;
                               break;
                               end;
                        end;
                     if NewPlayerPos<>0 then begin {move the player}
                        Dec(Board[PlayerPos],PLAYER); PlayerPos:=NewPlayerPos;
                        Inc(Board[PlayerPos],PLAYER);
                        if   TubeFillingMoveCount<>0 then begin
                             if Direction<>History.Moves[0].Direction then Inc(TubeFillingPlayerLines);
                             end
                        else TubeFillingPlayerLines:=1; {the first move counts as a playerline}
                        History.Moves[0].Direction:=Direction; {{the 0-element move contains the last tubefilling player move direction, even if the tubefiller also adds pushes to the history}
                        Inc(TubeFillingMoveCount);
                        end;
                     Board[i]:=WALL; More:=True;
                     end;
                  end;
               end;
      until not More;
      end;
  end; {FillTubes}

  function  CalculatePackingOrder:Boolean;
    type TPackingOrderType=(poNone,poPullBoxes,poPullBoxesToStartingPositionsWithoutParking,poPullBoxesToStartingPositionsWithParking); {item order cannot change}
         TSquareBoxSets=array[0..MAX_BOARD_SIZE] of TBoxSetWithCount; {for each square, the box starting positions/goals that are pull/push-reachable from the square}
    var  ConnectedGoalsCount,GoalGroupCount,SquareGoalNo,SquareValue:Integer;
         //BoxGoalSets:TBoxGoalSets;
         OriginalSearchLimits:TSearchLimits;
         GoalGroupNumbers:TBoxNumbers; {for each goal, the group of connected goals to which it belongs}
         //SquareBoxSets,SquareGoalSets:TSquareBoxSets;

    procedure CalculateConnectedGoals(var ConnectedGoalsCount__,GoalGroupCount__:Integer; var GoalGroupNumbers__:TBoxNumbers);
    var Count,GoalNo:Integer;

      function  FindConnectedGoals(GoalSquare__,VisitedCount__,GroupNo__:Integer;
                                   var GoalGroupNumbers__:TBoxNumbers):Integer;
      var NeighborSquare:Integer; Direction:TDirection;
      begin {precondition: 'GoalSquare__' is an unvisited goal}
        Result:=Succ(VisitedCount__); {'+1': 'GoalSquare__' is a not previously visited goal}
        GoalGroupNumbers__[Game.Board[GoalSquare__] shr GOAL_BIT_SHIFT_COUNT]:=GroupNo__; {assign the current group number to this goal number; 'shr': the goal numbers are stored in the high-order bits of the board square values}
        for Direction:=Low(Direction) to High(Direction) do begin
            NeighborSquare:=GoalSquare__+Game.SquareOffsetForward[Direction];
            if ((Game.Board[NeighborSquare] and GOAL)<>0)                       {'True': the neighbor square is also a goal}
               and
               (GoalGroupNumbers__[Game.Board[NeighborSquare] shr GOAL_BIT_SHIFT_COUNT]=0) {'True': the neighbor goal hasn't been assigned a group number yet}
               and
               (
                {the goal has an unvisited neighboring goal in this direction
                 but the squares along the other axis is also taken into
                 account; this improves the program's ability to distinguish
                 between true goal-rooms and goals that just happen to be
                 loosely connected, say, by being on a line in the middle of the
                 board;

                 only goals with a neighboring goal or a neighboring wall on the
                 other axis are counted as connected goals, counting towards the
                 threshold for the packing-order search;
                }
                ((Game.Board[GoalSquare__+Game.SquareOffsetLeft [Direction]] and (WALL+GOAL))<>0) {caution: assumes 4 directions only}
                or
                ((Game.Board[GoalSquare__+Game.SquareOffsetRight[Direction]] and (WALL+GOAL))<>0) {caution: assumes 4 directions only}
               )
               then
               Result:=FindConnectedGoals(NeighborSquare,Result,GroupNo__,GoalGroupNumbers__);
            end;
      end; {CalculatePackingOrder.CalculateConnectedGoals.FindConnectedGoals}

    begin {CalculatePackingOrder.CalculateConnectedGoals}
      with Game do begin
        ConnectedGoalsCount__:=0; GoalGroupCount__:=0;
        FillChar(GoalGroupNumbers__,SizeOf(GoalGroupNumbers__),0);

        {find connected goal groups}
        for GoalNo:=1 to GoalCount do
            if GoalGroupNumbers__[GoalNo]=0 then begin {'True': the goal square hasn't been visited before, meaning it hasn't been assigned a group number yet}
               Inc(GoalGroupCount__);
               Count:=FindConnectedGoals(GoalPos[GoalNo],0,GoalGroupCount__,GoalGroupNumbers__); {'FindConnectedGoals()' returns the number of goals connected to 'GoalNo' (including the goal 'GoalNo')}
               if Count>1 then Inc(ConnectedGoalsCount__,Count);
               end;
        end;
    end; {CalculatePackingOrder.CalculateConnectedGoals}

    procedure CalculatePullReachableGoalsForAllSquares(var SquareGoalSets__:TSquareBoxSets); {not used}
    var  BoxNo,GoalNo,OldPlayerPosition,Square:Integer;
         Distances:TSquareDirectionArrayOfInteger;
    begin {CalculatePackingOrder.CalculatePullReachableGoalsForAllSquares}
      with Game do begin
        OldPlayerPosition:=PlayerPos;
        for BoxNo:=1 to Game.BoxCount do Dec(Board[BoxPos[BoxNo]],BOX); {remove all boxes from the board}

        FillChar(SquareGoalSets__,SizeOf(SquareGoalSets__),0);

        for Square:=0 to BoardSize do
            if ((Board[Square] and (WALL+FLAG_BOX_REACHABLE_SQUARE+FLAG_ILLEGAL_BOX_SQUARE))=FLAG_BOX_REACHABLE_SQUARE) and {'True': the square isn't a wall, and it's a legal box-reachable square}
               (Solver.SearchLimits.DepthLimit>=0) then begin {'True': the solver hasn't been terminated}
               CalculateBoxPullOrPushDistances(Square,SEARCH_STATE_INDEX_DO_PUSH,False,False,False,Distances);

               for GoalNo:=1 to BoxCount do
                   if MinimumDistanceToSquare(GoalPos[GoalNo],Distances)<>INFINITY then with SquareGoalSets__[Square] do begin
                      Inc(Count); Include(BoxSet,GoalNo);
                      end;

               TimeCheck; {the calculation of the reachable goals for each square can be a time consuming task if it's a large and open board; check that the calculation doesn't exceed the time limit, if any}
               end;

        for BoxNo:=1 to Game.BoxCount do Inc(Board[BoxPos[BoxNo]],BOX); {put all boxes back on the board}
        PlayerPos:=OldPlayerPosition; {restore player position}
        end;
    end; {CalculatePackingOrder.CalculatePullReachableGoalsForAllSquares}

    procedure CalculateReachableBoxStartPositionsForAllSquares(var SquareBoxSets__:TSquareBoxSets); {not used}
    var BoxNo,Square:Integer; Distances:TBoardOfIntegers;
    begin
      with Game do begin
        FillChar(SquareBoxSets__,SizeOf(SquareBoxSets__),0);
        for BoxNo:=1 to BoxCount do {for each box, calculate the distances to the reachable squares by pushing the box around on the (empty) board}
            if Solver.SearchLimits.DepthLimit>=0 then begin {'True': the search hasn't been terminated; (the search may be terminated manually by the user or by a time limit)}
               CalculateDistanceToNearestBoxStartPositionForAllSquares(BoxNo,BoxNo,True,Distances);
               for Square:=0 to BoardSize do
                   if Distances[Square]<>INFINITY then with SquareBoxSets__[Square] do begin {'True': the square is push-reachable from the current box starting position}
                      Inc(Count); Include(BoxSet,BoxNo);
                      end;
               TimeCheck; {give the user a chance to terminate the calculation in case it takes too long time}
               end;
        end;
    end; {CalculatePackingOrder.CalculateReachableBoxStartPositionsForAllSquares}

    procedure CalculateReachableGoalsFromEachBoxStartPosition(const SquareBoxSets__:TSquareBoxSets; var BoxGoalSets__:TBoxGoalSets); {not used}
    var BoxNo,GoalNo:Integer;
    begin
      with Game do begin
        FillChar(BoxGoalSets__,SizeOf(BoxGoalSets__),0);
        for GoalNo:=1 to BoxCount do with SquareBoxSets__[GoalPos[GoalNo]] do
            for BoxNo:=1 to BoxCount do
                if BoxNo in BoxSet then with BoxGoalSets__[BoxNo] do begin
                   Inc(Count); Include(BoxSet,GoalNo);
                   end;
        end;
    end; {CalculatePackingOrder.CalculateReachableGoalsFromEachBoxStartPosition}

    procedure PackingOrderToText(var BoardAsTextLines__:TBoardAsTextLines);
    const PADDING_CHARACTER='-'; // CH_FLOOR;
    var Col,Row,SetNo,Square,SquareValue:Integer; s:String;
    begin
      for Row:=1 to Game.BoardHeight do with Game do begin
          BoardAsTextLines__[Row]:='';
          for Col:=1 to BoardWidth do begin
              Square:=ColRowToSquare(Col,Row);
              SquareValue:=Board[Square];
              if ((SquareValue and GOAL)=0) and
                 ( SquareValue shr GOAL_BIT_SHIFT_COUNT=0) then begin
                 if   (SquareValue and WALL)<>0 then
                      s:=CH_WALL
                 else s:=PADDING_CHARACTER;
                 BoardAsTextLines__[Row]:=BoardAsTextLines__[Row]+PADDING_CHARACTER+PADDING_CHARACTER+s;
                 end
              else with Solver.PackingOrder do begin
                 s:='';
                 SetNo:=Solver.PackingOrder.GoalSetNo[SquareValue shr GOAL_BIT_SHIFT_COUNT];
                 if SetNo<>0 then s:=IntToStr(SetNo); //s:=IntToStr(Succ( SetCount ) - SetNo);
                 while Length(s)<3 do s:=PADDING_CHARACTER+s;
                 BoardAsTextLines__[Row]:=BoardAsTextLines__[Row]+s;
                 end;
              end;
          end;
    end; {CalculatePackingOrder.PackingOrderToText}

    procedure ShowPackingOrder;
    var Row:Integer; BoardAsTextLines:TBoardAsTextLines;
    begin
      with Game do begin
        Write(TEXT_PACKING_ORDER);
        if Solver.PackingOrder.SetCount<=0 then Write(' (none)');
        Writeln;
        PackingOrderToText(BoardAsTextLines);
        for Row:=1 to BoardHeight do
            Writeln(BoardAsTextLines[Row]);
        Msg('','');
        end;
    end; {CalculatePackingOrder.ShowPackingOrder}

    function  CalculatePackingOrder__(PackingOrderType__:TPackingOrderType):Boolean;
    const GOAL_DISTANCE_TO_NEIGHBOR_GROUP_THRESHOLD=3;
    var   i,j,{BlockedAxisCount,}BoxNo,GoalNo,{GroupNo,}
          OldPlayerPos,ParkBoxesCountDown,
          Square,SetNo,{NewSetNo,}{MaxGoalSetNo,}Row{,Col1,Col2,Row1,Row2}:Integer;
          {GoalMinDistanceToNeighborGroup,}SetSize:TBoxArrayOfIntegers;
          //Distances:TSquareDirectionArrayOfInteger;
          BoardAsTextLines:TBoardAsTextLines;

      function  Search(PlayerPos__:Integer; PackingOrderType__:TPackingOrderType):Boolean;
      const MAX_PARKED_TWICE_GOAL_COUNT=2;
      var   BoxNo,GoalNo{,NewBoxPos,NewPlayerPos},PullCount:Integer;
            ParkedTwiceGoalSet,SeenBoxStartPositions:TBoxSetWithCount;
            ReachableBoxStartingPositions:array[0..MAX_BOX_COUNT] of TBoxSetWithCount;
            UsedBoxStartPositions:TBoxNumbers;

        function  Search__(SetCount__,SetMembersCount__,GoalAndParkingSquareCount__,
                           RemainingBoxCount__,PlayerPos__:Integer;
                           SeenBoxStartPositions__:TBoxSetWithCount;
                           var ParkedTwiceGoalSet__:TBoxSetWithCount;
                           var UsedBoxStartPositions__:TBoxNumbers):Boolean; {this is a depth-first recursive search where 'SetCount__' depicts the search depth}
        type TParkingSpace =record Distance,Square,PlayerPositionAfterParking:Integer; end;
             TParkingSpaces=array[0..2] of TParkingSpace; {elements 1..2 are the true parking spaces; element 0 is only used as a local variable}
        var  BoxNo,BoxStartPosIndex,Count,GoalNo,i,Index,j,NeighborFloorCount,
             NewPlayerPos,NewSetNo,Square,NeighborSquare:Integer;
             Direction:TDirection;
             ParkingSpaces:TParkingSpaces; TestedGoalsSet:TGoalSet;

          procedure ShowUnusedBoxStartingPositions;
          var BoxNo,StartBoxPosition:Integer;
          begin
            Write('Unused box starting positions: ');
            for BoxNo:=1 to Game.BoxCount do with Game do begin
                 StartBoxPosition:=BoxPos[BoxNo];
                 if (Board[StartBoxPosition] and FLAG_VISITED_SQUARE)=0 then begin
                     Write(LEFT_BRACKET,SquareToColRowAsText(StartBoxPosition),RIGHT_BRACKET,SPACE,SPACE);
                     end;
                 end;
            Writeln;
          end;

          function  FindGoalCandidateForParking(SearchDepth__:Integer; const TestedGoalsSet__:TGoalSet; const ParkedTwiceGoalSet__:TBoxSetWithCount; var GoalNo__:Integer; var ParkingSpaces__:TParkingSpaces):Integer;
          {returns the number of found parking spaces, i.e., 0..2}
          var GoalNo,ParkingSpacesCount,Square:Integer;
              IsACornerGoalSquare:Boolean;
              Direction:TDirection;
              ParkingSpaces:TParkingSpaces;

            function  CanPullBoxToParkingSquare(GoalNo__:Integer; var ParkingSpaces__:TParkingSpaces):Integer; {returns the number of found parking spaces, i.e., 0..2}
            const SEARCH_STATE_INDEX=SEARCH_STATE_INDEX_SCRATCHPAD_1; {index for calculating the player's reachable squares; 'Solver.SearchStates' must be freely available for the chosen index}
            var   BoxSquare,{Col,Row,}Distance,
                  OldPlayerPosition,Square:Integer;
                  Direction{,d}:TDirection;
                  BoxPullSquareDirectionDistances{,Distances}:TSquareDirectionArrayOfInteger;
                  BoxPushBackToGoalDistances:TBoardOfIntegers;
            begin {CalculatePackingOrder.CalculatePackingOrder__.Search.Search__.FindGoalCandidateForParking.CanPullBoxToParkingSquare}
              {the primary parking square is the one with the highest distance
               between the parking square and the goal square, measuring the
               push-distance on an empty board;
               these square-to-goal distances have already been calculated and
               are available in 'Solver.PackingOrder.SquareGoalDistance[,];

               the secondary parking square is the one with the highest
               Manhattan distance between the goal square and the parking
               square; as tiebreaker, the Manhattan distance between the
               primary and second parking square is used;
              }
              with Game do with Solver.SearchStates[SEARCH_STATE_INDEX] do begin
                Result:=0;
                ParkingSpaces__[1].Square:=0; ParkingSpaces__[2].Square:=0;

                BoxSquare:=GoalPos[GoalNo__];
                CalculateBoxPullOrPushDistances(BoxSquare,SEARCH_STATE_INDEX,False,True,False,BoxPullSquareDirectionDistances);
                {the 'True' parameter: the player's current position matters
                 when the initial legal pulls are generated;
                 otherwise all pullable boxes would be considered;
                }

                OldPlayerPosition:=PlayerPos;
                Dec(Board[BoxSquare],BOX); {temporarily remove the box from the square}

                {the calculation above found parking square candidates by
                 pulling the box away from the goal square, using the current
                 game state;
                 now find the highest parking distance from the goal square,
                 measured as push-distance from the goal square to the parking
                 square;
                }
                ParkingSpaces__[1].Distance:=-1; ParkingSpaces__[2].Distance:=-1;
                for Square:=0 to BoardSize do begin
                    Distance:=MinimumDistanceToSquare(Square,BoxPullSquareDirectionDistances);
                    if Distance<>INFINITY then {'True': the box can be pulled from the goal square to 'Square'}
                       if GoalNo__<=GoalCount then begin {'True': it's a normal goal square and not a parking space}
                          if   Solver.PackingOrder.SquareGoalDistance[Square,GoalNo__]<High(Solver.PackingOrder.SquareGoalDistance[Square,GoalNo__]) then {'True': the distance to the goal doesn't exceed the (byte-sized) maximum distance}
                               Distance:=Solver.PackingOrder.SquareGoalDistance[Square,GoalNo__]
                          else Distance:=INFINITY;
                          end
                       else begin
                          {the goal square is not a normal goal square but a
                           parking space, i.e., a pseudo goal;
                           square->goal distances are not available for parking
                           spaces at this time; only allow the parked box to
                           move a few steps away from its current parking space;
                          }
                          if   Distance<=2 then begin
                               end
                          else Distance:=INFINITY;
                          end;
                    BoxPushBackToGoalDistances[Square]:=Distance;

                    if   Distance<>INFINITY then begin
                         for Direction:=Low(Direction) to High(Direction) do
                             if Abs(BoxPullSquareDirectionDistances[Square,Direction])<>INFINITY then
                                BoxPullSquareDirectionDistances[Square,Direction]:=Distance; {overwrite the pull distance with the distance measured on an empty board}

                         if Distance>ParkingSpaces__[1].Distance then ParkingSpaces__[1].Distance:=Distance;
                         Distance:=ManhattanDistance(BoxSquare,Square);
                         if Distance>ParkingSpaces__[2].Distance then ParkingSpaces__[2].Distance:=Distance;
                         end;
                    end;

                repeat {find parking squares as far away from the goal square as possible}
                       Square:=0;
                       while Square<BoardSize do begin
                         Inc(Square);
                         if ((Board[Square]
                              and
                              (FLAG_BOX_REACHABLE_SQUARE+FLAG_ILLEGAL_BOX_SQUARE+FLAG_VISITED_SQUARE+
                               +
                               FLAG_GATE_SQUARE+DIRECTION_TO_TUNNEL_FLAGS)) {gate squares and 'do not stop here' tunnel squares are avoided}
                             =
                             FLAG_BOX_REACHABLE_SQUARE
                            )
                            and
                            (
                             ((Result=0) {'0': search for a primary parking square, with maximum push distance}
                              and
                              (BoxPushBackToGoalDistances[Square] =ParkingSpaces__[1].Distance)
                             )
                             or
                             ((Result=1) {'1': search for a secondary parking square, with maximum Manhattan distance between the box square and the parking square}
                              and
                              (ManhattanDistance(Square,BoxSquare)=ParkingSpaces__[2].Distance)
                              and
                              (Square<>ParkingSpaces__[1].Square)               {'True': the square is different from the best parking square counting push-back distance}
                             )
                             or
                             ((Result=2) {'2': search for a secondary parking square, with maximum Manhattan distance between box square and parking square, using Manhattan distance between primary and secondary parking square as tiebreaker}
                              and
                              (ManhattanDistance(Square,BoxSquare)=ParkingSpaces__[2].Distance)
                              and {'True': the square is farther away from the primary parking space than the existing secondary parking space}
                              (ManhattanDistance(Square                   ,ParkingSpaces__[1].Square)
                               >
                               ManhattanDistance(ParkingSpaces__[2].Square,ParkingSpaces__[1].Square)
                              )
                             )
                            )
                            then
                            {'Square' is a parking square candidate; check that
                             the pusher can get back to where it came from if
                             this square is used as parking square; this is the
                             criteria used for selecting a parking square;
                            }
                            for Direction:=Low(Direction) to High(Direction) do
                                if (Square<=BoardSize) and
                                   (BoxPullSquareDirectionDistances[Square,Direction]<>INFINITY) then begin
                                   Inc(Board[Square],BOX); {put the box on the square}

                                   ParkingSpaces__[0].PlayerPositionAfterParking:=Square+SquareOffsetForward[Direction]; {uses 'ParkingSpaces__[0]' as a temporary variable}
                                   MovePlayer(ParkingSpaces__[0].PlayerPositionAfterParking);  {move the player next to the box}

                                   CalculatePlayersReachableSquares(SEARCH_STATE_INDEX);

                                   Dec(Board[Square],BOX); {remove the box from the square again}

                                   if PlayersReachableSquares.Squares[BoxSquare]=PlayersReachableSquares.TimeStamp then begin
                                      {the pusher can get back to where it came
                                       from if this square is used as parking
                                       square;
                                      }
                                      if Result<2 then Inc(Result);
                                      ParkingSpaces__[Result].Square:=Square;
                                      ParkingSpaces__[Result].PlayerPositionAfterParking:=ParkingSpaces__[0].PlayerPositionAfterParking;
                                      if Result=1 then                          {'True': the primary parking square has just been found; start searching for the secondary parking square}
                                         Square:=Succ(BoardSize);               {'Succ': break out of the 'for each direction' loop and the 'while Square<=BoardSize' loop}
                                      end;
                                   end;
                         end;

                       if Square=BoardSize then                                    {'True': no parking square was found with the currently tested distance}
                          if      Result=0 then Dec(ParkingSpaces__[1].Distance)   {prepare for the next round if no square was found with the currently tested parking distance}
                          else if Result=1 then Dec(ParkingSpaces__[2].Distance);  {prepare for the next round if no square was found with the currently tested parking distance}
                until  (Result=2) {until two parking square candidates have been found, or until all parking distances have been tested}
                       or
                       (ParkingSpaces__[1].Distance<=0)
                       or
                       (ParkingSpaces__[2].Distance<=0);

                Inc(Board[BoxSquare],BOX); {put the box back on the square}
                MovePlayer(OldPlayerPosition); {restore the player position}
                end;
            end; {CalculatePackingOrder.CalculatePackingOrder__.Search.Search__.FindGoalCandidateForParking.CanPullBoxToParkingSquare}

          begin {CalculatePackingOrder.CalculatePackingOrder__.Search.Search__.FindGoalCandidateForParking}
                {precondition: the player's reachable squares have been calculated by calling 'CalculatePlayersReachableSquares(SearchDepth__)', i.e., with index 'SearchDepth__'}
            with Game do with Solver.PackingOrder do with Solver.SearchStates[SearchDepth__] do begin
              Result:=0;
              ParkingSpaces__[1].Distance:=-1;

              for GoalNo:=1 to {GoalCount} GoalAndParkingSquareCount__ do begin
                  Square:=GoalPos[GoalNo];
                  if (GoalSetNo[GoalNo]=0) and                                  {'True': the goal hasn't been assigned a packing order set number yet}
                     (not (GoalNo in TestedGoalsSet__)) and                     {'True': the box hasn't used its chance for parking}
                     ((Board[Square] and BOX)<>0) and                           {'True': there is a box at the goal square (a sanity check; it should always be true)}
                     ((GoalNo<=GoalCount)
                      or
                      ((ParkedTwiceGoalSet__.Count<MAX_PARKED_TWICE_GOAL_COUNT) {'True': the maximum number of parked-twice boxes hasn't been exceeded}
                       and
                       (not (GoalNo in ParkedTwiceGoalSet__.BoxSet))
                      )
                     ) and
                     (ParkBoxesCountDown>0) and                                 {'True': the maximum number of parking attempts hasn't been exceeded}
                     (Solver.SearchLimits.DepthLimit>=0) then begin             {'True': the search hasn't been terminated; (the search may be terminated manually by the user, or by a time limit)}
                     IsACornerGoalSquare:=False;
                     for  Direction:=Low(Direction) to High(Direction) do
                          if ((Board[Square+SquareOffsetForward[Direction]] and WALL)<>0)
                             and                                                {caution: assumes 4 directions only}
                             ((Board[Square+SquareOffsetLeft   [Direction]] and WALL)<>0) then
                             IsACornerGoalSquare:=True;

                     for  Direction:=Low(Direction) to High(Direction) do
                          if Square>0 then begin                                {'True': the square hasn't been processed in this loop from a different direction}
                             if ((Board[Square+SquareOffsetForward[Direction]] and (BOX+WALL+FLAG_BOX_REACHABLE_SQUARE))=FLAG_BOX_REACHABLE_SQUARE) and {'True': the neighbor square is an empty floor square, and it's legal to put a box there}
                                (PlayersReachableSquares.Squares[Square+2*SquareOffsetForward[Direction]]=PlayersReachableSquares.TimeStamp) then begin {'True': the player can reach the 'pull-from' square in this direction}

                                ParkingSpacesCount:=CanPullBoxToParkingSquare(GoalNo,ParkingSpaces);

                                if (ParkingSpacesCount>=1) and {'True': 1 or 2 parking squares for the box at the goal square have been found}
                                   (( ParkingSpaces[1].Distance>ParkingSpaces__[1].Distance) {'True': this is the first or a new highest parking distance}
                                    or
                                    ((ParkingSpaces[1].Distance=ParkingSpaces__[1].Distance)
                                     and
                                     {prefer parking goals taken from the middle
                                      of the board instead of parking goals from
                                      corner squares; a corner goal doesn't
                                      block as many squares as a goal in the
                                      middle of the board
                                     }
                                     (not IsACornerGoalSquare)
                                    )
                                   )
                                   then begin
                                   Result                    :=ParkingSpacesCount; {keep the best return value}
                                   GoalNo__                  :=GoalNo;          {remember the best found parking candidate}
                                   ParkingSpaces__           :=ParkingSpaces;   {keep the best found parking squares}
                                   end;
                                Square:=0;                                      {'0': the square has been processed; break out of the 'for each direction' loop}
                                end;
                             end
                          else break;                                           {quick-and-dirty exit the 'for' loop as soon as it has been established that the player can pull the box away from the goal square}
                     end;
                  end;

              if Result>0 then begin                                            {'True': a parking goal candidate has been found}
                 Dec(ParkBoxesCountDown);
                 if (ParkBoxesCountDown and (ONE_KIBI-1))=0 then begin
                    {$IFDEF CONSOLE_APPLICATION}
                      Writeln('Parking attemps: ',MAX_PACKING_ORDER_PARK_BOXES_ATTEMPTS-ParkBoxesCountDown);
                      //Readln;
                    {$ENDIF}
                    end;
                 if (ParkBoxesCountDown and 15)=0 then
                    TimeCheck;
                 end;
              end;
          end; {CalculatePackingOrder.CalculatePackingOrder__.Search.Search__.FindGoalCandidateForParking}

          function  CanPullBoxToStartingPosition(GoalNo__:Integer; var NewBoxStartPosIndex__,NewPlayerPos__,PullCount__:Integer; var ReachableBoxStartingPositions__:TBoxSetWithCount):Boolean;
          const END_GAME_PHASE_PERCENT=85; {in the final phase of the calculation, boxes are allowed to be removed from the board via a box starting position even if the distance to the starting position is below the normal distance threshold}
                MINIMUM_DISTANCE_BETWEEN_BOX_AND_REMOVAL_SQUARE=3;  {Manhattan distance threshold; allowing a box to be removed from the board using a too close starting square may make it easier to remove the remaining boxes than it really is}
                SEARCH_STATE_INDEX=SEARCH_STATE_INDEX_SCRATCHPAD_1; {index for calculating the player's reachable squares; 'Solver.SearchStates' must be freely available for the chosen index}
          var   BoxNo,GoalNo,GoalSquare,MaxGoalBoxEdgeCount,MinGoalBoxEdgeCount,OldPlayerPosition,StartBoxPosition,LastReachableBoxStartingPositionIndex:Integer;
                Direction:TDirection; Distances:TSquareDirectionArrayOfInteger;
          begin {CalculatePackingOrder.CalculatePackingOrder__.Search.Search__.CanPullBoxToStartingPosition}
            with Game do with Solver.PackingOrder do with Solver.SearchStates[SEARCH_STATE_INDEX] do begin
              Result:=False;
              GoalSquare:=GoalPos[GoalNo__];
              CalculateBoxPullOrPushDistances(GoalSquare,SEARCH_STATE_INDEX,False,True,False,Distances); {the 'True' parameter: the player's current position matters when the initial legal pulls are generated}
              OldPlayerPosition:=PlayerPos;
              Dec(Board[GoalSquare],BOX); {temporarily remove the box from the square}

              LastReachableBoxStartingPositionIndex:=-1;
              ReachableBoxStartingPositions__.Count:=0;
              MaxGoalBoxEdgeCount:=-1;

              {the following search for a target box starting position is a
               greedy search, selecting the not yet used box starting position
               which leaves the most chances open for the remaining goals when
               they are assigned a box starting position later;
              }
              for BoxNo:=1 to Game.BoxCount do begin
                  StartBoxPosition:=BoxPos[BoxNo];
                  if ((Board[StartBoxPosition] and FLAG_VISITED_SQUARE)=0) {'True': the box starting position hasn't been used for removing another box}
                     and
                     ((ManhattanDistance(StartBoxPosition,GoalSquare)
                       >= {'True': the box and the removal square aren't too close; otherwise, if it's a tightly packed goal room then using this square for removal could make the removal of the remaining boxes more easy than it really is}
                       MINIMUM_DISTANCE_BETWEEN_BOX_AND_REMOVAL_SQUARE
                      )
                      or
                      ((GoalSquare=StartBoxPosition) {'True': the box is already at a starting square}
                       and {'True': allow the box to be removed from the board using its current square if it's an original goal square and not a parking square; it may be a frozen box}
                       (GoalNo__<=GoalCount) {'True': it's a goal square and not a parking space}
                      )
                      or
//                    (SetMembersCount__>=Pred(GoalAndParkingSquareCount__)) {'True': this is the last box}
                      (SetMembersCount__>=((END_GAME_PHASE_PERCENT*GoalAndParkingSquareCount__) div 100)) {'True': most of the boxes, including the parked boxes, have been removed from the board}
                     ) then begin
                     MinGoalBoxEdgeCount:=High(MinGoalBoxEdgeCount);
                     if StartBoxPosition<>GoalSquare then begin
                        for Direction:=Low(Direction) to High(Direction) do
                            if (Abs(Distances[StartBoxPosition,Direction])<>INFINITY) then begin {'True': the box can be pulled to this box starting position}
                               if BoxNo<>LastReachableBoxStartingPositionIndex then begin {count the number of reachable box starting positions}
                                  LastReachableBoxStartingPositionIndex:=BoxNo;
                                  if ReachableBoxStartingPositions__.Count=0 then {'True': this is the first found box starting position; initialize the box set}
                                     ReachableBoxStartingPositions__.BoxSet:=[];
                                  Inc(ReachableBoxStartingPositions__.Count);
                                  Include( ReachableBoxStartingPositions__.BoxSet,BoxNo);
                                  end;
                               {check if the pusher after pulling the box to
                                this box starting position can get back to
                                where it came from;
                                this is the heuristic criteria for accepting
                                this original box square as target for the pull;
                               }
                               Inc(Board[StartBoxPosition],BOX); {temporarily move the box to the original box square under investigation}
                               PlayerPos:=StartBoxPosition+SquareOffsetForward[Direction]; {place the player accordingly, next to the box}
                               CalculatePlayersReachableSquares(SEARCH_STATE_INDEX);
                               Dec(Board[StartBoxPosition],BOX); {remove the box from the board again}
                               if (PlayersReachableSquares.Squares[OldPlayerPosition]=PlayersReachableSquares.TimeStamp) {'True': the pusher can get back to where it came from; this is a heuristic used for using the target square}
                                  or
                                  (SetMembersCount__>=Pred(GoalAndParkingSquareCount__)) {'True': this is the last box; ignore the player position after the pull}
                                  then begin
                                  for GoalNo:=1 to GoalAndParkingSquareCount__ do
                                      if (GoalBoxSets[GoalNo].Count<MinGoalBoxEdgeCount) and
                                         (GoalSetNo[GoalNo]=0) and {'True': the goal or parking square hasn't been assigned a packing order set number yet}
                                         (BoxNo in GoalBoxSets[GoalNo].BoxSet) then {'True': the box starting position is pull-reachable from this goal}
                                         MinGoalBoxEdgeCount:=GoalBoxSets[GoalNo].Count;
                                  if MinGoalBoxEdgeCount>MaxGoalBoxEdgeCount then begin {'True': 'BoxNo' is a new/first best box starting position candidate; the best candidate is the one with MAX(MIN(still open goal-box edges))}
                                     Result               :=True;
                                     NewBoxStartPosIndex__:=BoxNo;
                                     NewPlayerPos__       :=PlayerPos; {return the new player position after the pull}
                                     MaxGoalBoxEdgeCount  :=MinGoalBoxEdgeCount; {remember the best score}
                                     PullCount__          :=Distances[StartBoxPosition,Direction];
                                     end;
                                  break; {quick-and-dirty exit the 'for each direction' loop}
                                  end;
                               end;
                        end
                     else begin {the box is already at a box starting position}
                        for GoalNo:=1 to GoalAndParkingSquareCount__ do
                            if (GoalBoxSets[GoalNo].Count<MinGoalBoxEdgeCount) and
                               (GoalSetNo[GoalNo]=0) and {'True': the goal or parking square hasn't been assigned a packing order set number yet}
                               (BoxNo in GoalBoxSets[GoalNo].BoxSet) then {'True': the box starting position is pull-reachable from this goal}
                               MinGoalBoxEdgeCount:=GoalBoxSets[GoalNo].Count;
                        if MinGoalBoxEdgeCount  > MaxGoalBoxEdgeCount then begin {'True': 'BoxNo' is a new/first best box starting position candidate; the best candidate is the one with MAX(MIN(still open goal-box edges))}
                           Result               :=True;
                           NewBoxStartPosIndex__:=BoxNo;
                           NewPlayerPos__       :=PlayerPos; {return the new player position after the pull}
                           MaxGoalBoxEdgeCount  :=MinGoalBoxEdgeCount; {remember the best score}
                           PullCount__          :=0;
                           end;
                        LastReachableBoxStartingPositionIndex:=BoxNo;
                        if ReachableBoxStartingPositions__.Count=0 then {'True': this is the first found box starting position; initialize the box set}
                           ReachableBoxStartingPositions__.BoxSet:=[];
                        Inc(ReachableBoxStartingPositions__.Count);
                        Include( ReachableBoxStartingPositions__.BoxSet,BoxNo);
                        end;
                     end;
                  end;

              Inc(Board[GoalSquare],BOX); {put the box back on the square}
              MovePlayer(OldPlayerPosition); {restore the player position}
              end;
          end; {CalculatePackingOrder.CalculatePackingOrder__.Search.Search__.CanPullBoxToStartingPosition}

          function IsAllBoxesAtBoxStartingPositions( GoalAndParkingSquareCount__ : Integer ) : Boolean;
          var GoalNo : Integer;
          begin {returns 'True' is the remaining boxes on the board are located at box start positions}
            Result := True;
            for GoalNo := 1 to GoalAndParkingSquareCount__ do
                if ( Game.Board[ Game.GoalPos[ GoalNo ] ] and ( BOX + FLAG_BOX_START_SQUARE ) ) = BOX then begin
                   Result := False;
                   break;
                   end;
          end;

        begin {CalculatePackingOrder.CalculatePackingOrder__.Search.Search__}
          {the search function is a recursive depth-first search; each
           successful invocation performs one of these operations:
           1. removes the set of boxes that can be pulled to box starting positions, which haven't been used for that purpose earlier,
           or
           2. moves one box from a goal square to a parking square
          }
          Result:=RemainingBoxCount__=0;                                        {'True': all boxes have been removed from the board}

          if not Result then begin                                              {'True': some boxes haven't been removed from the board yet}
             if SetCount__<=MAX_HISTORY_BOX_MOVES then                          {'True': the maximum search depth hasn't been exceeded ('SetCount__' matches the recursion depth}
                with Game do with Solver.PackingOrder do with Solver.SearchStates[SetCount__] do begin
                  Count:=0;
                  MovePlayer(PlayerPos__);
                  CalculatePlayersReachableSquares(SetCount__);

                  if  SeenBoxStartPositions__.Count<BoxCount then {'True': the player hasn't had access to all box starting positions yet; add any new positions reachable from the current player position}
                      for BoxNo:=1 to BoxCount do
                          if (not (BoxNo in SeenBoxStartPositions__.BoxSet)) and
                             (PlayersReachableSquares.Squares[BoxPos[BoxNo]]>=PlayersReachableSquares.TimeStamp) then begin
                             Inc(SeenBoxStartPositions__.Count);                {note that even though 'SeenBoxStartPositions__' stems from the caller, the parameter is local to this invocation of 'Search__', and it's OK to update the set}
                             Include(SeenBoxStartPositions__.BoxSet,BoxNo);
                             end;

                  if  False
                      and
                      //(PackingOrderType__=poPullBoxesToStartingPositionsWithParking)
                      //and
                      ((MAX_PACKING_ORDER_PARK_BOXES_ATTEMPTS-ParkBoxesCountDown)>=0)
                      and
                      //(SetCount__>=10)
                      //(PackingOrderType__=poPullBoxes)
                      //and
                      True
                      then begin
                      Writeln;
                      ShowUnusedBoxStartingPositions;
                      ShowBoard;
                      Write(Ord(PackingOrderType__),
                            SPACE,MAX_PACKING_ORDER_PARK_BOXES_ATTEMPTS-ParkBoxesCountDown,
                            SPACE,PlayerPos__,
                            SPACE,ParkedTwiceGoalSet__.Count,
                            SPACE,COLON,SPACE,Count,' Find set: ',SetCount__,
                            ' Set members: ',SetMembersCount__,
                            ' Unseen start positions: ',BoxCount-SeenBoxStartPositions__.Count);
                      Readln;
                      end;

                  if  (SeenBoxStartPositions__.Count=BoxCount)                  {'True': boxes may be removed from the board when the player has had access to all box starting positions}
                      or
                      (PackingOrderType__=poPullBoxes)                          {'True': simply pull boxes away from the goal squares}
                      then begin
                      GoalNo:=1;
                      while GoalNo<=GoalAndParkingSquareCount__ do begin        {for each box at a goal square, and for each parked box, check if the box can be removed from the board}
                        Square:=GoalPos[GoalNo];
                        for Direction:=Low(Direction) to High(Direction) do
                            if (GoalSetNo[GoalNo]=0)                            {'True': the goal or parking square hasn't been assigned a packing order set number yet}
                               and
                               ((Board[Square] and BOX)<>0)
                               and
                               (
                                (
                                 ((Board[Square+SquareOffsetForward[Direction]] and (BOX+WALL+FLAG_BOX_REACHABLE_SQUARE))=FLAG_BOX_REACHABLE_SQUARE)
                                 and                                            {'True': the box can be pulled in this direction}
                                 (PlayersReachableSquares.Squares[Square+2*SquareOffsetForward[Direction]]=PlayersReachableSquares.TimeStamp)
                                )
                                or
                                (((Board[Square] and FLAG_BOX_START_SQUARE)<>0) {'True': the box is already at a box starting square}
                                 and
                                 IsAllBoxesAtBoxStartingPositions(GoalAndParkingSquareCount__) {wait until all boxes not at box starting positions have been removed}
                                )
                               )
                               and
                               (Solver.SearchLimits.DepthLimit>=0)              {'True': the search hasn't been terminated; (the search may be terminated manually by the user, or by a time limit)}
                               and
                               (( PackingOrderType__ =poPullBoxes)
                                or
                                ((PackingOrderType__>=poPullBoxesToStartingPositionsWithoutParking)
                                 //and
                                 //(PlayersReachableSquares.Squares[Game.StartPlayerPos]=PlayersReachableSquares.TimeStamp)
                                 and
                                 CanPullBoxToStartingPosition(GoalNo,BoxStartPosIndex,NewPlayerPos,PullCount,ReachableBoxStartingPositions[GoalNo])
                                 //and
                                 //( ReachableBoxStartingPositionsCount>=(RemainingBoxCount__ div 3))
                                )
                               )
                               then begin
                               Inc(Count);
                               GoalSetNo[GoalNo]:=SetCount__;                   {tentatively assign a packing order set number to the goal}
                               SetMembers[SetMembersCount__+Count]:=GoalNo;     {use 'SetMembers' temporarily to collect the goals in the packing order}

                               if   PackingOrderType__>=poPullBoxesToStartingPositionsWithoutParking then begin
                                    Inc(Board[BoxPos[BoxStartPosIndex]],FLAG_VISITED_SQUARE); {mark the box starting position as 'used'}
                                    UsedBoxStartPositions[SetMembersCount__+Count]:=BoxStartPosIndex; {collect the used box starting position numbers}
                                    for i:=1 to GoalAndParkingSquareCount__ do with GoalBoxSets[i] do {update the number of remaining unused box starting positions for all boxes on the board, i.e., boxes at goals and parking squares}
                                        if BoxStartPosIndex in BoxSet then Dec(Count);
                                    Inc(Solver.PushCount,PullCount);
                                    end
                               else Inc(Solver.PushCount);
                               end;

                        if   (GoalNo=GoalCount) and                             {'True': this is the last of the goal squares, before the parking squares, if any}
                             (Count=0) and                                      {'True': no boxes could be removed in this round}
                             (PackingOrderType__=poPullBoxesToStartingPositionsWithParking) and
                             (SetMembersCount__<GoalCount)                      {'True:  some boxes haven't left their goal squares yet}
                             then                                               {'True': don't remove parked boxes before the boxes have left their goal squares}
                             GoalNo:=Succ(GoalAndParkingSquareCount__);         {exit 'while' loop, i.e., stop removing boxes from the board in this round}

                        if   (GoalNo=GoalCount) and (Count<>0)                  {'True': this is the last normal goal square (before the parking squares), and some of the boxes at the goal squares could be removed}
                             and
                             (SetMembersCount__>=                               {'True': more than half of the boxes have been pulled away from the goal squares,}
                              (GoalAndParkingSquareCount div 2)                 {meaning the packing order calculation is probably in its final phase, dealing with the last boxes;}
                             ) then                                             {this is just a heuristic for choosing when to break goals/parked boxes groups; it may equally well be removed, it just happened to work slightly better in a few tests}
                             {it's often better to push boxes to parking
                              squares before pushing boxes to final goal
                              squares; therefore, boxes at goal squares and
                              parking squares are not removed from the board in
                              the same phase, i.e., they are not getting the
                              same packing order number;
                             }
                             GoalNo:=Succ(GoalAndParkingSquareCount__)          {exit 'while' loop, i.e., stop removing boxes from the board in this round}
                        else Inc(GoalNo);                                       {advance to the next goal number}
                        end;
                      end;

                  if  Count<>0 then begin                                       {'True': some boxes can be pulled away from the goal-squares or the parking squares}
                      for i:=1 to Count do begin                                {remove the boxes that can be pulled away from their goal-squares}
                          GoalNo:=SetMembers[SetMembersCount__+i];
                          if   (Board[GoalPos[GoalNo]] and BOX)<>0 then
                               Dec(Board[GoalPos[GoalNo]],BOX)
                          else Msg(TEXT_INTERNAL_ERROR+': Calculate packing order, goal: '+IntToStr(GoalNo),TEXT_APPLICATION_TITLE);
                          end;

                      if  False
                          and
                          (PackingOrderType__=poPullBoxesToStartingPositionsWithParking) then begin
                          ShowBoard;
                          Write(Ord(PackingOrderType__),
                                MAX_PACKING_ORDER_PARK_BOXES_ATTEMPTS-ParkBoxesCountDown,
                                SPACE,PlayerPos__,COLON,SPACE,Count,' Sets completed: ',SetCount__);
                          Readln;
                          end;

                      {try to remove any remaining boxes from the board}
                      Result:=Search__(Succ(SetCount__),SetMembersCount__+Count,GoalAndParkingSquareCount__,RemainingBoxCount__-Count,PlayerPos__,SeenBoxStartPositions__,ParkedTwiceGoalSet__,UsedBoxStartPositions__);

                      for i:=1 to Count do begin                                {put the removed boxes back on the board}
                          GoalNo       :=SetMembers[SetMembersCount__+i];
                          Square       :=GoalPos[GoalNo];
                          Board[Square]:=Board[Square] or BOX;

                          if   Result then begin
{
                               // fill this goal as soon as it's surrounded by walls
                               // and/or boxes on all sides except one;
                               // this is not in production because the idea is
                               // flawed; it can just as easily destroy the packing
                               // order as it can help;
                               NewSetNo:=Solver.PackingOrder.SetCount;
                               NeighborFloorCount:=DIRECTION_COUNT;             // count the number of empty floor square neighbors
                               for Direction:=Low(Direction) to High(Direction) do begin
                                   NeighborSquare:=Square+SquareOffsetForward[Direction];
                                   if      (Board[NeighborSquare] and (WALL+FLAG_ILLEGAL_BOX_SQUARE))<>0 then
                                           Dec(NeighborFloorCount)
                                   else if ((Board[NeighborSquare] and BOX)<>0) and
                                           (GoalCount=GoalAndParkingSquareCount__) then begin
                                           Dec(NeighborFloorCount);
                                           NewSetNo:=Min(NewSetNo,Pred(GoalSetNo[GoalNoAtSquare(NeighborSquare)]));
                                           end;
                                   end;
                               if  NeighborFloorCount=1 then                    // 'True': the goal is surrounded by walls and/or filled goals at all sides except one
                                   GoalSetNo[GoalNo]:=Max(GoalSetNo[GoalNo],NewSetNo); // fill this goal as soon as it's surrounded by walls and/or boxes at all sides except one
}
                               end
                          else GoalSetNo[GoalNo]:=0;                            {no packing order has been found yet; reset the packing order set number for the goal}

                          if   PackingOrderType__>=poPullBoxesToStartingPositionsWithoutParking then begin
                               BoxNo:=UsedBoxStartPositions[SetMembersCount__+i];
                               Board[BoxPos[BoxNo]]:=Board[BoxPos[BoxNo]] and (not FLAG_VISITED_SQUARE); {clear the 'used' flag for all the box starting positions used in this round}
                               for j:=1 to GoalAndParkingSquareCount__ do with GoalBoxSets[j] do         {for each box on the board, restore the number of pull-reachable box starting positions}
                                   if BoxNo in BoxSet then Inc(Count);
                               end;
                          end;
(*
                      if Result and ( Count > 1 ) then begin
                         {sort the goals in descending order on the number of box starting positions they could choose from}
                         for i := 2 to Count do begin {insertion sort}
                             GoalNo := SetMembers[ SetMembersCount__ + i ];
                             j := Pred( i );
                             while ( j > 0 ) and ( ReachableBoxStartingPositions[ GoalNo ].Count > ReachableBoxStartingPositions[ SetMembers[ SetMembersCount__ + j ] ].Count ) do begin
                                   SetMembers[ SetMembersCount__ + Succ( j ) ] := SetMembers[ SetMembersCount__ + j ];
                                   Dec( j );
                                   end;
                             SetMembers[ SetMembersCount__ + Succ( j ) ] := GoalNo;
                             end;

                         i := Succ( Count );
                         while   ReachableBoxStartingPositions[ SetMembers[ SetMembersCount__ + Pred( i ) ] ].Count <
                               ( ReachableBoxStartingPositions[ SetMembers[ Succ( SetMembersCount__ )     ] ].Count div 2 ) do
                               Dec( i );
                         if i <= Count then begin
                            {there is a large difference in the number of box
                             starting positions to choose from; this could
                             indicate that the goals should be filled from
                             different sides of the board; split the phase in
                             two}
                            Inc( SetCount );
                            for j := SetMembersCount__ + i to GoalAndParkingSquareCount do
                                Inc( GoalSetNo[ SetMembers[ j ] ] );
                            end;
                         end;
*)
                      end
                  else                                                          {no boxes could be removed from the board; try if there are boxes that can parked somewhere on the board}
                    if (PackingOrderType__=poPullBoxesToStartingPositionsWithParking) and
//                     (RemainingBoxCount__=BoxCount) and                       {'True': no boxes have been removed from the board yet}
                       (GoalAndParkingSquareCount__<High(TBoxNo)) and           {'True': some goal numbers are still free to use as pseudo-goal numbers for parking squares}
                       (Solver.SearchLimits.DepthLimit>=0) then begin           {'True': the search hasn't been terminated}
                       TestedGoalsSet:=[];
                       while (not Result) and                                   {'True': no full packing order has been found yet}
                             (FindGoalCandidateForParking(SetCount__,TestedGoalsSet,ParkedTwiceGoalSet__,GoalNo,ParkingSpaces)>0) do begin {'True': 1 or 2 parking squares have been found for the box at goal number 'GoalNo'}
                             Include(TestedGoalsSet,GoalNo);                    {each goal is only given one chance for parking}
                             GoalSetNo[GoalNo]:=SetCount__;                     {tentatively assign a packing order set number to the goal}
                             SetMembers[Succ(SetMembersCount__)]:=GoalNo;       {use 'SetMembers' temporarily to collect the goals and parking squares (pseudo goals) in the packing order}
                             Board[GoalPos[GoalNo]]:=Board[GoalPos[GoalNo]] and (not BOX); {remove the box from the goal square before it's moved to the parking square}

                             if  GoalNo>GoalCount then with ParkedTwiceGoalSet__ do begin
                                 Inc(Count); Include(BoxSet,GoalNo);
                                 end;

                             for Index:=1 to High(ParkingSpaces) do with ParkingSpaces[Index] do {'1': item 0 is unused}
                                 if (not Result) and (Square>0) then begin      {'True': a full packing order hasn't been found yet, and there is a parking square candidate in 'ParkingSpaces[Index]'}
                                    Board                  [Square]                           :=Board[Square] or BOX; {put a box at the parking square}
                                    GoalPos                [Succ(GoalAndParkingSquareCount__)]:=Square; {make the parking square a pseudo goal square}
                                    GoalSetNo              [Succ(GoalAndParkingSquareCount__)]:=0; {'0': the parked box hasn't been assigned a packing order number yet}
                                    UsedBoxStartPositions__[Succ(SetMembersCount__          )]:=0; {'0': the parked box hasn't been removed from the board yet, i.e., it hasn't been assigned a box starting position}
                                    Inc(Solver.PushCount,Distance); {update the number of pushes}

                                    //GoalBoxSets[Succ(GoalAndParkingSquareCount__)]:=SquareBoxSets[Square]; {the initial pull-reachable box starting positions from the parking square can be found in the 'SquareBoxSets' array (not in production)}
                                    with GoalBoxSets[Succ(GoalAndParkingSquareCount__)] do begin
                                      Count:=0; BoxSet:=[]; {the reachable box starting positions aren't calculated for parking squares, so instead the set must be cleared}
                                      for i:=1 to SetMembersCount__ do {for logical completeness, update the count of the still available box starting positions for the parked box, as if the set wasn't empty at this point}
                                          if UsedBoxStartPositions__[i] in BoxSet then Dec(Count); {update the count of the still available box starting positions for the parked box by retracting the already used box start positions}
                                      end;

                                    Result:=Search__(Succ(SetCount__),Succ(SetMembersCount__),Succ(GoalAndParkingSquareCount__),RemainingBoxCount__,PlayerPositionAfterParking,SeenBoxStartPositions__,ParkedTwiceGoalSet__,UsedBoxStartPositions__);

                                    Board[Square]:=Board[Square] and (not BOX); {remove the parked box from the board again}
                                    end;

                             if  GoalNo>GoalCount then with ParkedTwiceGoalSet__ do begin
                                 Dec(Count); Exclude(BoxSet,GoalNo);
                                 end;

                             if   Result then begin                             {'True': a packing order has been calculated}
                                  Square:=GoalPos[Succ(GoalAndParkingSquareCount__)]; {get the parking square}
                                  i:=Board[Square] shr GOAL_BIT_SHIFT_COUNT;          {get the goal number stored in the parking square, if any}
                                  if (i=0) or (i>GoalAndParkingSquareCount__) then    {'True': the goal number stored in the parking square isn't one of the real goal numbers, i.e., the number is 0 or a parking square number}
                                     Board[Square]:=Board[Square]
                                                    {insert pseudo goal number (parking space number) in the square value; numbers are inserted during backtracking so the smallest number wins}
                                                    +Cardinal(Succ(GoalAndParkingSquareCount__) shl GOAL_BIT_SHIFT_COUNT)
                                                    {substract previously inserted goal number, if any, from the square value}
                                                    -Cardinal(i shl GOAL_BIT_SHIFT_COUNT);

                                  ParkedBoxDestinationGoalSetNo[Succ(GoalAndParkingSquareCount__)]:=SetCount__; {a parked box should preferably stay at its parking square until it't time to fill the goal the parked box originally came from}
                                  end
                             else GoalSetNo[GoalNo]:=0;                         {the recursive call could not remove the remaining boxes from the board; reset the packing order set number for the goal}

                             Board[GoalPos[GoalNo]]:=Board[GoalPos[GoalNo]] or BOX; {put the box back at the goal square}
                             MovePlayer(PlayerPos__);                           {restore the player position}
                             end;
                       end;
                  end;
             end
          else begin {all boxes have been removed from the board; update the global variables with the found packing order information}
             Solver.PackingOrder.SetCount:=SetCount__;
             Solver.PackingOrder.GoalAndParkingSquareCount:=GoalAndParkingSquareCount__;
             end;
        end; {CalculatePackingOrder.CalculatePackingOrder__.Search.Search__}

      begin {CalculatePackingOrder.CalculatePackingOrder__.Search}
        {preconditions: all boxes have been removed from the board, and the player position 'PlayerPos__' isn't a goal square}
        {postcondition: all boxes have been removed from the board (from the goal positions and any parking squares)}
        with Game do with Solver.PackingOrder do begin
          MovePlayer(PlayerPos__);
          for GoalNo:=1 to GoalCount do Inc(Board[GoalPos[GoalNo]],BOX);        {put boxes at all the goal squares}

          SetCount:=0; GoalAndParkingSquareCount:=GoalCount;
          FillChar(GoalSetNo,SizeOf(GoalSetNo),0);
          FillChar(ParkedBoxDestinationGoalSetNo,SizeOf(ParkedBoxDestinationGoalSetNo),0);
          FillChar(ParkedTwiceGoalSet,SizeOf(ParkedTwiceGoalSet),0);
          ParkedTwiceGoalSet.Count:=MAX_PARKED_TWICE_GOAL_COUNT;                {disables moving parked boxes}
          //ParkBoxesCountDown:=MAX_PARK_BOXES_ATTEMPTS;

          FillChar(SeenBoxStartPositions,SizeOf(SeenBoxStartPositions),0);      {when to park, and when to remove boxes, is governed by which and how many starting positions the player has been able to reach}
          for BoxNo:=1 to BoxCount do                                           {boxes at goal squares are counted as "seen starting positions"; this is just a heuristic which seems reasonable, helping to get things started}
              if IsAGoalSquare(BoxPos[BoxNo]) then with SeenBoxStartPositions do begin
                 Inc(Count); Include(BoxSet,BoxNo);
                 end;

          Result:=Search__(1,0,GoalCount,BoxCount,PlayerPos__,SeenBoxStartPositions,ParkedTwiceGoalSet,UsedBoxStartPositions);

          for GoalNo:=1 to GoalAndParkingSquareCount do Board[GoalPos[GoalNo]]:=Board[GoalPos[GoalNo]] and (not BOX); {remove boxes from the board}
          MovePlayer(PlayerPos__);                                              {restore player position}
          end;
      end; {CalculatePackingOrder.CalculatePackingOrder__.Search}

      function  CalculateFreezeDeadlocks: Boolean;
      const FROZEN_GOALS_PATTERN_THRESHOLD = 4;
      var   BoxNo, GoalNo, Index, Square, NeighborSquare, OldCount, OldPlayerPos : Integer;
            Found : Boolean;
            Direction : TDirection;
            DeadlockSetCandidate : TDeadlockSetCandidate;
            APosition : TPosition;
            OldBoxPositions : TBoxSquares;
      begin {creates freeze deadlocks based on the packing order}
        with Game do with Solver.PackingOrder do begin
          Result          := False;
          for BoxNo       := 1 to BoxCount do                                   {remove all boxes from the board}
              Board[ BoxPos[ BoxNo ] ] := Board[ BoxPos[ BoxNo ] ] and ( not BOX );
          OldBoxPositions := Game.BoxPos;                                       {save box positions}
          OldPlayerPos    := Game.PlayerPos;
          Game.BoxPos     := Game.GoalPos;                                      {use goal positions as box positions}

          for Index       := GoalAndParkingSquareCount downto 1 do begin
              GoalNo      := SetMembers[ Index ];
              if GoalNo   <= GoalCount then begin
                 Square   := GoalPos[ GoalNo ];
                 Found    := False;
                 if IsAFreezingMove( 0, Square, True) then
                    for Direction := Low( Direction ) to High( Direction ) do begin
                        NeighborSquare := Square + SquareOffsetForward[ Direction ];
                        if IsABoxSquare( NeighborSquare ) and ( not IsAFreezingMove( 0, NeighborSquare, True ) ) then {'True': the neighbor box, which has been filled earlier in the packing order hasn't frozen yet}
                           Found := True;                                       {freezing a box at the current goal square gives rise to a new freeze situation on the board}
                        end;

                 Board[ Square ] := Board[ Square ] or BOX;                     {put box on board}

                 if Found then begin                                            {'True': freezing a box at the current goal square gives rise to a new freeze situation on the board}
                    DeadlockSetCandidate.Boxes.Count := 0;
                    DeadlockSetCandidate.Boxes.Squares[ 0 ] := 0;
                    for BoxNo  := Index  to GoalAndParkingSquareCount do begin
                        GoalNo := SetMembers[ BoxNo ];
                        if ( GoalNo <= GoalCount ) and IsAFreezingMove(0, GoalPos[ GoalNo ], True ) then with DeadlockSetCandidate.Boxes do begin
                           Inc( Count ); Squares[ Count ] := GoalNo;            {caution: despite the field name 'Squares', the squares really contain goal numbers and not square numbers here}
                           end;
                        end;
                    if DeadlockSetCandidate.Boxes.Count >= FROZEN_GOALS_PATTERN_THRESHOLD then begin
                       for BoxNo     := 1 to BoxCount do                        {remove all boxes on the board}
                           Board[ BoxPos[ BoxNo ] ] := Board[ BoxPos[ BoxNo ] ] and ( not BOX );
                       BoxPos        := OldBoxPositions;                        {restore start position}
                       for BoxNo     := 1 to BoxCount do                        {put all boxes on the board}
                           Board[ BoxPos[ BoxNo ] ] := Board[ BoxPos[ BoxNo ] ] or BOX;
                       MovePlayer( OldPlayerPos );                              {restore player position}
                       DeadlockSetCandidate.Flags := [ dsfTestFrozenGoalsSet ]; {with this flag, 'Boxes' is the only used deadlock set candidate information, hence, the other fields don't need to be filled}

                       OldCount      := DeadlockSets.Count;
                       CalculateDeadlockSets( PPosition( Addr( APosition ) ), DeadlockSetCandidate );
                       Result        := Result or ( OldCount <> DeadlockSets.Count ); {'True': new deadlock sets have been created by this function}
{
                       if ( OldCount <> DeadlockSets.Count ) then begin
                          Game.ShowDeadlockSetsEnabled := True;
                          for BoxNo := Succ( OldCount ) to DeadlockSets.Count do // not really a box number in this loop
                              ShowDeadlockSet( BoxNo, 0 );
                          Game.ShowDeadlockSetsEnabled := False;
                          Readln;
                          end;
}
                       for BoxNo     := 1 to BoxCount do                        {remove all boxes from the board again}
                           Board[ BoxPos[ BoxNo ] ] := Board[ BoxPos[ BoxNo ] ] and ( not BOX );
                       BoxPos        := GoalPos;                                {go back to working with goal positions}
                       for BoxNo     := Index to GoalAndParkingSquareCount do begin {'BoxNo' isn't really a box number here; it's just used as an index}
                           GoalNo    := SetMembers[ BoxNo ];
                           if GoalNo <= GoalCount then
                              Inc( Board[ GoalPos[ GoalNo ] ], BOX );           {put boxes on the board again}
                           end;
                       end;
                    end;
                 end;
              end;

          for BoxNo       := 1 to BoxCount do                                   {remove all boxes from the board}
              Board[ BoxPos[ BoxNo ] ] := Board[ BoxPos[ BoxNo ] ] and ( not BOX );
          Game.BoxPos     := OldBoxPositions;                                   {restore box start positions}
          for BoxNo       := 1 to BoxCount do                                   {put all boxes on the board}
              Board[ BoxPos[ BoxNo ] ] := Board[ BoxPos[ BoxNo ] ] or BOX;
          MovePlayer( OldPlayerPos );                                           {restore player position}

          end;
      end; {CalculatePackingOrder.CalculatePackingOrder__.CalculateFreezeDeadlocks}

    begin {CalculatePackingOrder.CalculatePackingOrder__}
      with Game do with Solver.PackingOrder do with Solver.SearchStates[0] do begin
        SetCount:=0;
        FillChar(GoalSetNo,SizeOf(GoalSetNo),0);

        ClearPlayersReachableSquares(0); {so unvisited squares contains '0', making it easy to check if a square has been visited, also after several access areas have been explored}

        OldPlayerPos:=PlayerPos;                                                {remember the original player starting position}
        for BoxNo:=1 to BoxCount do                                             {remove all boxes from the board and clear the 'Visited?' flag for all the box starting positions}
            Board[BoxPos[BoxNo]]:=Board[BoxPos[BoxNo]] and (not (BOX+FLAG_VISITED_SQUARE));

        ParkBoxesCountDown:=MAX_PACKING_ORDER_PARK_BOXES_ATTEMPTS;

        if PackingOrderType__=poPullBoxesToStartingPositionsWithoutParking then
           CalculateTunnelSquares;                                              {calculate the tunnel squares so parking at 'do not stop here' squares can be avoided}

        repeat
          for GoalNo:=1 to GoalCount do Inc(Board[GoalPos[GoalNo]],BOX);        {put boxes at all the goal squares}

          Square:=PlayerPos; {goal squares contain boxes, hence, ensure that the player isn't on a goal square}
          while  ((Board[Square] and (BOX+WALL+FLAG_BOX_REACHABLE_SQUARE))<>FLAG_BOX_REACHABLE_SQUARE) and {the goal squares contain boxes; ensure that the player isn't on top of one of them}
                 (PlayersReachableSquares.Squares[Square]<>0) and
                 (Square<>0) do                                                 {'0': all squares have been visited without finding an empty box-reachable square next to a goal; the level is probably malformed}
            if   Square<BoardSize then begin
                 Inc(Square);                                                   {try the next player square}
                 if Square=PlayerPos then Square:=0;                            {'True': all squares have been visited without finding an empty box-reachable square next to a goal square; the level is probably malformed}
                 end
            else Square:=1;                                                     {wrap around}

          MovePlayer(Square);
          CalculatePlayersReachableSquares(0);                                  {the reachable squares timestamps were cleared before the 'repeat' loop, hence, the squares in an unvisited player access area contain '0'}

          for GoalNo:=1 to GoalCount do Dec(Board[GoalPos[GoalNo]],BOX);        {remove boxes from the goal squares again}

          Result:=Search(PlayerPos,PackingOrderType__);                         {postcondition: 'Search()' has removed boxes from the board (from the goal squares and any parking squares)}

          if not Result then begin {'True': the goal squares could not be emptied when the player started from it current starting position}
             Square:=PlayerPos;
             repeat if Square<BoardSize then Inc(Square)                        {advance to the next square}
                    else Square:=0; {wrap around}
             until  ((PlayersReachableSquares.Squares[Square]=0)                {'0': 'Square' is an empty floor square in a player access area on the board which hasn't been visited before}
                     and
                     ((Board[Square] and (WALL+GOAL+FLOOR))=FLOOR)
                    )
                    or
                    (Square=OldPlayerPos);                                      {until an unvisited player access area has been found, or until all squares have been visited}
             MovePlayer(Square);
             end;

        until Result or (PlayerPos=OldPlayerPos); {until a packing order has been found, or until all player access areas on the board have been tested}

        for BoxNo:=1 to BoxCount do Inc(Board[BoxPos[BoxNo]],BOX);              {put all boxes back on the board}
        MovePlayer(OldPlayerPos);                                               {restore player position}

        if Result then begin
           if GoalAndParkingSquareCount>GoalCount then                          {'True': some boxes require parking; calculate the distances from all squares to the parking squares; the parking squares are handled as pseudo goal squares}
              CalculateSquareGoalDistances(Succ(GoalCount),GoalAndParkingSquareCount,0,False,SquareGoalDistance,GoalBoxSets);
           if ( 2 * GoalAndParkingSquareCount ) < High( TBoxNo ) then begin
              {the square->goal distance table is big enough to contain the
              distances calculated taking the packing order into account;
              calculate these more accurate distances and use them during the
              search when the game state evaluation function calculates bonuses
              and penalties based on distances to goals and parking spaces to
              fill in the current game phase}
              DistancesBasedOnPackingOrder:=GoalAndParkingSquareCount; {offset from the normal distances where the packing order aware distances can be found}
              CalculateSquareGoalDistances(1,GoalAndParkingSquareCount,DistancesBasedOnPackingOrder,True,SquareGoalDistance,GoalBoxSets);
              end;
(*
           {the peeling algorithm has peeled smaller groups from the board}
           {faster than large groups, meaning that a small group has smaller}
           {packing order set numbers, as if the small group should be filled}
           {late in the game;}
           {in lack of a more sophisticated algorithm, ensure that all groups}
           {are given the chance to be filled as early as possible;}
           {first calculate - for each goal - the minimum distance to a goal}
           {in a different group, if any}
           MaxGoalSetNo:=0; {highest set number for goals, as opposed to set numbers for parking squares}
           for GoalNo:=1 to GoalCount do begin
               MaxGoalSetNo:=Max(MaxGoalSetNo,GoalSetNo[GoalNo]);   {highest set number for goals, as opposed to set numbers for parking squares}
               GoalMinDistanceToNeighborGroup[GoalNo]:=MAX_BOARD_SIZE;
               //SquareToColRow(GoalPos[GoalNo],Col1,Row1);
               for i:=1 to GoalCount do
                   if GoalGroupNumbers[GoalNo]<>GoalGroupNumbers[i] then begin  {'True': the goals belong to different groups, i.e., they are not connected}
                      //SquareToColRow(GoalPos[i],Col2,Row2);
                      GoalMinDistanceToNeighborGroup[GoalNo]:=Min(GoalMinDistanceToNeighborGroup[GoalNo],
                                                                  //Abs(Col1-Col2)+Abs(Row1-Row2)
                                                                  Solver.PackingOrder.SquareGoalDistance[GoalPos[i],GoalNo]
                                                                 );
                      end;
               end;

           for GroupNo:=1 to GoalGroupCount do begin
               i:=0; j:=MAX_BOARD_SIZE; {find highest packing order number for the members of this group}
               for GoalNo:=1 to GoalCount do
                   if (GoalGroupNumbers[GoalNo]=GroupNo) then begin
                      i:=Max(i,GoalSetNo                     [GoalNo]);         {highest packing order set number for the goals in this group}
                      j:=Min(j,GoalMinDistanceToNeighborGroup[GoalNo]);         {lowest distance to a goal in a different group}
                      end;
               if (i<MaxGoalSetNo) and {'True': the current packing order indicates that that the group should be filled at a late stage of the game}
                  (j>GOAL_DISTANCE_TO_NEIGHBOR_GROUP_THRESHOLD) and             {'True': the group is so far away from the nearest neighboring group that there is a chance the groups are independent}
                  (j<MAX_BOARD_SIZE) then
                  for GoalNo:=1 to GoalCount do
                      if GoalGroupNumbers[GoalNo]=GroupNo then
                         Inc(GoalSetNo[GoalNo],MaxGoalSetNo-i);                 {set the packing order so this group is filled as early as the largest group}
               end;
*)
           {count the number of goals in each set}
           FillChar(SetSize,SizeOf(SetSize),0);
           for GoalNo:=1 to GoalAndParkingSquareCount do Inc(SetSize[GoalSetNo[GoalNo]]);

           {for each set, find the first member position in the final packing order}
           i:=1; FirstSetMemberIndex[0]:=0; SetSize[0]:=1;
           while i<=SetCount do begin
             if SetSize[i]<>0 then begin
                FirstSetMemberIndex[i]:=FirstSetMemberIndex[Pred(i)]+SetSize[Pred(i)];
                Inc(i);
                end
             else begin {empty set; remove it}
                for GoalNo:=1 to GoalAndParkingSquareCount do begin
                    if GoalSetNo                    [GoalNo]>i then Dec(GoalSetNo                    [GoalNo]);
                    if ParkedBoxDestinationGoalSetNo[GoalNo]>i then Dec(ParkedBoxDestinationGoalSetNo[GoalNo]);
                    end;
                Dec(SetCount);
                for j:=i to SetCount do SetSize[j]:=SetSize[Succ(j)];
                end;
             end;
           FirstSetMemberIndex[Succ(SetCount)]:=FirstSetMemberIndex[SetCount]+SetSize[SetCount]; {the set number after the last set contains a sentinel, i.e., the first unused list member number}

           SetMembers[0]:=0; {sentinel for backward tracing through the set members during the search}
           for GoalNo:=1 to GoalAndParkingSquareCount do begin
               SetNo:=GoalSetNo[GoalNo];
               if SetNo<>0 then begin
                  Dec(SetSize[SetNo]);
                  SetMembers[FirstSetMemberIndex[SetNo]+SetSize[SetNo]]:=GoalNo;
                  end;
               end;
           end
        else begin
           SetCount:=0; {'0': no packing order}
           FillChar(GoalSetNo,SizeOf(GoalSetNo),0);
           end;

        {restore the board, and store the goal numbers in the board square values for all goal squares and parking squares}
        for GoalNo:=1 to GoalCount do Board[GoalPos[GoalNo]]:=Board[GoalPos[GoalNo]] or GOAL; {ensure that goals are back on the board}

        for GoalNo:=0 to GoalAndParkingSquareCount do NextGoalAtSameSquare[GoalNo]:=GoalNo; {initially, make a circular list for each goal, where the goal itself is the only member of the list}
        for GoalNo:=1 to GoalAndParkingSquareCount do begin {for each goal and parking square}
            SquareValue                       :=Board[GoalPos[GoalNo]];               {the board square value for the goal number}
            SquareGoalNo                      :=SquareValue shr GOAL_BIT_SHIFT_COUNT; {the existing goal number for this square; a parking square may overlap real goal squares and previous parking squares}
            NextGoalAtSameSquare[GoalNo      ]:=NextGoalAtSameSquare[SquareGoalNo];   {link from the current goal back to the first member of the circular list of goals for this square}
            NextGoalAtSameSquare[SquareGoalNo]:=GoalNo;                               {link from the existing goal number for this square to the current goal number}

            Board[GoalPos[GoalNo]]:=(SquareValue and (not WALL))                {remove temporary wall, if any, from the goal square}
                                    -(SquareGoalNo shl GOAL_BIT_SHIFT_COUNT)    {substract previously inserted goal number from the square value}
                                    +(GoalNo shl GOAL_BIT_SHIFT_COUNT);         {insert the goal number in the square value, so there is a mapping from the board square values to the highest goal/parking place number}
            end;
        if Result then
           CalculateFreezeDeadlocks; {calculate freeze deadlocks based on the packing order}
        end;

      if Result and (LogFile.FileName<>'') then with Game do begin
         //WritelnToLogFile('');
         case PackingOrderType__ of
           poPullBoxesToStartingPositionsWithParking   : WritelnToLogFile(TEXT_PACKING_ORDER+': Parking');
           poPullBoxesToStartingPositionsWithoutParking: WritelnToLogFile(TEXT_PACKING_ORDER+': Simple, i.e., no parking required');
           else                                          WritelnToLogFile(TEXT_PACKING_ORDER+': Failed (This is just a fallback packing order)');
         end; // case
         PackingOrderToText(BoardAsTextLines);
         for Row:=1 to BoardHeight do WritelnToLogFile(BoardAsTextLines[Row]);
         //WritelnToLogFile('');
         end;

{
     if   Result //and (PackingOrderType__=poPullBoxesToStartingPositionsWithParking)
          then ShowPackingOrder
     else if PackingOrderType__=poPullBoxesToStartingPositionsWithParking then ShowPackingOrder;
}
    end; {CalculatePackingOrder.CalculatePackingOrder__}

  begin {CalculatePackingOrder}
    {preconditions:
      * the board, the box positions, and the player position match the initial game state;
      * 'CalculateSquareGoalDistances()' has been called in order to calculate packing order related information; ('CalculateDeadlockSets()' calls it);
    }
    with Game do with Solver.PackingOrder do begin
      TimeMS:=GetTimeMS; {remember the start time; the field is updated to elapsed time upon exit from the funtion}
      SetCount:=0; SetMembers[0]:=0; FirstSetMemberIndex[0]:=0; FirstSetMemberIndex[1]:=0; DistancesBasedOnPackingOrder:=0;
      FillChar(GoalSetNo,SizeOf(GoalSetNo),0);
      Solver.PushCount:=0;

      if Solver.Enabled and Solver.PackingOrder.Enabled and (Solver.SearchMethod=smPerimeter) then begin
         {$IFDEF CONSOLE_APPLICATION}
         {$ELSE}
           SetSokobanStatusText(TEXT_CALCULATING_PACKING_ORDER);
           Solver.LastCallBackTimeMS:=0;                                        {'0': force 'TimeCheck()' to update the screen if the calculation runs for more than a few seconds}
         {$ENDIF}
         TimeCheck;

         CalculateConnectedGoals(ConnectedGoalsCount,GoalGroupCount,GoalGroupNumbers);
         if ConnectedGoalsCount>=BoxCountThreshold then begin {'True': calculate a packing order}
            OriginalSearchLimits:=Solver.SearchLimits; {save search limits}

            Solver.TimeMS:=CalculateElapsedTimeMS(Solver.StartTimeMS,GetTimeMS); {calculate elapsed time, i.e., game initialization time so far}
            if (Solver.SearchLimits.TimeLimitMS< High(Solver.SearchLimits.TimeLimitMS)) and {'True': there is a time limit for the search}
               (Solver.TimeMS                  <=High(Solver.TimeMS)-MAX_PACKING_ORDER_CALCULATION_TIME_MS) and {'True': adding 'Solver.TimeMS+MAX_PACKING_ORDER_CALCULATION_TIME_MS' doesn't cause a numeric overflow}
               (Solver.SearchLimits.TimeLimitMS> Solver.TimeMS+MAX_PACKING_ORDER_CALCULATION_TIME_MS) then {'True': the total search time limit exceeds the time limit for packing order calculation}
               Solver .SearchLimits.TimeLimitMS:=Solver.TimeMS+MAX_PACKING_ORDER_CALCULATION_TIME_MS; {install the maximum time limit for the packing order calculation; the limit is 'elapsed time + packing order calculation time limit'}

            //CalculateReachableBoxStartPositionsForAllSquares(SquareBoxSets); {first calculate the reachable box starting positions from all squares}
            //CalculateReachableGoalsFromEachBoxStartPosition(SquareBoxSets,BoxGoalSets); {then calculate the reachable goals from each box starting position}
            //CalculatePullReachableGoalsForAllSquares(SquareGoalSets);

            if        CalculatePackingOrder__(poPullBoxesToStartingPositionsWithoutParking) then {first try pulling all boxes straight to the box starting positions}
            else if   CalculatePackingOrder__(poPullBoxesToStartingPositionsWithParking) then {then try pulling all boxes to box starting positions with intermediate steps, parking boxes at suitable squares}
                 else CalculatePackingOrder__(poPullBoxes); {as fall back method, simply pull boxes away from goal squares}

            Solver.SearchLimits:=OriginalSearchLimits; {restore search limits}
            end;
         end;

      Result:=SetCount>0; {'True': a packing order has been found}

      Solver.PushCount:=0;

      if Game.DeadlockSets.Count > Game.DeadlockSets.PrecalculatedSetsCount then begin {'True': new deadlock sets have been created by the packing order calculation; they must be added to the precalculated sets}
         Game.DeadlockSets.PrecalculatedSetsCount   := Game.DeadlockSets.Count;
         {protect the per square deadlock set numbers from overwriting by items in the transposition table by setting the 'EndOfPositions' high water mark}
         Positions.EndOfPositions                   := Pointer( Addr( Positions.Positions^[ Positions.Capacity ] ) );
         {remember the per square deadlock set numbers for the precalculated deadlock sets}
         DeadlockSets.PrecalculatedSquareSetNumbers := DeadlockSets.SquareSetNumbers;
         Game.DeadlockSets.DynamicSetsCount         := 0; {reset count; the newly created deadlock sets have been registered as dynamic deadlocks rather than precalculated deadlocks}
         end;

      {$IFDEF CONSOLE_APPLICATION}
      {$ELSE}
        SetSokobanStatusText('');
        Solver.LastCallBackTimeMS:=0;                                           {'0': force 'TimeCheck()' to update the screen if the calculation has been running for more than a few seconds}
        TimeCheck;
      {$ENDIF}

      TimeMS:=CalculateElapsedTimeMS(TimeMS,GetTimeMS); {calculate the packing order time statistics}
      end;
  end; {CalculatePackingOrder}

  procedure CalculateRooms; {caution: assumes 4 directions only}
  var {BoxNo,}DoorCount:Integer; DoorSquares:TBoardOfIntegers;

    procedure CalculateDoors; {caution: assumes 4 directions only}
    var ASquare,BoxNo,Square,OldCount:Integer; Direction:TDirection;
    begin
      with Game do begin
        for BoxNo:=1 to BoxCount do Dec(Board[BoxPos[BoxNo]],BOX);              {remove boxes from the board}

        DoorCount:=0;                                                           {initialize the door squares}
        FillChar(DoorSquares,SizeOf(DoorSquares),0);

        if CalculatePlayersReachableSquares(0)>0 then begin                     {calculate the player's access area when the boxes have been removed from the board, i.e., all player-reachable floors on the board}
           for Square:=0 to BoardSize do
               if (Solver.SearchStates[0].PlayersReachableSquares.Squares[Square]=
                   Solver.SearchStates[0].PlayersReachableSquares.TimeStamp)    {'True': 'Square' is a player-reachable (i.e., an active) floor square}
                  and
                  (DoorSquares[Square]=0) then begin                            {'True': the square hasn't been visited before}
                  OldCount:=DoorCount;
                  {
                   door pattern #1:
                   ?#?  "?": don't care
                   ->-  ">": the square; the direction is ->; "-": floor squares
                   ?#?
                  }
                  for Direction:=Low(Direction) to High(Direction) do begin     {for each direction}
                      ASquare:=Square;
                      while IsAFloorSquare(ASquare) and
                            IsAWallSquare(ASquare+SquareOffsetLeft    [Direction]) and
                            IsAWallSquare(ASquare+SquareOffsetRight   [Direction]) and
                            IsAFloorSquare(ASquare+SquareOffsetForward[Direction]) and
                            IsAFloorSquare(ASquare-SquareOffsetForward[Direction]) do begin
                            if DoorCount=OldCount then Inc(DoorCount);
                            DoorSquares[ASquare]:=DoorCount;                    {assign a door number to the square}

                            Inc(ASquare,SquareOffsetForward[Direction]);        {advance to the next square in this direction}
                            end;
                      end;
                  {
                   door pattern #2:
                   #-x
                   ->-  ">": the square; the direction is ->; "-": floor squares
                   y-#

                   if "x" is a floor then the ">" square is not just a door
                   square; at the same time it's a corner square belonging to
                   the room having "x" as member (the top-right quadrant);

                   if "y" is a floor then the ">" square is not just a door
                   square; at the same time it's a corner square belonging to
                   the room having "y" as member (the bottom-left quadrant);
                  }
                  if DoorSquares[Square]=0 then begin
                     ASquare:=Square;
                     for Direction:=Low(Direction) to Succ(Low(Direction)) do begin {for each axis}
                         if IsAFloorSquare(ASquare+SquareOffsetForward[Direction]) and
                            IsAFloorSquare(ASquare-SquareOffsetForward[Direction]) and
                            IsAFloorSquare(ASquare+SquareOffsetLeft   [Direction]) and
                            IsAFloorSquare(ASquare+SquareOffsetRight  [Direction]) and
                            IsAWallSquare (ASquare-SquareOffsetForward[Direction]+SquareOffsetLeft   [Direction]) and
                            IsAWallSquare (ASquare+SquareOffsetForward[Direction]+SquareOffsetRight  [Direction]) then begin
                            if DoorCount=OldCount then Inc(DoorCount);
                            DoorSquares[ASquare]:=-DoorCount;                   {"-": neighboring rooms with 2 floors next to the square must treat the square as a corner square belonging to the room}
                            end;
                         end;
                     end;
                  {
                   door pattern #3:
                   #-?  "?": don't care
                   ->#  ">": the square; the direction is ->; "-": floor squares
                   xy?

                   or mirrored squares, but with the same direction:
                   ?-#  "?": don't care
                   #>-  ">": the square; the direction is =>; "-": floor squares
                   ?xy

                   if "x" and "y" are floor squares then the ">" square is not
                   just a door square; at the same time it's a corner square
                   belonging to the room having "x" and "y" as members
                  }
                  if DoorSquares[Square]=0 then begin
                     ASquare:=Square;
                     for Direction:=Low(Direction) to High(Direction) do begin {for each axis}
                         if (IsAFloorSquare(ASquare-SquareOffsetForward[Direction]) and
                             IsAFloorSquare(ASquare+SquareOffsetLeft   [Direction]) and
                             IsAWallSquare (ASquare-SquareOffsetForward[Direction]+SquareOffsetLeft   [Direction]) and
                             IsAWallSquare (ASquare+SquareOffsetForward[Direction])
                            )
                            or
                            (IsAFloorSquare(ASquare+SquareOffsetForward[Direction]) and
                             IsAFloorSquare(ASquare+SquareOffsetLeft   [Direction]) and
                             IsAWallSquare (ASquare-SquareOffsetForward[Direction]) and
                             IsAWallSquare (ASquare+SquareOffsetForward[Direction]+SquareOffsetLeft   [Direction])
                            )
                            then begin
                            if DoorCount=OldCount then Inc(DoorCount);
                            DoorSquares[ASquare]:=-DoorCount;                   {"-": neighboring rooms with 2 floors next to the square must treat the square as a corner square belonging to the room}
                            end;
                         end;
                     end;
                  end;
           end;

        for BoxNo:=1 to BoxCount do Inc(Board[BoxPos[BoxNo]],BOX);              {put boxes back on the board}
        end;
    end; {CalculateDoors}

    procedure CalculateRooms__; {caution: assumes 4 directions only}
    var ASquare,NeighborSquare,RoomSquareCount,Square:Integer; Direction:TDirection; Stack:TBoardSquareSet;
    begin {preconditions: 'Game.Rooms' has been cleared, the door information in 'DoorSquares' has been calculated, and 'CalculateDeadlockSets()' has been called in order to do the 'CalculateBoxReachableSquaresForAllBoxes' calculation}
      with Game do begin
        for Square:=0 to BoardSize do
            if IsALegalAndBoxReachableSquare(Square) and
               (Rooms.Squares[Square].RoomNo=0) and                             {'True': the square hasn't been visited before}
               (DoorSquares  [Square]       =0) and                             {'True': the square isn't a door square}
               (Rooms.Count<MAX_ROOM_COUNT)     then begin                      {'True': there are more free room numbers}
               Inc(Rooms.Count); RoomSquareCount:=1;
               Rooms.Squares[Square].RoomNo:=Rooms.Count;
               Stack.Count:=1; Stack.Squares[1]:=Square; {find all squares in the room by floodfilling the area around the square}
               while Stack.Count<>0 do begin
                 ASquare:=Stack.Squares[Stack.Count]; Dec(Stack.Count);
                 for Direction:=Low(Direction) to High(Direction) do begin
                     NeighborSquare:=ASquare+SquareOffsetForward[Direction];
                     if IsAFloorSquare(NeighborSquare) and
                        (Rooms.Squares[NeighborSquare].RoomNo=0) then begin     {'True': the neighbor square hasn't been visited before}
                        if      DoorSquares[NeighborSquare]=0 then begin
                                Inc(Stack.Count); Stack.Squares[Stack.Count]:=NeighborSquare;
                                Rooms.Squares[NeighborSquare].RoomNo:=Rooms.Count;
                                if IsALegalAndBoxReachableSquare(NeighborSquare) then
                                   Inc(RoomSquareCount);
                                end
                        else if (DoorSquares[NeighborSquare]<0)                 {'True: the door square is not just a door square; a room with two floors next to the square must treat the square as a corner belonging to the room}
                                and
                                (
                                 (IsAFloorSquare(ASquare       +SquareOffsetLeft [Direction]) { --   "--": floor squares}
                                  and                                                         { >D   ">" : the square; the direction is ->; "D": the door square}
                                  IsAFloorSquare(NeighborSquare+SquareOffsetLeft [Direction])
                                 )
                                 or
                                 (IsAFloorSquare(ASquare       +SquareOffsetRight[Direction])
                                  and                                                         { >D   ">" : the square; the direction is ->; "D": the door square}
                                  IsAFloorSquare(NeighborSquare+SquareOffsetRight[Direction]) { --   "--": floor squares}
                                 )
                                ) then begin
                                Rooms.Squares[NeighborSquare].RoomNo:=Rooms.Count; {the gate square is a corner square belonging to the room}
                                if IsALegalAndBoxReachableSquare(NeighborSquare) then
                                   Inc(RoomSquareCount);
                                end;
                        end;
                     end;
                 end;

               if RoomSquareCount<ROOM_PRUNING_ROOM_SIZE_THRESHOLD then begin {room pruning makes the search incomplete, hence, it's only enabled for large rooms where an exhaustive search probably is out of reach anyway}
                  for ASquare:=0 to BoardSize do
                      if Rooms.Squares[ASquare].RoomNo=Rooms.Count then
                         Rooms.Squares[ASquare].RoomNo:=0;
                  Dec(Rooms.Count); {undo the premature update}
                  end;
               end;

        {for each room square, for each direction, find the nearest}
        {straight-line entry/exit point in that direction, if any;}
        {the distances are stored in 'StraightLineEntryPointDistances[Direction]'}
        for Square:=0 to BoardSize do
            if Rooms.Squares[Square].RoomNo<>0 then
               for Direction:=Low(Direction) to High(Direction) do begin
                   ASquare:=Square;
                   while Rooms.Squares[ASquare].RoomNo=Rooms.Squares[Square].RoomNo do {follow the line of sight in this direction until a square outside the room is met}
                     Inc(ASquare,SquareOffsetForward[Direction]);
                   if IsAFloorSquare(ASquare) then
                      Rooms.Squares[Square].StraightLineEntryPointDistances[Direction]:=Abs((ASquare-Square) div SquareOffsetForward[Direction]);
                   end;
        end;
    end; {CalculateRooms__}

    procedure RoomsToTextLines( var BoardAsTextLines__:TBoardAsTextLines );
    var i,Col,Row,Square:Integer; s:String;
    begin
      with Game do begin
        for Row:=Low(BoardAsTextLines__) to High(BoardAsTextLines__) do
            BoardAsTextLines__[Row]:='';

        for i:=1 to BoxCount do Dec(Board[BoxPos[i]],BOX);
        Board[PlayerPos]:=Board[PlayerPos] and (not PLAYER);

        for Row:=1 to BoardHeight do begin
            for Col:=1 to BoardWidth do begin
                Square:=ColRowToSquare(Col,Row);
                i:=Rooms.Squares[Square].RoomNo;
                if not IsALegalAndBoxReachableSquare(Square) then i:=0; {'0': don't show unreachable squares as members of the room}
                if i=0 then
                   BoardAsTextLines__[Row]:=BoardAsTextLines__[Row]+SquareToChar(Square)
                else begin
                   if        i<= 9 then s:=IntToStr(i)
                   else if   i<=36 then s:=Chr(Ord('A')+i-10)
                        else s:='%'; // depict the remaining rooms as a rest group
                   BoardAsTextLines__[Row]:=BoardAsTextLines__[Row]+s;
                   end;
                end;
            end;

        if PlayerPos<>0 then Inc(Board[PlayerPos],PLAYER);
        for i:=1 to BoxCount do Inc(Board[BoxPos[i]],BOX);
        end;
    end; {RoomsToTextLines}

    function  WriteRoomsToLogFile:Boolean;
    var Row:Integer; BoardAsTextLines:TBoardAsTextLines;
    begin
      Result:=LogFile.FileName<>'';
      if Result then with LogFile do begin
         RoomsToTextLines(BoardAsTextLines);
         Result:=WritelnToLogFile('') and
                 WritelnToLogFile('Rooms');
         for Row:=1 to Game.BoardHeight do
             Result:=Result and WritelnToLogFile(BoardAsTextLines[Row]);
         end;
    end; {WriteRoomsToLogFile}

    procedure ShowRooms;
    var Row:Integer; BoardAsTextLines:TBoardAsTextLines;
    begin
      RoomsToTextLines(BoardAsTextLines);
      Writeln('Rooms');
      for Row:=1 to Game.BoardHeight do
          Writeln(BoardAsTextLines[Row]);
      Msg('','');
    end; {ShowRooms}

  begin {CalculateRooms}
    with Game do begin
      FillChar(Rooms,SizeOf(Rooms),0);
      if Solver.Enabled then begin
         CalculateDoors;
         CalculateRooms__;
         WriteRoomsToLogFile;
         //for BoxNo:=1 to BoxCount do Inc(Rooms.RoomBoxCount[Rooms.Squares[BoxPos[BoxNo]].RoomNo]); {calculate the number of boxes in each room}
         {ShowRooms;}
         end;
      end;
  end; {CalculateRooms}

  procedure InitializeSearchStates;
  var  i:Integer;
  begin
    with Solver do begin
      {FillChar(Solver.SearchStates,SizeOf(Solver.SearchStates),0);}
      for i:=Low(SearchStates) to High(SearchStates) do with SearchStates[i].PlayersReachableSquares do
          TimeStamp:=High(TimeStamp); {so 'CalculatePlayersReachableSquares' initializes the work-areas on first call}
      ClearPlayersReachableSquares(SEARCH_STATE_INDEX_CORRAL_PRUNING);
      SearchStates[SEARCH_STATE_INDEX_CORRAL_PRUNING].PlayersReachableSquares.TimeStamp:=2; // '2': helps to distinguish between first time and a wrap around
      end;
  end;

begin {InitializeGame}
  with Game do begin
    StartTimeMS:=GetTimeMS;
    {$IFDEF CONSOLE_APPLICATION} {for a plugin, don't risk allocating global strings on top of the large transposition table}
      if Title='' then Title:=TEXT_LEVEL+' 1';
    {$ENDIF}
    History.Count:=0; SimpleLowerBound:=0; ReverseMode:=False;
    PluginResult__:=prOK; ErrorText__:='';
    BoxPos[0]:=0; GoalPos[0]:=0; SortedBoxSquares[0]:=0;
    InitializeBoard(Game.BoardWidth,Game.BoardHeight,False);
    Result:=FindBoxesAndGoalsAndPlayer(PluginResult__,ErrorText__);
    OriginalBoard:=Board; OriginalBoxPos:=BoxPos; OriginalPlayerPos:=PlayerPos;
    FillTubes;
    Game.StartPlayerPos:=Game.PlayerPos; Game.StartBoxPos:=Game.BoxPos;
    Game.EndPlayerPos:=0;
    Solver.PackingOrder.GoalAndParkingSquareCount:=Game.GoalCount;
    FillChar(SolutionPathHashValues,SizeOf(SolutionPathHashValues),0);
    DeadlockSets.TimeMS:=0; Solver.PackingOrder.TimeMS:=0;
    InitializationTimeMS:=0; Solver.TimeMS:=0; Optimizer.TimeMS:=0;

    {'TimeCheck' is based upon 'Solver.StartTimeMS' and 'Solver.TimeMS';
     initialize the fields so 'TimeCheck' can be called normally during the
     initialization of the game
    }
    Solver.StartTimeMS:=StartTimeMS;
    OriginalSearchLimits:=Solver.SearchLimits;                                  {save search limits}
    if (not Solver.Enabled) and Optimizer.Enabled then
       Solver.SearchLimits:=Optimizer.SearchLimits;                             {install optimizer limits as solver limits (they are used throughout the search and by 'Terminate')}

    if Reader.LevelCount>=Reader.FirstLevelNo then begin {kludge: avoid time-consuming calculations for skipped levels}
       {$IFDEF CONSOLE_APPLICATION}
         Writeln; Writeln(Reader.LevelCount,COLON,SPACE,Game.Title); ShowBoard; {show the board}
         //if not Result then Writeln(ErrorText__);
       {$ENDIF}
       if Result then begin
          InitializeSearchStates;

          for BoxNo:=1 to BoxCount do Dec(Board[BoxPos[BoxNo]],BOX);            {remove all boxes from the board}
          FloorCount:=CalculatePlayersReachableSquares(0);                      {calculate the number of reachable floor squares on the board}
          for BoxNo:=1 to BoxCount do Inc(Board[BoxPos[BoxNo]],BOX);            {put all boxes back on the board}

          for SquareNo := 0 to BoardSize do {remove floors outside the reachable part of the board; instead of filling them with walls, they are made "non-floors"; that way, they graphically still appear as empty squares}
              if ( ( Board[ SquareNo ] and FLOOR ) <> 0 ) and
                 ( Solver.SearchStates[ 0 ].PlayersReachableSquares.Squares[ SquareNo ] <>
                   Solver.SearchStates[ 0 ].PlayersReachableSquares.Timestamp ) then
                 Dec( Board[ SquareNo ], FLOOR );                               {make the unreachable floor square a "non-floor"}

          if not CalculateDeadlockSets(nil,DeadlockSetCandidate)  then SimpleLowerBound:=INFINITY; {'INFINITY': the level is unsolvable or the time-limit was exceeded}
          if SimpleLowerBound<>INFINITY then SimpleLowerBound:=CalculateSimpleLowerBound;
          if SimpleLowerBound<>INFINITY then begin
             CalculateRooms;
             if Game.OriginalSolution<>'' then
                if ReplayGame(Game.OriginalSolution) then begin
                   {$IFDEF CONSOLE_APPLICATION}
                     Writeln('Existing solution: ',Game.OriginalSolutionMoveCount,SLASH,Game.OriginalSolutionPushCount);
                   {$ENDIF}
                   end
                else begin
                   Game.OriginalSolution         :='';
                   Game.OriginalSolutionMoveCount:=0;
                   Game.OriginalSolutionPushCount:=0;
                   end;
             CalculatePackingOrder;
             end;
          Game.History.Count:=Game.TubeFillingPushCount;
          PackingOrderPushCount:=0;
          end;
       end;

    HashValue:=CalculateHashValue;

    {clean up after having used the function 'TimeCheck' during the
     initialization; 'TimeCheck' is based upon 'Solver.StartTimeMS' and
     'Solver.TimeMS' and updates various fields if a time limit has been
     exceeded;
    }
    Solver.StartTimeMS:=0; Solver.TimeMS:=0;                                    {clear the solver time statistics; the time spent on initialization is calculated a few code lines further down}
    Solver.SearchLimits:=OriginalSearchLimits;                                  {restore search limits}
    InitializationTimeMS:=CalculateElapsedTimeMS(StartTimeMS,GetTimeMS);        {calculate initialization time}
    end;
end;

function  ReduceBoxChanges:Integer;
  // preconditions:
  // * the history contains the game to be optimized;
  // * the board position matches the initial game state after push number 'Game.TubeFillingPushCount';
  // modifies the game state ('Board', 'PlayerPos', BoxPos');
var
  StartTimeMS:TTimeMS;

  // forward declarations
  function  IsALegalPush(BoxNo__:Integer; Direction__:TDirection):Boolean; forward;

  function  DoPushes(Start__,Stop__,BoxNo__:Integer; var Last__:Integer):Integer;
  var i:Integer;
  begin // tries to perform pushes from the push number 'Start__' up to, but not including, the push number 'Stop__';
        // postcondition: the player's reachable squares have been calculated, using index = 0;
    with Game do with History do begin
      Result:=0; Last__:=Pred(Start__); i:=Start__;
      CalculatePlayersReachableSquares(0);
      while (i<>Stop__) and
            ((BoxNo__=0) or (BoxNo__=Moves[i].BoxNo)) and
            IsALegalPush(Moves[i].BoxNo,Moves[i].Direction) and
            (SimpleLowerBound<>0) do
        with Moves[i] do begin
          DoPush(BoxNo,Direction,-1);
          CalculatePlayersReachableSquares(0);
          Inc(Result); Last__:=i; Inc(i);
          end;
      end;
  end;

  function  IsALegalPush(BoxNo__:Integer; Direction__:TDirection):Boolean;
  begin // precondition: the player's reachable squares have been calculated, using index = 0}
    with Game do with Solver.SearchStates[0].PlayersReachableSquares do
       Result:={inline simple checks for legal moves}
               (Squares[BoxPos[BoxNo__]-SquareOffsetForward[Direction__]]=TimeStamp){'=TimeStamp': the player can reach the opposite neighbor-square}
               and
               ((Board [BoxPos[BoxNo__]+SquareOffsetForward[Direction__]] and (BOX+WALL+FLAG_ILLEGAL_BOX_SQUARE))=0) {'=0' the square is legal and not blocked by a wall or another box}
               and
               {extended checks for legal moves}
               YASS.IsALegalPush(BoxNo__,Direction__,-1);
  end;

  procedure MoveItemsAfter(First__,Last__,After__:Integer);
  var i:Integer; H:THistory;
  begin
    with Game do with History do begin
      for i:=First__ to Last__ do H.Moves[i]:=Moves[i];
      if First__<=After__ then begin
         for i:=Succ(Last__) to After__ do Moves[First__+i-Succ(Last__)]:=Moves[i];
         for i:=First__ to Last__ do Moves[After__+i-Last__]:=H.Moves[i];
         end
      else begin
         for i:=Pred(First__) downto Succ(After__) do Moves[Last__+i-Pred(First__)]:=Moves[i];
         for i:=First__ to Last__ do Moves[Succ(After__)+i-First__]:=H.Moves[i];
         end;
      end;
  end;

  function  UndoPushes(First__,Last__:Integer):Integer;
  begin // takes back the pushes 'First__' .. 'Last__', both included;
        // returns the push number which matches the new game state;
        // precondition: the current game state matches push number 'Last__';
    with Game do with History do begin
      Result:=Last__;
      while First__<=Result do begin
        with Moves[Result] do UndoPush(BoxNo,Direction);
        Dec(Result);
        end;
      end;
  end;
{
  procedure CalculateDependencies(StartNo__:Integer);
  var i,j,OldPlayerPos:Integer; More:Boolean;
  begin
    with Game do with History do begin
      OldPlayerPos:=PlayerPos;

      // replay moves before 'StartNo__'
      for i:=Succ(Game.TubeFillingPushCount) to Pred(StartNo__) do
          with Moves[i] do DoPush(BoxNo,Direction);

      i:=Nodes[0].Next; LastNode:=0;
      while i<>0 do with Nodes[i] do with Move do begin
        with Nodes[i].Move do DoPush(BoxNo,Direction);
        FirstChild:=0; LastNode:=i; j:=i;

        repeat // find the point where the push 'i' becomes legal
          with Nodes[j].Move do UndoPush(BoxNo,Direction);
          CalculatePlayersReachableSquares(0);
          j:=Nodes[j].Prev;
          if Nodes[j].Move.BoxNo<>BoxNo then begin
             More:=IsALegalPush2(BoxNo,Direction);
             if More then Nodes[i].Parent:=j;
             end
          else begin
             More:=False;
             if IsALegalPush2(BoxNo,Direction) then Nodes[i].Parent:=j;
             end;
        until (j=0) or (not More);

        // replay moves so the board matches position 'i'
        DoPushes(Nodes[j].Next,Next,0,j);

        i:=Next;
        end;

      // build a list of successors for each node with members sorted in ascending order
      i:=LastNode; Nodes[0].FirstChild:=0;
      while (i<>0) do with Nodes[Nodes[i].Parent] do begin
        Nodes[i].NextSibling:=FirstChild;
        FirstChild:=i;
        i:=Nodes[i].Prev;
        end;

      // undo all moves again, i.e., reset the game
      UndoPushes(Nodes[0].Next,LastNode);
      for i:=Pred(StartNo) downto Succ(Game.TubeFillingPushCount) do
          with Moves[i] do UndoPush(BoxNo,Direction);
      MovePlayer(OldPlayerPos);
      end;
  end;
}

  function  ReduceBoxChanges__:Integer;
  var i,j,k,LastSameBoxIndex,OldPlayerPos,NormalizedPlayerPos:Integer; OK:Boolean; //s:String;
  begin
    Result:=0; //s:='';
    with Game do with History do begin
      OldPlayerPos:=PlayerPos; i:=0;

      while i<Count do begin
        // perform next push and any trailing same-box pushes
        repeat //ShowBoard; Write('Pushes: ',i); Readln(s);
               Inc(i);
               if i>Game.TubeFillingPushCount then
                  with Moves[i] do DoPush(BoxNo,Direction,-1);
        until  (i>=Game.TubeFillingPushCount) and
               ((i=Count) or (Moves[i].BoxNo<>Moves[Succ(i)].BoxNo)); // perform all same-box pushes at once

        //ShowBoard; Write('Pushes: ',i); Readln(s); if s<>'' then Writeln;

        with Moves[i] do begin
          LastSameBoxIndex:=i; OK:=False;
          repeat
            j:=LastSameBoxIndex;
            repeat Inc(j); // find next same-box push, if any
            until  (j>Count) or (Moves[j].BoxNo=BoxNo);
            // check if it's legal to perform the next same-box move after the current sequence of same-box-pushes
            if     (j<=Count) and
                   (DoPushes(j,Succ(Count),BoxNo,k)<>0) then
                   LastSameBoxIndex:=k
            else   j:=Succ(Count);

            if     j<=Count then begin // 'True': the next same-box-push is legal after the current sequence of same-box-pushes
                   j:=i;
                   repeat Inc(j); // test if all different-box-pushes in [current-push + 1 .. last-same-box-push] are legal now
                   until  (j=LastSameBoxIndex) or
                          (SimpleLowerBound=0) or
                          ((Moves[j].BoxNo<>BoxNo) and (DoPushes(j,Succ(j),0,k)=0));

                   if      (j=LastSameBoxIndex) then begin // 'True': all different-box-pushes are still legal
                           CalculatePlayersReachableSquares(0);
                           OK:=(LastSameBoxIndex=Count) or // check if the move after the last same-box-push still is legal
                               IsALegalPush(Moves[Succ(LastSameBoxIndex)].BoxNo,Moves[Succ(LastSameBoxIndex)].Direction);
                           end
                   else if SimpleLowerBound=0 then begin // 'True': the box changes produce a shorter solution
                           OK:=True;
                           Count:=i; // calculate the new number of pushes in the solution; 'i' is the number of already processed pushes
                           for k:=Succ(i) to LastSameBoxIndex do // for each push under investigation
                               if (Moves[k].BoxNo=BoxNo) // 'True': it's one of same-box pushes; they will be moved after push number 'i'
                                  or
                                  (k<j) then             // 'True': it's one of the other boxes; they end up being positioned after the moved same-box pushes
                                  Inc(Count);
                           end;

                   for k:=Pred(j) downto Succ(i) do // undo all performed different-box-pushes in [current-push + 1 .. last-performed-non-same-box-push]
                       if Moves[k].BoxNo<>BoxNo then
                          with Moves[k] do UndoPush(BoxNo,Direction);
                   end;

          until    (j>Count) or OK; // until all moves have been tested, or until the current sequence of same-box-pushes can be performed after the current move

          for k:=LastSameBoxIndex downto Succ(i) do // undo all same-box-pushes in [current-push + 1 .. last-same-box-push]
              if Moves[k].BoxNo=BoxNo then
                 with Moves[k] do UndoPush(BoxNo,Direction);

          if OK then begin // 'True': the sequence of same-box-pushes in [current-push + 1, last-same-box-push] can be performed after the current position
             //Write('Next: ',LastSameBoxIndex); Readln(s); if s<>'' then Writeln;
             j:=i;
             for k:=Succ(i) to LastSameBoxIndex do
                 if Moves[k].BoxNo=BoxNo then begin
                    if k<>Succ(j) then begin
                       MoveItemsAfter(k,k,j); Inc(Result);
                       end;
                    Inc(j);
                    end;
             end;
          end;
        end;

      // undo all moves again, i.e., reset the game
      for i:=Count downto Succ(Game.TubeFillingPushCount) do
          with Moves[i] do UndoPush(BoxNo,Direction);
      MovePlayer(OldPlayerPos);

      if Result<>0 then begin // 'True': the number of box changes has been reduced by rearranging the pushes on the solution path
         // remove redundant to and fro pushes, e.g., going left and then right, with the player in the same player access area as before the two pushes
         k:=Game.TubeFillingPushCount; // 'k': pushes performed so far
         i:=Succ(k); // first push on the solution path after tube-filling pushes, if any
         while i<Count do begin
           if (Moves[i].BoxNo    <>                   Moves[Succ(i)].BoxNo     ) or
              (Moves[i].Direction<>OPPOSITE_DIRECTION[Moves[Succ(i)].Direction]) or
              (DoPushes(Succ(k),i,0,k)<0) or // '<0': always false
              (k<>Pred(i)) then // '<>': performing pushes k+1..i-1 failed; this should never happen;
              Inc(i) // advance to next push
           else begin // check if pushes 'i' and 'i+1' are redundant; the board position matches push 'i-1';
              NormalizedPlayerPos:=Solver.SearchStates[0].PlayersReachableSquares.MinPlayerPos; // remember the normalized player position for the current position
              if DoPushes(Succ(k),i+2,0,k)=2 then begin // 'True': the pushes 'i' and 'i+1' have been performed
                 if NormalizedPlayerPos<>Solver.SearchStates[0].PlayersReachableSquares.MinPlayerPos then // 'True': the pushes 'i' and 'i+1' are not redundant, even though they are to and fro pushes
                    k:=UndoPushes(Succ(i),k) // backtrack to the board position matching push 'i' and continue checking for redundant pairs from 'i+1'; (see i:=Succ(k) further down)
                 else begin // the pushes 'i' and 'i+1' are redundant
                    k:=UndoPushes(Pred(i),k); // backtrack to the board position matching push 'i-2'; the pushes 'i-1' and i+2' may be a new redundant pair;
                    Dec(Count,2);
                    for j:=i to Count do
                        Moves[j]:=Moves[j+2];
                    end;
                 i:=Succ(k); // check for redundant pairs, starting from the first push after the pushes performed so far
                 end
              else i:=Count; // perform pushes 'i' and 'i+1' failed; this should not happen; exit loop;
              end;
           end;

         // undo all moves again, i.e., reset the game
         for i:=k downto Succ(Game.TubeFillingPushCount) do
             with Moves[i] do UndoPush(BoxNo,Direction);
         MovePlayer(OldPlayerPos);
         end;

      //ShowBoard; Write('Start position'); Readln(s);
      end;
  end; // ReduceBoxChanges.ReduceBoxChanges__

begin // ReduceBoxChanges; precondition: the history contains the game to be optimized; modifies the game state ('Board', 'PlayerPos', BoxPos') destructively
  StartTimeMS:=GetTimeMS; Optimizer.TimeMS:=0; Result:=0;
  if Game.History.Count<>0 then
     with Game do with History do begin
       Result:=ReduceBoxChanges__;

//     CalculateDependencies(StartNo);
//     Log(StartNo);
       end;
  Optimizer.TimeMS:=CalculateElapsedTimeMS(StartTimeMS,GetTimeMS);

//Write('Reduce boxchanges: ',Result); Readln;
//WritelnToLogFile('Optimizations: '+IntToStr(Result)+',  Time (milliseconds): '+IntToStr(Optimizer.TimeMS));
end; // ReduceBoxChanges

function  ReplayGame(const Moves__:String):Boolean;
var {$IFDEF CONSOLE_APPLICATION}
      a,b,
    {$ENDIF}
    i,j,n,Len,SquareNo:Integer; Ch:Char; Direction:TDirection;
begin {replays a game from a string; mostly used for testing that deadlock sets are all right}
  Result:=True;
  Game.OriginalSolutionMoveCount:=0;
  Game.OriginalSolutionPushCount:=0; Game.DeadlockSets.IsALegalPushOverflowingSets[1]:=0;
  Game.HashValue:=CalculateHashValue;
  FillChar(Game.SolutionPathHashValues,SizeOf(Game.SolutionPathHashValues),0);
  Len:=Length(Moves__); i:=0;
  while Result and (i<Len) do begin
    Inc(i); Ch:=Moves__[i];
    if (Ch<>LEFT_PAREN) and (Ch<>RIGHT_PAREN) and (Ch<>'*') then begin
       Result:=CharToDirection(Ch,Direction);
       if Result then begin
          //ShowBoard;
          //Write(Game.OriginalSolutionMoveCount,SLASH,Game.OriginalSolutionPushCount);
          //Readln;
          SquareNo:=Game.PlayerPos+Game.SquareOffsetForward[Direction];
          if Ch=LoCase(Ch) then begin {'LoCase': a player move as opposed to a box push}
             Inc(Game.OriginalSolutionMoveCount);
             if Game.OriginalSolutionMoveCount>Game.TubeFillingMoveCount then begin
                if   (Game.Board[SquareNo] and (WALL+BOX))=0 then
                     MovePlayer(SquareNo)
                else Result:=False;
                end;
             end
          else if Game.OriginalSolutionPushCount<Game.TubeFillingPushCount then begin
                  Inc(Game.OriginalSolutionMoveCount);
                  Inc(Game.OriginalSolutionPushCount);
                  if Game.OriginalSolutionPushCount<=High(Game.SolutionPathHashValues) then
                     Game.SolutionPathHashValues[Game.OriginalSolutionPushCount]:=Game.HashValue;
                  end
               else begin
                  Result:=False; j:=0;
                  while (not Result) and (j<Game.BoxCount) do begin
                    Inc(j);
                    if Game.BoxPos[j]=SquareNo then begin
                       Result:=IsALegalPush(j,Direction,0);
                       if Result then begin
                          Inc(Game.OriginalSolutionMoveCount);
                          Inc(Game.OriginalSolutionPushCount);
                          DoPush(j,Direction,0);
                          if Game.OriginalSolutionPushCount<=High(Game.SolutionPathHashValues) then
                             Game.SolutionPathHashValues[Game.OriginalSolutionPushCount]:=Game.HashValue;
                          if Game.OriginalSolutionPushCount<=High(Game.History.Moves) then begin
                             Game.History.Moves[Game.OriginalSolutionPushCount].BoxNo:=j;
                             Game.History.Moves[Game.OriginalSolutionPushCount].Direction:=Direction;
                             end;
{
                          ShowBoard;
                          Write('Current position in original solution: Moves: ',
                                Game.OriginalSolutionMoveCount,
                                ' Pushes: ',
                                Game.OriginalSolutionPushCount);
                          Readln;
}
                          end
                       else begin
                          Dec(i); {don't try to undo current move}
                          j:=Game.BoxCount;

                          {$IFDEF CONSOLE_APPLICATION}
                            Writeln;
                            Writeln(Game.Title);
                            ShowBoard;
                            Writeln('Current position in original solution: Moves: ',
                                    Game.OriginalSolutionMoveCount,
                                    ' Pushes: ',
                                    Game.OriginalSolutionPushCount);
                            SquareToColRow(SquareNo,a,b);
                            Write('Illegal Push?: (',a,',',b,')');
                            Inc(SquareNo,Game.SquareOffsetForward[Direction]);
                            SquareToColRow(SquareNo,a,b);
                            Writeln(' => (',a,',',b,') Square number: ',SquareNo);
                            Msg('','');

                            if Game.DeadlockSets.IsALegalPushOverflowingSets[1]<>0 then begin
                               Writeln; Writeln('Violated deadlock set:');
                               Game.ShowDeadlockSetsEnabled:=True;
                               ShowDeadlockSet(Game.DeadlockSets.IsALegalPushOverflowingSets[1],0);
                               Game.ShowDeadlockSetsEnabled:=False;
                               end;
                          {$ENDIF}
                          end;
                       end;
                    end;
                  end;
          if Result then begin
{
             Writeln;
             Writeln(Game.Title);
             ShowBoard;
             Writeln('Moves: ',MoveCount,' Pushes: ',PushCount);
             Readln;
}
             end
          else with Game do begin
             OriginalSolution:='';
             OriginalSolutionMoveCount:=0; OriginalSolutionPushCount:=0;
             end;
          end;
       end;
    end;

    Game.History.Count:=Min(Game.OriginalSolutionPushCount,High(Game.History.Moves));

    n:=Game.OriginalSolutionMoveCount;
    while (i>0) and
          (n>Game.TubeFillingMoveCount) do begin {undo the moves again}
      Ch:=Moves__[i]; Dec(i);
      if CharToDirection(Ch,Direction) then begin
         Dec(n);
         SquareNo:=Game.PlayerPos+Game.SquareOffsetForward[Direction];
         if   Ch=LoCase(Ch) then MovePlayer(Game.PlayerPos-Game.SquareOffsetForward[Direction])
         else for j:=1 to Game.BoxCount do
                  if Game.BoxPos[j]=SquareNo then UnDoPush(j,Direction);
         end;
      end;

    if Result then Inc(Game.DeadlockSets.SessionTestedGamesCount);
{
    ShowBoard;
    Msg('Start position','');
}
end;

{-----------------------------------------------------------------------------}

{Solver}

procedure TerminateSearch;
begin // terminates the current search; to terminate the solver, call 'Terminate' instead
  Solver.SearchLimits.DepthLimit:=-1;
  Solver.SearchLimits.PushCountLimit:=0;
  Positions.OpenPositions.MaxValue:=Low(Positions.OpenPositions.Buckets)-2;     {'-2': signals that some open positions haven't been fully expanded}
end; {TerminateSearch}

procedure TimeCheck;
begin
  Inc(Solver.TimeCheckCount);
  {$IFDEF WINDOWS}
    {$IFDEF CONSOLE_APPLICATION}
      if WasKeyPressed( VK_ESCAPE ) then begin
         TerminateSearch;                                                       {terminate the current search}
         SetSokobanStatusText(TEXT_TERMINATED_BY_USER);
         end
      else
    {$ENDIF}
  {$ENDIF}
  if (Solver.SearchLimits.TimeLimitMS<>High(Solver.SearchLimits.TimeLimitMS))   {high-value signals unlimited search time}
     or
     Assigned(Solver.SokobanCallBackFunction) then begin
     Solver.TimeMS:=CalculateElapsedTimeMS(Solver.StartTimeMS,GetTimeMS);

     if Solver.TimeMS<Solver.SearchLimits.TimeLimitMS then begin
        if Assigned(Solver.SokobanCallBackFunction) and
           (Solver.TimeMS-Solver.LastCallBackTimeMS>=SOKOBAN_PLUGIN_CALL_BACK_FUNCTION_THRESHOLD_TIME_MS) then begin
           Solver.LastCallBackTimeMS:=Solver.TimeMS;
           if PerformSokobanCallBackFunction<>0 then begin                      // '<>0': indicates that the plugin should terminate
              Solver.Terminated:=True;                                          // terminate the solver, not just the current search
              TerminateSearch;                                                  // terminate the current search
              SetSokobanStatusText(TEXT_TERMINATED_BY_USER);
              end;
           end;
        end
     else begin
        TerminateSearch;
        if not (Solver.Enabled and Game.ReverseMode and (Solver.SearchMethod=smPerimeter)) then
           SetSokobanStatusText(TEXT_TIME_LIMIT_EXCEEDED);
        end;
     end;
end; {TimeCheck}

function  Search:Boolean;
{precondition: the game has been initialized by calling 'InitializeGame'}
var OriginalBoxLimitForDynamicSets,OldPlayerPos:Integer;
    LevelTimeLimitMS:TTimeMS;
    OriginalSearchLimits:TSearchLimits;
    OriginalSearchMethod:TSearchMethod;
    PackingOrderSearchStatistics:TSearchStatistics;
    {$IFDEF CONSOLE_APPLICATION}
      s:String;
    {$ENDIF}
    p:PPosition; {F:Text;}

  procedure DoPull(BoxNo__:Integer; Direction__:TDirection);
  var FromSquare,ToSquare:Integer;
  begin {precondition: this local procedure must shadow the corresponding top-level procedure}
    if BoxNo__<>0 then with Game do begin {only pulls are handled}
       Direction__:=TDirection(Ord(Direction__) and DIRECTION_BIT_MASK);

       FromSquare:=BoxPos[BoxNo__];
       ToSquare  :=FromSquare+SquareOffsetForward[Direction__];
//     if (Game.Board[ToSquare] and (WALL+BOX))<>0 then
//        Writeln;
       Dec(Board[FromSquare],BOX);
       Inc(Board[ToSquare  ],BOX);
       BoxPos[BoxNo__]:=ToSquare;
       Dec(Board[PlayerPos],PLAYER);
       PlayerPos:=ToSquare+SquareOffsetForward[Direction__];
       Inc(Board[PlayerPos],PLAYER);
       HashValue:=(HashValue xor Positions.SquareHashValues[FromSquare])
                  xor
                  Positions.SquareHashValues[ToSquare];
       Inc(SimpleLowerBound,DistanceToNearestBoxStartPosition[ToSquare]-DistanceToNearestBoxStartPosition[FromSquare]);
       end;
  end;

  procedure UndoPull(BoxNo__:Integer; Direction__:TDirection);
  var FromSquare,ToSquare:Integer;
  begin {precondition: this local procedure must shadow the corresponding top-level procedure}
    if BoxNo__<>0 then with Game do begin {only pushes are handled}
       FromSquare:=BoxPos[BoxNo__];
       ToSquare  :=FromSquare-SquareOffsetForward[TDirection(Ord(Direction__) and DIRECTION_BIT_MASK)];
//     if (Game.Board[ToSquare] and (WALL+BOX))<>0 then
//        Writeln;
       Dec(Board[FromSquare],BOX);
       Inc(Board[ToSquare  ],BOX);
       BoxPos[BoxNo__]:=ToSquare;
       Dec(Board[PlayerPos],PLAYER);
       PlayerPos:=FromSquare;
       Inc(Board[PlayerPos],PLAYER);
       HashValue:=(HashValue xor Positions.SquareHashValues[FromSquare])
                  xor
                  Positions.SquareHashValues[ToSquare];
       Inc(SimpleLowerBound,DistanceToNearestBoxStartPosition[ToSquare]-DistanceToNearestBoxStartPosition[FromSquare]);
       end;
  end;

  // 'SetPosition' uses pointer reversal to track the path to the new position;
  // this may sound expensive but the running time is almost identical
  // to a version using an external vector for storing the current path;
  // the alternative, an extra forward-chain field in the position-record, is
  // wasting too much space
  procedure SetPosition(Position__:PPosition);
  // do/undo moves so the board matches the position at the tree-node 'Position__'
  var Depth,NewBoxNo,SquareNo:Integer; NewDirection:TDirection; p,Next,Temp:PPosition;
  begin // precondition : 'Position__' is a member of the transposition-table
       //  postcondition: if it's a forward search then 'Solver.SearchStates[Position__^.PushCount].PlayersReacableSquares.Calculated' has been set according to whether the calculation has been performed for the push number 'Position__^.PushCount'
    with Positions do begin
      Inc(SearchStatistics.SetPosition1Count);

      // find path back to common ancestor of new position and current position
      p:=Position__; Next:=nil;
      while (p<>nil) and
            ((Ord(p^.Move.Direction) and POSITION_PATH_TAG)=0) do with p^ do begin // '0': the position isn't a member of current path
        Temp:=Parent; Parent:=Next; Next:=p; p:=Temp; // pointer reversal; 'Parent' is temporarily used for a forward chain
        end;

      // undo old moves not on common path
      while (CurrentPosition<>p) and
            (CurrentPosition<>nil) do with CurrentPosition^ do begin
        Dec(UInt8(Move.Direction),POSITION_PATH_TAG); // reset 'on current path' tag
        if   not Game.ReverseMode then begin
             UndoPush(Move.BoxNo,Move.Direction);
             if (UInt8(Move.Direction) and POSITION_DEADLOCK_TAG)<>0 then begin
                Dec(Game.DeadlockSets.PathDeadlockCount);
                Dec(UInt8(Move.Direction),POSITION_DEADLOCK_TAG);
                end;
             end
        else UndoPull(Move.BoxNo,Move.Direction);
        CurrentPosition:=Parent;
        Inc(SearchStatistics.SetPosition2Count);
{
        if (CurrentPosition<>nil) and
           (CurrentPosition.HashValue<>Game.HashValue) then begin
           ShowBoard; Write('Backtrack: Internal error '); Readln;
           end;
}
        end;

      // perform new moves, starting with the successor of the common ancestor
      if Next<>nil then begin
         Depth:=Next^.PushCount;
         repeat
           with Next^ do begin
             if   not Game.ReverseMode then begin
                  // check that the push is legal; it's unlikely that 2 different
                  // positions accidentally have identical 64-bit hashvalues,
                  // but if it happened it could destroy the path chains;
                  //
                  // a more common reason for an illegal push is that the path
                  // to a position has changed; in that case there is still a
                  // push leading to this position, but it may be a different
                  // box and a different direction;
                  if  (Game.Board[PlayerPos] and BOX)<>0 then begin
                      SquareNo:=Game.BoxPos[Move.BoxNo];
                      if   SquareNo<>PlayerPos then begin // '<>': the move leading to 'Position__' isn't legal anymore; check if pushing another box can lead to the position represented by 'Position__'
                           if HasALegalPush(Next,NewBoxNo,NewDirection) then begin // 'True': substitute the old move with the new one
                              Move.BoxNo:=NewBoxNo;
                              UInt8(Move.Direction):=(UInt8(Move.Direction) and (not DIRECTION_BIT_MASK))+Ord(NewDirection);
                              //for NewBoxNo:=1 to Game.BoxCount do with Game do {repair the box numbers stored in the upper bits of the board squares}
                              //    Board[BoxPos[NewBoxNo]]:=Cardinal(Board[BoxPos[NewBoxNo]] and (not (BOX_GOAL_BIT_MASK shl BOX_BIT_SHIFT_COUNT))) or Cardinal(NewBoxNo shl BOX_BIT_SHIFT_COUNT);
                              end
                           else begin
                             TerminateSearch;
                             end;
                           end;
                      Solver.SearchStates[PushCount].PlayersReachableSquares.Calculated:=False; {initialize 'Calculated' before calling 'DoPush()'}
{
                      if Solver.PushCount=2072 then begin
                         ShowBoard;
                         Writeln(Game.HashValue,SPACE,Next^.PushCount);
                         Readln;
                         end;
}
                      if DoPush(Move.BoxNo,Move.Direction,PushCount) then begin
                         end
                      else begin // the move was performed, but it violates one or more of the dynamically calculated deadlock sets
                         UInt8(Move.Direction):=UInt8(Move.Direction) or POSITION_DEADLOCK_TAG;
                         Inc(Game.DeadlockSets.PathDeadlockCount);
{
                         if Game.Board[MAX_BOARD_SIZE]=FLOOR then begin
                            ShowBoard;
                            Write('Deadlock? ',PushCount,SPACE,Solver.PushCount,SPACE,YASS.Positions.Count);
                            Writeln; //Readln;
                            end;
}
                         end;
{
                      if Game.Board[MAX_BOARD_SIZE]=FLOOR then begin
                         ShowBoard;
                         Write(PushCount);
                         Writeln; //Readln;
                         end;
}
                      end
                  else if Move.BoxNo<>0 then begin
                          TerminateSearch; // something is wrong, such as 2 different positions accidentally having identical hashvalues
                          end;
                  end
             else DoPull(Move.BoxNo,Move.Direction);

             Inc(UInt8(Move.Direction),POSITION_PATH_TAG); // set 'on current path' tag; note that this is very dirty because 'Direction' is now out of bounds; use "TDirection(Ord(Direction__) and DIRECTION_BIT_MASK)" to extract the direction
{
             if Next^.HashValue<>Game.HashValue then begin
                ShowBoard; Write('Forward: Internal error '); Readln;
                Writeln;
                end;
}
             if PushCount<>Depth then begin
                if ((Ord(Move.Direction) and POSITION_OPEN_TAG)=0) and
                   (BestForgottenScore=DEAD_END_SCORE) then
                   Dec(BestForgottenScore,PushCount-Depth);
                Dec(Score,PushCount-Depth);
                PushCount:=Depth;
                Solver.SearchStates[PushCount].PlayersReachableSquares.Calculated:=False; {clear the 'player's reachable squares have been calculated' flag for the push}
                end;
             Inc(Depth);

             Temp:=Parent; Parent:=CurrentPosition; CurrentPosition:=Next; Next:=Temp; // pointer reversal so 'Parent' again contains a parent list instead of a forward list
             Inc(SearchStatistics.SetPosition2Count);
             end;
         until Next=nil; // until all pushes on the path leading to 'Position__' have been performed
         end
      else begin // no new moves, but the player must be placed correctly on the board
         if   Position__<>nil then with Position__^ do begin
              MovePlayer(PlayerPos);
              UInt8(Move.Direction):=UInt8(Move.Direction) or POSITION_PATH_TAG; // set 'on current path' tag
              Solver.SearchStates[PushCount].PlayersReachableSquares.Calculated:=False; {initialize 'Calculated' before returning from the function}
              end
         else begin Game.DeadlockSets.PathDeadlockCount:=0; // no pushes: reset the counter
              end;
         CurrentPosition:=Position__; // save new current position
         end;
      end;
  end; // Search.SetPosition

  procedure ShowPath(Position__:PPosition);
  var OldPlayerPos:Integer; p:PPosition;
  begin
    p:=Position__; OldPlayerPos:=Game.PlayerPos;
    while p<>nil do with p^ do begin
      SetPosition(p);
      ShowBoard;
      Write('Depth: ',PushCount,' Score: ',Score,' Hash value: ',Game.HashValue);
      Readln;
      p:=Parent;
      end;
    SetPosition(Position__);
    MovePlayer(OldPlayerPos);
  end; // Search.ShowPath

  procedure ShowBestPosition;
  {$IFDEF CONSOLE_APPLICATION}
    var OldPosition:PPosition;
    begin
      if   Positions.BestPosition<>nil then begin
           OldPosition:=Positions.CurrentPosition;
           SetPosition(Positions.BestPosition);
           ShowBoard;
           if Game.DeadlockSets.PathDeadlockCount>0 then Writeln('Deadlock');
           {Writeln('Positions: ',Positions.Count,' New best position count: ',Positions.SearchStatistics.NewBestPositionCount);}
           Write('Best found position, Pushes: ',Positions.BestPosition^.PushCount,SPACE,Game.HashValue);
           Readln;
           //ShowPath(Positions.BestPosition);
           SetPosition(OldPosition);
           end;
    end; // Search.ShowBestPosition
  {$ELSE}
    begin
    end; // Search.ShowBestPosition
  {$ENDIF}

  function  ConcatenateMovesFromBackwardSearch:Boolean;
  var BoxNo,FileSize,i,Index,PlayerStartPosition:Integer;
      StartPositionReverseMode:Boolean; p:PPosition;
      GraphFileItem:TGraphFileItem;
      ForwardBoxNo:TBoxNumbers;
      BackwardHistory:THistory; BoxStartPositions:TBoxSquares;
  begin {$I-}
    Result:=True;
    if (Positions.SolutionPosition<>nil) and
       (Positions.SolutionPosition^.Score=0) and
       (Positions.StartPosition<>nil) then
       with Positions.SolutionPosition^ do with BackwardHistory do begin
         Result:=False; Count:=0;
         FileSize:=System.FileSize(GraphFile.GraphFile) div SizeOf(GraphFileItem); {file size measured in number of graph file items}
         if   IOResult=0 then p:=Positions.SolutionPosition
         else p:=nil;
         while (p<>nil) do with GraphFile do begin
           Index:=TTIndexOf(p);
           if (Index>=0) and (Index<FileSize) then begin
              Seek(GraphFile,Index*SizeOf(GraphFileItem));
              BlockRead(GraphFile,GraphFileItem,SizeOf(GraphFileItem));
              if (IOResult=0) and (GraphFileItem.Move.BoxNo<>0) then begin      {'BoxNo' is 0 for the root-position}
                 Inc(Count);
                 if Count<=High(Moves) then with Moves[Count] do begin
                    BoxNo:=GraphFileItem.Move.BoxNo;
                    Direction:=TDirection(Ord(GraphFileItem.Move.Direction) and DIRECTION_BIT_MASK);
                    end;
                 p:=GraphFileItem.Parent;
                 end
              else p:=nil;
              end
           else p:=nil;
           end;

         if (Count>0) and (Count<=High(Moves)) then begin
            Result:=True;
            SetPosition(Positions.SolutionPosition); {put forward path on the board}
            //ShowBoard; Write('Concatenation, Forward'); Readln;
            {put goal-position on the board and replay the pulls}
            SetBoard(0,Game.GoalPos,True,PlayerStartPosition,BoxStartPositions,StartPositionReverseMode); {returns current state in the last 3 variables}
            //ShowBoard; Write('Goal'); Readln;
            for Index:=Count downto 1 do with Moves[Index] do {replay pulls}
                DoPull(BoxNo,Direction);
            //ShowBoard; Write('Backwards'); Readln;
            {now backward box-numbers can be mapped to the forward numbers}
            FillChar(ForwardBoxNo,SizeOf(ForwardBoxNo),0);
            for BoxNo:=1 to Game.BoxCount do                                    {map backward box-numbers to numbers used in the forward game}
                for i:=1 to Game.BoxCount do
                    if Game.BoxPos[i]=BoxStartPositions[BoxNo] then begin
                       ForwardBoxNo[i]:=BoxNo; break;
                       end;

            for BoxNo:=1 to Game.BoxCount do                                    {check that forward path and backward path really meet each other}
                if (ForwardBoxNo[BoxNo]=0) or
                   (BoxStartPositions[ForwardBoxNo[BoxNo]]<>Game.BoxPos[BoxNo]) then
                   Result:=False;

            {restore forward game-play mode}
            SetBoard(PlayerStartPosition,BoxStartPositions,StartPositionReverseMode,PlayerStartPosition,BoxStartPositions,StartPositionReverseMode);
            SetPosition(Positions.StartPosition); {reset game}
            //ShowBoard; Write('Start position'); Readln;

            if Result then
               for Index:=1 to Count do begin                                   {now concatenate the moves from the backward search}
                   Inc(Game.History.Count);
                   if Game.History.Count<=High(Game.History.Moves) then begin
                      Game.History.Moves[Game.History.Count].BoxNo    :=ForwardBoxNo[Moves[Index].BoxNo];
                      Game.History.Moves[Game.History.Count].Direction:=OPPOSITE_DIRECTION[Moves[Index].Direction];
                      end;
                   end;
            end;
         end;
    if not Result then Positions.SolutionPosition:=nil;
  end; {Search.ConcatenateMovesFromBackwardSearch} {$I+}

  procedure InitializeProgressCheckPoint(Score__:Integer; ClearLastPushedTimeStamps__ : Boolean);
  begin
    with Solver.ProgressCheckPoint do begin
      PushCountDown:=SOLVER_PROGRESS_CHECK_POINT_INTERVAL;
      if ClearLastPushedTimeStamps__ then begin
         FillChar( BoxTimeStamps, SizeOf( BoxTimeStamps ), 0 );
         BestScore:=High(BestScore);
         end;
      FillChar(PushedBoxes,SizeOf(PushedBoxes),0);
      if Score__<BestScore then begin
         BestScore:=Score__;
         NoProgressCount:=0;
         end;
      Score:=Score__;
      end;
  end; {Search.InitializeProgressCheckPoint}

  {- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - }

  function  BackwardSearch:Integer;
  {precondition: the transposition-table has been initialized before calling 'BackwardSearch'}
  var i,BoxNo,PlayerStartPosition,Square:Integer;
      OriginalCapacity:Cardinal;
      OriginalReuseNodesEnabled:Boolean;
      StartPositionReverseMode:Boolean; Position:PPosition;
      ForwardBoxNo:TBoxNumbers;
      BoxStartPositions:TBoxSquares;
      Visited:TBoardOfBooleans;

    function  Search(Position__:PPosition):Integer; {Search.BackwardSearch.Search}
    {precondition: player's reachable squares have been calculated for this depth, that is, 'Position__^.PushCount'}
    var BoxNo,LastPushedBoxNo,PositionScore,Square,
        SuccessorPushCount,SuccessorScore:Integer;
        Direction:TDirection; SuccessorPosition:PPosition;
    begin {Search.BackwardSearch.Search}
      //ShowBoard; Write('Depth: ',Position__^.PushCount,' Score: ',Position__^.Score,' Lower bound: ',Position__^.LowerBound,' ',Game.SimpleLowerBound,' Positions: ',Positions.Count); Readln;
      Result:=DEAD_END_SCORE;

      if Position__^.PushCount<Solver.SearchLimits.DepthLimit then begin
         Positions.OpenPositions.WorstRover:=nil;

         //Position__^.Score:=DEAD_END_SCORE;
         //PositionScore:=Position__^.PushCount+Game.SimpleLowerBound;
         PositionScore:=Position__^.Score;

         LastPushedBoxNo:=Position__^.Move.BoxNo;

         {check for tunnel pushes}
         with Game do
           {having 'SuccessorPushCount:=...' in both forks of the following}
           {'if'-statement may look strange but the rationale is that since an}
           {'if' cannot be avoided here, then the normal case should at least}
           {'fall through' in order to avoid cpu stalling; therefore, this}
           {assignment has been put into the 'if' so there is something to do}
           {in the normal case}
           if (Board[BoxPos[LastPushedBoxNo]] and DIRECTION_TO_TUNNEL_FLAG[TDirection(Ord(Position__^.Move.Direction) and DIRECTION_BIT_MASK)])=0 then
              SuccessorPushCount:=Succ(Position__^.PushCount)
           else with Solver.SearchStates[Position__^.PushCount].PlayersReachableSquares do begin
             SuccessorPushCount:=Succ(Position__^.PushCount);
             {the box left a tunnel square, and therefore it's unnecessary}
             {to generate moves for the other boxes; see 'CalculateTunnelSquares'}
             {for figures depicting the situation}
             for BoxNo:=1 to BoxCount do Squares[BoxPos[BoxNo]]:=0;             {mark all boxes as not being candidates for expansion in the current position}
             Squares[BoxPos[LastPushedBoxNo]]:=Succ(TimeStamp);                 {mark the last pushed box as the only candidate for expansion in the current position}
             UInt8(Position__^.Move.Direction):=UInt8(Position__^.Move.Direction) or POSITION_REVISIT_TAG; {nodes marked for revisiting are not subject to filters such as the corral pruning found in the forward search}
             {
             if True or (TDirection(Ord(Position__^.Move.Direction) and DIRECTION_BIT_MASK)<>dDown) then begin
                ShowBoard;
                Write(DIRECTION_TO_TEXT[TDirection(Ord(Position__^.Move.Direction) and DIRECTION_BIT_MASK)]);
                Readln;
                end;
             }
             end;

         if   LastPushedBoxNo<>0 then
              BoxNo:=LastPushedBoxNo {starting with the last pushed box helps a little to make solutions look more natural}
         else BoxNo:=1;

         {generate successors}
         while BoxNo<=Game.BoxCount do
           with Solver.SearchStates[Position__^.PushCount].PlayersReachableSquares do begin
             //Game.History.Moves[SuccessorPushCount].BoxNo:=BoxNo;             {update game history}
             Square:=Game.BoxPos[BoxNo];

             if (Squares[Square]>TimeStamp) then begin // generate pulls for this box, i.e., the box is reachable

                for Direction:=Low(Direction) to High(Direction) do
                    if {inline simple checks for legal moves}
                       (Squares[Square+Game.SquareOffsetForward[Direction]]=TimeStamp){'=TimeStamp': the player can reach this square}
                       and
                       ((Game.Board[Square+2*Game.SquareOffsetForward[Direction]] and (BOX+WALL))=0) {'0': the square is not blocked by a wall or another box}
                       //and
                       //{extended checks for legal moves}
                       //IsALegalPush(BoxNo,Direction)
                       then
                       if Solver.PushCount<Solver.SearchLimits.PushCountLimit then begin {limit not exceeded}

                          //Game.History.Moves[SuccessorPushCount].Direction:=Direction; {update game history}

                          DoPull(BoxNo,Direction);                              {do the move, i.e., update the board}

                          SuccessorScore:=SuccessorPushCount+Game.SimpleLowerBound;
{
                          if Game.HashValue=7871191360298861987 then begin
                          //if Game.SimpleLowerBound<=1 then begin
                             ShowBoard;
                             Write('Depth: ',Position__^.PushCount,' Score: ',Position__^.Score,' Lowerbound: ',Game.SimpleLowerBound,' Positions: ',Positions.Count);
                             Readln;
                             end;
}
                          if SuccessorScore>=PositionScore then
                             Inc(Solver.PushCount)                              {update statistics}
                          else begin
                             SuccessorScore:=PositionScore;                     {score := max(score, parent-score)}
                             Inc(Solver.PushCount);                             {update statistics}
                             end;

                          //ShowBoard;
                          //Write('Depth: ',SuccessorPushCount,' Total pushes: ',Solver.PushCount,' Positions: ',Positions.Count, ' Open: ',Positions.OpenPositions.Count);
                          //Readln;

                          if (Solver.PushCount and (ONE_MEBI-1))=0 then begin
                             {$IFDEF CONSOLE_APPLICATION}
                               Write(Reader.LevelCount,': Depth: ',Position__^.PushCount);
                               if SuccessorScore<INFINITY then Write(' Score: ',SuccessorScore);
                               Write(' Pushes: ',Solver.PushCount div ONE_MILLION,' million');
                               if   Positions.SearchStatistics.ReuseCount=0 then
                                    Write(' Positions: ',Positions.Count)
                               else Write(' Reused positions: ',Positions.SearchStatistics.ReuseCount);
                               {Write(' Time: ',(CalculateElapsedTimeMS(Solver.StartTimeMS,GetTimeMS)+500) div 1000);}
                               Writeln;
                            {$ENDIF}

                             TimeCheck;

                             //ShowBoard;
                             //Write('Depth: ',SuccessorPushCount,' Total pushes: ',Solver.PushCount,' Positions: ',Positions.Count, ' Open: ',Positions.OpenPositions.Count);
                             //Readln;
                             end;

                          if SuccessorScore<=Solver.SearchLimits.DepthLimit then begin
                             Solver.SearchStates[SuccessorPushCount].PlayersReachableSquares.Calculated:=False; {the player's reachable squares haven't been calculated yet}
                             //CalculatePlayersReachableSquares(SuccessorPushCount); {find the player's reachable squares}
                             {SuccessorPosition:=nil;}                          {not necessary, 'TTAdd' sets it to 'nil'}
                             {add the successor position to the transposition-table}
                             if TTAdd(Game.HashValue,                           {hash signature for this position}
                                      {Solver.SearchStates[SuccessorPushCount].PlayersReachableSquares.MinPlayerPos,} {normalized (top-left) player position}
                                      Game.PlayerPos,                           {player position; note that this isn't the normalized (top-left) player position}
                                      SuccessorPushCount,                       {pushes = depth}
                                      SuccessorScore,                           {pushes + heuristic estimate}
                                      BoxNo,                                    {moved box}
                                      Direction,                                {box direction}
                                      Position__,                               {parent node}
                                      SuccessorPosition) then begin             {'SuccessorPosition' is the new saved position}

                                if    (SuccessorScore>PositionScore) then begin
                                      if    SuccessorPushCount<=Solver.BackwardSearchDepthLimit then begin {'True': backward search depth-limit not exceeded}
                                            Inc(Positions.SearchStatistics.Enqueue1Count);
                                            OPENAdd(SuccessorPosition);         {put the position on the open-queue}
                                            end;
                                      end
                                else  if SuccessorPosition<>Positions.StartPosition then
                                         with SuccessorPosition^ do with ScoreBucket do begin
                                           {the successor is just as promising as}
                                           {its parent-node, hence, it belongs at}
                                           {the front of the open-queue; therefore}
                                           {it's better to recurse immidiately,}
                                           {exploiting that the game state already}
                                           {is correct for this position}
                                           if    SuccessorPushCount<=Solver.BackwardSearchDepthLimit then begin {'True': backward search depth-limit not exceeded}
                                                 Inc(Positions.SearchStatistics.Enqueue2Count);
                                                 if not Solver.SearchStates[SuccessorPushCount].PlayersReachableSquares.Calculated then {'True': 'TTAdd' didn't trigger the calculation; do it now}
                                                    CalculatePlayersReachableSquares(SuccessorPushCount); {find the player's reachable squares}
                                                 Score:=Search(SuccessorPosition);
                                                 SuccessorScore:=Score;
                                                 end;
                                           end
                                      else begin                                {a solution}
                                         Positions.SolutionPosition:=SuccessorPosition;
                                         TerminateSearch;
                                         Positions.OpenPositions.Count:=0;      {'0': signals an exhaustive search, i.e., an optimal solution}
                                         end;
                                end
                             else                                               {the position wasn't added to the transposition-table}
                                if   SuccessorPosition<>nil then                {'True': the position already exists in the transposition-table}
                                     if SuccessorPosition<>Positions.StartPosition then begin {'True': not a solution}
                                        SuccessorScore:=SuccessorPosition^.Score; {the saved score may be a backup value, hence, retrieve the actually saved score for the position}
                                        end
                                     else with SuccessorPosition^ do begin      {start-position = goal-position}
                                        {modify the start position node so it contains this last move leading to the solution}
                                        PushCount        :=SuccessorPushCount;
                                        Score            :=SuccessorPushCount;
                                        Parent           :=Position__;          {handle with care: the solution is now a circular list}
                                        Move.BoxNo       :=BoxNo;
                                        Move.Direction   :=Direction;
                                        Positions.SolutionPosition:=SuccessorPosition;
                                        TerminateSearch;
                                        Positions.OpenPositions.Count:=0;       {'0': signals an exhaustive search, i.e., an optimal solution}
                                        end
                                else                                            {the transposition-table is full}
                                   if Solver.ReuseNodesEnabled then begin
                                      if SuccessorScore<Position__^.BestForgottenScore then
                                         Position__^.BestForgottenScore:=SuccessorScore; {the successor-position wasn't stored, i.e., its score wasn't better than the current worst score; remember the best forgotten score}
                                      end
                                   else TerminateSearch;                        {stop searching when the transposition-table is full}
                             end
                          else begin                                            {search depth limit exceeded}
                             if (Solver.SearchLimits.DepthLimit>=0) and         {'>=0': the search hasn't been terminated}
                                (SuccessorScore>OriginalSearchLimits.DepthLimit) and {'>': 'Solver.SearchStates.DepthLimit' may have been lowered after finding a solution}
                                (SuccessorScore<INFINITY) then                  {'<INFINITY': it's a legal pull, i.e., the box isn't on simple deadlocked square from which it's impossible to reach a start position}
                                Inc(Solver.LimitExceededPushCount);
                            end;

                          if SuccessorScore<Result then Result:=SuccessorScore;

                          UndoPull(BoxNo,Direction);                            {take back the move, i.e., update the board}
                          end
                       else begin                                               {push count limit exceeded}
                          if Solver.SearchLimits.DepthLimit>=0 then             {'>=0': the search hasn't been terminated}
                             Inc(Solver.LimitExceededPushCount);
                          end;
                end;

             if   BoxNo<>LastPushedBoxNo then Inc(BoxNo)
             else BoxNo:=1;                                                     {first time through the loop}
             if   BoxNo= LastPushedBoxNo then Inc(BoxNo);                       {skip last pushed box when seeing it for the second time}
             end;

         with Position__^ do begin
           if (BestForgottenScore<DEAD_END_SCORE) and
              (SuccessorCount=0) then begin
              {'Position__' had successors but none of them were saved}
              {in the transpostion table;}
              {put 'Position__' back on the open-queue}
              if Position__=Positions.CurrentPosition then
                 if   Parent<>nil then SetPosition(Parent)
                 else Positions.CurrentPosition:=nil;
              Score:=BestForgottenScore;
//            BestForgottenScore:=DEAD_END_SCORE;
              if PushCount<=Solver.SearchLimits.DepthLimit then OPENAdd(Position__);
              Result:=Position__^.Score;
              end;
           end;

         end
      else begin                                                                {depth limit exceeded}
         end;

      Position__^.Score:=Result;
    end; {Search.BackwardSearch.Search}

  begin {Search.BackwardSearch}
    Result:=INFINITY;
    {$IFDEF PLUGIN_MODULE}
      SetSokobanStatusText(TEXT_BACKWARD_SEARCH+SPACE+LEFT_PAREN+IntToStr(Positions.MemoryByteSize div ONE_MEBI)+SPACE+TEXT_MEBI_BYTES+RIGHT_PAREN);
    {$ENDIF}
    StartPositionReverseMode:=Game.ReverseMode; Game.ReverseMode:=True; Game.Rooms.Count:=Abs(Game.Rooms.Count);

    if Game.TubeFillingPushCount+Game.SimpleLowerBound<=Solver.SearchLimits.DepthLimit then begin {'True': the level might be solvable with this search depth limit}
       OriginalCapacity := Positions.Capacity;                                  {remember the total transposition table capacity}
       if (Solver.SearchLimits.TimeLimitMS<High(Solver.SearchLimits.TimeLimitMS)) {'True': the search time is limited}
          and
          (Solver.SearchMethod<>smBackward) then begin                          {'True': the backward search isn't the only requested search; a forward search will follow if the the backward search doesn't find a solution}
          {when the search time is limited, it's necessary to take into account
           that it can be a time-consuming task to save the entire game graph to
           disk after the backward search; to ensure that there still is time to
           perform a forward search, there is a built-in transposition table
           size limit for the backward search;}
          Positions.Capacity := Min( Integer(Positions.Capacity), MAX_BACKWARD_SEARCH_POSITIONS );
          Positions.UninitializedItemCount := Integer( Positions.Capacity );
          end;

       {enqueue start-position (for a normal forward game)}
       CalculatePlayersReachableSquares(0);                                     {find normalized (top-left) player-position}
       if TTAdd(Game.HashValue,                                                 {hash signature for this position}
                Solver.SearchStates[0].PlayersReachableSquares.MinPlayerPos,    {normalized player position}
                DEAD_END_SCORE,                                                 {pushes; the high value allows 'TTAdd' to find a cheaper path to an existing node}
                DEAD_END_SCORE-1,                                               {score; subtract 1 from 'DEAD_END_SCORE' to allow the program to find a cheaper path to this position}
                0,                                                              {moved box (none in this case)}
                dUp,                                                            {box direction}
                nil,                                                            {parent node}
                Positions.StartPosition) then                                   {'StartPosition': the created position}
                with Positions do with StartPosition^.ScoreBucket do begin
                  Prev:=nil; Next:=nil;                                         {mark the position as not being a member of the open-queue}
                  end;

       CalculateDistanceToNearestBoxStartPositionForAllSquares(1,Game.BoxCount,False,Game.DistanceToNearestBoxStartPosition);
       //ShowBoxDistanceToAllSquares(Game.DistanceToNearestBoxStartPosition); Readln;

       CalculateTunnelSquares;
       {ShowTunnelSquares; Readln;}

       Game.ReverseMode:=StartPositionReverseMode; {restore reverse mode before the caller's game state really is saved}
       SetBoard(0,Game.GoalPos,True,PlayerStartPosition,BoxStartPositions,StartPositionReverseMode); {returns current state in the last 3 variables}

       OPENClear; {clear open-queue}
       OriginalReuseNodesEnabled:=Solver.ReuseNodesEnabled;
       if Solver.SearchMethod=smPerimeter then Solver.ReuseNodesEnabled:=False;
       Positions.CurrentPosition:=nil;
       //Solver.HighestSearchDepth:=0;

       //ShowBoard; Readln;

       {enqueue start-positions (with boxes on goal-squares), 1 start-position for each player access area}
       FillChar(Visited,SizeOf(Visited),0);
       for Square:=0 to Game.BoardSize do with Game do
           if ((Board[Square] and (WALL+BOX+FLOOR))=FLOOR) and                  {'True': an empty floor-square}
              (not Visited[Square]) then begin
              MovePlayer(Square);
              CalculatePlayersReachableSquares(0);
              for i:=Low(Game.Board) to High(Game.Board) do
                  with Solver.SearchStates[0].PlayersReachableSquares do
                    if Squares[i]=TimeStamp then Visited[i]:=True;              {mark all squares in this access area as visited}

              if (Game.TubeFillingPushCount+Game.SimpleLowerBound<=Solver.SearchLimits.DepthLimit) or
                 (Solver.SearchMethod=smPerimeter) then
                 if TTAdd(Game.HashValue,                                       {hash signature for this position}
                          Solver.SearchStates[0].PlayersReachableSquares.MinPlayerPos, {normalized player position}
                          0,                                                    {pushes = depth}
                          Min(0+Game.SimpleLowerBound,                          {0 pushes + heuristic estimate}
                              Solver.SearchLimits.DepthLimit),
                          0,                                                    {moved box (none in this case)}
                          dUp,                                                  {box direction}
                          nil,                                                  {parent node}
                          Position) then begin                                  {'Position': the created position}
                    OPENAdd(Position);
                    Inc(UInt8(Position^.Move.Direction),POSITION_PATH_TAG);
                    end
                 else begin
                    TerminateSearch;
                    Msg(TEXT_MEMORY_FULL,TEXT_APPLICATION_TITLE);
                    end;
              end;

       {the central loop; repeatedly expand the (deepest) least-cost position on the open-queue}
       while OPENRemoveNextPositionSelectedForExpansion(Position) do begin
         SetPosition(Position); {update the board so it matches this position}
         {ShowBoard; Write('Depth: ',Position^.PushCount); Readln;}
         CalculatePlayersReachableSquares(Position^.PushCount);                 {find the player's reachable squares; a precondition for 'Search'}
         Search(Position);
         end;

       if Positions.SolutionPosition<>nil then with Positions do begin
          SetPosition(SolutionPosition);

          for BoxNo:=1 to Game.BoxCount do                                      {map backward box-numbers to numbers used in the forward game}
              for i:=1 to Game.BoxCount do
                  if Game.BoxPos[i]=BoxStartPositions[BoxNo] then begin
                     ForwardBoxNo[i]:=BoxNo; break;
                     end;

          Result:=Game.TubeFillingPushCount+SolutionPosition^.PushCount;
          //FillChar(Game.History,SizeOf(Game.History),0);
          Game.History.Count:=Result;
          Position:=SolutionPosition; StartPosition:=nil;
          repeat with Game.History.Moves[1+Result-Position^.PushCount] do begin
                   BoxNo    :=ForwardBoxNo      [Position^.Move.BoxNo];
                   Direction:=OPPOSITE_DIRECTION[TDirection(Ord(Position^.Move.Direction) and DIRECTION_BIT_MASK)]; {reverse move direction}
                   end;
                 StartPosition:=Position;
                 Position:=Position^.Parent;
          until  (Position^.Parent=nil) or
                 (Position^.PushCount>=StartPosition^.PushCount)                {'>=': the positions form a circular list in case start-position = goal-position}
          end
       else
          if Positions.StartPosition<>nil then TTRemove(Positions.StartPosition);

       {restore game start-position and forward game-play mode}
       SetBoard(PlayerStartPosition,BoxStartPositions,StartPositionReverseMode,PlayerStartPosition,BoxStartPositions,StartPositionReverseMode);
       Solver.ReuseNodesEnabled:=OriginalReuseNodesEnabled;                     {restore 'reuse nodes'}
       //ShowBoard; Readln;

       {restore the maximum transposition table capacity in case the backward search was running with a smaller table}
       Inc( Positions.UninitializedItemCount, Integer( OriginalCapacity - Positions.Capacity ) );
       Positions.Capacity := OriginalCapacity;
       end;
  end; {Search.BackwardSearch}

  {- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - }

  function  ForwardSearch:Integer;
  {precondition: the transposition-table has been initialized before calling 'ForwardSearch'}
  var Position:PPosition;
      {$IFDEF PLUGIN_MODULE}
        s:String;
      {$ENDIF}

    procedure LogDeadlockSetStatistics;
    var i:Integer; s:String; Totals:array[Boolean] of Cardinal;
    begin
      if LogFile.Enabled then begin
         FillChar(Totals,SizeOf(Totals),0);
         s:='';
         for i:=1 to 48 do s:=s+HYPHEN;

         WritelnToLogFile('');
         WritelnToLogFile('Deadlock set statistics - blocked pushes');
         for i:=1 to Game.DeadlockSets.Count do begin
             WritelnToLogFile(IntToStr(i)+COLON+SPACE+IntToStr(Game.DeadlockSets.Statistics[i]));
             Totals[i<=Game.DeadlockSets.PrecalculatedSetsCount]:=Totals[i<=Game.DeadlockSets.PrecalculatedSetsCount]+Game.DeadlockSets.Statistics[i]; {'i<=...': it's a precalculated deadlock set}
             if (i=Game.DeadlockSets.PrecalculatedSetsCount) and
                (Game.DeadlockSets.PrecalculatedSetsCount<Game.DeadlockSets.Count) then
                WritelnToLogFile(Copy(s,1,4));
             end;

         WritelnToLogFile(s);
         WritelnToLogFile('Total - precalculated sets: '+IntToStr(Totals[True])+SPACE+TEXT_PUSHES);
         WritelnToLogFile('Total - dynamic sets: '+IntToStr(Totals[False])+SPACE+TEXT_PUSHES);
         WritelnToLogFile('Total: '+IntToStr(Totals[False]+Totals[True])+SPACE+TEXT_PUSHES);
         WritelnToLogFile(s);
         WritelnToLogFile('');
         end;
    end; {Search.ForwardSearch.LogDeadlockSetStatistics}

    function  Search(Position__:PPosition):Integer; {Search.ForwardSearch.Search}
    {precondition: the player's reachable squares have been calculated for this depth, i.e., 'Position__^.PushCount'}
    type
      PCorral                = ^TCorral;
      TCorral                = record
        HashValue            : THashValue;
        IsANewCorral         : Boolean;
        IsANotStoredDeadlock : Boolean;
        BoxSquares           : TBoxSquareSet;
        MinPlayerPos         : Integer;
        NextCorral           : PCorral; {linked list of neighboring corrals}
      end;

    var
      BoxNo,CorralBoxCount,Distance,GoalNo,i,Index,j,k,LastPushedBoxNo,
      NeighborSquare,OldPushCount,PositionScore,FreezePenalty,
      RoomNo,RoomPruningBoxCount,
      Square,SuccessorBoxPos,SuccessorPushCount,SuccessorScore,Col,Row:Integer;
      OldPositionCount:Cardinal;
      LowWaterBoxTimeStamp,OldTimeStamp:TTimeStamp;
      HasAllBoxesOnGoals,IsACombinedCorral:Boolean; Direction:TDirection;
      SuccessorPosition:PPosition;
      CorralMinPlayerPos:TBoxSquareSet;
//    PrunedBoxSet:TBoxSet;
//    PositionHashValue:THashValue;
//    SortedBoxSquares:array[TBoxNo] of UInt16; // for test only; it will overflow the stack if it's left in the production version}

      procedure UpdateBestSolution(Position__:PPosition);
      begin {Search.ForwardSearch.Search.UpdateBestSolution}
        if (Positions.SolutionPosition=nil) or                                  {'nil': 'Position__' is the first found solution}
           (Position__^.PushCount<Positions.SolutionPosition^.PushCount) then begin {'<': this is a new best solution}
           Positions.SolutionPosition:=Position__;
           if      (Positions.OpenPositions.MinValue>=Pred(Position__^.PushCount)) then begin {'True': there are no open positions with a chance of leading to a better solution}
                   TerminateSearch;
                   Positions.OpenPositions.Count:=0;                            {'0': signals an exhaustive search, i.e., an optimal solution}
                   end
           else if (Solver.PackingOrder.SetCount>0)                             {'True': packing order search doesn't search for optimal solutions, hence, stop as soon as a solution has been found}
                   or
                   Solver.StopWhenSolved then begin
                   TerminateSearch;
                   end
                else begin
                   Solver.SearchLimits.DepthLimit:=Position__^.PushCount;
                   Solver.SokobanStatusPointer^.Flags:=SOKOBAN_PLUGIN_FLAG_SOLUTION;
                   SetSokobanStatusText(TEXT_SOLUTION_INFO_1+IntToStr(Position__^.PushCount)+TEXT_SOLUTION_INFO_2);
                   OPENDropPositions(Solver.SearchLimits.DepthLimit);           {prune the open-queue and the transpostion-table; there is no need to search paths longer than or equal to the best found solution}
                   end;
           if not CheckDeadlockSetCapacities then begin                         {use the solution position for a sanity check of the deadlock set capacity calculation}
              Msg(TEXT_INTERNAL_ERROR+': Wrong deadlock set capacity calculation.',TEXT_APPLICATION_TITLE);
              end;
           end;
      end; {Search.ForwardSearch.Search.UpdateBestSolution}

      function  CalculateCorralSquares(InnerFloorSquare__:Integer; var HasAllBoxesOnGoals__:Boolean; var Corral__:TCorral):Integer; {caution: assumes 4 directions only}
      var {Index,}BoardSquareValue,Square,NeighborSquare,NeighborSquare2:Integer;
          Direction:TDirection;
          BoxSquaresTop,StackTop:^Integer; Stack:array[0..MAX_BOARD_SIZE] of Integer; {caution: 'BoxSquaresTop' relies on 'TBoxSquareSet.BoxSquares' being a zero-based vector of integers where element 0 is unused}
      begin {Returns the inner floor squares in the global value 'Solver.SearchStates[SEARCH_STATE_INDEX_CORRAL_PRUNING].PlayersReachableSquares'}
        with Solver.SearchStates[SEARCH_STATE_INDEX_CORRAL_PRUNING].PlayersReachableSquares do begin
          if TimeStamp>=PLAYERS_REACHABLE_SQUARES_TIMESTAMP_UPPER_BOUND then
             ClearPlayersReachableSquares(SEARCH_STATE_INDEX_CORRAL_PRUNING);
          Inc(TimeStamp,2); {reachable empty floors = timestamp; reachable boxes = timestamp + 1}

          Result:=0; Calculated:=True; MinPlayerPos:=InnerFloorSquare__;
          Corral__.HashValue:=0;
          BoxSquaresTop:=Addr(Corral__.BoxSquares.Squares); //Corral.BoxSquares.Count:=0;

          if InnerFloorSquare__<>0 then begin
             Result:=1; StackTop:=Addr(Stack[1]); StackTop^:=InnerFloorSquare__;
             Squares[InnerFloorSquare__]:=TimeStamp;
             while StackTop<>Addr(Stack[0]) do begin
               {using a stack makes the program run at least 10% faster than}
               {a version using a more elegant recursive implementation}
               Square:=StackTop^; Dec(StackTop); {get next square from the stack}
               for Direction:=Low(Direction) to High(Direction) do begin {examine neighbors to this square}
                   NeighborSquare:=Square+Game.SquareOffsetForward[Direction];
                   if //(Board[NeighborSquare] and (WALL)=0) and {check for walls and visited squares}
                      //(Squares[NeighborSquare]<>TimeStamp) then
                      Squares[NeighborSquare]<TimeStamp then begin {'True': an unvisited floor, possibly with a box (walls contain high-value)}
                      BoardSquareValue:=Game.Board[NeighborSquare];
                      if (BoardSquareValue and BOX)=0 then begin {not a box}
                         Inc(Result); Inc(StackTop); StackTop^:=NeighborSquare;
                         Squares[NeighborSquare]:=TimeStamp;
                         if  NeighborSquare<MinPlayerPos   then MinPlayerPos:=NeighborSquare; {update the normalized (top-left) player position}
                         if (BoardSquareValue and GOAL)<>0 then HasAllBoxesOnGoals__:=False;  {if there are inner goal squares, not occupied by boxes, then the corral needs to be opened at some time}
                         end
                      else begin {a neighbor box}
                         Squares[NeighborSquare]:=Succ(TimeStamp);
                         Corral__.HashValue:=Corral__.HashValue xor Positions.SquareHashValues[NeighborSquare];
                         //Inc(BoxSquares.Count);
                         //BoxSquares.BoxSquares[BoxSquares.Count]:=NeighborSquare;
                         Inc(BoxSquaresTop); BoxSquaresTop^:=NeighborSquare; {use pointer addressing to collect the box squares in the hope that it's slightly faster than array indexing}

                         NeighborSquare2:=NeighborSquare+Game.SquareOffsetForward[Direction]; {the next square after the neighbor square in this direction}
                         if ((Game    .Board[NeighborSquare2] and BOX)<>0) and
                            (Squares        [NeighborSquare2]<TimeStamp) then begin
                            if (((Game.Board[NeighborSquare2+Game.SquareOffsetLeft  [Direction]] and WALL)<>0) and
                                ((Game.Board[NeighborSquare +Game.SquareOffsetLeft  [Direction]] and (WALL+BOX))=0) and
                                ((Game.Board[        Square +Game.SquareOffsetLeft  [Direction]] and (WALL+BOX))=0)
                               { $$< the right-most box has just been added to the corral; the direction is <--; the left-most box is added too because it may contribute to close the fence around the corral}
                               { #-- "-": empty floor squares}
                               )
                               or
                               (((Game.Board[NeighborSquare2+Game.SquareOffsetRight [Direction]] and WALL)<>0) and
                               ((Game .Board[NeighborSquare +Game.SquareOffsetRight [Direction]] and (WALL+BOX))=0) and
                               ((Game .Board[        Square +Game.SquareOffsetRight [Direction]] and (WALL+BOX))=0)
                               { >$$ the left-most box has just been added to the corral; the direction is -->; the right-most box is added too because it may contribute to close the fence around the corral}
                               { --# "-": empty floor squares}
                               ) then begin
                               Squares[NeighborSquare2]:=Succ(TimeStamp);
                               Corral__.HashValue:=Corral__.HashValue xor Positions.SquareHashValues[NeighborSquare2];
                               Inc(BoxSquaresTop); BoxSquaresTop^:=NeighborSquare2;
                               end;
                            end;

                         Inc(NeighborSquare,Game.SquareOffsetLeft[Direction]);  {caution: assumes 4 directions only}
                         if ((Game.Board[NeighborSquare] and BOX)<>0) and
                            (Squares[NeighborSquare]<TimeStamp) and
                            ((Game.Board[Square+Game.SquareOffsetLeft[Direction]] and (WALL+BOX))<>0) then begin
                            { $<  this box has just been added to the corral; the direction is <--}
                            { $#  this outer box is added too because it may contribute to close the fence around the corral; the square depicted by a wall may either be a wall or a box - the only requirement is that it's a non-empty square}
                            Squares[NeighborSquare]:=Succ(TimeStamp);
                            Corral__.HashValue:=Corral__.HashValue xor Positions.SquareHashValues[NeighborSquare];
                            Inc(BoxSquaresTop); BoxSquaresTop^:=NeighborSquare;
                            end;

                         Inc(NeighborSquare,2*Game.SquareOffsetRight[Direction]); {caution: assumes 4 directions only}
                         if ((Game.Board[NeighborSquare] and BOX)<>0) and
                            (Squares[NeighborSquare]<TimeStamp) and
                            ((Game.Board[Square+Game.SquareOffsetRight[Direction]] and (WALL+BOX))<>0) then begin
                            { >$  this box has just been added to the corral; the direction is -->}
                            { #$  this outer box is added too because it may contribute to close the fence around the corral; the square depicted by a wall may either be a wall or a box - it just have to be a blocked square}
                            Squares[NeighborSquare]:=Succ(TimeStamp);
                            Corral__.HashValue:=Corral__.HashValue xor Positions.SquareHashValues[NeighborSquare];
                            Inc(BoxSquaresTop); BoxSquaresTop^:=NeighborSquare;
                            end;
                         end;
                      end;
                   end;
               end;
             end;

          {calculate the number of boxes belonging to the corral; 'BoxSquareTop' points to the last added box square}
          Corral__.BoxSquares.Count:=(Cardinal(BoxSquaresTop)-Cardinal(Addr(Corral__.BoxSquares.Squares))) div SizeOf(TBoxSquare); {vector element 0 is not used}
          Corral__.MinPlayerPos    :=MinPlayerPos; {return the normalized top-left player position}
          Corral__.IsANewCorral    :=False; {initialize the 'is a new corral?' flag}
          end;
      end; {Search.ForwardSearch.Search.CalculateCorralSquares}

      function  CalculateCorralDeadlockStatus(GamePosition__,CorralPosition__:PPosition; var DeadlockSetCandidate__:TDeadlockSetCandidate):Boolean;
//    var OriginalFloorCount:Integer;
      begin {precondition: 'DeadlockSetCandidate__' contains the deadlock candidate}
//      OriginalFloorCount                          :=DeadlockSetCandidate__.Floors.Count;
        DeadlockSetCandidate__.MaxBoxCount          :=DeadlockSetCandidate__.Boxes.Count;
        DeadlockSetCandidate__.EscapedBoxesCountDown:=DeadlockSetCandidate__.Boxes.Count; {all boxes must escape the fenced-in area; otherwise it's a deadlock}
        DeadlockSetCandidate__.GoalCount            :=0; {the number of goals is recalculated from scratch by 'CalculateDeadlockSets' when the candidate has a center square, but even so, the number must be initialized with a proper value}

        //Write(Game.DeadlockSets.Count,SPACE,Positions.SearchStatistics.CalculateCorralDeadlockStatusCount,'...');

        Result:=CalculateDeadlockSets(GamePosition__,DeadlockSetCandidate__);

        //Writeln(Game.DeadlockSets.Count);

        with CorralPosition__^.Move do begin
          {Direction:=TDirection(Cardinal(Ord(Direction)) or POSITION_VISITED_TAG);}
          if   Result then
               Direction:=TDirection(Cardinal(Ord(Direction)) or POSITION_DEADLOCK_TAG)
          else {the corral could not be proved to be a deadlock at creation}
               {time; the search may later hit a dead end with this corral on}
               {the board; at that time it's tested once again if the corral}
               {now is a deadlock (new deadlock sets can help finding a proof);}
               {to that end, the 'open' tag is added here to signal that the}
               {second attempt hasn't been performed yet}
               Direction:=TDirection(Cardinal(Ord(Direction)) or POSITION_OPEN_TAG);
          end;

        Inc(Positions.SearchStatistics.CalculateCorralDeadlockStatusCount);

        {$IFDEF CONSOLE_APPLICATION}
          if (Positions.SearchStatistics.CalculateCorralDeadlockStatusCount and (ONE_KIBI-1))=0 then begin
             Write(Reader.LevelCount,': Depth: ',GamePosition__^.PushCount);
             if GamePosition__^.Score<DEAD_END_SCORE then Write(' Score: ',GamePosition__^.Score);
             Write(' Pushes: ');
             if   Solver.PushCount>=ONE_MILLION then
                  Write(Solver.PushCount div ONE_MILLION,' million')
             else Write(Solver.PushCount);
             if   Positions.SearchStatistics.ReuseCount=0 then
                  Write(' Positions: ',Positions.Count)
             else Write(' Reused positions: ',Positions.SearchStatistics.ReuseCount);
             {Write(' Time: ',(CalculateElapsedTimeMS(Solver.StartTimeMS,GetTimeMS)+500) div 1000);}
             Writeln;
             end;
        {$ENDIF}

        TimeCheck; {calculating deadlock sets can be a time-consuming operation; call the time check frequently}

        if Game.SimpleLowerBound>=INFINITY then
           Msg(TEXT_INTERNAL_ERROR,'CalculateCorralDeadlockStatus');

{
        ShowBoard;
        Write('Corral boxes: ');
        for i:=1 to DeadlockSetCandidate__.Boxes.Count do
            Write(DeadlockSetCandidate__.Boxes.Squares[i],SPACE);
        Write('Deadlock? ',TEXT_NO_YES[Result],'  Pushes: ',Solver.PushCount);
        Readln;
}
{
        if Result then begin
           Game.ShowDeadlockSetsEnabled:=True;
           ShowDeadlockSet(Game.DeadlockSets.Count,Game.DeadlockSets.CenterSquare[Game.DeadlockSets.Count]);
           Game.ShowDeadlockSetsEnabled:=False;
           //ShowBoard;
           if   OriginalFloorCount=0 then
                Write('New single-room deadlock ')
           else Write('New hindsight deadlock ');
           Write(Game.DeadlockSets.Count,'; Positions: ',Positions.Count,' Pushes: ',Solver.PushCount,'  ',Position__^.HashValue);
           Readln;
           //Writeln;
           end;
}
      end; {Search.ForwardSearch.Search.CalculateCorralDeadlockStatus}

      function  TTAddNoPushesDeadlock(GamePosition__,CorralDeadlockPosition__:PPosition; IsACorralDeadLock__:Boolean; var NoPushesDeadlockPosition__:PPosition):Boolean;
      var BoxNo,Square,SuccessorPushCount:Integer;
          OldControllerAndFreezeSetPairsEnabled:Boolean;
          BoxSquares:TBoxSquares;
          Direction:TDirection;
          DeadlockSetCandidate:TDeadlockSetCandidate;
          OldHashValue:THashValue;

        function  CanABoxBePushed(SuccessorPushCount__:Integer):Boolean;
        var BoxNo,NeighborSquare,Square:Integer; Direction:TDirection;
        begin {preconditions:
                 1. the player's reachable squares have been calculated using index 'MAX_HISTORY_BOX_MOVES';
                 2. the player's reachable squares for search depth 'SuccessorPushCount__' are free to use;
              }
          Result:=False;
          with Game do with Solver.SearchStates[MAX_HISTORY_BOX_MOVES].PlayersReachableSquares do
            for BoxNo:=1 to Game.BoxCount do
                if   (not Result) then begin {'True': no legal pushes have been found yet}
                     Square:=BoxPos[BoxNo];
                     if (Square>0) and {'True': it's one of the candidate boxes (e.g., corral boxes) and it hasn't been removed from the board yet}
                        (Squares[Square]=Succ(TimeStamp)) then begin {'True': the player can reach the box}
                        for Direction:=Low(Direction) to High(Direction) do
                            if   (not Result) then begin
                                 NeighborSquare:=Square+Game.SquareOffsetForward[Direction];
                                 if {inline simple checks for legal moves}
                                    (Squares[Square-Game.SquareOffsetForward[Direction]]=TimeStamp){'True': the player can reach the neighbor-square}
                                    and
                                    ((Game.Board[NeighborSquare] and (BOX+WALL+FLAG_ILLEGAL_BOX_SQUARE))=0) {'True': the square is legal and not blocked by a wall or another box}
                                    and
                                    {extended checks for legal moves}
                                    IsALegalPush(BoxNo,Direction,SuccessorPushCount__) then begin {'True': this box can be pushed in this direction}
                                    Result:=True; {'True': box 'BoxNo' can be pushed}
                                    end
                                 end
                            else break; {quick-and-dirty exit 'for each direction' loop}
                        end;
                     end
                else break; {quick-and-dirty exit 'for each box number' loop}
        end; {Search.ForwardSearch.Search.TTAddNoPushesDeadlock.CanABoxBePushed}

      begin {'TTAddNoPushesDeadlock' tries to add a deadlock set based upon a game state having no legal pushes}
            {preconditions:
             1. the game position is a deadlock, i.e., there are no legal pushes in the currect game position;
             2. the player's reachable squares have been calculated for the current game state
                and are available in the global 'Solver.SearchStates[GamePosition__^.PushCount].PlayersReachableSquares' vector;
                furthermore, boxes which aren't candidates (e.g., not members of a corral) have 'zero' in their slot in that vector;
             3. the player's reachable squares for index 'MAX_HISTORY_BOX_MOVES' in 'Solver.SearchStates[]' are free to use;
            }
        NoPushesDeadlockPosition__:=nil; //Result:=False; exit;
        SuccessorPushCount:=Succ(GamePosition__^.PushCount);
        Inc(Positions.SearchStatistics.NoPushDeadEndsCount);

        if SuccessorPushCount<MAX_HISTORY_BOX_MOVES then with Game do begin {'<': 'Solver.SearchStates[MAX_HISTORY_BOX_MOVES]' is used by this function}
           OldControllerAndFreezeSetPairsEnabled:=DeadlockSets.ControllerAndFreezeSetPairsEnabled;
           DeadlockSets.ControllerAndFreezeSetPairsEnabled:=False;
           {
            remove boxes which aren't expected to contribute to the
            'no legal pushes' condition for the current game state;

            for a corral ('CorralDeadlockPosition__' <> nil) this is the
            boxes outside the corral;

            for other deadlocks, ('CorralDeadlockPosition__' = nil) the caller
            has marked the boxes to remove by putting '0' into their
            'reachable squares' slot in the vector;
            currently, the function is only called this way with frozen boxes
            marked for removal;
           }
           for BoxNo:=1 to BoxCount do with Solver.SearchStates[GamePosition__^.PushCount].PlayersReachableSquares do begin
               Square:=BoxPos[BoxNo];
               BoxSquares[BoxNo]:=Square; {remember the box positions}
               if Squares[Square]=0 then {'True': the box doesn't belong to the box candidates (or it's an interior corral square which hasn't been reachable yet for this search depth; either way, it's ok to try to remove it here)}
                  RemoveBoxFromBoard(BoxNo);
               end;

           {calculate the player's reachable squares with only the candidate boxes on the board}
           CalculatePlayersReachableSquares(MAX_HISTORY_BOX_MOVES);

           Result:=IsACorralDeadlock__ {'True': it's a corral-type deadlock candidate; continue the calculation by trying to remove interior corral boxes}
                   or
                   (not CanABoxBePushed(SuccessorPushCount)); {'True': for this non-corral candidate, none of the boxes can be pushed; continue the calculation by trying to remove more of the box candidates}

           if  Result then begin {'True': continue the calculation}
               if  IsACorralDeadlock__ then Result:=False; {for a corral-type candidate, require that at least one interior box can be removed; otherwise the new candidate doesn't differ from the existing corral}
               for BoxNo:=1 to BoxCount do with Solver.SearchStates[MAX_HISTORY_BOX_MOVES].PlayersReachableSquares do begin
                   Square:=BoxPos[BoxNo];
                   if Square<>0 then begin {'True': the box belongs to the candidate set (e.g., the corral)}
                      if   Squares[Square]<TimeStamp then begin {'True': the player cannot reach the box (e.g., it's an interior corral box)}
                           RemoveBoxFromBoard(BoxNo);
                           if   CanABoxBePushed(SuccessorPushCount) then {'True': the box couldn't be removed without breaking the 'no legal pushes' condition for the current game state}
                                PutBoxOnBoard(BoxNo,BoxSquares[BoxNo]) {put the box back on the board}
                           else Result:=True; {'True': the box 'BoxNo' can be removed without breaking the 'no legal pushes' condition}
                           end
                      else {the player can reach the box}
                           if (not IsACorralDeadlock__) then begin {the boxes don't necessarily form a corral; try to remove the box even though the player can reach it}
                              RemoveBoxFromBoard(BoxNo);
                              CalculatePlayersReachableSquares(MAX_HISTORY_BOX_MOVES); {calculate the player's reachable squares now that the box has been removed from the board}
                              if   CanABoxBePushed(SuccessorPushCount) then begin {'True': the box couldn't be removed without breaking the 'no legal pushes' condition for the current game state}
                                   PutBoxOnBoard(BoxNo,BoxSquares[BoxNo]); {put the box back on the board}
                                   CalculatePlayersReachableSquares(MAX_HISTORY_BOX_MOVES); {recalculate the player's reachable squares now that the box is back on the board}
                                   end
                              else Result:=True; {'True': the box 'BoxNo' can be removed without breaking the 'no legal pushes' condition}
                              end;
                      end;
                   end;
               end;

           if  Result {'True': some boxes (e.g., interior corral boxes) have been removed, or it's a non-corral candidate where none of the boxes can be pushed}
               and
               (SimpleLowerBound<>0) then begin {'True': at least one remaining candidate box isn't located at a goal square}
{
               if Game.HashValue=7025532974808831662 then begin
                  ShowBoard;
                  end;
}
               if TTAdd(Game.HashValue,
                        Solver.SearchStates[MAX_HISTORY_BOX_MOVES].PlayersReachableSquares.MinPlayerPos+MAX_BOARD_SIZE,
                        0,DEADLOCK_SCORE,0,dUp,nil,NoPushesDeadlockPosition__) {'True': this is a new corral and now it has been added to the transposition table}
                  or
                  ((NoPushesDeadlockPosition__<>nil) {'True': the candidate has been saved in the transposition table earlier}
                   and
                   ((Ord(NoPushesDeadlockPosition__^.Move.Direction) and POSITION_NO_LEGAL_PUSHES_TEST_TAG)=0) {'True': the candidate hasn't been tested earlier for being a 'has no legal pushes' deadlock}
                  )
                  then with DeadlockSetCandidate do begin
                  //ShowBoard;
                  //Writeln('New pruned deadlock? ',Solver.PushCount,SPACE,Positions.Count);
                  FillChar(DeadlockSetCandidate,SizeOf(DeadlockSetCandidate),0);

                  for BoxNo:=1 to BoxCount do begin
                      Square:=BoxPos[BoxNo];
                      if Square<>0 then begin
                         Inc(Boxes.Count); Boxes.Squares[Boxes.Count]:=Square;
                         for Direction:=Low(Direction) to High(Direction) do
                             with Solver.SearchStates[MAX_HISTORY_BOX_MOVES].PlayersReachableSquares do begin
                               NeighborSquare:=Square+SquareOffsetForward[Direction];
                               if      ((Board[NeighborSquare] and (WALL+BOX))=0) and {'True': the neighbor square is an empty floor square}
                                       (Squares[NeighborSquare]<TimeStamp) then begin {'True': the player (which is outside the fence if the candidate boxes form a corral) cannot reach the empty floor square}
                                       Inc(Floors.Count); Floors.Squares[Floors.Count]:=NeighborSquare;
                                       Squares[NeighborSquare]:=Succ(TimeStamp); {mark the neighboring floor square as 'visited'}
                                       end
                               else if Squares[NeighborSquare]=TimeStamp then begin {'True': the player can reach the neighbor square (which is outside the corral if the box candidates form a corral); collect these squares}
                                       Inc(SquaresOutsideFence.Count);
                                       SquaresOutsideFence.Squares[SquaresOutsideFence.Count]:=NeighborSquare;
                                       Squares[NeighborSquare]:=Succ(TimeStamp); {mark the neighboring floor square as 'visited'}
                                       end;
                               end;
                         end;
                      end;

                  if (Floors.Count>0) and  {'True': there is at least one floor square inside the corral; the following deadlock set calculation requires that; in particular, 'CommitDeadlockSet' requires it for calculating flags and capacity}
                     (SquaresOutsideFence.Count>0) then begin {'True': there are floor squares outside the corral}
                     CenterSquare             :=Floors.Squares[1]; {elevate one the floor squares inside the corral to center square}
                     Flags                    :=[dsfIsADeadlock,dsfPlayerMustBeOutsideSet,dsfIsOnlyADeadlockForListedPlayerAccessAreasOutsideFence]; {'dsfIsADeadlock': the corral is a deadlock; no further analysis is necessary}
                     SquareOutsideFence       :=-SquaresOutsideFence.Squares[1]; {elevate one of the squares outside the fence to be the representative for the outside area; (the negated value makes 'CommitDeadlockSet' use the absolute value)}
                     SquaresOutsideFence.Count:=-SquaresOutsideFence.Count; {negate the count; it makes 'CommitDeadlockSet' use the absolute value instead of resetting the count}
                     with Positions.SearchStatistics do CorralPositionsBoxCount:=CorralPositionsBoxCount+Cardinal(DeadlockSetCandidate.Boxes.Count);  {update statistics}

                     OldHashValue:=Game.HashValue;
                     CalculateCorralDeadlockStatus(GamePosition__,NoPushesDeadlockPosition__,DeadlockSetCandidate);

                     if OldHashValue<>Game.HashValue then Msg(TEXT_INTERNAL_ERROR,'TTAddNoPushesDeadlock');

                     with NoPushesDeadlockPosition__^.Move do Direction:=TDirection(Ord(Direction) and (not POSITION_OPEN_TAG)); {remove the 'open' tag, if any; ('open' = not tested as a deadlocked dead end corral)}
                     end;

                  //Writeln(SPACE,TEXT_NO_YES[(Ord(NoPushesDeadlockPosition__^.Move.Direction) and POSITION_DEADLOCK_TAG)<>0]);
                  //Readln;
                  end;
               end;

           for BoxNo:=1 to BoxCount do {put removed boxes, if any, back on the board}
               if BoxPos[BoxNo]=0 then PutBoxOnBoard(BoxNo,BoxSquares[BoxNo]);

           if  Game.HashValue<>CalculateHashValue then begin {sanity check}
               Game.HashValue:=CalculateHashValue; {repair the value so the solver can continue}
               Msg(TEXT_INTERNAL_ERROR,'TTAddNoPushesDeadlock');
               end;

           DeadlockSets.ControllerAndFreezeSetPairsEnabled:=OldControllerAndFreezeSetPairsEnabled;
           end;

        if CorralDeadlockPosition__<>nil then with CorralDeadlockPosition__^.Move do {mark that pruning has been attempted for this corral}
           Direction:=TDirection(Cardinal(Ord(Direction)) or POSITION_NO_LEGAL_PUSHES_TEST_TAG); {note that the tag only tells that pruning has been attempted; this is not the same as saying that the pruned corral is a deadlock}

        if NoPushesDeadlockPosition__<>nil then with NoPushesDeadlockPosition__^.Move do {mark that an attempt has been made to prune this deadlock candidate}
           Direction:=TDirection(Cardinal(Ord(Direction)) or POSITION_NO_LEGAL_PUSHES_TEST_TAG);

        Result:=(NoPushesDeadlockPosition__<>nil) and {'True': True': the deadlock candidate has been stored in the transposition table; (not necessarily created by this call to the function; the candidate may have been stored earlier}
                ((Ord(NoPushesDeadlockPosition__^.Move.Direction) and POSITION_DEADLOCK_TAG)<>0); {'True': the pruned deadlock has been classified as a deadlock}
{
        if Result then begin
           ShowBoard;
           Write('* Deadlock position? ',TEXT_NO_YES[Result],SPACE,Solver.PushCount,SPACE,Positions.Count,SPACE,Game.DeadlockSets.SequenceNo);
           Readln;
           end;
}
      end; {Search.ForwardSearch.Search.TTAddNoPushesDeadlock}

      function  TTAddSingleRoomCorral(Position__:PPosition; var Corral__:TCorral):Boolean;
      var BoxIndex{,MemoryBlockByteSize,MemoryBlockPositionCount}:Integer;
          CorralPosition:PPosition; DeadlockSetCandidate:TDeadlockSetCandidate;
      begin {adds a 1-pocket corral (an area fenced-in by boxes) to the transposition table; returns 'True' if the corral is added and classified as a deadlock}
        Result:=False; //exit;
        Corral__.IsANotStoredDeadlock:=False;
{
        if  Corral__.HashValue=7040650081781527456 then begin
            ShowBoard;
            Write(Solver.PushCount,SPACE,Positions.Count);
            Readln;
            Game.Board[MAX_BOARD_SIZE]:=FLOOR;
            end;
}
        if  TTAdd(Corral__.HashValue,Corral__.MinPlayerPos+MAX_BOARD_SIZE,0,DEADLOCK_SCORE,0,dUp,nil,CorralPosition) then begin {'True': this is a new corral and now it has been added to the transposition table}
(*
            {store the corral box squares permanently in a memory block reserved for that purpose;}
            {this is not in production because the individual squares are not used for anything at the moment}
            if Positions.CorralBoxSquares.BoxSquaresCountDown<BoxSquares.Count then begin
               {allocate a new memory block for corral box squares from the free section of the transposition table memmory block}
               MemoryBlockByteSize:=CORRAL_BOX_SQUARES_MEMORY_BLOCK_BYTE_SIZE;
               repeat MemoryBlockPositionCount:=(MemoryBlockByteSize+Pred(SizeOf(TPosition))) div SizeOf(TPosition); {calculate the number of normal game positions that must be "stolen" for getting a memory block of this size}
                      MemoryBlockByteSize     := MemoryBlockByteSize div 2; {prepare for the next 'repeat ... until' loop if there isn't enough memory for the current memory block size}
               until (MemoryBlockPositionCount<=Positions.UninitializedItemCount);
               Positions.CorralBoxSquares.BoxSquare:=PBoxSquare2(Addr(Positions.Positions^[Positions.Capacity-Cardinal(Positions.UninitializedItemCount)]);
               Positions.CorralBoxSquares.BoxSquaresCountDown:=(MemoryBlockPositionCount*SizeOf(TPosition)) div SizeOf(TBoxSquare);
               Dec(Positions.UninitializedItemCount,MemoryBlockPositionCount);
               end;

            if Positions.CorralBoxSquares.BoxSquaresCountDown>=BoxSquares.Count then begin {'True': there is enough memory available to store the box squares}
               Dec(Positions.CorralBoxSquares.BoxSquaresCountDown,BoxSquares.Count);
               Position^.Move.BoxNo:=BoxSquares.Count; {save the number of boxes in 'Move.BoxNo'}
               Position^.BoxSquare:=Positions.CorralBoxSquares.BoxSquare;
               for BoxNo:=1 to BoxSquares.Count do begin
                   Positions.CorralBoxSquares.BoxSquare^:=BoxSquares.Squares[BoxNo];
                   Inc(Positions.CorralBoxSquares.BoxSquare);
                   end;
               //Inc(Positions.SearchStatistics.CorralPositionsBoxCount,BoxSquares.Count);
               end;
*)
            DeadlockSetCandidate.Boxes.Count:=Corral__.BoxSquares.Count;
            for BoxIndex:=1 to Corral__.BoxSquares.Count do
                DeadlockSetCandidate.Boxes.Squares[BoxIndex]:=Corral__.BoxSquares.Squares[BoxIndex];
            DeadlockSetCandidate.Floors.Count:=0;
            DeadlockSetCandidate.CenterSquare:=Corral__.MinPlayerPos;
            DeadlockSetCandidate.Flags:=[];

            with Positions.SearchStatistics do CorralPositionsBoxCount:=CorralPositionsBoxCount+Cardinal(DeadlockSetCandidate.Boxes.Count);  {update statistics}
{
//          if HashValue=6115705272791024053 then begin
            if Solver.PushCount=4383191 then begin
//          if True then begin
               ShowBoard;
               Writeln('Deadlock? ','  Pushes: ',Solver.PushCount,'  Positions: ',Positions.Count,' Corral boxes: ',DeadlockSetCandidate.Boxes.Count);
               for BoxIndex:=1 to DeadlockSetCandidate.Boxes.Count do
                   Write(SquareToColRowAsText(DeadlockSetCandidate.Boxes.Squares[BoxIndex]),SPACE);
               Writeln;
               Readln;
               Game.Board[MAX_BOARD_SIZE]:=FLOOR;
               end;
}
            Result:=CalculateCorralDeadlockStatus(Position__,CorralPosition,DeadlockSetCandidate);
{
            if HashValue=... then begin
               ShowBoard;
               for BoxIndex:=1 to BoxSquares.Count do Write(BoxSquares.Squares[BoxIndex],SPACE);
               Writeln;
               Write('Deadlock: ',TEXT_NO_YES[Result],'  Pushes: ',Solver.PushCount,'  Positions: ',Positions.Count);
               Readln;
               end;
}
            Corral__.IsANewCorral:=True; {the corral has been added to the transposition table}

            if (not Result) and {the candidate isn't a new deadlock, or it hasn't been stored because of a table overflow}
               (dsfIsADeadlockButTableOverflow in DeadlockSetCandidate.Flags) then begin {'True': the candidate is a new deadlock set but is hasn't been saved because of table overflow}
               //ShowBoard;
               //Write('Deadlock, but table overflow. Pushes: ',Solver.PushCount);
               //Readln;

               with CorralPosition^.Move do begin
                 Direction:=TDirection((Cardinal(Ord(Direction)) or (POSITION_DEADLOCK_TAG+POSITION_NOT_STORED_DEADLOCK_TAG)) and (not POSITION_OPEN_TAG));
                 end;
               Corral__.IsANotStoredDeadlock:=True;
               end;
            end
        else {the corral has already been saved in the transposition table (or more correctly, a corral with the same hash value and player position exists in the transposition table}
            if (CorralPosition<>nil) and
               ((Ord(CorralPosition^.Move.Direction) and POSITION_NOT_STORED_DEADLOCK_TAG)<>0) then begin
               Corral__.IsANotStoredDeadlock:=True;
               end;
      end; {Search.ForwardSearch.Search.TTAddSingleRoomCorral}

      function  TTAddCombinedCorral(Position__:PPosition; IsACombinedCorral__,HasNoLegalPushes__:Boolean; LowWaterBoxTimeStamp__:TTimeStamp; var CorralMinPlayerPos__:TBoxSquareSet):Boolean;
      {precondition: 'CorralPruning' has been called for the current game position 'Position__'}
      var BoxNo,Index,NeighborSquare,NeighborWallsCount,
          NeigborCorralSquaresCount,Square:Integer;
          Direction:TDirection;
          CorralHashValue:THashValue; CorralPosition,PrunedCorralPosition:PPosition;
          DeadlockSetCandidate:TDeadlockSetCandidate;

        function  AddNeighborCorral(const DeadlockSetCandidate__:TDeadlockSetCandidate; var CorralMinPlayerPos__:TBoxSquareSet):Integer;
        var BoxIndex,NeighborSquare,Square:Integer;
            b:Boolean; Direction:TDirection; NeighborCorral:TCorral;
        begin
          Result:=0;
          with Solver.SearchStates[SEARCH_STATE_INDEX_CORRAL_PRUNING].PlayersReachableSquares do
            for BoxIndex:=1 to DeadlockSetCandidate__.Boxes.Count do
                if Result=0 then begin
                   Square:=DeadlockSetCandidate__.Boxes.Squares[BoxIndex];
                   for Direction:=Low(Direction) to High(Direction) do
                       if Result=0 then begin
                          NeighborSquare:=Square+Game.SquareOffsetForward[Direction];
                          if ((Game.Board[NeighborSquare] and (WALL+BOX+FLOOR))=FLOOR)
                             and
                             (Solver.SearchStates[Position__^.PushCount].PlayersReachableSquares.Squares[NeighborSquare]
                              <> {'True': the player cannot reach the floor square}
                              Solver.SearchStates[Position__^.PushCount].PlayersReachableSquares.TimeStamp
                             )
                             and
                             (Solver.SearchStates[SEARCH_STATE_INDEX_CORRAL_PRUNING].PlayersReachableSquares.Squares[NeighborSquare]
                              < {'True': the floor square isn't inside the existing combined corral}
                              Pred(LowWaterBoxTimeStamp__)
                             ) then begin
                             CalculateCorralSquares(NeighborSquare,b,NeighborCorral);
                             if   TimeStamp<>2 then begin {'True': no timestamp wrap around}
                                  Result:=NeighborCorral.BoxSquares.Count;
                                  Inc(CorralMinPlayerPos__.Count); {add a floor square from the neighboring corral to the list of anchor squares inside the combined corral}
                                  CorralMinPlayerPos__.Squares[CorralMinPlayerPos__.Count]:=NeighborCorral.MinPlayerPos;
                                  if NeighborCorral.MinPlayerPos<CorralMinPlayerPos__.Squares[0] then
                                     CorralMinPlayerPos__.Squares[0]:=NeighborCorral.MinPlayerPos; {keep the minimum player position inside the corral updated}
                                  end
                             else Result:=-1;
                             end;
                          end;
                   end;
        end; {Search.ForwardSearch.Search.TTAddCombinedCorral.AddNeighborCorral}

      begin {'TTAddCombinedCorral'; returns 'True' if the corral, or one of its variants after pruning, is classified as a deadlock}
        Result:=False; //exit;
        with Solver.SearchStates[SEARCH_STATE_INDEX_CORRAL_PRUNING].PlayersReachableSquares do
          repeat
            {collect box squares in the set and calculate the hash value}
            CorralHashValue:=0;
            DeadlockSetCandidate.Boxes.Count:=0; DeadlockSetCandidate.Boxes.Squares[0]:=0;
            for BoxNo:=1 to Game.BoxCount do begin
                Square:=Game.BoxPos[BoxNo];
                if Squares[Square]>=LowWaterBoxTimeStamp__ then with DeadlockSetCandidate.Boxes do begin
                   Inc(Count); Squares[Count]:=Square;
                   CorralHashValue:=CorralHashValue xor Positions.SquareHashValues[Square];
                   end
                else begin {look for neighboring boxes that might contribute to close the fence around the corral}
                   NeigborCorralSquaresCount:=0; NeighborWallsCount:=0;
                   for Direction:=Low(Direction) to High(Direction) do begin
                       NeighborSquare:=Square+Game.SquareOffsetForward[Direction];
                       if Squares[NeighborSquare]>=LowWaterBoxTimeStamp__ then  {'True': the neighbor square is either a wall or a square belonging to the (combined) corral}
                          if   Game.Board[NeighborSquare]<>WALL then begin      {'True': the neighbor square contains a box belonging to the (combined) corral}
                               Inc(NeigborCorralSquaresCount);
                               if ((Game.Board[Square+Game.SquareOffsetLeft [Direction]] and WALL)<>0)
                                  or                                            {caution: assumes 4 directions only}
                                  ((Game.Board[Square+Game.SquareOffsetRight[Direction]] and WALL)<>0) then
                                  Inc(NeighborWallsCount);
                               end;
                       end;
                   if NeighborWallsCount<>0 then Inc(NeigborCorralSquaresCount); {'True': neighboring walls, if any, count as one single corral "neighbor" square}

                   if NeigborCorralSquaresCount>=2 then with DeadlockSetCandidate.Boxes do begin {'True': the box has at least one neighbor box which belongs to the (combined) corral}
                      Inc(Count); Squares[Count]:=Square;

                      CorralHashValue:=CorralHashValue xor Positions.SquareHashValues[Square];
                      Solver.SearchStates[SEARCH_STATE_INDEX_CORRAL_PRUNING].PlayersReachableSquares.Squares[Square]:=LowWaterBoxTimeStamp__;
                      end;
                   end;
                end;

            {check if the corral is a new one; if it is then store it}
            if //(DeadlockSetCandidate.Boxes.Count<=Game.DeadlockSets.BoxLimitForDynamicSets) and
               TTAdd(CorralHashValue,CorralMinPlayerPos__.Squares[0]+MAX_BOARD_SIZE,
                     0,DEADLOCK_SCORE,0,dUp,nil,CorralPosition)                 {'True': this is a new corral and now it has been added to the transposition table}
               or
               ((CorralPosition<>nil)                                           {'True': the corral has been saved in the transposition table earlier}
                and
                ((Ord(CorralPosition^.Move.Direction) and POSITION_OPEN_TAG)<>0) {'True': the corral wasn't classified as a deadlock at the time it was saved in the transposition table}
               )
               then begin
               {test if the new corral is a deadlock}
               DeadlockSetCandidate.Floors.Count:=CorralMinPlayerPos__.Count;   {add the normalized player positions for each "pocket" in the combined corral; 'CalculateDeadlockSets' floodfills from this set}
               for Index:=1 to CorralMinPlayerPos__.Count do
                   DeadlockSetCandidate.Floors.Squares[Index]:=CorralMinPlayerPos__.Squares[Index];
               Square:=Positions.StartPosition^.PlayerPos;
               if   ((Game.Board[Square] and (WALL+BOX+FLOOR))=FLOOR) and
                    (Squares[Square]>=Pred(LowWaterBoxTimeStamp__)) then        {if the player in the starting position is located inside the set at an empty floor, then use it as center square; 'CalculateDeadlockSets' depends on that}
                    DeadlockSetCandidate.CenterSquare:=Square
               else DeadlockSetCandidate.CenterSquare:=CorralMinPlayerPos__.Squares[0]; {use the normalized (top-left) player position as center square}

               DeadlockSetCandidate.MaxBoxCount:=DeadlockSetCandidate.Boxes.Count;
               DeadlockSetCandidate.EscapedBoxesCountDown:=DeadlockSetCandidate.Boxes.Count; {all boxes must escape the fenced-in area; otherwise it's a deadlock}
               DeadlockSetCandidate.GoalCount:=0; {the number of goals is recalculated from scratch by 'CalculateDeadlockSets' when the candidate has a center square, but the number must be initialized with a proper value}
               DeadlockSetCandidate.Flags:=[];

               with Positions.SearchStatistics do CorralPositionsBoxCount:=CorralPositionsBoxCount+Cardinal(DeadlockSetCandidate.Boxes.Count); {update statistics}
{
               if Game.HashValue=1391017276032698857 then begin
                  ShowBoard;
                  Writeln(Game.HashValue);
                  for Index:=1 to DeadlockSetCandidate.Boxes.Count do
                      Write(SquareToColRowAsText(DeadlockSetCandidate.Boxes.Squares[Index]),SPACE,SPACE);
                  Game.Board[MAX_BOARD_SIZE]:=FLOOR;
                  end;
}
               Result:=CalculateCorralDeadlockStatus(Position__,CorralPosition,DeadlockSetCandidate);
{
               if not Result
                  and
                  (Game.HashValue=1391017276032698857)
                  then begin
                  ShowBoard;
                  Writeln(Game.HashValue);
                  for Index:=1 to DeadlockSetCandidate.Boxes.Count do
                      Write(SquareToColRowAsText(DeadlockSetCandidate.Boxes.Squares[Index]),SPACE,SPACE);
                  Writeln;
                  Write('Deadlock: ',Solver.PushCount,SPACE,Positions.Count);
                  Readln;
                  //Writeln;
                  end;
}
               with CorralPosition^.Move do Direction:=TDirection(Ord(Direction) and (not POSITION_OPEN_TAG)); {remove the 'open' tag, if any; ('open' = not tested as a deadlocked dead end corral)}
               end
            else if (CorralPosition<>nil) and
                    ((Ord(CorralPosition^.Move.Direction) and POSITION_DEADLOCK_TAG)<>0) then
                    Result:=True; {the corral has been added before and classified as a deadlock}

            if  HasNoLegalPushes__ and {'True': there are no legal pushes in the current game position}
                (not Result) and {'True': the corral has not been classified as a deadlock}
                (CorralPosition<>nil) and {'True': the corral has been stored in the transposition table}
                ((Ord(CorralPosition^.Move.Direction) and POSITION_NO_LEGAL_PUSHES_TEST_TAG)=0) {'True': it hasn't been tested yet, whether a deadlock pattern can be found by simple pruning of the corral (i.e., removal of some interior boxes)}
                then
                Result:=TTAddNoPushesDeadlock(Position__,CorralPosition,True,PrunedCorralPosition);

          until Result or
                IsACombinedCorral__ or {if it's a combined corral then any neighboring corrals are already a part of the corral}
                Solver.Terminated or
                (AddNeighborCorral(DeadlockSetCandidate,CorralMinPlayerPos__)<=0); {'AddNeighborCorral': when the input corral is a single-room corral, there is a chance that a bigger combined corral constitutes a deadlock}
      end; {Search.ForwardSearch.Search.TTAddCombinedCorral}

      function  TTAddFrozenGoalsPattern(GamePosition__:PPosition):Boolean;
      const FROZEN_GOALS_PATTERN_THRESHOLD=3;
      var   GoalNo,OldCount,Square:Integer; PatternHashValue:THashValue;
            PatternPosition:PPosition;
            DeadlockSetCandidate:TDeadlockSetCandidate;
      begin {creates deadlock sets based on boxes freezing at goal squares}
        Result:=False; //exit;
        with Game do begin
          PatternHashValue:=0;
          DeadlockSetCandidate.Boxes.Count:=0; DeadlockSetCandidate.Boxes.Squares[0]:=0;
          for GoalNo:=1 to GoalCount do begin
              Square:=GoalPos[GoalNo];
              if ((Board[Square] and BOX)<>0) and
                 IsAFreezingMove(0,Square,True) then with DeadlockSetCandidate.Boxes do begin
                 Inc(Count); Squares[Count]:=GoalNo;                            {caution: despite the field name 'Squares', the squares really contain goal numbers and not square numbers here}
                 PatternHashValue:=PatternHashValue xor Positions.SquareHashValues[Square];
                 end;
              end;

          if (DeadlockSetCandidate.Boxes.Count>=FROZEN_GOALS_PATTERN_THRESHOLD) and {'True': the number of frozen goals >= threshold; for speed, smaller patterns are ignored}
             TTAdd(PatternHashValue,MAX_BOARD_SIZE+1,0,0,0,dUp,nil,PatternPosition) then begin {'True': this is a new frozen goals pattern and now it has been added to the transposition table}
             //DeadlockSetCandidate.MaxBoxCount:=DeadlockSetCandidate.Boxes.Count;
             //DeadlockSetCandidate.EscapedBoxesCountDown:=DeadlockSetCandidate.Boxes.Count; {all boxes must escape the fenced-in area; otherwise it's a deadlock}
             //DeadlockSetCandidate.GoalCount:=DeadlockSetCandidate.Boxes.Count;
             DeadlockSetCandidate.Flags:=[dsfTestFrozenGoalsSet];               {with this flag, 'Boxes' is the only used deadlock set candidate information, hence, the other fields don't need to be filled}
             //DeadlockSetCandidate.CenterSquare:=0;
             //DeadlockSetCandidate.Floors.Count:=0;

             OldCount:=DeadlockSets.Count;
             CalculateDeadlockSets(GamePosition__,DeadlockSetCandidate);
             Result:=OldCount<>DeadlockSets.Count; {returns 'True' if the frozen goals pattern produced new deadlock sets}
             end;
          end;
      end; {Search.ForwardSearch.Search.TTAddFrozenGoalsPattern}

      function  TTAddNoProgressPattern( Position__ : PPosition ) : Boolean; {registers any new "no progress" deadlocks and starts a new "no progress" detection cycle}
      var BoxNo,MinPlayerPos:Integer; BoxHashValue:THashValue;
          DeadlockSetCandidate:TDeadlockSetCandidate;

        procedure CalculatePlayersReachableSquaresWithPushableBoxesRemovedFromTheBoard;
        var BoxNo:Integer;
        begin
          for BoxNo:=1 to Game.BoxCount do
              if Solver.ProgressCheckPoint.PushedBoxes[BoxNo] then
                 Game.Board[Game.BoxPos[BoxNo]]:=Game.Board[Game.BoxPos[BoxNo]] and (not BOX); {temporarily remove the boxes which has moved/can move}

          CalculatePlayersReachableSquares(SEARCH_STATE_INDEX_SCRATCHPAD_1); {calculate the player's reachable squares in order to obtain the normalized (top-left) player position with only the not-pushed boxes on the board}
{
          ShowBoard;
          Writeln(Solver.PushCount,SPACE,Positions.Count,' Progress checkpoint - unpushed boxes');
          Readln;
}
          for BoxNo:=1 to Game.BoxCount do
              if Solver.ProgressCheckPoint.PushedBoxes[BoxNo] then
                 Game.Board[Game.BoxPos[BoxNo]]:=Game.Board[Game.BoxPos[BoxNo]] or BOX; {put all boxes back on the board}
        end;

        function  PruneNotPushedBoxes:Boolean;
        var BoxNo,Square,NeighborSquare:Integer; More:Boolean;
            Direction:TDirection;
        begin
          {prune the set of unpushed boxes by removing the ones that can be
           pushed if the pushable ones weren't blocking the access to them;
           in other words, all pushable boxes are removed from the board, and
           then the remaining boxes are tested for being pushable; this test
           continues until no more boxes can be pushed and pruned;
          }
          Result:=False;
          repeat
            More:=False;
            CalculatePlayersReachableSquaresWithPushableBoxesRemovedFromTheBoard;

            {search for more boxes that can be pushed}
            for BoxNo:=1 to Game.BoxCount do with Solver.SearchStates[SEARCH_STATE_INDEX_SCRATCHPAD_1].PlayersReachableSquares do
                if not Solver.ProgressCheckPoint.PushedBoxes[BoxNo] then begin
                   Square:=Game.BoxPos[BoxNo];
                   for Direction:=Low(Direction) to High(Direction) do begin
                       NeighborSquare:=Square+Game.SquareOffsetForward[Direction];
                       if {inline simple checks for legal moves}
                          (Squares[Square-Game.SquareOffsetForward[Direction]]=TimeStamp){'=TimeStamp': the player can reach the neighbor-square}
                          and
                          ((Game.Board[NeighborSquare] and (BOX+WALL+FLAG_ILLEGAL_BOX_SQUARE))=0) {'=0' the square is legal and not blocked by a wall or another box}
                          and
                          {extended checks for legal moves;}
                          {note that the check isn't accurate here because the}
                          {deadlock set capacities haven't been updated for the}
                          {boxes that have been removed from the board;}
                          {this means that fewer boxes are pruned than a more}
                          {accurate pruning could have done}
                          IsALegalPush(BoxNo,Direction,-1) then begin
                          More:=True; Result:=True;
                          Solver.ProgressCheckPoint.PushedBoxes[BoxNo]:=True;
                          break; {quick and dirty exit the 'for each direction' loop as soon as it's known that the box can be pushed in one of the directions}
                          end;
                       end;
                   end;
          until not More;

          if Result then begin
             Result:=False;
             for BoxNo:=1 to Game.BoxCount do
                 if not Solver.ProgressCheckPoint.PushedBoxes[BoxNo] then Result:=True; {'True': the pruned set isn't empty}
             end;
        end; {PruneNotPushedBoxes}

        function  MakeDeadlockSetCandidateWithNotPushedBoxes(var BoxHashValue__:THashValue; var MinPlayerPos__ : Integer; var DeadlockSetCandidate__:TDeadlockSetCandidate):Boolean;
        var BoxNo,Square:Integer;
        begin
          with DeadlockSetCandidate__ do begin
            BoxHashValue__:=0; Boxes.Count:=0; GoalCount:=0; CenterSquare:=0; Flags := [dsfIsANoProgressDeadlockCandidate];

            for BoxNo:=1 to Game.BoxCount do
                if not Solver.ProgressCheckPoint.PushedBoxes[BoxNo] then begin
                   Square:=Game.BoxPos[BoxNo];
                   Inc(Boxes.Count); Boxes.Squares[Boxes.Count]:=Square;
                   BoxHashValue__:=BoxHashValue__ xor Positions.SquareHashValues[Square];
                   if (Game.Board[Square] and GOAL)<>0 then Inc(GoalCount);
                   end;

            CalculatePlayersReachableSquaresWithPushableBoxesRemovedFromTheBoard; {calculates player's reachable squares and normalized (top-left) player position}
            MinPlayerPos__ := Solver.SearchStates[ SEARCH_STATE_INDEX_SCRATCHPAD_1 ].PlayersReachableSquares.MinPlayerPos;

            Result:=(Boxes.Count>=MIN_NO_PROGRESS_DEADLOCK_SET_CANDIDATE_BOX_COUNT) and (Boxes.Count>GoalCount);
            end;
        end; {MakeDeadlockSetCandidateWithNotPushedBoxes}

        function  MakeDeadlocklockSetCandidateWithInactiveBoxes( var BoxHashValue__ : THashValue; var MinPlayerPos__ : Integer; var DeadlockSetCandidate__ : TDeadlockSetCandidate ) : Boolean;
        const ACTIVE_BOX_THRESHOLD = 200 * ONE_KIBI;
        var BoxNo, NeigborCorralSquaresCount, OppositeAxisBlockCount, OldPlayerPos, Square : Integer;
            ActiveBoxThreshold : Cardinal;
            Direction : TDirection;
        begin
          Result := False;
          if   Positions.Count    >  ACTIVE_BOX_THRESHOLD then
               ActiveBoxThreshold := Positions.Count - ACTIVE_BOX_THRESHOLD
          else ActiveBoxThreshold := 0;
          {find a box which hasn't moved in a long time; and which is part of
           corral with the player currently on the outside}
          Square := 0;
          for BoxNo := 1 to Game.BoxCount do with Solver.ProgressCheckPoint do begin
              if Square = 0 then begin {'True': no corral with inactive boxes found yet}
                 if ( BoxTimeStamps[ BoxNo ] < ActiveBoxThreshold ) and
                    ( not IsAGoalSquare( Game.BoxPos[ BoxNo ] ) ) then
                    for Direction := Low( Direction ) to High( Direction ) do
                        if Square = 0 then begin {find an empty floor square next to the inactive box}
                           Square := Game.BoxPos[ BoxNo ] + Game.SquareOffsetForward[ Direction ];
                           if IsAnEmptyFloorSquare( Square ) then begin
                              OldPlayerPos := Game.PlayerPos;
                              MovePlayer( Square );
                              CalculatePlayersReachableSquares( SEARCH_STATE_INDEX_SCRATCHPAD_1 );
                              MovePlayer( OldPlayerPos );
                              with Solver.SearchStates[ SEARCH_STATE_INDEX_SCRATCHPAD_1 ].PlayersReachableSquares do
                                if Squares[ Game.PlayerPos ] = TimeStamp then {'True': it's the player's current access area; continue search for a different access area}
                                   Square := 0;
                              end
                           else Square := 0; {try next direction}
                           end
                        else break; {quick-and-dirty: exit loop when a corral with inactive boxes has been found}
                 end
              else break; {quick-and-dirty: exit loop when a corral with inactive boxes has been found}
              end;

          if  Square <> 0 then with Solver.SearchStates[ SEARCH_STATE_INDEX_SCRATCHPAD_1 ].PlayersReachableSquares do begin
              DeadlockSetCandidate__.Boxes.Count := 0;
              DeadlockSetCandidate__.GoalCount := 0;
              DeadlockSetCandidate__.CenterSquare := Square;
              DeadlockSetCandidate__.Flags := []; {'[]': normal treatment; processing the corral as a "no progress" deadlock candidate doesn't work; it produces false deadlocks when the search explores variations of the base deadlock candidate}

              BoxHashValue__:=0;
              for BoxNo := 1 to Game.BoxCount do begin
                  Square := Game.BoxPos[ BoxNo ];
                  if   Squares[ Square ] < TimeStamp then begin
                       {the box isn't a part of the corral; include it in the
                        corral anyway if the box might contribute to close the
                        fence around the corral;
                       }
                       NeigborCorralSquaresCount := 0;
                       OppositeAxisBlockCount := 0;
                       for Direction := Low( Direction ) to High( Direction ) do begin
                           NeighborSquare := Square + Game.SquareOffsetForward[ Direction ];
                           if Squares[ NeighborSquare ] = Succ( TimeStamp ) then   {'True': the neighbor square is either a wall or a square belonging to the corral}
                              if   Game.Board[ NeighborSquare ] <> WALL then begin {'True': the neighbor square contains a box belonging to the corral}
                                   Inc( NeigborCorralSquaresCount );
                                   if ((Game.Board[ Square + Game.SquareOffsetLeft [ Direction ] ] and WALL ) <> 0 )
                                      or                                           {caution: assumes 4 directions only}
                                      ((Game.Board[ Square + Game.SquareOffsetRight[ Direction ] ] and WALL ) <> 0 )
                                      or
                                      (Squares[     Square + Game.SquareOffsetLeft [ Direction ] ]            =  Succ( TimeStamp ) )
                                      or                                           {caution: assumes 4 directions only}
                                      (Squares[     Square + Game.SquareOffsetRight[ Direction ] ]            =  Succ( TimeStamp ) )
                                      then
                                      Inc( OppositeAxisBlockCount );
                                   end;
                           end;
                       if  OppositeAxisBlockCount <> 0 then                     {'True': there are wall and corral boxes blocking the other axis }
                           Inc( NeigborCorralSquaresCount );                    {'True': walls and corral boxes blocking the other axis count as one single corral "neighbor" square}
                       if  NeigborCorralSquaresCount >= 2 then                  {'True': the box has at least one neighbor box which belongs to the corral}
                           Squares[ Square ] := TimeStamp;                      {'TimeStamp', not 'Succ( TimeStamp )' which here is reserved for the original members of the corral}
                       end;

                  if   Squares[ Square ] >= TimeStamp then begin                {'True': a corral box}
                       Inc( DeadlockSetCandidate__.Boxes.Count );
                       DeadlockSetCandidate__.Boxes.Squares[ DeadlockSetCandidate__.Boxes.Count ] := Square;
                       BoxHashValue__ := BoxHashValue__ xor Positions.SquareHashValues[ Square ];
                       if ( Game.Board[ Square ] and GOAL) <>0 then Inc( DeadlockSetCandidate__.GoalCount );
                       Solver.ProgressCheckPoint.PushedBoxes[BoxNo] := False;
                       end
                  else Solver.ProgressCheckPoint.PushedBoxes[BoxNo] := True;
                  end;

              CalculatePlayersReachableSquaresWithPushableBoxesRemovedFromTheBoard; {calculates player's reachable squares and normalized (top-left) player position}
              MinPlayerPos__ := MinPlayerPos;

              Result:=( DeadlockSetCandidate__.Boxes.Count >= MIN_NO_PROGRESS_DEADLOCK_SET_CANDIDATE_BOX_COUNT ) and
                      ( DeadlockSetCandidate__.Boxes.Count >  DeadlockSetCandidate__.GoalCount );
{
              if Result then begin
                 ShowBoard;
                 Write( 'Inactive boxes: ' );
                 for BoxNo := 1 to DeadlockSetCandidate__.Boxes.Count do
                     Write( DeadlockSetCandidate__.Boxes.Squares[ BoxNo ], ' ' );
                 Writeln;
                 Readln;
                 end;
}
              end;
        end;

        function CheckDeadlockSetCandidate( Position__ : PPosition; BoxHashValue__ : THashValue; MinPlayerPos__ : Integer; var DeadlockSetCandidate__ : TDeadlockSetCandidate ) : Boolean;
        var //BoxNo : Integer;
            DeadlockPosition : PPosition;
        begin
          Result := False;
          {check if the deadlock set candidate is a new pattern; if it is, then store it in the transposition table}
          if //(DeadlockSetCandidate.Boxes.Count<=Game.DeadlockSets.BoxLimitForDynamicSets) and
             TTAdd(//UnpushedBoxesHashValue,MinPlayerPos+2*MAX_BOARD_SIZE,   {'2*MAX_BOARD_SIZE': separates unpushed-boxes patterns from normal game positions and from deadlocks stored in the transposition table}
                   BoxHashValue__,MinPlayerPos__+MAX_BOARD_SIZE,             {'MAX_BOARD_SIZE': differentiates deadlock set candidates from normal game positions in the transposition table}
                   0,0,0,dUp,nil,DeadlockPosition)                           {'True': the deadlock set candidate is a new pattern, and now it has been added to the transposition table}
             or
             ((DeadlockPosition<>nil)                                        {'True': the pattern has been saved in the transposition table earlier}
              and
              ((Ord(DeadlockPosition^.Move.Direction) and POSITION_OPEN_TAG)<>0) {'True': the pattern wasn't classified as a deadlock at the time it was saved in the transposition table}
             )
             then begin
             {test if the new pattern is a deadlock}
             DeadlockSetCandidate__.Boxes.Squares[0]:=0;
             DeadlockSetCandidate__.Floors.Count:=0;
             DeadlockSetCandidate__.MaxBoxCount:=DeadlockSetCandidate__.Boxes.Count;
             DeadlockSetCandidate__.EscapedBoxesCountDown:=DeadlockSetCandidate__.Boxes.Count; {all boxes must escape the fenced-in area; otherwise it's a deadlock}
             DeadlockSetCandidate__.Capacity:=-1; {the capacity isn't recalculated from scratch if 'CenterSquare' = 0}
             DeadlockSetCandidate__.SquareOutsideFence:=0;
             DeadlockSetCandidate__.SquaresOutsideFence.Count:=0;
{
             ShowBoard;
             Writeln(Game.HashValue);

             for BoxNo:=1 to DeadlockSetCandidate__.Boxes.Count do
                 Write(SquareToColRowAsText(DeadlockSetCandidate.Boxes.Squares[BoxNo]),SPACE,SPACE);
             Writeln;
             Write('Check no progress deadlock: ',Game.DeadlockSets.Count,SPACE,Solver.PushCount,SPACE,Positions.Count);
             Readln;
}
             Result:=CalculateCorralDeadlockStatus(Position__,DeadlockPosition,DeadlockSetCandidate__);

             if Result then begin
                DeadlockPosition^.Score:=DEADLOCK_SCORE;
{
                ShowBoard;
                Writeln(Game.HashValue);

                for BoxNo:=1 to DeadlockSetCandidate__.Boxes.Count do
                    Write(SquareToColRowAsText(DeadlockSetCandidate.Boxes.Squares[BoxNo]),SPACE,SPACE);
                Writeln;
                Write('No progress deadlock: ',Game.DeadlockSets.Count,SPACE,Solver.PushCount,SPACE,Positions.Count);
                Readln;
                //Writeln;

                Game.ShowDeadlockSetsEnabled:=True;
                ShowDeadlockSet(Game.DeadlockSets.Count,Game.DeadlockSets.CenterSquare[Game.DeadlockSets.Count]);
                Game.ShowDeadlockSetsEnabled:=False;
                Readln;
}
                end;

             with DeadlockPosition^.Move do Direction:=TDirection(Ord(Direction) and (not POSITION_OPEN_TAG)); {remove the 'open' tag, if any; ('open' = not tested as a deadlocked dead end corral)}
             end;
        end; {Search.ForwardsSearch.Search.TTAddNoProgressPattern.CheckDeadlockSetCandidate}

      begin {'TTAddNoProgressPattern'}
        Result:=False;

        for BoxNo := 1 to Game.BoxCount do {update "last-pushed" timestamps for the boxes}
            if Solver.ProgressCheckPoint.PushedBoxes[ BoxNo ] then
               Solver.ProgressCheckPoint.BoxTimeStamps[ BoxNo ] := Positions.Count;

        if MakeDeadlockSetCandidateWithNotPushedBoxes(BoxHashValue,MinPlayerPos,DeadlockSetCandidate) then
           Result := CheckDeadlockSetCandidate( Position__, BoxHashValue, MinPlayerPos, DeadlockSetCandidate );

        if ( not Result ) and ( Solver.PackingOrder.SetCount > 0 ) and {'>0': only try to make inactivity patterns, which aren't necessarily deadlocks, with packing order search, which already has dropped search completeness}
           MakeDeadlocklockSetCandidateWithInactiveBoxes( BoxHashValue, MinPlayerPos, DeadlockSetCandidate) then begin
           Result := CheckDeadlockSetCandidate( Position__, BoxHashValue, MinPlayerPos, DeadlockSetCandidate );

           if False and
              ( not Result ) and
              {the deadlock detection module couldn't prove that the inactive
               boxes are deadlocked; use the box configuration as a deadlock
               anyway; (this is disabled because tests show that it loses more
               solutions than it wins)
              }
              MakeDeadlocklockSetCandidateWithInactiveBoxes( BoxHashValue, MinPlayerPos, DeadlockSetCandidate ) then begin
              DeadlockSetCandidate.Boxes.Squares[0]:=0;
              DeadlockSetCandidate.Floors.Count:=0;
              DeadlockSetCandidate.MaxBoxCount:=DeadlockSetCandidate.Boxes.Count;
              DeadlockSetCandidate.EscapedBoxesCountDown:=DeadlockSetCandidate.Boxes.Count; {all boxes must escape the fenced-in area; otherwise it's a deadlock}
              DeadlockSetCandidate.Flags:=[ dsfIsADeadlock, dsfIsANoProgressDeadlockCandidate, dsfIsANoProgressPattern ];
              DeadlockSetCandidate.Capacity:=-1;
              CalculateDeadlockSets( Position__, DeadlockSetCandidate );
              end;
           end;

        Inc(Solver.ProgressCheckPoint.NoProgressCount);
        if Solver.ProgressCheckPoint.NoProgressCount>1 then begin
           {$IFDEF CONSOLE_APPLICATION}
              //Writeln('No progress: ', Solver.ProgressCheckPoint.NoProgressCount);
           {$ENDIF}
           {toggle room pruning for the next "no progresss" detection cycle}
           Game.Rooms.Count := -Game.Rooms.Count;
           end;
        InitializeProgressCheckPoint( Position__^.Score, False ); {start a new "no progress" detection cycle}
      end; {Search.ForwardsSearch.Search.TTAddNoProgressPattern}

      //const DebugThreshold:Cardinal=1;

      ///{///$DEFINE DEBUG_CORRALS}

      function  CorralPruning(Position__:PPosition;
                              SearchDepth__,FloorSquare__,RecursionDepth__:Integer;
                              LowWaterBoxTimeStamp__                      :TTimeStamp;
                              NeighborCorral__                            :PCorral;
                              var HasAllBoxesOnGoals__                    :Boolean;
                              var IsACombinedCorral__                     :Boolean;
                              var CorralMinPlayerPos__                    :TBoxSquareSet; {normalized (top-left) player position for each "pocket" or "room" in the combined corral}
                              var PruningTimeStamp__                      :TTimeStamp):Boolean;
      var
        BoxNo,//Index,//Col,Row,
        NeighborSquare,OppositeNeighborSquare,Square:Integer;
        BoxTimeStamp,NeighborSquareTimeStamp,OppositeNeighborSquareTimeStamp:TTimeStamp;
        NeighborCorralHasAllBoxesOnGoals,
        NeighborCorralIsACombinedCorral:Boolean;
        Direction:TDirection;
        Corral:TCorral;

        procedure AddConnectedBoxesToCorral(BoxSquare__:Integer; BoxTimeStamp__,LowWaterBoxTimeStamp__:TTimeStamp; var Corral__:TCorral; var NextBoxNo__:Integer);
//      function  AddConnectedBoxesToCorral(BoxSquare__:Integer; BoxTimeStamp__,LowWaterBoxTimeStamp__:TTimeStamp; var NextBoxNo__:Integer):Integer;
        var {Index,}Square:Integer; Direction:TDirection;
            StackTop:^Integer; Stack:TBoxArrayOfIntegers;
        begin
          //Result:=0;
          with Solver.SearchStates[SEARCH_STATE_INDEX_CORRAL_PRUNING].PlayersReachableSquares do begin

            StackTop:=Addr(Stack[1]); StackTop^:=BoxSquare__; {put the square on the stack}
            Squares[BoxSquare__]:=BoxTimeStamp__; {update the timestamp for the square}
            while StackTop<>Addr(Stack[0]) do begin
              //Inc(Result);
              Inc(Solver.AddedCorralBoxesCount);
              BoxSquare__:=StackTop^; Dec(StackTop); {get the next/first box square from the stack}

              Inc(Corral__.BoxSquares.Count); {add the box square to the corral}
              Corral__.BoxSquares.Squares[Corral__.BoxSquares.Count]:=BoxSquare__;
{
              // find out if the box at 'BoxSquare__' is a new lowest numbered untested box;
              // (this is obsolete; the corral boxsquares are collected in 'Corral__' instead
              // of enumerating all boxes in the main corral pruning loop for finding the
              // boxes with the correct timestamp)
              for Index:=1 to NextBoxNo__ do   // find out if the box at 'BoxSquare__' is a new lowest numbered untested box
                  if Game.BoxPos[Index]=BoxSquare__ then begin
                     NextBoxNo__:=Pred(Index); // 'Pred': the main loop in 'CorralPruning' increments the box-number before it processes a box, hence, adjust it accordingly
                     break;
                     end;
}
              for Direction:=Low(Direction) to High(Direction) do begin
                  Square:=BoxSquare__+Game.SquareOffsetForward[Direction];
                  if ((Game.Board[Square] and BOX)<>0) and
                     (Squares[Square]<=LowWaterBoxTimeStamp__) then begin
                     Inc(StackTop); StackTop^:=Square; {put the square on the stack}
                     Squares[Square]:=BoxTimeStamp__; {update the timestamp for the square}
                     end;
                  end;
              end;

            {$IFDEF DEBUG_CORRALS}
              {$IFDEF CONSOLE_APPLICATION}
                if BoxTimeStamp__>=DebugThreshold then begin
                   Writeln('Added boxes');
                   //Writeln('Added ',Result,' boxes');
                   ShowCorral(SEARCH_STATE_INDEX_CORRAL_PRUNING,BoxTimeStamp__);
                   end;
              {$ENDIF}
            {$ENDIF}
            end;
        end; {Search.ForwardSearch.Search.CorralPruning.AddConnectedBoxesToCorral}

        function  BoxCanMoveIndependentlyOfCorralBoxes(Square__: Integer; Direction__:TDirection; LowWaterBoxTimeStamp__,BoxTimeStamp__:TTimeStamp; var IsACombinedCorral__:Boolean):Boolean;
        var NeighborSquare,NeighborSquareValue,
            OppositeNeighborSquare,OppositeNeighborSquareValue:Integer;
        begin
          with Solver.SearchStates[SEARCH_STATE_INDEX_CORRAL_PRUNING].PlayersReachableSquares do begin
            NeighborSquare              :=Square__+Game.SquareOffsetRight[Direction__];
            OppositeNeighborSquare      :=Square__+Game.SquareOffsetLeft [Direction__];

            NeighborSquareValue         :=Game.Board[NeighborSquare];
            OppositeNeighborSquareValue :=Game.Board[OppositeNeighborSquare];

            if      ((NeighborSquareValue and WALL) <> 0)                       // blocked by a wall
                    or
                    ((OppositeNeighborSquareValue and WALL)<>0) then            // blocked by a wall
                    Result:=False
            else if (((NeighborSquareValue and BOX) <> 0)
                     and
                     (Squares[NeighborSquare] > LowWaterBoxTimeStamp__)         // blocked by a corral box
                    ) then begin
                    Result:=False;
                    if Squares[NeighborSquare] <> BoxTimeStamp__ then           // 'True': the box isn't in a part of the currently investigated corral
                       IsACombinedCorral__:=True;                               // the current corral depends on the combined corral
                    end
            else if (((OppositeNeighborSquareValue and BOX) <> 0)
                     and
                     (Squares[OppositeNeighborSquare] > LowWaterBoxTimeStamp__) // blocked by a corral box
                    ) then begin
                    Result:=False;
                    if Squares[OppositeNeighborSquare] <> BoxTimeStamp__ then   // True': the box isn't in a part of the currently investigated corral
                       IsACombinedCorral__:=True;                               // the current corral depends on the combined corral
                    end
            else if (((NeighborSquareValue         and FLAG_BOX_REACHABLE_SQUARE) = 0)
                     and                                                        // blocked along this axis
                     ((OppositeNeighborSquareValue and FLAG_BOX_REACHABLE_SQUARE) = 0)
                    ) then
                    Result:=False
            else Result:=True; // the box can move independently of the corral boxes
            end;
        end; {Search.ForwardSearch.Search.CorralPruning.BoxCanMoveIndependentlyOfCorralBoxes}

        function  IsAFreezingMoveConsideringCorralBoxesOnly ( FromSquareNo__ , ToSquareNo__ : Integer;
                                                              LowWaterBoxTimeStamp__ , BoxTimeStamp__: TTimeStamp;
                                                              var IsACombinedCorral__ : Boolean ) : Boolean;
        var OriginalFromSquareValue : Integer;
            ABoxIsBlockedOnANonGoalSquare , OriginalIsACombinedCorral__ : Boolean;

          function  BoxIsBlockedAlongOneAxis ( SquareNo__                : Integer;
                                               Direction__               : TDirection;
                                               {RecursionDepthCountDown__ : Integer;} {the recursion guard has been substituted by timestamping one axis per square}
                                               var ABoxIsBlockedOnANonGoalSquare__ : Boolean ):Boolean;
          var Neighbor1 , Neighbor2 , Neighbor1Position , Neighbor2Position : Integer;
              OriginalACombinedCorral__ : Boolean;
          begin
            {if RecursionDepthCountDown__ > 0 then}
               with Solver.SearchStates [ SEARCH_STATE_INDEX_CORRAL_PRUNING ].PlayersReachableSquares do begin
                 OriginalACombinedCorral__    := IsACombinedCorral__;

                 if   Direction__              = Low(Direction__) then          {flip horizontal/vertical direction}
                      Direction__             := Succ ( Low ( Direction__ ) )   {caution: 'Succ(Low...'): assumes 4 directions only}
                 else Direction__             := Low  ( Direction__ );

                 if ( Direction__              = Low ( Direction__ ) )
                    and
                    (Game.FreezeTestTimeStamps.Squares [ SquareNo__ ] >= Game.FreezeTestTimeStamps.TimeStamp) then {'True': use the already calculated value}

                    Result                    := Game.FreezeTestTimeStamps.Squares [ SquareNo__ ] > Game.FreezeTestTimeStamps.TimeStamp     {relies on Ord ( False , True ) = (0 , 1)}

                 else begin
                    Neighbor1Position         := SquareNo__ - Game.SquareOffsetForward[ Direction__ ];
                    Neighbor1                 := Game.Board [ Neighbor1Position ];

                    Neighbor2Position         := SquareNo__ + Game.SquareOffsetForward[ Direction__ ];
                    Neighbor2                 := Game.Board [ Neighbor2Position ];

                    Inc ( Game.Board [ SquareNo__ ] , WALL);                    {temporarily change this square to a wall}

                    Result := ((  Neighbor1 and WALL           ) <> 0 )         {is there a wall on any of the neighbor squares?}
                              or
                              ((  Neighbor2 and WALL           ) <> 0 )
                              or
                              ((( Neighbor1 and FLAG_ILLEGAL_BOX_SQUARE ) <> 0 ) {are both neighbors illegal squares?}
                               and
                               (( Neighbor2 and FLAG_ILLEGAL_BOX_SQUARE ) <> 0 )
                              );

                    if (not ( Result and ABoxIsBlockedOnANonGoalSquare__ ))     {it's not enough to know whether a box is blocked; it's also necessary to know whether a box is blocked on a non-goal square}
                       and
                       (( Neighbor1 and ( WALL + BOX ) ) = BOX )                {test if neighbor1 is a blocked box}
                       and
                       (Squares [ Neighbor1Position ] > LowWaterBoxTimeStamp__) {only consider boxes that belong to the (combined) corral}
                       and
                       BoxIsBlockedAlongOneAxis( Neighbor1Position , Direction__ , {Pred ( RecursionDepthCountDown__ ) ,} ABoxIsBlockedOnANonGoalSquare__ )
                       then begin
                       Result := True;
                       if Squares [ Neighbor1Position ] <> BoxTimeStamp__ then
                          IsACombinedCorral__ := True;
                       end;

                    if (not ( Result and ABoxIsBlockedOnANonGoalSquare__ ))     {it's not enough to know whether a box is blocked; it's also necessary to know whether a box is blocked on a non-goal square}
                       and
                       (( Neighbor2 and ( WALL + BOX ) ) = BOX )                {test if neighbor2 is a blocked box}
                       and
                       (Squares [ Neighbor2Position ] > LowWaterBoxTimeStamp__) {only consider boxes that belong to the (combined) corral}
                       and
                       BoxIsBlockedAlongOneAxis( Neighbor2Position , Direction__ , {Pred ( RecursionDepthCountDown__ ) ,} ABoxIsBlockedOnANonGoalSquare__ )
                       then begin
                       Result:=True;
                       if Squares [ Neighbor2Position ] <> BoxTimeStamp__ then
                          IsACombinedCorral__ := True;
                       end;

                    Dec ( Game.Board [ SquareNo__ ] , WALL );                   {remove the wall again}
                    end;

                 if   Result then                                               {if this box is blocked}
                      if ( ( Game.Board [ SquareNo__ ] and GOAL ) = 0 ) then    {and it's not a goal-square}
                         ABoxIsBlockedOnANonGoalSquare__ := True                {then set the flag}
                      else
                 else IsACombinedCorral__  := OriginalACombinedCorral__;        {restore the original value}

                 if   Direction__ = Low ( Direction__ ) then with Game.FreezeTestTimeStamps do  {reduce the exponential growth by storing the results for one axis}
                      Squares [ SquareNo__ ] := TimeStamp + TTimeStamp ( Ord ( Result ) ); {relies on Ord ( False , True ) = (0 , 1)}
                 end
            {else Result:=False;}                                               {recursion depth exceeded}
          end; {BoxIsBlockedAlongOneAxis}

        begin {IsAFreezingMoveConsideringCorralBoxesOnly}
          with Game.FreezeTestTimeStamps do
            if TimeStamp < High ( TimeStamp ) - 5 then
               Inc ( TimeStamp , 2 )
            else begin
               FillChar ( Squares , SizeOf ( Squares ) , 0 ); TimeStamp := 2;
               end;

          ABoxIsBlockedOnANonGoalSquare := False;
          OriginalIsACombinedCorral__ := IsACombinedCorral__;
          OriginalFromSquareValue := Game.Board [ FromSquareNo__ ];
          Game.Board [FromSquareNo__] := Game.Board [ FromSquareNo__ ] and (not BOX);   {remove box, if any ('FromSquareNo__' is optional), from its current position}

          Result := (( Game.Board [ ToSquareNo__ ] and ( WALL + FLAG_ILLEGAL_BOX_SQUARE ) ) <> 0 )   {a wall is considered a deadlocked square}
                    or
                    (( Game.Board [ ToSquareNo__ ] and   FLAG_BOX_REACHABLE_SQUARE        ) =  0 )   {inlined '(not IsABoxReachableSquare( ToSquareNo__ ))'}
                    or
                    (( not Game.ReverseMode ) and
                     BoxIsBlockedAlongOneAxis( ToSquareNo__ , Low(        TDirection )   , {MAX_IS_A_FREEZING_MOVE_RECURSION_DEPTH ,} ABoxIsBlockedOnANonGoalSquare) and
                     BoxIsBlockedAlongOneAxis( ToSquareNo__ , Succ( Low ( TDirection ) ) , {MAX_IS_A_FREEZING_MOVE_RECURSION_DEPTH ,} ABoxIsBlockedOnANonGoalSquare) and  {caution: 'Succ(Low...'): assumes 4 directions only}
                     ABoxIsBlockedOnANonGoalSquare
                    );

          Game.Board [FromSquareNo__] := OriginalFromSquareValue;               {put box, if any, back on the board}
          if not Result then IsACombinedCorral__ := OriginalIsACombinedCorral__;{restore original value; the first call of 'BoxIsBlockedAlongOneAxis' may have updated it}
        end; {Search.ForwardSearch.Search.CorralPruning.IsAFreezingMoveConsideringCorralBoxesOnly}

      begin {Search.ForwardSearch.Search.CorralPruning}
        with Solver.SearchStates[SEARCH_STATE_INDEX_CORRAL_PRUNING].PlayersReachableSquares do begin
          Inc(Solver.CorralCount);
          IsACombinedCorral__:=False; HasAllBoxesOnGoals__:=True;
          Corral.NextCorral:=NeighborCorral__;
          if RecursionDepth__=0 then with CorralMinPlayerPos__ do begin         // initialize the number of "pockets" or "rooms" in the combined corral which 'CorralPruning' may return
             Count:=0; Squares[0]:=MAX_BOARD_SIZE+1;                            // vector element 0 contains the minimum of the normalized (top-left) player position for each "pocket" in the combined corral
             //if TimeStamp>=PLAYERS_REACHABLE_SQUARES_TIMESTAMP_UPPER_BOUND-2*MAX_BOARD_SIZE-2 then // ensure that the timestamp cannot wrap around while the "pockets" inside a combined corral are visited by recursive calls to this function
             //   ClearPlayersReachableSquares(SEARCH_STATE_INDEX_CORRAL_PRUNING);                   // this is commented out because the 'if TimeStamp>2' statement below makes this extra initialization unnecessary
             end;

          // find:
          // 1. floor squares in the "pocket" that the player cannot reach, and
          // 2. inner boxes and boxes surrounding the "pocket";
          // this is accomplished by calling a specialized version of the
          // 'CalculatePlayersReachableSquares' function with the
          // player inside the "pocket", or "corral"
          CalculateCorralSquares(FloorSquare__,HasAllBoxesOnGoals__,Corral);
          BoxTimeStamp:=Succ(TimeStamp);                                        // 'Succ': boxes belonging to the corral are marked with this value

          if //True and
             {(Squares[Game.BoxPos[Position__^.Move.BoxNo]]=Succ(TimeStamp)) and} {'True': the last pushed box particated in the making of this corral; contrary to what one might think, it doesn't help to use this guard, hence, it's disabled}
             (Corral.BoxSquares.Count<=Game.DeadlockSets.BoxLimitForDynamicSets) then {'True': store the corral in the transposition table}
             if TTAddSingleRoomCorral(Position__,Corral) then begin             {'True': the corral is a new one and it is a deadlock, or more correct: at least one new deadlock set could be constructed based on this corral}
                end
             else if Corral.IsANotStoredDeadlock and                            {'True': the single-room corral is a deadlock, unless there is a hash-key collision}
                     (Solver.PackingOrder.SetCount>0) then begin                {'True': it's a packing order search which isn't a complete search anyway; therefore, it's OK to ignore hash-key collisions and assume that the corral is a deadlock}
                     for BoxNo:=1 to Corral.BoxSquares.Count do begin
                         Square:=Corral.BoxSquares.Squares[BoxNo];
                         Squares[Square]:=0;                                    {clear the timestamps for the corral boxes so no pushes are generated back in the main search loop}
                         if (Game.Board[Square] and GOAL)=0 then HasAllBoxesOnGoals__:=False;
                         end;
                     end;

          {$IFDEF DEBUG_CORRALS}
            {$IFDEF CONSOLE_APPLICATION}
              if BoxTimeStamp>=DebugThreshold then begin
                 SquareToColRow(FloorSquare__,Col,Row); Writeln('Test corral [',Col,':',Row,']');
                 Writeln(Solver.SearchStates[SEARCH_STATE_CORRAL_PRUNING].PlayersReachableSquares.Squares[FloorSquare__],SPACE,LowWaterBoxTimeStamp__);
                 ShowCorral(SEARCH_STATE_INDEX_CORRAL_PRUNING,TimeStamp);
                 end;
            {$ENDIF}
          {$ENDIF}

          // check that corral-boxes only can be pushed inwards
          // and that all these pushes are possible in the current position

          if (TimeStamp>2) and                                                  {'True': no timestamp wrap around; corral pruning fails if the timestamp wraps around}
             (CorralMinPlayerPos__.Count<High(CorralMinPlayerPos__.Squares)) then begin {'True': the number of "pockets" or "rooms" in the combined corral does not exceed the vector size}
             with CorralMinPlayerPos__ do begin
               Inc(Count); Squares[Count]:=MinPlayerPos;
               if MinPlayerPos<Squares[0] then Squares[0]:=MinPlayerPos;        {vector element 0 contains the minimum of the normalized (top-left) player position for each "pocket" in the combined corral}
               end;

             {check 2-pocket corrals for being deadlocks; this can be expensive
              in terms of computation time, but it catches so many deadlock
              situations that it seems worth it;
             }
             if (NeighborCorral__<>nil) and
                (NeighborCorral__^.NextCorral=nil) and { 'True': the current combined corral consists of exactly two neighboring corrals}
                (Corral.IsANewCorral or NeighborCorral__^.IsANewCorral) and
                {insisting on that one of the corrals must be a new one
                 saves time, but it also sacrifices finding some solutions;
                }
                (NeighborCorral__^.BoxSquares.Count<=Game.DeadlockSets.BoxLimitForDynamicSets) and
                (Corral           .BoxSquares.Count<=Game.DeadlockSets.BoxLimitForDynamicSets) then begin
                if TTAddCombinedCorral(Position__,True,False,BoxTimeStamp-2,CorralMinPlayerPos__) then begin // '-2': boxes belonging to the caller's corral have this timestamp
{
                   Game.ShowDeadlockSetsEnabled:=True;
                   ShowDeadlockSet(Game.DeadlockSets.Count,Game.DeadlockSets.CenterSquare[Game.DeadlockSets.Count]);
                   Game.ShowDeadlockSetsEnabled:=False;
                   ShowBoard;
                   Write('New 2-corral deadlock ');
                   Write(Game.DeadlockSets.Count,'; Positions: ',Positions.Count,' Pushes: ',Solver.PushCount,'  ',Position__^.HashValue);
                   Readln;
}
                   end;
{
                if (NeighborCorral__^.NextCorral<>nil) and
                   (NeighborCorral__^.NextCorral^.BoxSquares.Count<=Game.DeadlockSets.BoxLimitForDynamicSets) then
                   if TTAddCombinedCorral(Position__,True,False,BoxTimeStamp-4,CorralMinPlayerPos__) then begin // '-4': boxes belonging to the caller's caller's corral have this timestamp
                      Game.ShowDeadlockSetsEnabled:=True;
                      ShowDeadlockSet(Game.DeadlockSets.Count,Game.DeadlockSets.CenterSquare[Game.DeadlockSets.Count]);
                      Game.ShowDeadlockSetsEnabled:=False;
                      ShowBoard;
                      Write('New 3-corral deadlock ');
                      Write(Game.DeadlockSets.Count,'; Positions: ',Positions.Count,' Pushes: ',Solver.PushCount,'  ',Position__^.HashValue);
                      Readln;
                      end;
}
                end;

             BoxNo:=0;
//           while BoxNo<Game.BoxCount do begin
             while BoxNo<Corral.BoxSquares.Count do begin
               Inc(BoxNo);
//             Square:=Game.BoxPos[BoxNo];
               Square:=Corral.BoxSquares.Squares[BoxNo];
               if Squares[Square]=BoxTimeStamp then begin {the box is a part of this corral and it hasn't been investigated by a recursive call}
                  if (Game.DistanceToNearestGoal[Square]<>0) then HasAllBoxesOnGoals__:=False;

                  for Direction:=Low(Direction) to High(Direction) do begin
                      NeighborSquare         :=Square+Game.SquareOffsetForward[Direction];
                      OppositeNeighborSquare :=Square-Game.SquareOffsetForward[Direction];
                      NeighborSquareTimeStamp:=Squares[NeighborSquare];

                      if ((Game.Board[NeighborSquare        ]  and FLOOR)<>0) // a neighbor floor square (possibly with a box), from where the player will try to push the box
                         and
                         ((Game.Board[OppositeNeighborSquare]  and (BOX+WALL+FLAG_ILLEGAL_BOX_SQUARE))=0) // an empty floor square in the opposite direction where it's legal to put a box
                         and
                         ((NeighborSquareTimeStamp or 1)       <>  BoxTimeStamp) // the floor square (possibly with a box) is outside the current corral (it may be a part of the combined corral) ('or 1': to check both floor-members and box-members)
                         //and
                         //(not IsAFreezingMoveConsideringCorralBoxesOnly(Square,OppositeNeighborSquare,LowWaterBoxTimeStamp__,BoxTimeStamp,IsACombinedCorral__))
                         then begin
                         OppositeNeighborSquareTimeStamp:=Squares[OppositeNeighborSquare];
                         if   OppositeNeighborSquareTimeStamp>LowWaterBoxTimeStamp__ then // the empty floor square is inside the (combined) corral
                              if   Solver.SearchStates[SearchDepth__].PlayersReachableSquares.Squares[NeighborSquare]
                                   = // 'True': the player can reach the floor 'NeighborSquare'
                                   Solver.SearchStates[SearchDepth__].PlayersReachableSquares.TimeStamp
                                   then begin
                                   // OK; the outer floor square 'NeighborSquare' is empty and in the player's access area
                                   if      (OppositeNeighborSquareTimeStamp or 1)<>BoxTimeStamp then // 'True': the empty floor is a part of the combined corral but not in the current area, hence, the current corral depends on the combined corral
                                           IsACombinedCorral__:=True;
                                   end
                              else // the outer floor, 'NeighborSquare', isn't in the player's access area
                                   if      NeighborSquareTimeStamp>LowWaterBoxTimeStamp__ then // 'True': 'NeigborSquare' is a part of the combined corral
                                           // when 'NeighborSquare' is an empty floor inside the combined corral,
                                           // then it's OK to start pushing the box with the player at 'NeighborSquare';
                                           //
                                           // likewise, when 'NeighborSquare' contains a box that is a member of the combined corral,
                                           // then it's OK that the player cannot reach the square
                                           IsACombinedCorral__:=True
                                   else // 'NeighborSquare' is a floor (possibly with a box) outside the combined corral
                                        if (Game.Board[NeighborSquare] and BOX)=0 then // 'True': 'NeighborSquare' is an empty floor
                                           if CorralPruning(Position__,
                                                            SearchDepth__,NeighborSquare,Succ(RecursionDepth__),
                                                            LowWaterBoxTimeStamp__,
                                                            PCorral(Addr(Corral)),
                                                            NeighborCorralHasAllBoxesOnGoals,
                                                            NeighborCorralIsACombinedCorral,
                                                            CorralMinPlayerPos__,
                                                            PruningTimeStamp__) then begin
                                              // adding the corral around the empty floor 'NeighborSquare' succeeded;
                                              // now check if it contributes to the combined corral, or if it's a stand-alone corral
                                              if NeighborCorralIsACombinedCorral then begin
                                                 HasAllBoxesOnGoals__        :=HasAllBoxesOnGoals__ and NeighborCorralHasAllBoxesOnGoals;
                                                 IsACombinedCorral__         :=True;
                                                 end
                                              else with CorralMinPlayerPos__ do begin
                                                 // use the found stand-alone corral for pruning the expansion of the current position
                                                 HasAllBoxesOnGoals__        :=False; // this follows from the fact that ('NeighborCorralIsACombinedCorral' = False) => ('NeighborCorralHasAllBoxesOnGoals' = False)
                                                 IsACombinedCorral__         :=False;
                                                 Squares[1]                  :=Squares[Count];
                                                 Squares[0]                  :=Squares[1];
                                                 Count                       :=1;
                                                 BoxNo                       :=Game.BoxCount;
                                                 break;
                                                 end;
                                              end
                                            else begin
                                              // fail; it wasn't possible to add a new corral around 'NeighborSquare'
                                              BoxNo:=MAX_BOX_COUNT+1;           // stops iterating though the boxes, returning 'fail'
                                              break;                            // stops iterating through the directions
                                              end
                                        else
                                           // the box at the outside floor 'NeighborSquare' blocks the player's access to the square
                                           if IsAFreezingMoveConsideringCorralBoxesOnly(Square,OppositeNeighborSquare,LowWaterBoxTimeStamp__,BoxTimeStamp,IsACombinedCorral__) then begin
                                              // OK; pushing the box inwards to 'OppositeNeighborSquare' cannot be the first push in an attempt to open the corral
                                              end
                                           else
                                              if BoxCanMoveIndependentlyOfCorralBoxes(NeighborSquare,Direction,LowWaterBoxTimeStamp__,BoxTimeStamp,IsACombinedCorral__) then
                                                 // extend the corral with this box and its neighbors and continue the analysis
                                                 AddConnectedBoxesToCorral(NeighborSquare,BoxTimeStamp,LowWaterBoxTimeStamp__,Corral,BoxNo)
                                              else begin
                                                 // OK; the outer box at 'NeighborSquare cannot move unless corral boxes move first
                                                 // Squares[NeighborSquare]:=Pred(LowWaterBoxTimeStamp__); // mark the box as a neighbor of the corral
                                                 end

                         else // 'NeighborSquare' is a floor (possibly with a box) outside the currently investigated corral (it may be member of the combined corral)
                              // and
                              // 'OppositeNeighborSquare' is an empty floor outside the combined corral

                              if   (Game.Board[NeighborSquare] and BOX)=0 then // 'True': 'NeighborSquare' is an empty floor
                                   if   Solver.SearchStates[SearchDepth__].PlayersReachableSquares.Squares[NeighborSquare]
                                        = // 'True': the player can reach the outer empty floor 'NeighborSquare'
                                        Solver.SearchStates[SearchDepth__].PlayersReachableSquares.TimeStamp
                                        then begin
                                        // the player can reach the outer empty floor 'NeighborSquare'
                                        if (Solver.SearchStates[SearchDepth__].PlayersReachableSquares.Squares[OppositeNeighborSquare]
                                            <> // '<>' the player cannot reach the empty floor 'OppositeNeighborSquare'
                                            Solver.SearchStates[SearchDepth__].PlayersReachableSquares.TimeStamp
                                           )
                                           and
                                           CorralPruning(Position__,
                                                         SearchDepth__,OppositeNeighborSquare,Succ(RecursionDepth__),
                                                         LowWaterBoxTimeStamp__,
                                                         PCorral(Addr(Corral)),
                                                         NeighborCorralHasAllBoxesOnGoals,
                                                         NeighborCorralIsACombinedCorral,
                                                         CorralMinPlayerPos__,
                                                         PruningTimeStamp__) then begin
                                           // adding the corral around the empty floor 'OppositeNeighborSquare' succeeded;
                                           // now check if it contributes to the combined corral, or if it's a stand-alone corral
                                           if NeighborCorralIsACombinedCorral then begin
                                              HasAllBoxesOnGoals__           :=HasAllBoxesOnGoals__ and NeighborCorralHasAllBoxesOnGoals;
                                              IsACombinedCorral__            :=True;
                                              end
                                           else with CorralMinPlayerPos__ do begin
                                              // use the found stand-alone corral for pruning the expansion of the current position
                                              HasAllBoxesOnGoals__           :=False;         // this follows from the fact that ('NeighborCorralIsACombinedCorral' = False) => ('NeighborCorralHasAllBoxesOnGoals' = False)
                                              IsACombinedCorral__            :=False;
                                              Squares[1]                     :=Squares[Count];
                                              Squares[0]                     :=Squares[1];
                                              Count                          :=1;
                                              BoxNo                          :=Game.BoxCount; // stops iterating though the boxes, returning 'OK'
                                              break;                                          // stops iterating through the directions
                                              end;
                                           end
                                        else begin
                                           // fail; the corral can be opened by pushing the box to a square outside the corral
                                           BoxNo:=MAX_BOX_COUNT+1;
                                           break;
                                           end;
                                        end
                                   else // the player cannot reach the empty floor 'NeighborSquare'
                                        if   NeighborSquareTimeStamp>LowWaterBoxTimeStamp__ then
                                             // the empty floor is inside one of the corrals currently under investigation
                                             IsACombinedCorral__:=True
                                        else // the empty floor 'NeighborSquare' is outside the combined corral;
                                             if CorralPruning(Position__,
                                                              SearchDepth__,NeighborSquare,Succ(RecursionDepth__),
                                                              LowWaterBoxTimeStamp__,
                                                              PCorral(Addr(Corral)),
                                                              NeighborCorralHasAllBoxesOnGoals,
                                                              NeighborCorralIsACombinedCorral,
                                                              CorralMinPlayerPos__,
                                                              PruningTimeStamp__) then begin
                                                // adding the corral around the empty floor 'NeighborSquare' succeeded;
                                                // now check if it contributes to the combined corral, or if it's a stand-alone corral
                                                if NeighborCorralIsACombinedCorral then begin
                                                   HasAllBoxesOnGoals__      :=HasAllBoxesOnGoals__ and NeighborCorralHasAllBoxesOnGoals;
                                                   IsACombinedCorral__       :=True;
                                                   end
                                                else with CorralMinPlayerPos__ do begin
                                                   // use the found stand-alone corral for pruning the expansion of the current position
                                                   HasAllBoxesOnGoals__      :=False;         // this follows from the fact that ('NeighborCorralIsACombinedCorral' = False) => ('NeighborCorralHasAllBoxesOnGoals' = False)
                                                   IsACombinedCorral__       :=False;
                                                   Squares[1]                :=Squares[Count];
                                                   Squares[0]                :=Squares[1];
                                                   Count                     :=1;
                                                   BoxNo                     :=Game.BoxCount; // stops iterating though the boxes, returning 'OK'
                                                   break;                                     // stops iterating though the directions
                                                   end;
                                                end
                                             else begin
                                                // fail; it wasn't possible to add a new corral around 'NeighborSquare'
                                                BoxNo:=MAX_BOX_COUNT+1;         // stops iterating though the boxes, returning 'fail'
                                                break;                          // stops iterating though the directions
                                                end
                              else if   NeighborSquareTimeStamp<=LowWaterBoxTimeStamp__ then
                                        // the box at the outside floor 'NeighborSquare' blocks the player's access to the square;
                                        if BoxCanMoveIndependentlyOfCorralBoxes(NeighborSquare,Direction,LowWaterBoxTimeStamp__,BoxTimeStamp,IsACombinedCorral__) then
                                           // extend the corral with this box and its neighbors and continue the analysis
                                           AddConnectedBoxesToCorral(NeighborSquare,BoxTimeStamp,LowWaterBoxTimeStamp__,Corral,BoxNo)
                                        else begin
                                           // OK; the outer box at 'NeighborSquare cannot move unless corral boxes move first
                                           // Squares[NeighborSquare]:=Pred(LowWaterBoxTimeStamp__); // mark the box as a neighbor of the corral
                                           end
                                   else // the blocking box belongs to another sub-corral, hence, this corral depends on the combined corral
                                        IsACombinedCorral__:=True;
                         end
                      else begin
                         // at this point 'OppositeNeighborSquare' may contain
                         // a box outside the corral, and this is a situation
                         // that must be investigated; however, iterating
                         // through the directions will at some time flip
                         // 'NeighborSquare' and 'OppositeNeighborSquare'
                         // and then the outside box will be given the proper
                         // treatment;
                         end;
                      end;
                  end;
               end
             end
          else
             BoxNo:=MAX_BOX_COUNT+1;                                            // corral pruning failed, i.e., after a timestamp wrap around

          Result:=BoxNo<=Game.BoxCount;
          if Result then begin
             if   RecursionDepth__=0 then                                       // 'True': this is the call from the outside
                  if   HasAllBoxesOnGoals__ then
                       Result:=False                                            // the corral isn't a candidate for pruning when all boxes are lcoated at goals
                  else if   PruningTimeStamp__< BoxTimeStamp then               // 'True' no other single-room corral was selected as pruning candidate
                            PruningTimeStamp__:=BoxTimeStamp                    // return pruning threshold
                       else
             else if   HasAllBoxesOnGoals__ then
                       IsACombinedCorral__:=True // even though the corral only can be opened using inwards pushes, it cannot stand alone when all boxes are on goals
                  else if   not IsACombinedCorral__ then                        // 'True': a single-room corral has been selected as stand-alone pruning candidate (not necessarily the current corral)
                            if  PruningTimeStamp__< BoxTimeStamp then begin     // 'True': no other single-room corral was selected as pruning candidate, hence, it's the current corral which is the pruning candidate
                                PruningTimeStamp__:=BoxTimeStamp;               // return pruning threshold
                                {$IFDEF DEBUG_CORRALS}
                                  {$IFDEF CONSOLE_APPLICATION}
                                    if BoxTimeStamp>=DebugThreshold then begin
                                       Writeln('Deep corral');
                                       ShowCorral(SEARCH_STATE_INDEX_CORRAL_PRUNING,PruningTimeStamp__);
                                       end;
                                  {$ENDIF}
                                {$ENDIF}
                                end;
             end;
(*
          if Result
             or                                                                 {'True': store the corral in the transposition table}
             (Corral.BoxSquares.Count<=Game.DeadlockSets.BoxLimitForDynamicSets)
             then
             if TTAddSingleRoomCorral(Position__,Corral) then begin             {'True': the corral is a new one and it is a deadlock, or more correct: at least one new deadlock set could be constructeed based on this corral}
                end;
*)
          {$IFDEF DEBUG_CORRALS}
            {$IFDEF CONSOLE_APPLICATION}
              if BoxTimeStamp>=DebugThreshold then
                 if Result then begin
                    Write('OK ',Pred(BoxTimeStamp)); Readln;
                    end
                 else begin
                    Write('Fail ',Pred(BoxTimeStamp)); Readln;
                    end;
            {$ENDIF}
          {$ENDIF}
          end;
      end; {Search.ForwardSearch.Search.CorralPruning}

      function  HasPushCreatedANewCorralDeadlock(Position__:PPosition):Boolean;
      var BoxSquare:Integer; HasAllBoxesOnGoals:Boolean; Direction:TDirection;
          LowWaterTimeStamp:TTimeStamp; Corral:TCorral;
      begin {preconditions: 'Position__' matches the current game state; the player's reachable squares have been calculated for the search depth, i.e., 'Position__^.PushCount'}
        Result:=False;
        BoxSquare:=Game.BoxPos[Position__^.Move.BoxNo];
        LowWaterTimeStamp:=Solver.SearchStates[SEARCH_STATE_INDEX_CORRAL_PRUNING].PlayersReachableSquares.TimeStamp;
        with Solver.SearchStates[Position__^.PushCount].PlayersReachableSquares do
          for Direction:=Low(Direction) to High(Direction) do begin
              NeighborSquare:=BoxSquare+Game.SquareOffsetForward[Direction];
              if ((Game.Board[NeighborSquare] and (BOX+WALL))=0)                {'True': and empty floor}
                 and
                 (Squares[NeighborSquare]<>TimeStamp)                           {'True': the floor isn't in the player's current access area}
                 and
                 (Solver.SearchStates[SEARCH_STATE_INDEX_CORRAL_PRUNING].PlayersReachableSquares.Squares[NeighborSquare]<=LowWaterTimeStamp) {'True': the square hasn't been explored from another direction (except for a timestamp wrap around)}
                 and
                 (CalculateCorralSquares(NeighborSquare,HasAllBoxesOnGoals,Corral)>0)
                 and
                 (not HasAllBoxesOnGoals)
                 and
                 (Corral.BoxSquares.Count<=Game.DeadlockSets.BoxLimitForDynamicSets) {'True': store the corral in the transposition table}
                 and
                 TTAddSingleRoomCorral(Position__,Corral{,Solver.SearchStates[SEARCH_STATE_INDEX_CORRAL_PRUNING].PlayersReachableSquares.MinPlayerPos}) then begin {'True': the corral is a new one and it is a deadlock}
                 Result:=False;
                 end;
             end;
      end;

(*
      function  PackingOrderSearch(Position__:PPosition; GoalNo__,PackingOrderSetNo__,RelativeDepth__:Integer):Integer;
      {precondition: player's reachable squares have been calculated for this depth, that is, 'Position__^.PushCount'}
      var //Index,
          BoxToSquare,PositionScore,SuccessorPushCount,SuccessorScore,Square:Integer;
          Direction:TDirection; SuccessorPosition:PPosition;
      begin {Search.ForwardSearch.Search.PackingOrderSearch}
{
//      if Game.HashValue=2544286736954669252 then begin
        if (Solver.PushCount>=3201) and (RelativeDepth__<>0) then begin
           ShowBoard;
           Write('PO Depth: ',Position__^.PushCount,' Score: ',Position__^.Score,' Positions: ',Positions.Count,' Pushes: ',Solver.PushCount,' Open: ',Positions.OpenPositions.Count);
           //Writeln;
           Readln;
           end;
}
{
         for Index:=1 to High(Game.SolutionPathHashValues) do // testing original solution...
             if Game.SolutionPathHashValues[Index]=0 then
                break
             else if Game.HashValue=Game.SolutionPathHashValues[Index] then begin
                     if Index >= 1 then begin
                        ShowBoard;
                        Write('PO: Solution path ',Index,SLASH,Position__^.PushCount,' Pushes: ',Solver.PushCount);
                        Readln;
                        //Writeln;
                        end;
                     break;
                     end;
}
        Position__^.PackingOrder.SetNo:=PackingOrderSetNo__;

        if Game.BoxPos[Position__^.Move.BoxNo]<>Game.GoalPos[GoalNo__] then begin
           Result:=0;
           PositionScore:=Position__^.Score;
           if (Position__^.PushCount+Game.SimpleLowerBound<Solver.SearchLimits.DepthLimit) and
              (PositionScore<=High(Positions.OpenPositions.Buckets)) then
              with Position__^ do with Solver.SearchStates[PushCount].PlayersReachableSquares do
                with Solver.PackingOrder do begin
                  Inc(UInt8(Move.Direction),POSITION_PATH_TAG);                 {mark the position as a member of the currently investigated path}
                  SuccessorPushCount:=Succ(PushCount);

                  //Game.History.Moves[PushCount].Move.BoxNo:=BoxNo;            {update game history}
                  Square:=Game.BoxPos[Move.BoxNo];

                  for Direction:=Low(Direction) to High(Direction) do begin
                      BoxToSquare:=Square+Game.SquareOffsetForward[Direction];

                      if (SquareGoalDistance[Square,GoalNo__] >                 {'True': moving the box in this direction brings it closer to the goal}
                          SquareGoalDistance[BoxToSquare,GoalNo__])
                         and
                         {inline simple checks for legal moves}
                         (Squares[Square-Game.SquareOffsetForward[Direction]]=TimeStamp){'= TimeStamp': the player can reach the neighbor-square}
                         and
                         ((Game.Board[BoxToSquare] and (BOX+WALL+FLAG_ILLEGAL_BOX_SQUARE))=0) {'=0' the square is legal and not blocked by a wall or another box}
                         and
                         {extended checks for legal moves}
                         IsALegalPush(Move.BoxNo,Direction,SuccessorPushCount) then

                         if Solver.PushCount<Solver.SearchLimits.PushCountLimit then begin   {limit not exceeded}

                            //Game.History.Moves[PushCount].Direction:=Direction; {update game history}
                            DoPush(Move.BoxNo,Direction,SuccessorPushCount);    {do the move, i.e., update the board}

(
                            {successor score := (parent score) + (1 push) - (1 point for getting closer to the designated goal) + (difference between the lower bound for the new position and the parent position)}
                            SuccessorScore   :=PositionScore //Succ(PositionScore)
                                               +Game.DistanceToNearestGoal[BoxToSquare]
                                               -Game.DistanceToNearestGoal[Square];
                            if SuccessorScore<PositionScore then
                               SuccessorScore:=PositionScore;
)

                            SuccessorScore:= SuccessorPushCount                 {'SuccessorPushCount + Game.SimpleLowerBound' is the normal score for a position}
                                            +Game.SimpleLowerBound
                                            -Game.DistanceToNearestGoal[Game.BoxPos[Move.BoxNo]] {subtract the normal contribution to 'Game.SimpleLowerBound' for this box}
                                            +SquareGoalDistance[BoxToSquare,GoalNo__] {the distance to the designated goal}
                                            -Game.PackingOrderPushCount;        {packing-order pushes on current path; by subtracting them it only counts as a single push to bring the box closer to the designated goal}
                                            //-RelativeDepth__;                 {prefer positions where the box is closer to the designated goal square}
(
                            if   (Game.Board[Square        ] shr GOAL_BIT_SHIFT_COUNT)
                                 >=                                               {'>=': the calculated packing order, if any, doesn't indicate that this brings the box closer to a square that should be filled first}
                                 (Game.Board[BoxToSquare   ] shr GOAL_BIT_SHIFT_COUNT) then
                                 SuccessorScore:=     SuccessorPushCount +Game.SimpleLowerBound-Game.PackingOrderPushCount
                            else {'<': the box moves to a square that according to the calculated packing order should be filled first}
                                 SuccessorScore:=Pred(SuccessorPushCount)+Game.SimpleLowerBound-Game.PackingOrderPushCount;
)
                            Inc(Solver.PushCount);                              {update statistics}

//                          WriteBoardToLogFile('PO '+IntToStr(Solver.PushCount)+SPACE+IntToStr(Positions.Count)+' Score: '+IntToStr(SuccessorScore));

                            if (Solver.PushCount and (ONE_MEBI-1))=0 then begin
                               {$IFDEF CONSOLE_APPLICATION}
                                 Write(Reader.LevelCount,': Depth: ',Position__^.PushCount);
                                 if SuccessorScore<INFINITY then Write(' Score: ',SuccessorScore);
                                 Write(' Pushes: ',Solver.PushCount div ONE_MILLION,' million');
                                 if   Positions.SearchStatistics.ReuseCount=0 then
                                      Write(' Positions: ',Positions.Count)
                                 else Write(' Reused positions: ',Positions.SearchStatistics.ReuseCount);
                                 {Write(' Time: ',(CalculateElapsedTimeMS(Solver.StartTimeMS,GetTimeMS)+500) div 1000);}
                                 Writeln;
                               {$ENDIF}

                               TimeCheck;
                               end;

                            if (SuccessorScore<=Solver.SearchLimits.DepthLimit) and
                               (SuccessorPushCount+Game.SimpleLowerBound<=Solver.SearchLimits.DepthLimit) then begin
                               UsePlayersReachableSquaresFromPredecessor:=
                                 (Solver.SearchStates[Pred(SuccessorPushCount)].PlayersReachableSquares.Squares[BoxToSquare]
                                  <> // '<>': in the position 'Position__' (before the move [Move.BoxNo, Direction]), the player cannot reach the other side of the box
                                  Solver.SearchStates[Pred(SuccessorPushCount)].PlayersReachableSquares.TimeStamp
                                 )
                                 or
                                 (((Game.Board[BoxToSquare+Game.SquareOffsetRight[TDirection(Ord(Move.Direction) and DIRECTION_BIT_MASK)]] and (WALL+BOX))<>0)
                                  and
                                  ((Game.Board[BoxToSquare+Game.SquareOffsetLeft [TDirection(Ord(Move.Direction) and DIRECTION_BIT_MASK)]] and (WALL+BOX))<>0)
                                 );
                               Inc(Solver.ReusePlayersReachableSquaresFromPredecessorCount[UsePlayersReachableSquaresFromPredecessor]);

                               if not Solver.SearchStates[SuccessorPushCount].PlayersReachableSquares.Calculated then
                                  CalculatePlayersReachableSquares(SuccessorPushCount); {find the player's reachable squares}

                               {SuccessorPosition:=nil;}                        {not necessary, 'TTAdd' sets it to 'nil'}

                               {try to add the successor position to the transposition table;}
                               {if it already is in the table, then 'TTAdd' returns}
                               {'False' and the existing position in 'SuccessorPosition'}
                               if TTAdd(Game.HashValue,                         {hash signature for this position}
                                        //Solver.SearchStates[SuccessorPushCount].PlayersReachableSquares.MinPlayerPos, {normalized (top-left) player position}
                                        Game.PlayerPos,                         {player position; note that this isn't the normalized (top-left) player position; 'SetPosition' depends on having the true player position after the push}
                                        SuccessorPushCount,                     {pushes = depth}
                                        SuccessorScore,                         {pushes + heuristic estimate}
                                        Move.BoxNo,                             {moved box}
                                        Direction,                              {box direction}
                                        Position__,                             {parent node}
                                        SuccessorPosition) then begin           {'SuccessorPosition' is the new saved position}

//                                WritelnToLogFile('New '+IntToStr(Positions.Count));

                                  SuccessorScore:=SuccessorPosition^.Score;     {'Score' is 0 for perimeter-nodes from a search in the opposite direction, hence, retrieve the actually saved score for the position}
{
                                  if       Game.HashValue=1652664153217381026 then begin
                                           Positions.DebugPosition:=SuccessorPosition;
                                           ShowBoard;
                                           Writeln('PO Debug position: ',Positions.Count,SPACE,Solver.PushCount,' Pushes: ',SuccessorPushCount,' Score: ',SuccessorScore,SPACE,Game.SimpleLowerBound,SPACE,Game.PackingOrderPushCount,SPACE,Solver.PushCount);
                                           Readln;
                                           end;
}
                                  if       (Game.SimpleLowerBound<>0) and (SuccessorScore<>0) then begin {'True': not a solution}
                                           if not Game.DeadlockSets.NewDynamicDeadlockSets then {'True':  no new deadlock sets have been created after the main search loop retracted a node from the open-list}
                                              Result:=PackingOrderSearch(SuccessorPosition,GoalNo__,PackingOrderSetNo__,Succ(RelativeDepth__));
                                           if False {Result=0} then with SuccessorPosition^ do begin {'Result=0': the box didn't make it all the way to the designated goal square}
                                              SuccessorScore:=SuccessorPushCount+Game.SimpleLowerBound-Game.PackingOrderPushCount; {the normal evaluation heuristic when packing order isn't considered}
                                              if SuccessorScore<Score then begin
                                                 if   (Ord(Move.Direction) and POSITION_OPEN_TAG)<>0 then begin
                                                      OPENRemove(SuccessorPosition);
                                                      Score:=SuccessorScore;
                                                      OPENAdd(SuccessorPosition);
                                                      end
                                                 else Score:=SuccessorScore;
                                                 end;
                                              end;
                                           end
                                  else  if Game.SimpleLowerBound<>0 then begin  {'True': a perimeter-position from a search in the opposite direction}
                                           SuccessorScore:=SuccessorPushCount+  {'PathLengthToSolution' contains distance to the goal-position}
                                                           SuccessorPosition^.PathLengthToSolution;
                                           if (Positions.SolutionPosition=nil)
                                              or
                                              (Cardinal(SuccessorScore) <
                                               (Positions.SolutionPosition^.PushCount+
                                                Positions.SolutionPosition^.PathLengthToSolution))
                                              or
                                              (SuccessorPosition=Positions.SolutionPosition) {'=': new cheaper path to the already found perimeter-position}
                                              then begin {new or first found solution}
                                              Positions.SolutionPosition:=SuccessorPosition;
                                              Solver.SearchLimits.DepthLimit:=SuccessorScore;
                                              Solver.SokobanStatusPointer^.Flags:=SOKOBAN_PLUGIN_FLAG_SOLUTION;
                                              SetSokobanStatusText(TEXT_SOLUTION_INFO_1+IntToStr(SuccessorScore)+TEXT_SOLUTION_INFO_2);
                                              OPENDropPositions(Solver.SearchLimits.DepthLimit);{prune the open-queue and the transpostion-table; there is no need to search paths longer than or equal to the best found solution}
                                              //TerminateSearch; //testing
                                              end;
                                           end
                                  else  begin                                   {lower bound = 0, i.e., it's the goal position}
                                          Positions.SolutionPosition:=SuccessorPosition;
                                          TerminateSearch;
                                          //Positions.OpenPositions.Count:=0;   {'0': signals an exhaustive search, i.e., an optimal solution}
                                        end;
                                  end
                               else                                             {the position wasn't added to the transposition table}
                                  if SuccessorPosition<>nil then begin          {'True': the position already exists in the transposition table}
                                     if Game.SimpleLowerBound<>0 then begin     {'True': not a solution}
                                        end
                                     else with SuccessorPosition^ do begin      {start-position = goal-position, or a shorter path to an existing position}
                                        {if this is the start-position then modify it so it contains this last move leading to the solution}
                                        PushCount        :=SuccessorPushCount;
                                        Score            :=SuccessorPushCount;
                                        Parent           :=Position__;          {handle with care: if this is the start-position, then the solution is now a circular list}
                                        Move.BoxNo       :=Position__^.Move.BoxNo;
                                        Move.Direction   :=Direction;
                                        Positions.SolutionPosition:=SuccessorPosition;

                                        TerminateSearch;
                                        //Positions.OpenPositions.Count:=0;     {'0': signals an exhaustive search, i.e., an optimal solution}
                                       end
                                     end
                                  else                                          {the transposition table is full}
                                     if Solver.ReuseNodesEnabled then begin
                                        if SuccessorScore<Position__^.BestForgottenScore then
                                           Position__^.BestForgottenScore:=SuccessorScore; {the successor-position wasn't stored; remember the best forgotten score}
                                        end
                                     else TerminateSearch;                      {stop searching when the transposition table is full}
                               end
                            else begin                                          {search depth limit exceeded}
                               if (Solver.SearchLimits.DepthLimit>=0) and                    {'>=0': the search hasn't been terminated}
                                  (SuccessorPushCount+Game.SimpleLowerBound>OriginalDepthLimit) then {'>OriginalDepthLimit': 'Solver.SearchLimits.DepthLimit' may have been lowered after finding a solution}
                                  Inc(Solver.LimitExceededPushCount);
                              end;

                            UndoPush(Move.BoxNo,Direction);                     {take back the move, i.e., update the board}
                            end
                         else begin                                             {push count limit exceeded}
                            if Solver.SearchLimits.DepthLimit>=0 then           {'>=0': the search hasn't been terminated}
                               Inc(Solver.LimitExceededPushCount);
                            end;
                      end;
                  Dec(UInt8(Move.Direction),POSITION_PATH_TAG);                 {remove the 'current path' tag}
                  end;
           end
        else with Position__^ do begin                                          {the box arrived at its target square}
           if Game.SimpleLowerBound<>0 then begin                               {'<>': not a solution}
              if   RelativeDepth__<Score then
                   Score:=Score-RelativeDepth__                                 {all the pushes leading to the target square are packing order pushes; subtract them from the score to give the position a substantial bonus}
              else Score:=1;
              end;
           Result:=RelativeDepth__;
{
           if Solver.PushCount>=0 then begin
//         if Positions.Count>=1+0*ONE_MILLION then begin
              ShowBoard;
              Write('PO!: Depth: ',PushCount,' Score: ',Score,'  Pushes: ',Solver.PushCount,'  Positions: ',Positions.Count);
              Readln;
              end;
}
           end;

        if (RelativeDepth__<>0) and                                             {'<>': this isn't the base position which is handled by the caller, i.e., either added to the open-list or expanded at once}
           (Position__^.PushCount+Game.SimpleLowerBound<=Solver.SearchLimits.DepthLimit) and
//         (Position__^.Score>=Low (Positions.OpenPositions.Buckets)) and
           (Position__^.Score<=High(Positions.OpenPositions.Buckets)) then with Position__^ do begin
           {if (Ord(Move.Direction) and POSITION_OPEN_TAG=0) then} OPENAdd(Position__); {put the position on the open-queue}
           Inc(Positions.SearchStatistics.Enqueue1Count);
           PackingOrder.SetNo:=PackingOrderSetNo__;
           Inc(UInt8(Move.Direction),POSITION_PACKING_ORDER_TAG);
           end;
      end; {Search.ForwardSearch.Search.PackingOrderSearch}
*)
(*
      function  PackingOrderSearch(Position__:PPosition; PackingOrderSetNo__,RelativeDepth__,PlayersReachableSquaresIndex__,FirstSetMemberIndex__,LastSetMemberIndex__:Integer):Integer;
      {precondition: player's reachable squares have been calculated for this depth, which is 'PlayersReachableSquaresIndex__'; it may differ from 'Position__^.PushCount'}
      var //Index,
          BoxToSquare,PlayerFromSquare,GoalNo,i,Index,j,PositionScore,//Col,Row,
          SuccessorPlayersReachableSquaresIndex,SuccessorPushCount,SuccessorScore,Square:Integer;
          Direction:TDirection; SuccessorPosition:PPosition;
      begin {Search.ForwardSearch.Search.PackingOrderSearch}
//{
//      if Game.HashValue=4317490461407458846 then begin
//      if Positions.Count>=33650 then begin
        if (Solver.PushCount>=0) then begin //and (RelativeDepth__<>0) then begin
//      if xyz and (RelativeDepth__<>0) then begin
           ShowBoard;
           Writeln(Cardinal(Position__),SPACE,Game.HashValue);
           Write('PO Depth: ',Position__^.PushCount,' Score: ',Position__^.Score,' Positions: ',Positions.Count,' Pushes: ',Solver.PushCount,' Open: ',Positions.OpenPositions.Count);
           //Writeln;
           if   HasPushCreatedANewCorralDeadlock(Position__) then
                Write(' Deadlock')
           else Write(' OK');
           Readln;
           end;
//}
{
        for Index:=1 to High(Game.SolutionPathHashValues) do // testing original solution...
            if Game.SolutionPathHashValues[Index]=0 then
               break
            else if Game.HashValue=Game.SolutionPathHashValues[Index] then begin
                    if Index >= 0 then begin
                       ShowBoard;
                       Write('PO: Solution path ',Index,SLASH,Position__^.PushCount,' Pushes: ',Solver.PushCount,' Score: ',Position__^.Score);
                       //if   Index=141 then
                       //     Readln
                       //else Writeln;
                       Readln;
                       Positions.DebugPosition:=Position__;
                       end;
                    break;
                    end;
}
        Position__^.PackingOrder.SetNo:=PackingOrderSetNo__;
        Square:=Game.BoxPos[Position__^.Move.BoxNo];

        if Integer(Game.Board[Square] shr GOAL_BIT_SHIFT_COUNT)<>PackingOrderSetNo__ then begin {'True': the box hasn't reached one of the target squares in the current packing order goal set}
           Result:=0;
           PositionScore:=Position__^.Score;
           if (Position__^.PushCount+Game.SimpleLowerBound<Solver.SearchLimits.DepthLimit) and
              (PositionScore<=High(Positions.OpenPositions.Buckets)) and
              (PlayersReachableSquaresIndex__<MAX_HISTORY_BOX_MOVES) then
              with Position__^ do with Solver.SearchStates[PlayersReachableSquaresIndex__].PlayersReachableSquares do begin
                  Inc(UInt8(Move.Direction),POSITION_PATH_TAG);                 {mark the position as a member of the currently investigated path}
                  SuccessorPushCount:=Succ(PushCount);
                  SuccessorPlayersReachableSquaresIndex:=Succ(PlayersReachableSquaresIndex__);

                  //Game.History.Moves[PushCount].Move.BoxNo:=BoxNo__;          {update game history}

                  for Direction:=Low(Direction) to High(Direction) do begin
                      PlayerFromSquare:=Square-Game.SquareOffsetForward[Direction];
                      BoxToSquare     :=Square+Game.SquareOffsetForward[Direction];
                      if (Result=0) {'True': no path to a target square has been found yet}
                         and
                         {inline simple checks for legal moves}
                         (Squares[PlayerFromSquare]=TimeStamp){'= TimeStamp': the player can reach the neighbor-square}
                         and
                         ((Game.Board[BoxToSquare] and (BOX+WALL+FLAG_ILLEGAL_BOX_SQUARE))=0) then begin {'=0' the square is legal and not blocked by a wall or another box}

                         GoalNo:=0;

                         Index:=FirstSetMemberIndex__;
                         while Index<=LastSetMemberIndex__ do begin
                           GoalNo:=Solver.PackingOrder.SetMembers[Index];
                           if   (Game.Board[Game.GoalPos[GoalNo]] and BOX)=0 then begin {'True': the goal/parking square doesn't contain a box}
                                i         :=Solver.PackingOrder.SquareGoalDistance[Square           ,GoalNo];   {distance from the box position to the target square}
                                j         :=Solver.PackingOrder.SquareGoalDistance[BoxToSquare      ,GoalNo]-i; {difference between the new and old distance to the target square}
                                if        j<0 then {'True': moving the box in this direction brings it closer to the goal}
                                          break {quick-and-dirty exit the 'while' loop when a goal candidate has been found}
                                else if   j=1 then begin {'True': moving the box in this direction brings it 1 square farther away from the goal}
                                          j:=Solver.PackingOrder.SquareGoalDistance[PlayerFromSquare,GoalNo];
                                          if   (j-i>1)
                                               and
                                               (j<High(Solver.PackingOrder.SquareGoalDistance[PlayerFromSquare,GoalNo])) then begin {'<High': there is a box path from the 'playerFromSquare' to the goal/parking square}
                                               {moving the box in this direction (probably) brings
                                                it closer to the target square, even though the push
                                                numerically brings the box farther away;

                                                the scenario can be like this excerpt from
                                                the level "Original 35" by "Thinking Rabbit":

                                                #-#p#### 'p': player
                                                #-gb---# 'g': goal/parking square
                                                #-#-##-# 'b': box
                                                #-#----#
                                                #-#---##
                                                -#-#---# game state: before the push
                                                -#-##### push direction: down

                                                the distances to the target square 'g':
                                                #-#4#### '4': player square
                                                #-01---# '0': goal/parking square
                                                #-#2##-# '2': box 'to' square
                                                #-#----# '1': box 'from' square
                                                #-#---##
                                                -#-#---# game state: before the push
                                                -#-##### push direction: down

                                                the facts that...
                                                * the squares '2' - '1' = 1, and
                                                * the squares '4' - '1' > 1
                                                indicates that the push (probably)
                                                brings the box closer to the target square;
                                               }
                                               break; {quick-and-dirty exit the 'while' loop when a goal candidate has been found}
                                               end
                                          else GoalNo:=0;
                                          end
                                     else GoalNo:=0;
                                end
                           else GoalNo:=0;
                           Inc(Index);
                           end;
{{
                         Distance:=INFINITY;
                         for Index:=FirstSetMemberIndex__ to LastSetMemberIndex__ do begin
                             GoalNo:=Solver.PackingOrder.SetMembers[Index];
                             if (Game.Board[Game.GoalPos[GoalNo]] and BOX)=0 then begin {'True': the goal square doesn't contain a box}
                                i:=Solver.PackingOrder.SquareGoalDistance[BoxToSquare,GoalNo];
                                if (i<Distance) and
                                   (i<=Solver.PackingOrder.SquareGoalDistance[Square,GoalNo]) then
                                   Distance:=i;
                                end;
                             end;

                         if (Distance<>INFINITY)                                {'True': pushing the box in the current direction brings it closer to one of the goals in the goal set that should be filled next according to the packing order}
}}
                         if (GoalNo<>0)                                         {'True': pushing the box in the current direction brings it closer to the goal 'GoalNo'}
                            and
                            {extended checks for legal moves}
                            IsALegalPush(Move.BoxNo,Direction,SuccessorPlayersReachableSquaresIndex) then

                            if Solver.PushCount<Solver.SearchLimits.PushCountLimit then begin {limit not exceeded}

                               //Game.History.Moves[PushCount].Direction:=Direction; {update game history}
                               DoPush(Move.BoxNo,Direction,SuccessorPlayersReachableSquaresIndex); {do the move, i.e., update the board}
{{
                               SuccessorScore:= SuccessorPushCount              {'SuccessorPushCount + Game.SimpleLowerBound' is the normal score for a position}
                                                +Game.SimpleLowerBound
                                                -Game.DistanceToNearestGoal[BoxToSquare] {subtract the normal contribution to 'Game.SimpleLowerBound' for this box}
                                                +Solver.PackingOrder.SquareGoalDistance[BoxToSquare,GoalNo] {the distance to the designated goal}
                                                -Game.PackingOrderPushCount;    {packing-order pushes on current path; by subtracting them it only counts as a single push to bring the box closer to the designated goal}
                                                //-RelativeDepth__;             {prefer positions where the box is closer to the designated goal square}

}}
                               SuccessorScore:=PositionScore
                                               +Game.DistanceToNearestGoal[BoxToSquare]
                                               -Game.DistanceToNearestGoal[Square];
                               if SuccessorScore<PositionScore then SuccessorScore:=PositionScore;

{{
                               {successor score := (parent score) + (1 push) - (1 point for getting closer to the designated goal) + (difference between the lower bound for the new position and the parent position)}
                               SuccessorScore   :=PositionScore //Succ(PositionScore)
                                                  +Game.DistanceToNearestGoal[BoxToSquare]
                                                  -Game.DistanceToNearestGoal[Square];
                               if SuccessorScore<PositionScore then
                                  SuccessorScore:=PositionScore;
}}

{{
                               if   (Game.Board[Square        ] shr GOAL_BIT_SHIFT_COUNT)
                                    >=                                               {'>=': the calculated packing order, if any, doesn't indicate that this brings the box closer to a square that should be filled first}
                                    (Game.Board[BoxToSquare   ] shr GOAL_BIT_SHIFT_COUNT) then
                                    SuccessorScore:=     SuccessorPushCount +Game.SimpleLowerBound-Game.PackingOrderPushCount
                               else {'<': the box moves to a square that according to the calculated packing order should be filled first}
                                    SuccessorScore:=Pred(SuccessorPushCount)+Game.SimpleLowerBound-Game.PackingOrderPushCount;
}}
{{
                               SuccessorScore:=((SuccessorPushCount              {'SuccessorPushCount + Game.SimpleLowerBound' is the normal score for a position}
                                                 -Game.PackingOrderPushCount    {packing-order pushes on current path; by subtracting them it only counts as a single push to bring the box closer to the designated goal}
                                                )
                                                div
                                                2
                                               )
                                                +Game.SimpleLowerBound
                                                -Game.DistanceToNearestGoal[BoxToSquare] {subtract the normal contribution to 'Game.SimpleLowerBound' for this box}
                                                +Solver.PackingOrder.SquareGoalDistance[BoxToSquare,GoalNo] {the distance to the designated goal}

                                                //-RelativeDepth__;             {prefer positions where the box is closer to the designated goal square}
                                                ;
}}
                               Inc(Solver.PushCount);                              {update statistics}

//                             WriteBoardToLogFile('PO '+IntToStr(Solver.PushCount)+SPACE+IntToStr(Positions.Count)+' Score: '+IntToStr(SuccessorScore));

                               if (Solver.PushCount and (ONE_MEBI-1))=0 then begin
                                  {$IFDEF CONSOLE_APPLICATION}
                                    Write(Reader.LevelCount,': Depth: ',Position__^.PushCount);
                                    Write(' Score: ',Position__^.Score);
                                    Write(' Pushes: ',Solver.PushCount div ONE_MILLION,' million');
                                    if   Positions.SearchStatistics.ReuseCount=0 then
                                         Write(' Positions: ',Positions.Count)
                                    else Write(' Reused positions: ',Positions.SearchStatistics.ReuseCount);
                                    {Write(' Time: ',(CalculateElapsedTimeMS(Solver.StartTimeMS,GetTimeMS)+500) div 1000);}
                                    Writeln;
                                  {$ENDIF}

                                  TimeCheck;
                                  end;

                               if (SuccessorScore<=Solver.SearchLimits.DepthLimit) and
                                  (SuccessorPushCount+Game.SimpleLowerBound<=Solver.SearchLimits.DepthLimit) then begin
                                  UsePlayersReachableSquaresFromPredecessor:=
                                    (Solver.SearchStates[PlayersReachableSquaresIndex__].PlayersReachableSquares.Squares[BoxToSquare]
                                     <> // '<>': in the position 'Position__' (before the move [Move.BoxNo, Direction]), the player cannot reach the other side of the box
                                     Solver.SearchStates[PlayersReachableSquaresIndex__].PlayersReachableSquares.TimeStamp
                                    )
                                    or
                                    (((Game.Board[BoxToSquare+Game.SquareOffsetRight[Direction]] and (WALL+BOX))<>0)
                                     and
                                     ((Game.Board[BoxToSquare+Game.SquareOffsetLeft [Direction]] and (WALL+BOX))<>0)
                                    );
                                  Inc(Solver.ReusePlayersReachableSquaresFromPredecessorCount[UsePlayersReachableSquaresFromPredecessor]);

                                  if not Solver.SearchStates[SuccessorPlayersReachableSquaresIndex].PlayersReachableSquares.Calculated then
                                     CalculatePlayersReachableSquares(SuccessorPlayersReachableSquaresIndex); {find the player's reachable squares}

                                  {SuccessorPosition:=nil;}                     {not necessary, 'TTAdd' sets it to 'nil'}

                                  {try to add the successor position to the transposition table;}
                                  {if it already is in the table, then 'TTAdd' returns}
                                  {'False' and the existing position in 'SuccessorPosition'}
                                  if TTAdd(Game.HashValue,                      {hash signature for this position}
                                           //Solver.SearchStates[SuccessorPushCount].PlayersReachableSquares.MinPlayerPos, {normalized (top-left) player position}
                                           Game.PlayerPos,                      {player position; note that this isn't the normalized (top-left) player position; 'SetPosition' depends on having the true player position after the push}
                                           SuccessorPushCount,                  {pushes = depth}
                                           SuccessorScore,                      {pushes + heuristic estimate}
                                           Move.BoxNo,                          {moved box}
                                           Direction,                           {box direction}
                                           Position__,                          {parent node}
                                           SuccessorPosition) then begin        {'SuccessorPosition' is the new saved position}

//                                   WritelnToLogFile('New '+IntToStr(Positions.Count));

                                     SuccessorScore:=SuccessorPosition^.Score;  {'Score' is 0 for perimeter-nodes from a search in the opposite direction, hence, retrieve the actually saved score for the position}
{
                                     if       Game.HashValue=1652664153217381026 then begin
                                              Positions.DebugPosition:=SuccessorPosition;
                                              ShowBoard;
                                              Writeln('PO Debug: ',Positions.Count,SPACE,Solver.PushCount,' Pushes: ',SuccessorPushCount,' Score: ',SuccessorScore,SPACE,Game.SimpleLowerBound,SPACE,Game.PackingOrderPushCount,SPACE,Solver.PushCount);
                                              Readln;
                                              end;
}
                                     if       (Game.SimpleLowerBound<>0) and (SuccessorScore<>0) then begin {'True': not a solution}
                                              if not Game.DeadlockSets.NewDynamicDeadlockSets then {'True':  no new deadlock sets have been created after the main search loop retracted a node from the open-list}
                                                 Result:=PackingOrderSearch(SuccessorPosition,PackingOrderSetNo__,Succ(RelativeDepth__),SuccessorPlayersReachableSquaresIndex,FirstSetMemberIndex__,LastSetMemberIndex__);
{
                                              if Result=0 then with SuccessorPosition^ do begin // 'Result=0': the box didn't make it all the way to one of the designated goal squares
                                                 SuccessorScore:=SuccessorPushCount+Game.SimpleLowerBound-Game.PackingOrderPushCount; // the normal evaluation heuristic when packing order isn't considered
                                                 if SuccessorScore<Score then begin
                                                   if   (Ord(Move.Direction) and POSITION_OPEN_TAG)<>0 then begin
                                                        OPENRemove(SuccessorPosition);
                                                        Score:=SuccessorScore;
                                                        OPENAdd(SuccessorPosition);
                                                        end
                                                   else Score:=SuccessorScore;
                                                   end;
                                                 end;
}
                                              end
                                     else  if Game.SimpleLowerBound<>0 then begin  {'True': a perimeter-position from a search in the opposite direction}
                                              SuccessorScore:=SuccessorPushCount+  {'PathLengthToSolution' contains distance to the goal-position}
                                                              SuccessorPosition^.PathLengthToSolution;
                                              if (Positions.SolutionPosition=nil)
                                                 or
                                                 (Cardinal(SuccessorScore) <
                                                  (Positions.SolutionPosition^.PushCount+
                                                   Positions.SolutionPosition^.PathLengthToSolution))
                                                 or
                                                 (SuccessorPosition=Positions.SolutionPosition) {'=': new cheaper path to the already found perimeter-position}
                                                 then begin {new or first found solution}
                                                 Positions.SolutionPosition:=SuccessorPosition;
                                                 Solver.SearchLimits.DepthLimit:=SuccessorScore;
                                                 Solver.SokobanStatusPointer^.Flags:=SOKOBAN_PLUGIN_FLAG_SOLUTION;
                                                 SetSokobanStatusText(TEXT_SOLUTION_INFO_1+IntToStr(SuccessorScore)+TEXT_SOLUTION_INFO_2);
                                                 OPENDropPositions(Solver.SearchLimits.DepthLimit);{prune the open-queue and the transpostion-table; there is no need to search paths longer than or equal to the best found solution}
                                                 //TerminateSearch; //testing
                                                 end;
                                              end
                                     else  begin                                {lower bound = 0, i.e., it's the goal position}
                                             Positions.SolutionPosition:=SuccessorPosition;
                                             TerminateSearch;
                                             //Positions.OpenPositions.Count:=0;   {'0': signals an exhaustive search, i.e., an optimal solution}
                                           end;
                                     end
                                  else                                          {the position wasn't added to the transposition table}
                                     if SuccessorPosition<>nil then with SuccessorPosition^ do begin {'True': the position already exists in the transposition table}
                                        if Game.SimpleLowerBound<>0 then begin  {'True': not a solution}
                                           if (SuccessorPushCount<=PushCount) and
                                              ((Ord(Move.Direction) and (POSITION_OPEN_TAG+POSITION_PATH_TAG+POSITION_PACKING_ORDER_TAG))=0) and
                                              (not Game.DeadlockSets.NewDynamicDeadlockSets) then begin {'True': no new deadlock sets have been created after the main search loop retracted a node from the open-list}
                                              Result:=PackingOrderSearch(SuccessorPosition,PackingOrderSetNo__,Succ(RelativeDepth__),SuccessorPlayersReachableSquaresIndex,FirstSetMemberIndex__,LastSetMemberIndex__);
                                              end;
                                           end
                                        else begin                              {start-position = goal-position, or a shorter path to an existing position}
                                           {if this is the start-position then modify it so it contains this last move leading to the solution}
                                           PushCount        :=SuccessorPushCount;
                                           Score            :=SuccessorPushCount;
                                           Parent           :=Position__;       {handle with care: if this is the start-position, then the solution is now a circular list}
                                           Move.BoxNo       :=Position__^.Move.BoxNo;
                                           Move.Direction   :=Direction;
                                           Positions.SolutionPosition:=SuccessorPosition;

                                           TerminateSearch;
                                           //Positions.OpenPositions.Count:=0;  {'0': signals an exhaustive search, i.e., an optimal solution}
                                           end
                                        end
                                     else                                       {the transposition table is full}
                                        if Solver.ReuseNodesEnabled then begin
                                           if SuccessorScore<Position__^.BestForgottenScore then
                                              Position__^.BestForgottenScore:=SuccessorScore; {the successor-position wasn't stored; remember the best forgotten score}
                                           end
                                        else TerminateSearch;                   {stop searching when the transposition table is full}
                                  end
                               else begin                                       {search depth limit exceeded}
                                  if (Solver.SearchLimits.DepthLimit>=0) and                 {'>=0': the search hasn't been terminated}
                                     (SuccessorPushCount+Game.SimpleLowerBound>OriginalDepthLimit) then {'>OriginalDepthLimit': 'Solver.SearchLimits.DepthLimit' may have been lowered after finding a solution}
                                     Inc(Solver.LimitExceededPushCount);
                                  end;

                               UndoPush(Move.BoxNo,Direction);                  {take back the move, i.e., update the board}
                               end
                            else begin                                          {push count limit exceeded}
                               if Solver.SearchLimits.DepthLimit>=0 then        {'>=0': the search hasn't been terminated}
                                  Inc(Solver.LimitExceededPushCount);
                               end;
                         end;
                      end;

                  Dec(UInt8(Move.Direction),POSITION_PATH_TAG);                 {remove the 'current path' tag}
                  end;
           end
        else with Position__^ do begin                                          {the box arrived at a target square}
           if Game.SimpleLowerBound<>0 then begin                               {'<>': not a solution}
              if   RelativeDepth__<Score then
                   Score:=Score-RelativeDepth__                                 {all the pushes leading to the target square are packing order pushes; subtract them from the score to give the position a substantial bonus}
              else Score:=1;

              if ((Game.Board[Square] and GOAL)<>0) and                         {'True': the box is pushed to a goal square}
                 IsAFreezingMove(0,Square,True) then                            {'True': the box freezes at the goal square}
                 TTAddFrozenGoalsPattern(Position__);                           {collect frozen goals patterns and check for deadlocks}
              end;
           Result:=RelativeDepth__;
{
//         if Game.HashValue=6863522399279464882 then begin
           if Solver.PushCount>=0 then begin
//         if Positions.DebugPosition<>nil then begin
//         if Position__^.PushCount>=0 then begin
//         if Positions.Count>1*ONE_MILLION then begin

              ShowBoard;
              Writeln(Cardinal(Position__),SPACE,Game.HashValue);
              SquareToColRow(Square,Col,Row);
              Writeln('Square: ',Square,' = [',Col,COMMA,Row,']');
              Write('PO!: Depth: ',PushCount,' Score: ',Score,'  Pushes: ',Solver.PushCount,'  Positions: ',Positions.Count,' Packing order: ',PackingOrderSetNo__);
              Readln;
              //Positions.DebugPosition:=Position__;
              end;
}
           end;

        if (RelativeDepth__<>0) and                                             {'<>': this isn't the base position which is handled by the caller, i.e., either added to the open-list or expanded at once}
           (Position__^.PushCount+Game.SimpleLowerBound<=Solver.SearchLimits.DepthLimit) and
//         (Position__^.Score>=Low (Positions.OpenPositions.Buckets)) and
           (Position__^.Score<=High(Positions.OpenPositions.Buckets)) and
           ((Ord(Position__^.Move.Direction) and (POSITION_OPEN_TAG+POSITION_PATH_TAG+POSITION_PACKING_ORDER_TAG))=0) then
           with Position__^ do begin
             {if (Ord(Move.Direction) and POSITION_OPEN_TAG=0) then} OPENAdd(Position__); {put the position on the open-queue}
             Inc(Positions.SearchStatistics.Enqueue1Count);
             PackingOrder.SetNo:=PackingOrderSetNo__;
             Inc(UInt8(Move.Direction),POSITION_PACKING_ORDER_TAG);
             end;
      end; {Search.ForwardSearch.Search.PackingOrderSearch}
*)
    function MinimumDistanceToGamePhaseTargetSquares( Position__ : PPosition ) : Integer;
    var Index:Integer;
    begin
      Result := High( Result );
      with Game do with Solver.PackingOrder do
        for Index := FirstSetMemberIndex[ Position__^.PackingOrder.SetNo ] to
                     Pred( FirstSetMemberIndex[ Succ( Position__^.PackingOrder.SetNo ) ] ) do
            Result := Min( Result,  SquareGoalDistance[ BoxPos[ Position__^.Move.BoxNo ], DistancesBasedOnPackingOrder + SetMembers[Index] ] );
      if Result = High( Result ) then
         Result := -1;
    end;

    procedure CalculatePackingOrderPhaseAndScore(Position__:PPosition; FromSquare__,ToSquare__:Integer);
    {preconditions:
     1. 'Position__' is the result of pushing a box from 'FromSquare__' to 'ToSquare__';
     2. 'Position__^.PackingOrder.SetNo' contains the game phase before the push;
    }
    var Distance,EmptySquaresCount,FilledSquaresCount,GamePhase,GoalNo,
        i,Index,LastSetMemberIndex,Score,SetMemberSquare,SquarePhase:Integer;
    begin
      with Game do with Solver.PackingOrder do begin
        GamePhase:=Position__^.PackingOrder.SetNo;                              {game phase before the push}

        GoalNo:=Board[FromSquare__] shr GOAL_BIT_SHIFT_COUNT;                   {get the goal/parking place number, if any, for the 'from' square}
        SquarePhase:=GoalSetNo[GoalNo];                                         {get the square phase number, if any; if the square is a target square in more than one phase, then the number in 'GoalSetNo[]' is the highest phase for the square}

        if SquarePhase>=GamePhase then begin                                    {'True': the box is leaving a square which was filled in this game phase or an earlier game phase}
           if SquarePhase>GamePhase then                                        {'True': the box leaves a square which was filled in an earlier and already completed game phase}
              repeat GoalNo      :=NextGoalAtSameSquare[GoalNo];                {find the lowest square-phase which is greater than or equal to the current game phase}
                     SquarePhase :=GoalSetNo[GoalNo];
              until  SquarePhase >=GamePhase;                                   {same-square targets are linked in ascending order by a circular list, and the highest valued goal number entered the loop first, so this terminating criteria will do}

           if   SquarePhase>GamePhase then                                      {'True': the box leaves a square which was filled in an earlier game phase}
                if   ParkedBoxDestinationGoalSetNo[GoalNo]<GamePhase then       {'True': the box should stay at its current position until the game phase advances (decreases) to 'ParkedBoxDestinationGoalSetNo[GoalNo]'}
                     GamePhase:=SquarePhase                                     {retreat (increase) to the most recent phase phase where the 'FromSquare__' square should be filled}
                else
           else {SquarePhase = GamePhase}                                       {the box leaves a square which should be filled in this game phase}
                if GamePhase<Solver.PackingOrder.SetCount then                  {'True': this isn't the start (highest) game phase}
                   if   GoalSetNo[NextGoalAtSameSquare[GoalNo]]>GamePhase then  {'True': the square should be filled in an earlier (higher) phase}
                        GamePhase:=GoalSetNo[NextGoalAtSameSquare[GoalNo]];     {retreat (increase) to the earlier phase where the 'from' square should be filled}

           Position__^.PackingOrder.SetNo:=GamePhase;                           {retreat to the game phase which was destroyed by moving the box away from 'FromSquare__'}
           Position__^.PackingOrder.SetMemberIndex:=0;                          {clear the existing 'last unfilled set member index', if any}
           end;

        LastSetMemberIndex:=Pred(FirstSetMemberIndex[Succ(GamePhase)]);         {the last goal/parking space member index for the current packing order phase}

        Score:=0; Distance:=High(SquareGoalDistance[ToSquare__,GoalNo]);        {initialize 'Distance' to 'INFINITY' which in this case with the byte-sized SquareGoalDistance[,]' array is '255'}
        FilledSquaresCount:=0; EmptySquaresCount:=0;                            {calculate empty and filled squares for the phase}
        for Index:=FirstSetMemberIndex[GamePhase] to LastSetMemberIndex do begin {for each target square for the current phase}
            GoalNo:=SetMembers[Index];                                          {get a target (goal or parking square) belonging to this phase}
            SetMemberSquare:=GoalPos[GoalNo];                                   {get the square number for the target}
            if (Board[SetMemberSquare] and BOX)=0 then begin                    {'True': no box at this square}
               Inc(EmptySquaresCount);

               i  :=SquareGoalDistance[ToSquare__  ,DistancesBasedOnPackingOrder+GoalNo]; {the distance from the new box square to the target square}
               if i<Distance then Distance:=i;                                  {'True': this is a new/first closest target; remember its distance}
               if i<SquareGoalDistance[FromSquare__,DistancesBasedOnPackingOrder+GoalNo] then Inc(Score); {'True': pushing the box in this direction brings it closer to this goal/parking square}

               Position__^.PackingOrder.SetMemberIndex:=Index;                  {update the 'last unfilled set member' index for the position}
               end
            else begin
               Inc(FilledSquaresCount);
               if SetMemberSquare=ToSquare__ then begin                         {'True': pushing the box in this direction brings it to this goal/parking square}
                  Inc(Score);
                  Distance:=0;
                  end;
               end;
            end;

        if  Score>0 then begin                                                  {'True': the push brought the box closer to one or more of the target squares which should be filled during the current packing order phase}
            UInt8(Position__^.Move.Direction):=UInt8(Position__^.Move.Direction) or POSITION_PACKING_ORDER_TAG; {mark the position as the result of a packing order push; successive packing order pushes only count as 1 push}
            end;

        if  EmptySquaresCount=0 then begin                                      {'True': all target squares for the current game phase have been filled}
            if GamePhase>0 then begin
               Position__^.PackingOrder.SetNo:=Pred(GamePhase);                 {advance (decrease) to the next packing order phase}
               CalculatePackingOrderPhaseAndScore(Position__,0,0);              {recurse; the next phase may already be complete; it not, the calculation of the score should take the new improved phase number into account}
               end;
            end
        else begin
            {update the score by taking the packing order phase into account}
            Dec(Position__^.Score,                                              {give a bonus for the completed squares in this game phase}
                (GoalAndParkingSquareCount-LastSetMemberIndex                   {the number of target squares for the completed phases (the squares are not necessarily filled anymore; parked boxes may have moved towards their goals)}
                 +FilledSquaresCount                                            {the number of filled target squares for the current game phase}
                )
                *
                EMPTY_GOAL_PENALTY                                              {before this bonus is deducted, the score contains the penalty 'MAX_BOX_COUNT * EMPTY_GOAL_PENALTY'}
               );

            if Distance<High(SquareGoalDistance[ToSquare__,GoalNo]) then begin  {'True': the distance isn't 'INFINITY', where 'INFINITY' may just mean that the distance is too big to be recorded in the square->goal table with its byte-sized elements}
               {give a penalty for the distance to the nearest of the target
                squares for this game phase;

                the 'times 2' factor is there for winning over a bonus given in
                'SimpleLowerBound' for getting closer to one of the final
                goal squares;

                the 'Succ()', i.e., '+1' is there for winning over a
                'SimpleLowerBound' bonus, also when 'Distance' = 0;
               }
               Inc(Position__^.Score,2*Succ(Distance));
               end
            else begin
               {give a penalty for pushing a box which cannot reach any of the
                target squares for this game phase;
               }
               Inc(Position__^.Score,8);
               end;
            if Score<=Position__^.Score then Dec(Position__^.Score,Score);      {give a bonus for getting closer to the target squares for this game phase}

            if Position__^.Score> High(Positions.OpenPositions.Buckets) then
               Position__^.Score:=High(Positions.OpenPositions.Buckets);        {clamp the score to fit the buckets in the OPEN table}
            end;
        end;

    end; {Search.ForwardSearch.Search.CalculatePackingOrderPhaseAndScore}

    begin {Search.ForwardSearch.Search}
{
//   if (Game.HashValue=3563177739092011630) then begin
//   if Positions.Count>=1*ONE_MILLION then begin
//     if ( (Solver.PushCount mod (10*ONE_KIBI))=0 ) then begin
//   if ( IsABoxSquare( 153 ) and IsABoxSquare( 194 ) and IsABoxSquare( 216 ) and IsABoxSquare( 218 ) ) then begin
     if ((Solver.PushCount mod (25*ONE_THOUSAND))=0) //or (Positions.Count>=8165105)
        //or ((Position__^.PackingOrder.SetNo<=10) and (Solver.PushCount>=00000))
        then begin
//   if (Solver.PushCount mod (100*ONE_THOUSAND))=0 then begin
//   if (Solver.PushCount>=0) and ( ( Solver.PushCount mod 1 ) = 0 ) then begin
         //Game.ShowDeadlockSetsEnabled:=True;
         //with Game.DeadlockSets do ShowDeadlockSet(5,CenterSquare[5]);
         //Game.ShowDeadlockSetsEnabled:=False;
         ShowBoard;
         Writeln(Cardinal(Position__),SPACE,Game.HashValue,
                 SPACE,Positions.SearchStatistics.CalculateCorralDeadlockStatusCount,
                 SPACE,Game.DeadlockSets.Count,
                 SPACE,MinimumDistanceToGamePhaseTargetSquares( Position__ ),
                 SPACE,Position__^.PackingOrder.SetNo);
         Write('Forwards  ');
         Write('Depth: ',Position__^.PushCount,SPACE,Position__^.PushCount-Positions.CurrentPosition^.PushCount,SPACE,Game.PackingOrderPushCount,
                 ' Score: ',Position__^.Score,
                 ' Positions: ',Positions.Count,
                 ' Pushes: ',Solver.PushCount,
                 ' Open: ',Positions.OpenPositions.Count,
                 ': ',Positions.OpenPositions.MinValue
//               ' Reused: ',Positions.SearchStatistics.ReuseCount
               );
         Writeln;
         //if (Positions.Count>=8165105) then Readln;
         //if (Position__^.PackingOrder.SetNo<=10) and (Solver.PushCount>=00000) then
         //   Readln;
         end;
}
{
         for Index:=1 to High(Game.SolutionPathHashValues) do // testing original solution...
             if Game.SolutionPathHashValues[Index]=0 then
                break
             else if Game.HashValue=Game.SolutionPathHashValues[Index] then begin
                     if Index >= 0 then begin
                        ShowBoard;
                        Write('Solution path ',Index,SLASH,Position__^.PushCount,SPACE,Game.HashValue,' Pushes: ',Solver.PushCount);
                        Writeln; Readln;
                        Positions.DebugPosition:=Position__;
                        end;
                     break;
                     end;
}
{
      // test that recursion doesn't overflow the stack;
      // (calls to sub-functions are not a part of the test, hence, some surplus
      // is required)
      if Position__^.PushCount<=High(Solver.SearchStates) then begin
         Writeln(Position__^.PushCount,SPACE,Cardinal(Addr(BoxNo)));
         Inc(Position__^.PushCount);
         Search(Position__);
         end
      else begin
         Writeln(Position__^.PushCount,SPACE,Cardinal(Addr(BoxNo)));
         Readln;
         Halt;
         end;
}
      if Position__^.PushCount>Solver.HighestSearchDepth then
         Solver.HighestSearchDepth:=Position__^.PushCount;

      OldPositionCount:=Positions.Count; OldPushCount:=Solver.PushCount;
      CorralBoxCount:=0; RoomNo:=0;

      if Position__^.PushCount{+Game.SimpleLowerBound}<Solver.SearchLimits.DepthLimit then begin
         Result:=DEADLOCK_SCORE;

         Positions.OpenPositions.WorstRover:=nil;

         PositionScore:=Position__^.Score;

         LastPushedBoxNo:=Position__^.Move.BoxNo;

         {set packing order, if any}
         with Position__^.PackingOrder do begin
           if (SetNo<>0) and (SetMemberIndex=0) then begin
              SetMemberIndex:=Solver.PackingOrder.FirstSetMemberIndex[Succ(SetNo)];
              i             :=Solver.PackingOrder.FirstSetMemberIndex[SetNo];
              repeat Dec(SetMemberIndex);
                     if SetMemberIndex<i then begin {advance (decrease) to the next packing order phase}
                        Dec(SetNo);
                        i:=Solver.PackingOrder.FirstSetMemberIndex[SetNo];
                        end;
              until  (Game.Board[Game.GoalPos[Solver.PackingOrder.SetMembers[SetMemberIndex]]] and BOX)=0; {until the goal doesn't contain a box, or until all goals have been tested}
              end;
           end;

        {check for tunnel pushes}
        with Game do begin
           Square := BoxPos[LastPushedBoxNo];
           Direction := TDirection(Ord(Position__^.Move.Direction) and DIRECTION_BIT_MASK);
           {having 'SuccessorPushCount:=...' in both forks of the following}
           {'if'-statement may look strange but the rationale is that since an}
           {'if' cannot be avoided here, the normal case should at least "fall}
           {through" in order to avoid cpu stalling; therefore, the assignment}
           {has been put into the 'if' so there is something to do in both of}
           {the branches}
           if (Board[Square] and DIRECTION_TO_TUNNEL_FLAG[Direction])=0 then
              SuccessorPushCount:=Succ(Position__^.PushCount)
           else with Solver.SearchStates[Position__^.PushCount].PlayersReachableSquares do begin
              SuccessorPushCount:=Succ(Position__^.PushCount);

              if ( ( Board[ Square ] shr GOAL_BIT_SHIFT_COUNT ) = 0 )
                 or
                 {for goal tunnel squares, pruning all other box pushes should
                  only take place if the box physically can be pushed to the
                  next square in the tunnel
                 }
                 ( ( ( Board[ Square + SquareOffsetForward[ Direction ] ] and ( BOX + WALL + FLAG_ILLEGAL_BOX_SQUARE ) ) = 0 )
                   //and
                   //IsALegalPush( LastPushedBoxNo, Direction, SEARCH_STATE_INDEX_CORRAL_PRUNING ) {this "IsALegalPush" test must *not* be applied; if the move is illegal, then it must be made anyway, so the search detects that it's on a deadlocked path}
                 ) then begin;
                 {the box left a tunnel square, and therefore it's unnecessary}
                 {to generate moves for the other boxes; see 'CalculateTunnelSquares'}
                 {for figures depicting the situation}
                 for BoxNo:=1 to BoxCount do Squares[BoxPos[BoxNo]]:=0;         {mark all boxes as not being candidates for expansion in the current position}
                 Squares[Square]:=Succ(TimeStamp);                              {mark the last pushed box as the only candidate for expansion in the current position}
                 UInt8(Position__^.Move.Direction):=UInt8(Position__^.Move.Direction) or POSITION_REVISIT_TAG; {nodes marked for revisiting are not subject to box pruning, hence, setting the flag is one way to bypass the corral pruning below}
                 //ShowBoard;
                 //Write(DIRECTION_TO_TEXT[TDirection(Ord(Position__^.Move.Direction) and DIRECTION_BIT_MASK)]);
                 //Readln;
                 end;
              end;
           end;

         {try corral pruning:}
         {if there is a fenced-in area (a 'corral') on the board,}
         {   and all the boxes in the fence only can be pushed inside the corral,}
         {   and all these pushes are possible in the current position}
         {   (meaning the player's access to the boxes isn't blocked by other boxes),
         {   and the corral boxes aren't all located at goal squares,}
         {   then it suffices to generate these pushes because the corral boxes}
         {   must be pushed sooner or later anyway, and they don't influence the}
         {   program's ability to push the other boxes later}
//(*
         //CorralBoxCount:=0;
         if (Ord(Position__^.Move.Direction) and POSITION_REVISIT_TAG)=0 then begin
            BoxNo:=0;
            OldTimeStamp:=Solver.SearchStates[SEARCH_STATE_INDEX_CORRAL_PRUNING].PlayersReachableSquares.TimeStamp;
            while BoxNo<Game.BoxCount do
              with Solver.SearchStates[Position__^.PushCount].PlayersReachableSquares do begin
                Inc(BoxNo);
                Square:=Game.BoxPos[BoxNo];
                if Squares[Square]>=TimeStamp then                              // 'True': the player can reach this box
                   for Direction:=Low(Direction) to High(Direction) do begin    // investigate each of the box neighbor squares
                       NeighborSquare:=Square+Game.SquareOffsetForward[Direction]; // get the neighbor square, next to the box

                       // alternatively, find the next non-box square in this
                       // direction; it may spot a few extra corrals at the
                       // expense of a slightly increased running time;
                       // i:=Game.SquareOffsetForward[Direction];
                       // NeighborSquare:=Square;
                       // repeat Inc(NeighborSquare,i);                         // find the next non-box square in this direction
                       // until  Game.Board[NeighborSquare] and (BOX)=0;

                       if ((Game.Board[NeighborSquare] and (BOX+WALL))=0)       // 'True': and empty floor
                          and
                          (Squares[NeighborSquare]<>TimeStamp)                  // 'True': the floor isn't in the player's current access area
                          and
                          (OldTimeStamp>=Solver.SearchStates[SEARCH_STATE_INDEX_CORRAL_PRUNING].PlayersReachableSquares.Squares[NeighborSquare]) // 'True': the floor isn't in a corral that already has been investigated
                          then begin
                          // there is a 'corral' on the board, i.e., the boxes separate the empty floors on the board into different 'pockets'
                          with Solver.SearchStates[SEARCH_STATE_INDEX_CORRAL_PRUNING].PlayersReachableSquares do // 'CORRAL...STATE_INDEX': the 'CorralPruning' function uses this search-state array index to mark floors and boxes belonging to the corral
                            LowWaterBoxTimeStamp:=Succ(TimeStamp);              // 'Succ': the box timestamp, not the empty floor timestamp
                          //Writeln('Try direction ',DIRECTION_TO_CHAR[Direction]);
                          if CorralPruning(Position__,Position__^.PushCount,NeighborSquare,0,LowWaterBoxTimeStamp,nil,HasAllBoxesOnGoals,IsACombinedCorral,CorralMinPlayerPos,LowWaterBoxTimeStamp) then begin
                             // only generate pushes for boxes belonging to the corral

                             // note that 'LowWaterBoxTimeStamp' now has changed "<=" and ">=" logic;
                             // before calling 'CorralPruning()':
                             //   boxes flagged with a value <= 'LowWaterBoxTimeStamp' had not been investigated yet
                             // after returning from 'CorralPruning':
                             //   boxes flagged with a value >= 'LowWaterBoxTimeStamp' is a part of the corral

                             {$IFDEF DEBUG_CORRALS}
                               {$IFDEF CONSOLE_APPLICATION}
                                 if LowWaterBoxTimeStamp>=DebugThreshold then begin
                                    Writeln('Corral pruning:');
                                    ShowCorral(SEARCH_STATE_INDEX_CORRAL_PRUNING,LowWaterBoxTimeStamp);
                                    end;
                               {$ENDIF}
                             {$ENDIF}

                             //CorralBoxCount:=0; CorralHashValue:=0;
                             //SortedBoxSquares[0]:=0; //FillChar(PrunedBoxSet,SizeOf(PrunedBoxSet),0);

                             for BoxNo:=1 to Game.BoxCount do begin // filter out non-corral boxes before entering the generate-successors box-loop below
                                 Square:=Game.BoxPos[BoxNo];
                                 with Solver.SearchStates[SEARCH_STATE_INDEX_CORRAL_PRUNING].PlayersReachableSquares do
                                   if Squares[Square]<LowWaterBoxTimeStamp then begin {'True': the box isn't a part of the corral}
                                      Solver.SearchStates[Position__^.PushCount].PlayersReachableSquares.Squares[Square]:=0;
                                      //Include(PrunedBoxSet,BoxNo);
                                      end
                                   else begin
                                      //with Solver.SearchStates[Position__^.PushCount].PlayersReachableSquares do
                                      //  if Squares[Square]<TimeStamp then Squares[Square]:=Pred(TimeStamp);
                                      {
                                      Index:=CorralBoxCount; // sort box numbers in ascending order
                                      while Square<SortedBoxSquares[Index] do begin
                                        SortedBoxSquares[Succ(Index)]:=SortedBoxSquares[Index];
                                        Dec(Index);
                                        end;
                                      SortedBoxSquares[Succ(Index)]:=Square;
                                      }
                                      Inc(CorralBoxCount);
                                      //CorralHashValue:=CorralHashValue xor Positions.SquareHashValues[Square];
                                      end;
                                 end;

                             if   CorralBoxCount<Game.BoxCount then
                                  begin //Writeln('Corral pruning:');
                                        //if Solver.PushCount>=1082153 then
                                        //   ShowCorral(SEARCH_STATE_INDEX_CORRAL_PRUNING,LowWaterBoxTimeStamp);
                                        if CorralBoxCount=0 then RoomNo:=-1; {'True': the corral pruning found a deadlocked corral; don't try room-pruning}
                                        Inc(Solver.ExposedInwardsCorralCount1);
                                  end
                             else begin Inc(Solver.ExposedInwardsCorralCount2);
                                        //CorralBoxCount:=0;
                                  end;

                             {
                             CorralHashValue:=0;
                             for  Index:=1 to CorralBoxCount do
                                  CorralHashValue:=CorralHashValue xor Positions.SquareHashValues[SortedBoxSquares[Index]];
                             if   TTLookup(CorralHashValue,Solver.SearchStates[Position__^.PushCount].PlayersReachableSquares.MinPlayerPos,-Position__^.PushCount,SuccessorPosition) and
                                  (SuccessorPosition^.Score=DEADLOCK_SCORE) then begin
                                  LastPushedBoxNo:=MAX_BOX_COUNT+1;
                                  CorralBoxCount:=0;
                                  Inc(Solver.DeadEndDuplicatesCount);

                                  Writeln(Solver.DeadEndCount,SLASH,Solver.PushCount);
                                  ShowBoard;
                                  SquareToColRow(Solver.SearchStates[Position__^.PushCount].PlayersReachableSquares.MinPlayerPos,Col,Row);
                                  Write('Deadend ',CorralHashValue,SPACE,Col,',',Row);
                                  Readln;
                                  end;
                             }
                             if Solver.CorralSearchDepth=0 then Solver.HighestSearchDepth:=0;

                             {
                             if (Solver.PushCount>=5288582) or (Position__^.HashValue=5137934836441589523)  then
                                with Game do with Solver.SearchStates[Position__^.PushCount].PlayersReachableSquares do begin
                                  ShowCorral(Position__^.PushCount,TimeStamp);
                                  end;
                             }
                             BoxNo:=MAX_BOX_COUNT+1;                            {terminate the 'while' box loop}
                             break;                                             {terminate the 'for'  direction loop}
                             end
                          else begin {corral pruning failed for this box}
                             with Solver.SearchStates[SEARCH_STATE_INDEX_CORRAL_PRUNING].PlayersReachableSquares do // 'High': the 'CorralPruning' function uses this search-state to mark floors and boxes belonging to the corral
                               if TimeStamp<OldTimeStamp then begin             {timestamp wrap around: cancel corral pruning for this position}
                                  BoxNo:=MAX_BOX_COUNT+1;                       {terminate the 'while' box loop}
                                  break;                                        {terminate the 'for'   direction loop}
                                  end;
                             end;
                          end;
                       end;
                end;

            {if corral pruning failed then try room pruning;}
            {room pruning makes the search incomplete, i.e., some legal pushes}
            {may not be explored}
            if (CorralBoxCount=0) and                                           {'True': corral pruning failed, i.e., all pushes for all reachable boxes need to be generated}
               (Position__^.PackingOrder.SetNo<>0) and                          {'True': packing order is enabled, it sacrifices solution push-optimality just like room pruning does; room pruning also sacrifices completeness}
               (RoomNo=0) and                                                   {'True': corral pruning didn't find a deadlocked corral}
               (Game.Rooms.Count>0) then begin                                  {'True': room pruning is enabled}
               Direction     :=TDirection(Ord(Position__^.Move.Direction) and DIRECTION_BIT_MASK); {get the direction of the push leading to the current position}
               Square        :=Game.BoxPos[LastPushedBoxNo];                    {get the box square for the push leading to the current position}
               NeighborSquare:=Square-Game.SquareOffsetForward[Direction];      {calculate the box position before the last push}
               RoomNo        :=Game.Rooms.Squares[Square].RoomNo;               {get the room number, if any for the box square}

               if   (RoomNo<>0)                                                 {'True': the box is at a square which is a member of a room}
                    and
                    (RoomNo=Game.Rooms.Squares[NeighborSquare].RoomNo) and      {'True': the last push took place inside the current room}
                    ((Game.Board[Square] shr GOAL_BIT_SHIFT_COUNT)=0) then begin {'True': the last push didn't bring the box to a goal square or a parking square}

                    for Direction:=Low(Direction) to High(Direction) do begin
                        Distance:=Game.Rooms.Squares[NeighborSquare].StraightLineEntryPointDistances[Direction];
                        if (Distance<>0) and StraightLineVisibility(NeighborSquare,Pred(Distance),Direction) then begin {'Pred(Distance)': the line of sight does not require the square outside the room to be empty}
                           RoomNo:=0;                                           {'0': no room pruning; the last push may have opened up for pushing more boxes into the room}
                           break;                                               {quick-and-dirty exit the 'for' loop as soon as it has been established that the push may have opened up for pushing more boxes into the room}
                           end;
                        end;

                    if RoomNo<>0 then begin                                     {'True': leaving the 'from' square didn't open up for pushing more boxes into the room}
                       for Direction:=Low(Direction) to High(Direction) do begin {check if the box has entered the 'slipstream' of one of the entry/exit points for the room; that could be the first step towards pushing the box out of the room}
                           Distance:=Game.Rooms.Squares[Square].StraightLineEntryPointDistances[Direction];
                           if (Distance<>0)
                              and
                              (Solver.SearchStates[Position__^.PushCount].PlayersReachableSquares.Squares[Square+Distance*Game.SquareOffsetForward[Direction]]
                               <>                                               {'True': the player cannot reach the square outside the room in this direction}
                               Solver.SearchStates[Position__^.PushCount].PlayersReachableSquares.TimeStamp
                              )
                              and
                              StraightLineVisibility(Square,Pred(Distance),Direction) then begin {'True': there is straight-line visibility from the push destination square to the square outside the room in this direction}
                              RoomNo:=0;                                        {'0': no room pruning}
                              break;                                            {quick-and-dirty exit the 'for' loop as soon as it has been established that the push may have opened up for pushing more boxes into the room}
                              end;
                           end;
                       end;
                    end
               else RoomNo:=0;

               if RoomNo<>0 then begin                                          {'True': only push boxes which currently are inside this room}
                  RoomPruningBoxCount:=0;
                  for BoxNo:=1 to Game.BoxCount do with Solver.SearchStates[Position__^.PushCount] do begin
                      Square:=Game.BoxPos[BoxNo];
                      if (PlayersReachableSquares.Squares[Square]>PlayersReachableSquares.TimeStamp) and {'True': the box is player-reachable}
                         (Game.Rooms.Squares[Square].RoomNo<>RoomNo) then begin {'True': the box is outside the current room}
                         PlayersReachableSquares.Squares[Square]:=0;
                         Inc(RoomPruningBoxCount);
                         end;
                      end;
                  if   RoomPruningBoxCount<>0 then begin
                       Inc(Positions.SearchStatistics.RoomPositionsCount);
                       end
                  else RoomNo:=0; {no real room pruning; all the reachable boxes are inside the current room anyway}
{
                  if (RoomNo<>0) and (SuccessorPushCount>=1000) then begin
                     ShowBoard;
                     Write('Room pruning; Room: ',RoomNo,' Pruned boxes: ',RoomPruningBoxCount,' Pushes: ',Solver.PushCount,' Positions: ',Positions.Count);
                     Readln;
                     end;
}
                  end;
               end;
            end;
//*)
         {decide which box to try first}
         if        LastPushedBoxNo<>0 then
                   BoxNo:=LastPushedBoxNo {starting with the last pushed box helps a little to make solutions look more natural}
         else if   Odd(Position__^.PushCount) then
                   BoxNo:=1
              else BoxNo:=Game.BoxCount;

         {generate successors}
         while BoxNo<=Game.BoxCount do
           with Solver.SearchStates[Position__^.PushCount].PlayersReachableSquares do begin
             //Game.History.Moves[SuccessorPushCount].BoxNo:=BoxNo;             {update game history}
             Square:=Game.BoxPos[BoxNo];
{
             if Game.HashValue=4415175859714849619 then begin
                ShowBoard;
                Write(Solver.PushCount,SPACE,Positions.Count,' Box: ',BoxNo,' at: ',Square,SPACE,LEFT_PAREN,SquareToColRowAsText(Square),RIGHT_PAREN,' timestamp: ',Squares[Square],SPACE,TimeStamp);
                Writeln;
                Readln;
                end;
}
             if (Squares[Square]>TimeStamp) {'True': the player can reach the box from at least one side, and the box hasn't been pruned}
                //and
                //((CorralBoxCount=0)
                // or
                // (not (BoxNo in PrunedBoxSet))
                //)
                then begin // generate pushes for this box, i.e., the player can reach the box and none of the pruning mechanisms have pruned the box
                for Direction:=Low(Direction) to High(Direction) do begin
                    NeighborSquare:=Square+Game.SquareOffsetForward[Direction];
                    if {inline simple checks for legal moves}
                       (Squares[Square-Game.SquareOffsetForward[Direction]]=TimeStamp){'=TimeStamp': the player can reach the neighbor-square}
                       and
                       ((Game.Board[NeighborSquare] and (BOX+WALL+FLAG_ILLEGAL_BOX_SQUARE))=0) {'=0' the square is legal and not blocked by a wall or another box}
                       and
                       {extended checks for legal moves}
                       IsALegalPush(BoxNo,Direction,SuccessorPushCount) then begin

                       Solver.ProgressCheckPoint.PushedBoxes[BoxNo]:=True;

                       if Solver.PushCount<Solver.SearchLimits.PushCountLimit then begin {limit not exceeded}

{
//                        if (Solver.PushCount>=0) then begin
                          if Game.HashValue=3914083414399637035 then begin
                             ShowBoard;
                             Write(Solver.PushCount,SPACE,Game.SimpleLowerBound);
                             Readln;
                             //
                             end;
}
                          //Game.History.Moves[SuccessorPushCount].Direction:=Direction; {update game history}
                          DoPush(BoxNo,Direction,SuccessorPushCount);           {do the move, i.e., update the board}

                          if   Position__^.PackingOrder.SetNo>0 then
                               SuccessorScore:=SuccessorPushCount+Game.SimpleLowerBound  {normal heuristic score: number of pushes + simple lower bound}
                                               -Game.PackingOrderPushCount               {a pushing-session which brings a box closer to a target square (goal or parking place) only counts as one single push}
                                               +MAX_BOX_COUNT*EMPTY_GOAL_PENALTY         {add a penalty now, so a bonus can be given later by 'CalculatePackingOrderPhaseAndScore()' for filling squares according to the packing order}
                          else SuccessorScore:=SuccessorPushCount+Game.SimpleLowerBound; {normal heuristic score: number of pushes + simple lower bound; the implemented lower bound never over-estimates the distance to a solution}

                          if SuccessorScore>=PositionScore then begin
                             Inc(Solver.PushCount);                             {update statistics}
                             end
                          else begin
                             //SuccessorScore:=PositionScore;                   {score := max(score, parent-score)}
                             Inc(Solver.PushCount);                             {update statistics}
                             end;
{
                          if (Game.HashValue=1430312999849821417) or //then begin
                             (Position__^.HashValue=1430312999849821417) then begin
                          //if (Solver.PushCount>=4000000) then begin
                             ShowBoard;
                             Write('Do push: ');
                             Write('Depth: ',Succ(Position__^.PushCount),SPACE,Succ(Position__^.PushCount-Positions.CurrentPosition^.PushCount),
                                   ' Score: ',SuccessorScore,
                                   ' Lb: ',Game.SimpleLowerBound,
                                   ' Positions: ',Positions.Count,
                                   ' Pushes: ',Solver.PushCount,
                                   ' Open: ',Positions.OpenPositions.Count
                                  );
                             Writeln;
                             Readln;
                             end;
}

//                        WriteBoardToLogFile(IntToStr(Solver.PushCount)+SPACE+IntToStr(Positions.Count)+' Score: '+IntToStr(SuccessorScore));

                          if (Solver.PushCount and (ONE_MEBI-1))=0 then begin
                             {$IFDEF CONSOLE_APPLICATION}
                               Write(Reader.LevelCount,': Depth: ',Position__^.PushCount);
                               Write(' Score: ',Position__^.Score);
                               Write(' Pushes: ',Solver.PushCount div ONE_MILLION,' million');
                               if   Positions.SearchStatistics.ReuseCount=0 then
                                    Write(' Positions: ',Positions.Count)
                               else Write(' Reused positions: ',Positions.SearchStatistics.ReuseCount);
                               {Write(' Time: ',(CalculateElapsedTimeMS(Solver.StartTimeMS,GetTimeMS)+500) div 1000);}
                               Writeln;
                               //ShowBoard;
                               //Readln;
                             {$ENDIF}

                             TimeCheck;
                             end;

                          if SuccessorPushCount+Game.SimpleLowerBound<=Solver.SearchLimits.DepthLimit then begin
                             SuccessorBoxPos:=Game.BoxPos[BoxNo];
                             UsePlayersReachableSquaresFromPredecessor:=
                               (Solver.SearchStates[Pred(SuccessorPushCount)].PlayersReachableSquares.Squares[SuccessorBoxPos]
                                <> // '<>': in the position 'Position__' (before the move [BoxNo, Direction]), the player cannot reach the other side of the box
                                Solver.SearchStates[Pred(SuccessorPushCount)].PlayersReachableSquares.TimeStamp
                               )
                               or
                               (((Game.Board[SuccessorBoxPos+Game.SquareOffsetRight[Direction]] and (WALL+BOX))<>0)
                                and
                                ((Game.Board[SuccessorBoxPos+Game.SquareOffsetLeft [Direction]] and (WALL+BOX))<>0)
                               );
                             Inc(Solver.ReusePlayersReachableSquaresFromPredecessorCount[UsePlayersReachableSquaresFromPredecessor]);

                             //CalculatePlayersReachableSquares(SuccessorPushCount); {find the player's reachable squares}
                             {SuccessorPosition:=nil;}                          {not necessary, 'TTAdd' sets it to 'nil'}

                             {try to add the successor position to the transposition-table;}
                             {if it already is in the table, then 'TTAdd' return}
                             {'False' and the existing position in 'SuccessorPosition'}
                             if TTAdd(Game.HashValue,                           {hash signature for this position}
//                                    Solver.SearchStates[SuccessorPushCount].PlayersReachableSquares.MinPlayerPos, {normalized (top-left) player position}
                                      Game.PlayerPos,                           {player position; note that this isn't the normalized (top-left) player position; the normalized position may not have been calculated yet}
                                      SuccessorPushCount,                       {pushes = depth}
                                      SuccessorScore,                           {pushes + heuristic estimate}
                                      BoxNo,                                    {moved box}
                                      Direction,                                {box direction}
                                      Position__,                               {parent node}
                                      SuccessorPosition) then begin             {'SuccessorPosition' is the new saved position if 'TTAdd()' succeeds}
{
                                if Game.HashValue=1652664153217381026 then begin
                                   Positions.DebugPosition:=SuccessorPosition;
                                   ShowBoard;
                                   Writeln('Debug position: ',Positions.Count,SPACE,Solver.PushCount,' Pushes: ',SuccessorPushCount,' Score: ',SuccessorScore,SPACE,Game.SimpleLowerBound,SPACE,Game.PackingOrderPushCount);
                                   Readln;
                                   end;
}
                                // WriteBoardToLogFile(IntToStr(SuccessorPushCount)+'  '+IntToStr(Solver.PushCount));

//                              WritelnToLogFile('New '+IntToStr(Positions.Count));


                                SuccessorScore:=SuccessorPosition^.Score;       {'Score' is 0 for perimeter-nodes from a search in the opposite direction, hence, retrieve the actually saved score for the position}

                                if (Game.SimpleLowerBound<>0) and (SuccessorScore<>0) then begin {'True': not a solution}

                                   FreezePenalty:=0;
                                   if    ((Game.Board[NeighborSquare] and GOAL)<>0) and     {'True': the box is pushed to a goal square}
                                         IsAFreezingMove(0,NeighborSquare,True) then begin  {'True': the box freezes at the goal square}
                                         i:=Solver.PackingOrder.GoalSetNo[Game.Board[NeighborSquare] shr GOAL_BIT_SHIFT_COUNT]; {get packing order phase for the destination square}
                                         if i<Position__^.PackingOrder.SetNo then with Solver.PackingOrder do begin
                                            {the box freezes at a goal square which should
                                             not be filled in this packing order phase;
                                            }
                                            //FreezePenalty:=(FirstSetMemberIndex[Position__^.PackingOrder.SetNo]-FirstSetMemberIndex[i])*EMPTY_GOAL_PENALTY;
                                            FreezePenalty:=Game.SimpleLowerBound; {choose a penalty for what may be a premature freezing push}
                                            if SuccessorScore<DEAD_END_SCORE-FreezePenalty then {guard against overflow (it's probably impossible given the other limits; that's why the code doesn't bother to maximize 'SuccessorScore' on overflow)}
                                               Inc(SuccessorScore,FreezePenalty);    {penalize the push}
                                            SuccessorPosition^.Score:=SuccessorScore;
                                            end;

                                         TTAddFrozenGoalsPattern(Position__);   {collect frozen goals patterns and check for deadlocks}

                                         //ShowBoard;
                                         //Writeln(Solver.PushCount,SPACE,Positions.Count);
                                         //Write('Premature frozen box?');
                                         //Readln;
                                         end;

                                   if    Position__^.PackingOrder.SetNo>0 then begin
                                         SuccessorPosition^.PackingOrder.SetNo:=Position__^.PackingOrder.SetNo;
                                         CalculatePackingOrderPhaseAndScore(SuccessorPosition,Square,NeighborSquare); {calculate the packing order phase after the push; also calculate a new score for 'SuccessorPosition' taking the phase into account}
                                         if (CorralBoxCount=0) or
                                            (SuccessorPosition^.Score<=PositionScore) or
                                            (CorralBoxCount=Game.BoxCount) or
                                            (FreezePenalty<>0) then begin
                                            SuccessorScore:=SuccessorPosition^.Score;
                                            if Cardinal(SuccessorScore)<Positions.BestScore then begin
                                               Positions.BestScore:=SuccessorScore;
                                               Positions.BestPosition:=SuccessorPosition;
                                               end;
                                            end
                                         else begin
                                            {a push which attempts to open up a corral
                                             is given the same heuristic score as its
                                             parent position; otherwise, opening the
                                             corral could have a score with so low
                                             priority that the search doesn't explore
                                             that path;
                                            }
                                            SuccessorScore:=PositionScore;
                                            SuccessorPosition^.Score:=SuccessorScore;
                                            end;
                                         end;

                                   if    False and {'False': expanding corral box pushes recursively isn't helping; the search generates more positions and gets slower}
                                         (CorralBoxCount<>0) then with SuccessorPosition^ do begin
                                         {expand corral box pushes recursively}
                                         Inc(Uint8(Move.Direction),POSITION_PATH_TAG); {mark the successor position as a member of the currently investigated path}
                                         Inc(Positions.SearchStatistics.Enqueue2Count);
                                         SuccessorPosition^.PackingOrder.SetNo:=Position__^.PackingOrder.SetNo;

                                         if not Solver.SearchStates[SuccessorPushCount].PlayersReachableSquares.Calculated then {'True': 'TTAdd' didn't trigger the calculation; do it now}
                                            CalculatePlayersReachableSquares(SuccessorPushCount); {find the player's reachable squares}

                                         Inc(Solver.CorralSearchDepth);
                                         //if (Ord(Move.Direction) and POSITION_PACKING_ORDER_TAG)<>0 then
                                              Inc(Game.PackingOrderPushCount);
                                         Score:=Search(SuccessorPosition);
                                         //if (Ord(Move.Direction) and POSITION_PACKING_ORDER_TAG)<>0 then
                                              Dec(Game.PackingOrderPushCount);
                                         Dec(Solver.CorralSearchDepth);

                                         SuccessorScore:=Score;
                                         Dec(UInt8(Move.Direction),POSITION_PATH_TAG); {remove the 'current path' tag}
                                         end
                                   else  if (SuccessorScore>PositionScore)      {'True': the successor is less promising than the current position}
                                            or
                                            (SuccessorScore>Positions.OpenPositions.MinValue) {'True': the packing-order search has put at least one new position on the open-queue which is more promising than the current position}
                                            or
                                            Game.DeadlockSets.NewDynamicDeadlockSets {'True':  new deadlock sets have been created after the main search loop retracted a node from the open-list}
                                            then begin {put the successor position on the open-queue}
                                            if SuccessorPosition^.PushCount+Game.SimpleLowerBound<=Solver.SearchLimits.DepthLimit then begin
                                               Inc(Positions.SearchStatistics.Enqueue1Count);
                                               OPENAdd(SuccessorPosition);      {put the position on the open-queue}
                                               end;
                                            end
                                         else with SuccessorPosition^ do begin {expand the successor position immediately}
                                            Inc(UInt8(Move.Direction),POSITION_PATH_TAG); {mark the successor position as a member of the currently investigated path}
                                            Inc(Positions.SearchStatistics.Enqueue2Count);

                                            {the successor is just as promising as}
                                            {its parent-node, hence, it belongs at}
                                            {the front of the open-queue; therefore}
                                            {it's better to recurse immidiately,}
                                            {taking advantage of the fact that the}
                                            {game state already is set for this}
                                            {position}

                                            if not Solver.SearchStates[SuccessorPushCount].PlayersReachableSquares.Calculated then {'True': 'TTAdd' didn't trigger the calculation; do it now}
                                               CalculatePlayersReachableSquares(SuccessorPushCount); {find the player's reachable squares}

                                            {update the player position so it's
                                             the normalized (top-left) position;
                                             (don't do it; the player's position
                                             next to the pushed box is required);
                                            }
                                            //SuccessorPosition^.PlayerPos:=Solver.SearchStates[SuccessorPushCount].PlayersReachableSquares.MinPlayerPos;

                                            if (Ord(Move.Direction) and POSITION_PACKING_ORDER_TAG)<>0 then {'True': it's a packing order push; update the packing order push count accordingly before the recursion}
                                               Inc(Game.PackingOrderPushCount);
                                            Score:=Search(SuccessorPosition);
                                            if (Ord(Move.Direction) and POSITION_PACKING_ORDER_TAG)<>0 then {'True': it's a packing order push; update the packing order push count accordingly after  the recursion}
                                               Dec(Game.PackingOrderPushCount);

                                            SuccessorScore:=Score;
                                            Dec(UInt8(Move.Direction),POSITION_PATH_TAG); {remove the 'current path' tag}

                                            //if (Positions.CurrentPosition<>nil) and
                                            //   (Positions.CurrentPosition^.Score>Positions.OpenPositions.MinValue) then
                                               {the resursive calls have put at least one new position on the open-queue
                                                which is more promising than position at the bottom of the recursion;
                                                unwind the recursion to the top level so the best node can be expanded
                                                as quickly as possible; one way to unwind the recursion is faking that
                                                new deadlock sets have been made;
                                               }
                                            //   Game.DeadlockSets.NewDynamicDeadlockSets:=True;
                                            {
                                            // alternatively, put the position on the
                                            // open-queue as usual
                                            if SuccessorPosition^.PushCount<=Solver.SearchLimits.DepthLimit then begin
                                               Inc(Positions.SearchStatistics.Enqueue1Count);
                                               OPENAdd(SuccessorPosition);      // put the position on the open-queue
                                               end;
                                            SuccessorPosition^.PackingOrder.SetNo:=Position__^.PackingOrder.SetNo;
                                            CorralBoxCount:=0;                  // '0': successors have been generated; don't test if the current corral, if any, is a deadlock
                                            }
                                            end;
                                   end {not a solution}
                                else {a solution has been found; either it's a goal position or a perimeter-position from a search in the opposite direction}
                                     if Game.SimpleLowerBound<>0 then begin     {'True': a perimeter-position from a search in the opposite direction}
                                        //ShowBoard;
                                        //Write('Depth: ',SuccessorPosition^.PushCount,' Score: ',SuccessorPosition^.Score,' Total pushes: ',Solver.PushCount,' Positions: ',Positions.Count,' P-order: ',Position__^.PackingOrder .SetNo);
                                        //Readln;
                                        SuccessorScore:=SuccessorPushCount+
                                                        SuccessorPosition^.PathLengthToSolution;
                                        if (Positions.SolutionPosition=nil)
                                           or
                                           (Cardinal(SuccessorScore) <
                                            (Positions.SolutionPosition^.PushCount+
                                             Positions.SolutionPosition^.PathLengthToSolution))
                                           or
                                           (SuccessorPosition=Positions.SolutionPosition) {'=': new cheaper path to the already found perimeter-position}
                                           then begin {new or first found solution}
                                           Positions.SolutionPosition:=SuccessorPosition;
                                           Solver.SearchLimits.DepthLimit:=SuccessorScore;
                                           Solver.SokobanStatusPointer^.Flags:=SOKOBAN_PLUGIN_FLAG_SOLUTION;
                                           OPENDropPositions(Solver.SearchLimits.DepthLimit); {prune the open-queue and the transpostion-table; there is no need to search paths longer than or equal to the best found solution}
                                           if   Solver.StopWhenSolved then
                                                TerminateSearch
                                           else SetSokobanStatusText(TEXT_SOLUTION_INFO_1+IntToStr(SuccessorScore)+TEXT_SOLUTION_INFO_2);
                                           end;
                                        end
                                     else begin                                 {lower bound = 0, i.e., it's a goal position}
                                        UpdateBestSolution(SuccessorPosition);
                                        //ShowBoard; Write('Solution'); Readln;
                                        //ShowPath(Positions.SolutionPosition);
                                       end;
                                end {position added to the transposition table}
                             else                                               {the position wasn't added to the transposition-table}
                                if SuccessorPosition<>nil then begin            {'True': the position already exists in the transposition-table}
                                   if Game.SimpleLowerBound<>0 then begin       {'True': not a solution}
                                      if   SuccessorPosition^.Score<>0 then begin {'True': not a perimeter-node from a search in the opposite direction}
                                           if   SuccessorPosition^.Score>SuccessorScore then begin
(*
                                               {generally, the saved score could be a backup value}
                                               {but as long as node recycling is disabled,}
                                               {the higher score probably means that the node has}
                                               {been generated by the packing order search}
                                               {which doesn't guarantee optimal paths;}
                                               {if the node is on the open-queue,}
                                               {then change the score}
                                               if (Ord(SuccessorPosition^.Move.Direction) and POSITION_OPEN_TAG)<>0 then begin
                                                  OPENRemove(SuccessorPosition); {remove the position from its current position on the open-queue}
                                                  SuccessorPosition^.Score:=SuccessorScore;
                                                  OPENAdd(SuccessorPosition);   {put the position back on the open-queue with the new more optimistic heuristic score}
                                                  end;
*)
                                                SuccessorScore:=SuccessorPosition^.Score;
                                                if SuccessorScore<>DEADLOCK_SCORE then
                                                   CorralBoxCount:=-Abs(CorralBoxCount); {a negative corral count means that there were legal successor moves, i.e., the position isn't a candidate for a new dynamically calculated deadlock set}
                                                end
                                           else begin                           {current path to 'SuccessorPosition' has the same score or a smaller score than the old path}
                                                end;

                                           if SuccessorPosition=Position__^.Parent then with SuccessorPosition^ do begin
                                              //ShowBoard;
                                              //Write('Reversible push: ',Solver.PushCount,SPACE,Positions.Count);
                                              //Readln;
                                              end;
                                           end
                                      else SuccessorScore:=SuccessorPushCount+  {'Score'=0: it's a perimeter position from a search in the opposite direction}
                                                           SuccessorPosition^.PathLengthToSolution;
                                      end
                                   else with SuccessorPosition^ do begin        {start-position = goal-position, or a shorter path to an existing position}
                                      {if this is the start-position then modify it so it contains this last move leading to the solution}
                                      if (Positions.SolutionPosition=nil) or    {'nil': this is the first found solution}
                                         (SuccessorPushCount<PushCount) then begin {'<': this is a new better path to this position (which is a solution but not necessarily the best one)}
                                         if (Ord(Move.Direction) and POSITION_OPEN_TAG)<>0 then {'True': this shouldn't happen but better safe than sorry}
                                            OPENRemove(SuccessorPosition);      {remove the position from the open-queue}
                                         PushCount        :=SuccessorPushCount;
                                         Score            :=SuccessorPushCount;
                                         Parent           :=Position__;         {handle with care: if this is the start-position, then the solution is now a circular list}
                                         Move.BoxNo       :=BoxNo;
                                         Move.Direction   :=Direction;
                                         end;
                                      SuccessorScore      :=Score;
                                      UpdateBestSolution(SuccessorPosition);
                                      end
                                   end
                                else                                            {the transposition-table is full}
                                   if Solver.ReuseNodesEnabled then begin
                                      if SuccessorScore<Position__^.BestForgottenScore then
                                         Position__^.BestForgottenScore:=SuccessorScore; {the successor-position wasn't stored; remember the best forgotten score}
                                      end
                                   else TerminateSearch;                        {stop searching when the transposition-table is full}
                             end
                          else begin                                            {search depth limit exceeded}
                             if (Solver.SearchLimits.DepthLimit>=0) and         {'>=0': the search hasn't been terminated}
                                (SuccessorScore   > OriginalSearchLimits.DepthLimit) and {'>': 'Solver.SearchLimits.DepthLimit' may have been lowered after finding a solution}
                                (SuccessorScore   <>DEADLOCK_SCORE) then        {'DEADLOCK_SCORE': the position is a deadlock}
                                Inc(Solver.LimitExceededPushCount);
                             end;

                          if SuccessorScore<Result then Result:=SuccessorScore;

                          UndoPush(BoxNo,Direction);                            {take back the move, i.e., update the board}
                          end
                       else begin                                               {push count limit exceeded}
                          if Solver.SearchLimits.DepthLimit>=0 then             {'>=0': the search hasn't been terminated}
                             Inc(Solver.LimitExceededPushCount);
                          end;
                       end;
                    end;
                end;

             if Odd(Position__^.PushCount) then begin
                if   BoxNo<>LastPushedBoxNo then Inc(BoxNo)
                else BoxNo:=1;                                                  {first time through the loop}
                if   BoxNo= LastPushedBoxNo then Inc(BoxNo);                    {skip last pushed box when seeing it for the second time}
                end
             else begin
                if   BoxNo<>LastPushedBoxNo then Dec(BoxNo)
                else BoxNo:=Game.BoxCount;                                      {first time through the loop}
                if   BoxNo= LastPushedBoxNo then Dec(BoxNo);                    {skip last pushed box when seeing it for the second time}
                if BoxNo<=0 then
                   BoxNo:=High(BoxNo);                             {'0': all boxes have been visited}
                end;

             //if   BoxNo<>LastPushedBoxNo then Inc(BoxNo)
             //else BoxNo:=1;                                                   {first time through the loop}
             //if   BoxNo= LastPushedBoxNo then Inc(BoxNo);                     {skip last pushed box when seeing it for the second time}
             end;

         with Position__^ do
           if RoomNo<=0 then begin                                              {'True': no room pruning took place; all boxes have been candidates for node expansion, or only corral pruning and tunnel pruning have limited the box candidates}
              if (BestForgottenScore<DEAD_END_SCORE) and                        {'True': the position is not a dead-end, and one or more successors have been deleted from the tranposition table}
                 (SuccessorCount=0) and                                         {'True': the position has no successors stored in the transposition table}
                 (Score<>0) and                                                 {'True': the position is not a perimeter node from a search in the opposite direction}
                 ((Ord(Move.Direction) and POSITION_OPEN_TAG)=0) then begin     {'True': the position is not on the open-queue}

                 {'Position__' had successors but none of them were saved,}
                 {hence, put 'Position__' back on the open-queue}
                 if Position__=Positions.CurrentPosition then
                    if   Parent<>nil then SetPosition(Parent)
                    else Positions.CurrentPosition:=nil;
                 Score:=BestForgottenScore;
                 if (PushCount<=Solver.SearchLimits.DepthLimit) then
                    OPENAdd(Position__);
                 if Parent<>nil then Position__^.PackingOrder.SetNo:=Parent^.PackingOrder.SetNo;
                 Result:=Score;
                 end;
              end
           else {only pushes for the boxes in the current room have been expanded}
              if (Ord(Move.Direction) and POSITION_OPEN_TAG)=0 then begin       {'True': the position isn't on the open-queue; put it on the list for further expansion later in case no solution is found in the room-pruned part of the game graph}
                 Result:=PositionScore; {ensure that the position keeps its original score; otherwise optimality cannot be guaranteed}
                 UInt8(Move.Direction):=UInt8(Move.Direction) or POSITION_REVISIT_TAG; {generate all legal pushes the next time this position is expanded}
                 if   (OldPositionCount<>Positions.Count)                       {'True': new successor positions have been generated}
                      and
                      (PackingOrder.SetNo>0) {'True': packing order search is enabled for this position; only then can 'TTAdd()' guarantee that an attempt to add an identical position doesn't result in an update of the existing one}
                      then begin                                                {put the position on the list of partially expanded positions}
                      NextPartiallyExpandedPosition:=Positions.PartiallyExpandedPositionsList;
                      Positions.PartiallyExpandedPositionsList:=Position__;
                      {adjust the successor count so it has an artificially high
                       value to ensure that:
                       1. removal of successor positions from the transposition
                          table doesn't trigger putting the partially expanded
                          position back on the open-list (see 'TTRemove');
                       2. an attempt to add an identical position to the
                          transposition table doesn't make 'TTAdd' choose to
                          update the existing position, "inviting" the search
                          to put the updated position on the open-list;
                       both operations would corrupt the linked list of
                       partially expanded positions; they are linked using the
                       same fields in each position as the open-list;
                      }
                      Inc(Position__^.SuccessorCount);
                      end
                 else {no successor positions have been generated, or the search
                       doesn't support a list of partially expanded positions;
                       process the position again, this time expanding pushes
                       for all boxes on the board;
                      }
                      OPENAdd(Position__);
                 end;
         end
      else begin                                                                {depth limit exceeded}
         Result:=DEAD_END_SCORE;
         end;

      Position__^.Score:=Result;

      if   Position__^.Score>=Solver.ProgressCheckPoint.Score then begin
           Dec(Solver.ProgressCheckPoint.PushCountDown);
           if Solver.ProgressCheckPoint.PushCountDown<=0 then
              TTAddNoProgressPattern(Position__);
           end
      else InitializeProgressCheckPoint(Position__.Score,False);                {new best score; create a new progress check point}

      if (Result>=DEAD_END_SCORE) and
         (Solver.SearchLimits.DepthLimit>=0) then begin                         {'Solver.SearchLimits.DepthLimit>0': the solver hasn't been terminated}
         if RoomNo<=0 then Inc(Solver.DeadEndCount);                            {'True': if room pruning took place then some boxes haven't been expanded, and the position isn't necessarily a dead end}
{
         if Solver.PushCount>=44525 then begin
            ShowBoard;
            Writeln('Deadend ',Result);
            Write('Depth: ',Position__^.PushCount,' Score: ',Position__^.Score,' Positions: ',Positions.Count,' Pushes: ',Solver.PushCount,' Open: ',Positions.OpenPositions.Count,' Reused: ',Positions.SearchStatistics.ReuseCount);
            //Writeln;
            Readln;
            end;
}
         if Result=DEADLOCK_SCORE then begin                                    {'True': the game position is a deadlock; note that a dead-end is not the same as a deadlock; a dead-end position has no successor positions in the transposition table}
            if (OldPushCount=Solver.PushCount) and                              {'True': there were no legal pushes in the current position}
               (Game.DeadlockSets.Count<MAX_DEADLOCK_SETS) then begin           {'True': new deadlock sets may still be created}
               if (CorralBoxCount=0) and
                  ((Game.Board[Game.BoxPos[Position__^.Move.BoxNo]] and DIRECTION_TO_TUNNEL_FLAG[TDirection(Ord(Position__^.Move.Direction) and DIRECTION_BIT_MASK)])<>0) and
                  {the box left a tunnel square and bypassed corral pruning; call it now so it can be checked whether the deadlock situation can produce a new deadlock set}
                  (RoomNo>=0) then                                              {'True': the corral pruning didn't find a deadlocked corral}
                  with Solver.SearchStates[Position__^.PushCount].PlayersReachableSquares do begin
                    OldPushCount:=-1; {'-1': it's undefined whether there are any legal pushes in the current position; only successors for the box at the tunnel square have been generated}
                    //NeighborSquare:=Game.BoxPos[Position__^.Move.BoxNo]+Game.SquareOffsetForward[TDirection(Ord(Position__^.Move.Direction) and DIRECTION_BIT_MASK)];
                    i:=Game.SquareOffsetForward[TDirection(Ord(Position__^.Move.Direction) and DIRECTION_BIT_MASK)];
                    NeighborSquare:=Game.BoxPos[Position__^.Move.BoxNo];        {get the square number for the push leading to the current position}
                    repeat Inc(NeighborSquare,i);                               {find the next non-box square in the current direction}
                    until  Game.Board[NeighborSquare] and (BOX)=0;
                    if ((Game.Board[NeighborSquare] and (BOX+WALL))=0)          {'True': and empty floor}
                       and
                       (Squares[NeighborSquare]<>TimeStamp) then                {'True': the floor isn't in the player's current access area}
                       {there is a 'corral' on the board, i.e., the boxes separate the empty floors on the board into different 'pockets'}
                       with Solver.SearchStates[SEARCH_STATE_INDEX_CORRAL_PRUNING].PlayersReachableSquares do begin
                         LowWaterBoxTimeStamp:=Succ(TimeStamp);                 {'Succ': the box timestamp, not the empty floor timestamp}
                         if CorralPruning(Position__,Position__^.PushCount,NeighborSquare,0,LowWaterBoxTimeStamp,nil,HasAllBoxesOnGoals,IsACombinedCorral,CorralMinPlayerPos,LowWaterBoxTimeStamp) then begin
                            for BoxNo:=1 to Game.BoxCount do {remove the '0' from the box squares in the player's reachable squares vector for the current search depth}
                                Solver.SearchStates[Position__^.PushCount].PlayersReachableSquares.Squares[Game.BoxPos[BoxNo]]:=1;
                            CalculatePlayersReachableSquares(Position__^.PushCount); {recalculate the player's reachable squares in order to mark the reachable boxes}

                            for  BoxNo:=1 to Game.BoxCount do begin // count number of boxes in the corral
                                 Square:=Game.BoxPos[BoxNo];
                                 if   Squares[Square]<LowWaterBoxTimeStamp then {'True': the box isn't a part of the corral}
                                      Solver.SearchStates[Position__^.PushCount].PlayersReachableSquares.Squares[Square]:=0
                                 else Inc(CorralBoxCount);                      {the box is a part of the corral}
                                 end;
                            if   CorralBoxCount<Game.BoxCount then
                                 Inc(Solver.ExposedInwardsCorralCount1)
                            else Inc(Solver.ExposedInwardsCorralCount2);
                            //Writeln; Writeln('Corral boxes: ',CorralBoxCount);
                            //ShowCorral(SEARCH_STATE_INDEX_CORRAL_PRUNING,LowWaterBoxTimeStamp);
                            //Writeln;
                            end;
                         end;
                    end;

               if CorralBoxCount=0 then begin                                   {'True': no corral has been found in the current game position; try to fake one by treating all non-frozen boxes as part of a corral}
                  if (RoomNo=0) and                                             {'True': no room pruning took place, so the expansion hasn't been limited to boxes in a single room}
                     ((Ord(Position__^.Move.Direction) and POSITION_REVISIT_TAG)=0) then {'True': no tunnel square pruning took place, so the expansion hasn't been limited to a single box}
                     with Game do with Solver.SearchStates[Position__^.PushCount].PlayersReachableSquares do begin
                       for BoxNo:=1 to BoxCount do begin
                           Square:=BoxPos[BoxNo];
                           if   IsAFreezingMove(0,Square,True) then
                                Squares[Square]:=0                              {'0': the box doesn't belong to the faked corral}
                           else begin
                             Squares[Square]:=Succ(TimeStamp);                  {treat all non-frozen boxes as a part of a faked corral}
                             Inc(CorralBoxCount);
                             end;
                           end;
                       if  (CorralBoxCount<=Game.DeadlockSets.BoxLimitForDynamicSets)
                           or
                           True {'True': check all no-legal-pushes situations, no matter how many boxes there may be involved in the situation}
                           then
                           if TTAddNoPushesDeadlock(Position__,nil,False,Position__) then begin
                              end;
                       end;
                  end
               else {'True': there is a corral on the board}
                  if   CorralBoxCount<=Game.DeadlockSets.BoxLimitForDynamicSets then begin
                       if TTAddCombinedCorral(Position__,IsACombinedCorral,OldPushCount=Solver.PushCount,LowWaterBoxTimeStamp,CorralMinPlayerPos) then
                       else begin
{
                          ShowBoard;
                          Write('Deadlock position ',Solver.PushCount,SPACE,Positions.Count,SPACE,SPACE,CorralBoxCount,' Combined corral: ',TEXT_NO_YES[IsACombinedCorral]);
                          Readln;
}
                          end;
                       end
                  else if (OldPushCount=Solver.PushCount) and {'True': it's guaranteed that there are no legal pushes in the current position}
                          TTAddNoPushesDeadlock(Position__,nil,True,Position__) then begin
{
                          ShowBoard;
                          Write('Deadlock position ',Solver.PushCount,SPACE,Positions.Count,SPACE,SPACE,CorralBoxCount,SPACE,TEXT_NO_YES[IsACombinedCorral],SPACE,Game.DeadlockSets.SequenceNo);
                          Readln;
}
                          end;
               end;
            end;
         end;
    end; {Search.ForwardSearch.Search}

  begin {Search.ForwardSearch}
    Result:=INFINITY;
    {$IFDEF PLUGIN_MODULE}
      s:=SPACE+LEFT_PAREN+IntToStr(Positions.MemoryByteSize div ONE_MEBI)+SPACE+TEXT_MEBI_BYTES+RIGHT_PAREN;
      if   Solver.PackingOrder.SetCount>0 then
           SetSokobanStatusText(TEXT_FORWARD_SEARCH_PACKING_ORDER+s)
      else SetSokobanStatusText(TEXT_FORWARD_SEARCH+s);
    {$ENDIF}
    Game.ReverseMode:=False;
    Positions.StartPosition:=nil;
    Positions.CurrentPosition:=nil;
    Game.DeadlockSets.PathDeadlockCount:=0;
    Game.Rooms.Count:=Abs(Game.Rooms.Count);
    Solver.HighestSearchDepth:=0; Solver.CorralSearchDepth:=0;
    InitializeProgressCheckPoint(High(Solver.ProgressCheckPoint.Score),True);

    if (Game.Board[0] and DIRECTION_TO_TUNNEL_FLAGS)<>DIRECTION_TO_TUNNEL_FLAGS then {'True': tunnel squares haven't been calculated yet}
       CalculateTunnelSquares;
    {ShowTunnelSquares; Readln;}

    OPENClear; {clear open-queue}

    {enqueue start-position}
    CalculatePlayersReachableSquares(Game.TubeFillingPushCount);                {find normalized (top-left) player-position}
    if  (Game.TubeFillingPushCount+Game.SimpleLowerBound<=Solver.SearchLimits.DepthLimit) and
        TTAdd(Game.HashValue,                                                   {hash signature for this position}
              Solver.SearchStates[Game.TubeFillingPushCount].PlayersReachableSquares.MinPlayerPos, {normalized (top-left) player position}
              Game.TubeFillingPushCount,                                        {pushes = depth}
              Game.TubeFillingPushCount+Game.SimpleLowerBound,                  {pushes + heuristic estimate}
              0,                                                                {moved box (none in this case)}
              dUp,                                                              {box direction}
              nil,                                                              {parent node}
              Positions.StartPosition) then begin                               {'StartPosition': the created position}
              if not OPENAdd(Positions.StartPosition) then TerminateSearch;
              Positions.StartPosition^.PackingOrder.SetNo:=Max(0,Solver.PackingOrder.SetCount);
              Inc(UInt8(Positions.StartPosition^.Move.Direction),POSITION_PATH_TAG);
              end;

    Positions.BestScore:=High(Positions.BestScore);
    Positions.BestPosition:=nil;
    Positions.SearchStatistics.NewBestPositionCount:=0;

    //LogFile.Enabled:=True;
    //CreateLogFile('t1.txt');

    {the central loop; repeatedly expand the (deepest) least-cost position on the open-queue}
    while OPENRemoveNextPositionSelectedForExpansion(Position) do begin
//    Writeln;
//    Writeln('Open: ',Positions.OpenPositions.Count,' New deadlock sets: ',TEXT_NO_YES[Game.DeadlockSets.NewDynamicDeadlockSets]);
{
      if Position^.HashValue= ... then begin
         ShowBoard;
         Game.Board[MAX_BOARD_SIZE]:=FLOOR;
         Writeln;
         end;
}
{
      if (Positions.DebugPosition<>nil) and (Position^.Score>=127) then begin
         ShowBoard;
         Write('Depth: ',Position^.PushCount,' Score: ',Position^.Score,'    Pushes: ',Solver.PushCount,' Positions: ',Positions.Count,' Open: ',Positions.OpenPositions.Count);
         Readln;
         Writeln;
         end;
}
{
      if (Positions.SolutionPosition<>nil) and (Positions.SolutionPosition^.PushCount=105) then begin
         SetPosition(nil);
         ShowPathForwards(Positions.SolutionPosition);
         TerminateSearch;
         end;
}
{
      if Solver.PushCount>=55018 then begin
         ShowBoard;
         Writeln(Game.DeadlockSets.PathDeadlockCount,SPACE,TEXT_NO_YES[Game.DeadlockSets.NewDynamicDeadlockSets]);
         Write('Depth: ',Position^.PushCount,' Score: ',Position^.Score,'    Pushes: ',Solver.PushCount,' Positions: ',Positions.Count,' Open: ',Positions.OpenPositions.Count);
         Writeln;
         //Readln;
         end;
}
      if not Game.DeadlockSets.NewDynamicDeadlockSets then
         SetPosition(Position) {update the board so it matches this position}
      else begin
         Game.DeadlockSets.NewDynamicDeadlockSets:=False;
         SetPosition(nil); {backtrack to the start position so all deadlock sets, including the new ones are considered when the board is updated to match the position}
         SetPosition(Position); {update the board so it matches this position}
         end;
{
      with Game.DeadlockSets do
        if (Count>=163) and
           (Capacity[163]<0) then begin
           ShowBoard;
           Write(Position^.PushCount,
                 SPACE,SquareOutsideFence[163],'=',SquareToColRowAsText(SquareOutsideFence[163]),
                 SPACE,Game.DeadlockSets.PathDeadlockCount
                );
           Readln;
           end;
}
{
      if Solver.PushCount>=121 then begin
         ShowBoard;
         Writeln(Game.DeadlockSets.PathDeadlockCount);
         Write('Depth: ',Position^.PushCount,' Score: ',Position^.Score,'    Pushes: ',Solver.PushCount,' Positions: ',Positions.Count,' Open: ',Positions.OpenPositions.Count);
         Readln;
         end;
}
{
      if TTIsOnPath(Position,Positions.DebugPosition) then begin
         ShowBoard;
         Writeln('Try position, Depth: ',Position^.PushCount,' Score: ',Position^.Score,' Total pushes: ',Solver.PushCount,' Positions: ',Positions.Count,' Packing order: ',Position^.PackingOrder .SetNo);
         Readln;
         end;
}
{
      if Solver.PushCount>=8858979 then begin
         ShowBoard;
         Write('Expand: ',Positions.Count,SPACE,Solver.PushCount);
         Readln;
         end;
}

      if Game.DeadlockSets.PathDeadlockCount=0 then begin
         with Solver.SearchStates[Position^.PushCount].PlayersReachableSquares do
           UsePlayersReachableSquaresFromPredecessor:=False;

         if not Solver.SearchStates[Position^.PushCount].PlayersReachableSquares.Calculated then
            CalculatePlayersReachableSquares(Position^.PushCount);              {find the player's reachable squares; a precondition for 'Search'}
{
         if Position^.HashValue=367793041495818054 then begin
            ShowPlayersReachableSquares(Position^.PushCount);
            Writeln;
            end;
}
         Search(Position);
{
         if Positions.DebugPosition<>nil then begin
            ShowPath(Positions.DebugPosition);
            Positions.DebugPosition:=nil;
            end;
}
         end
      else begin
         Game.DeadlockSets.NewDynamicDeadlockSets:=True; {ensure that all deadlock sets are taken into account when the next position is selected and put on the board}
         Inc(Positions.SearchStatistics.DeadlockedOpenPositionsCount);
         {$IFDEF CONSOLE_APPLICATION}
{
           if Game.DeadlockSets.PathDeadlockCount<0 then begin
              ShowBoard;
              Write('Deadlocked position? ',Game.DeadlockSets.PathDeadlockCount,SPACE,Solver.PushCount,SPACE,Positions.Count,SPACE,Positions.OpenPositions.Count);
              Readln;
              end;
}
         {$ENDIF}
         end;
      end;

    //LogDeadlockSetStatistics;

    //CloseLogFile;

    if Positions.SolutionPosition<>nil then with Positions do begin             {put the pushes into the game history}
       Result:=SolutionPosition^.PushCount;
       Game.History.Count:=Result; Position:=SolutionPosition;
       repeat with Game.History.Moves[Position^.PushCount] do begin
                BoxNo:=Position^.Move.BoxNo;
                Direction:=TDirection(Ord(Position^.Move.Direction) and DIRECTION_BIT_MASK);
                end;
              Position:=Position^.Parent;
       until  Position=StartPosition;
       end;

    if Positions.StartPosition<>nil then SetPosition(Positions.StartPosition);
    MovePlayer(OldPlayerPos);                                                   {put player back on start-position}
  end; {Search.ForwardSearch}

  {- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - }

begin {Search}
  Result:=False;
  Solver.StartTimeMS:=GetTimeMS;
  Solver.TimeMS:=0; Optimizer.TimeMS:=0;
  Solver.LastCallBackTimeMS:=0; Solver.TimeCheckCount:=0;
  Solver.MoveCount:=0; Solver.PushCount:=0; Solver.LimitExceededPushCount:=0;
  FillChar(PackingOrderSearchStatistics,SizeOf(PackingOrderSearchStatistics),0);
  Game.History.Count:=Game.TubeFillingPushCount;
  Game.History.Moves[0].BoxNo:=1; Game.IsAnOptimalSolution:=False;
  OriginalSearchLimits:=Solver.SearchLimits;
  OriginalSearchMethod:=Solver.SearchMethod;
  OldPlayerPos:=Game.PlayerPos;
  Solver.SokobanStatusPointer^.Flags:=SOKOBAN_PLUGIN_FLAG_UNSOLVED;
  OriginalBoxLimitForDynamicSets:=Game.DeadlockSets.BoxLimitForDynamicSets;
  Game.DeadlockSets.BoxLimitForDynamicSets:=Min(Game.DeadlockSets.BoxLimitForDynamicSets,Max(Min(MIN_BOX_LIMIT_FOR_DYNAMIC_DEADLOCK_SETS,Game.BoxCount),Game.BoxCount div 2)); {select a reasonably small box limit for dynamic deadlock sets}

  {$IFDEF PLUGIN_MODULE}
    SetSokobanStatusText('');
  {$ENDIF}

  TTClear; {clear transposition-table}

  //FillChar(Game.DeadlockSets.SquareSetCount,SizeOf(Game.DeadlockSets.SquareSetCount),0); // tests the search without precalculated deadlocks

  //AssignFile(F,'Log.txt'); Rewrite(F);

  if    Game.SimpleLowerBound<INFINITY then
        Solver.LowerBound:=CalculateSimpleLowerBound
  else  Solver.LowerBound:=INFINITY;

  {$IFDEF CONSOLE_APPLICATION}
    Writeln('Simple lower bound: ',Solver.LowerBound);
  {$ENDIF}

    if Game.SimpleLowerBound=0 then begin
       {$IFDEF CONSOLE_APPLICATION}
         Writeln(TEXT_TRIVIAL_SOLUTION_1); Writeln(TEXT_TRIVIAL_SOLUTION_2);
       {$ENDIF}
       if Assigned(Solver.SokobanCallBackFunction) then begin
          SetSokobanStatusText(TEXT_TRIVIAL_SOLUTION_1);
          PerformSokobanCallBackFunction;
          end;
       end;

//if Game.OriginalSolution<>'' then

  if Solver.LowerBound<INFINITY then begin
     if Game.InitializationTimeMS<Solver.SearchLimits.TimeLimitMS then begin
        if not Solver.Terminated then begin
           if Solver.SearchLimits.TimeLimitMS<High(Solver.SearchLimits.TimeLimitMS) then {otherwise, the search time is unlimited}
              if   Solver.SearchLimits.TimeLimitMS>Game.InitializationTimeMS then
                   Solver.SearchLimits.TimeLimitMS:=Solver.SearchLimits.TimeLimitMS-Game.InitializationTimeMS {the time limit excludes the time already spent on initialization}
              else Solver.SearchLimits.TimeLimitMS:=0;

           if Solver.PackingOrder.SetCount>0 then begin
              LevelTimeLimitMS:=Solver.SearchLimits.TimeLimitMS; {remember the total search time for the level; different search methods may each get a slice of the search time and install their own temporary search time limits}

              if (Solver.SearchLimits.TimeLimitMS< High(Solver.SearchLimits.TimeLimitMS)) and {'True': there is a time limit for the search}
                 (Solver.SearchLimits.TimeLimitMS>=MIN_SEARCH_TIME_FOR_EACH_SEARCH_METHOD_MS) then {'True': there is enough search time to make it worthwhile giving more than one search method a try}
                 Solver .SearchLimits.TimeLimitMS:=Solver.SearchLimits.TimeLimitMS div 2; {spend maximum 50% of the search time on packing order search}

              ForwardSearch();

              Solver.SearchLimits.TimeLimitMS:=LevelTimeLimitMS; {restore total search time for the level}

              //Writeln(Positions.Count,SPACE,Solver.PushCount);

              if (Positions.SolutionPosition=nil) and
                 (not Solver.Terminated) then begin
                 if Solver.ShowBestPosition then ShowBestPosition;

                 if   Solver.SearchLimits.TimeLimitMS<High(Solver.SearchLimits.TimeLimitMS) then begin
                      Solver.TimeMS:=CalculateElapsedTimeMS(Solver.StartTimeMS,GetTimeMS);
                      if   Solver.TimeMS>=Solver.SearchLimits.TimeLimitMS then  {'>=': time limit exceeded}
                           Solver.SearchLimits.TimeLimitMS:=0;
                      end;

                 if   //False and
                      (Solver.SearchLimits.TimeLimitMS>0) and (not Solver.Terminated) then begin {perform a second search without packing order moves}
                      Solver.PackingOrder.SetCount                      :=-Abs(Solver.PackingOrder.SetCount);
                      Solver.SearchMethod                               :=smPerimeter;                {run backward search + forward search}
                      Solver.SearchLimits.DepthLimit                    :=OriginalSearchLimits.DepthLimit; {restore depth limit}
                      Solver.SearchLimits.PushCountLimit                :=OriginalSearchLimits.PushCountLimit; {restore pushes limit}
                      with Positions.SearchStatistics do DroppedCount   :=DroppedCount+Positions.Count;  {update statistics}
                      PackingOrderSearchStatistics                      :=Positions.SearchStatistics; {save the statistics so some of them can be resurrected after calling 'TTClear' as part of the preparation for the next search; see below}
                      Positions.SearchStatistics.ForwardPositionCount   :=0;    {clear the totals that will be updated with the packingorder statistics later; see further down}
                      Positions.SearchStatistics.CorralPositionsCount   :=0;
                      Positions.SearchStatistics.CorralPositionsBoxCount:=0;
                      Positions.SearchStatistics.RoomPositionsCount     :=0;
                      end
                 else Solver.SearchLimits.DepthLimit:=0;                        {'0': don't try another search}
                 end;
              end;

           if (not Solver.Terminated) and
              (Positions.SolutionPosition=nil) and
              (Solver.SearchLimits.DepthLimit>0) then begin
              TTClear;
              {resurrect the statictics for dropped positions now because it's}
              {used for status reports during the search; more statistics from}
              {the packingorder search are added to the totals after the}
              {forward and/or backward search have completed; see further down}
              Positions.SearchStatistics.DroppedCount:=PackingOrderSearchStatistics.DroppedCount;

              case Solver.SearchMethod of
                smBackward              : BackwardSearch();
                smForward               : ForwardSearch();
                smPerimeter             : begin
                                            LevelTimeLimitMS:=Solver.SearchLimits.TimeLimitMS; {the backward search overwrites 'Solver.SearchLimits.TimeLimitMS', hence, save the time limit here so it can be restored later for the forward search}
                                            Solver.TimeMS:=CalculateElapsedTimeMS(Solver.StartTimeMS,GetTimeMS);
                                            if (Solver.SearchLimits.TimeLimitMS<High(Solver.SearchLimits.TimeLimitMS)) and   {'<High()': otherwise, the search time is unlimited}
                                               (Solver.TimeMS<=High(Solver.SearchLimits.TimeLimitMS)-(4*(Solver.SearchLimits.TimeLimitMS div 10))) and {'True': adding 'Solver.TimeMS+(4*(... div 10))' doesn't cause a numeric overflow}
                                               (Solver.SearchLimits.TimeLimitMS>Solver.TimeMS) and {'>': the time limit has not been exceeded}
                                               (Solver.SearchLimits.TimeLimitMS-Solver.TimeMS>=MIN_SEARCH_TIME_FOR_EACH_SEARCH_METHOD_MS) {'>=': otherwise, switching from backward search to forward search is probably too costly}
                                               then
                                               {only spend maximum 40% of the remaining time on the backward search}
                                               Solver.SearchLimits.TimeLimitMS:=Solver.TimeMS+4*((Solver.SearchLimits.TimeLimitMS-Solver.TimeMS) div 10);

                                            if (BackwardSearch()=INFINITY) and  {'INFINITY': no solution was found}
                                               (not Solver.Terminated) and
                                               (Positions.OpenPositions.MaxValue<=Low(Positions.OpenPositions.Buckets)-2) and {'-2': signals that not all open positions have been fully expanded}
                                               (CalculateElapsedTimeMS(Solver.StartTimeMS,GetTimeMS)<LevelTimeLimitMS) and   {'<': the time limit has not been exceeded}
                                               (TTCalculatePerimeter>=0) and                       {'>=0': the game graph was successfully saved to disk}
                                               (not Solver.Terminated) then begin                  {'Solver.Terminated': the user may have terminated the search while the program saved the game graph to disk}
                                               Solver.SearchLimits.DepthLimit    :=OriginalSearchLimits.DepthLimit;     {restore depth limit}
                                               Solver.SearchLimits.PushCountLimit:=OriginalSearchLimits.PushCountLimit; {restore pushes limit}
                                               Solver.SearchLimits.TimeLimitMS   :=LevelTimeLimitMS;                    {restore time limit}

                                               if ForwardSearch()<>INFINITY then
                                                  ConcatenateMovesFromBackwardSearch;

                                               if (Positions.SolutionPosition=nil) and
                                                  Solver.ShowBestPosition then
                                                  ShowBestPosition;
                                               end;
                                          end;
              end; {case}
              end;
           end;
        end
     else SetSokobanStatusText(TEXT_TIME_LIMIT_EXCEEDED);
     end
  else SetSokobanStatusText(TEXT_LEVEL_UNSOLVABLE);

  {add statistics from the packing order search, if any}
  with Positions.SearchStatistics do begin
    ForwardPositionCount   :=ForwardPositionCount   +PackingOrderSearchStatistics.ForwardPositionCount;
    CorralPositionsCount   :=CorralPositionsCount   +PackingOrderSearchStatistics.CorralPositionsCount;
    CorralPositionsBoxCount:=CorralPositionsBoxCount+PackingOrderSearchStatistics.CorralPositionsBoxCount;
    RoomPositionsCount     :=RoomPositionsCount     +PackingOrderSearchStatistics.RoomPositionsCount;
    end;

  //WritelnToLogFile('');
  //WritelnToLogFile('*** Active deadlock sets: '+IntToStr(Game.DeadlockSets.Count));
  //WritelnToLogFile('');

  if (Positions.SolutionPosition<>nil) or (Game.SimpleLowerBound=0) then begin  {a solution was found}
     {Write('Positions: ',Positions.Count,' New best position count: ',Positions.SearchStatistics.NewBestPositionCount); Readln;}
     Game.IsAnOptimalSolution:=(Positions.OpenPositions.Count=0) and
                               (Positions.PartiallyExpandedPositionsList=nil); {if some positions haven't been fully expanded (e.g., because of room pruning) then optimality and completeness cannot be guaranteed}

     p:=Positions.SolutionPosition;
     while Game.IsAnOptimalSolution and
           (p<>nil) and
           (p^.Parent<>nil) and
           (p^.PushCount>p^.Parent^.PushCount) do with p^ do
       if   (Ord(Move.Direction) and POSITION_PACKING_ORDER_TAG)=0 then
            p:=Parent
       else Game.IsAnOptimalSolution:=False; {if the solution stems from a packing order search then optimality cannot be guaranteed}

     if   (not Game.IsAnOptimalSolution) and
          (Positions.SolutionPosition<>nil) and
          (Positions.SolutionPosition^.PushCount<>0) then begin
          {$IFDEF PLUGIN_MODULE}
            SetSokobanStatusText(TEXT_LEVEL_SOLVED_MAY_NOT_BE_OPTIMAL);
          {$ENDIF}
          Solver.SokobanStatusPointer^.Flags:=SOKOBAN_PLUGIN_FLAG_SOLUTION;
          end
     else begin {$IFDEF PLUGIN_MODULE}
                  SetSokobanStatusText(TEXT_LEVEL_SOLVED);
                {$ENDIF}
                Solver.SokobanStatusPointer^.Flags:=SOKOBAN_PLUGIN_FLAG_SOLUTION+SOKOBAN_PLUGIN_FLAG_PUSHES;
                if (Positions.SolutionPosition=nil) or
                   (Positions.SolutionPosition^.PushCount=0) then
                   Inc(Solver.SokobanStatusPointer^.Flags,SOKOBAN_PLUGIN_FLAG_MOVES);
          end;

     {$IFDEF CONSOLE_APPLICATION}
       Write('Solution: Pushes: ',Game.History.Count);
       if Game.TubeFillingPushCount<>0 then begin
          if   Game.TubeFillingPushCount=1 then s:=''
          else s:='es';
          Write(', including ',Game.TubeFillingPushCount,' initial push',s,' leading to the depicted board.');
          end;
       if (not Game.IsAnOptimalSolution) and
          (Positions.SolutionPosition<>nil) and
          (Positions.SolutionPosition^.PushCount<>0) then Write('  (may not be optimal)');
       Writeln;
       //Readln;

       //SetPosition(nil);
       //ShowPathForwards(Positions.SolutionPosition);
       //ShowPath(Positions.SolutionPosition);
     {$ENDIF}

     Result:=True;
     end
  else begin {no solution found}
//{
     if (Positions.BestPosition<>nil) and
        (Positions.BestScore<>High(Positions.BestScore)) then begin
{
        SetPosition(Positions.BestPosition);
        ShowBoard;
        Write('Best found position, Pushes: ',Positions.BestPosition.PushCount,SPACE,Game.HashValue);
        Readln;
}
{
        LogFile.Enabled:=True;
        if CreateLogFile('t1.txt') then begin
           WriteBoardToLogFile('Best found position, pushes: '+IntToStr(Positions.BestPosition.PushCount));
           CloseLogFile;
           end;
        LogFile.Enabled:=False;
}
{
        while (Positions.BestPosition.Parent<>nil) and
              (Positions.BestPosition.PushCount>Positions.BestPosition.Parent.PushCount) do
          with Positions.BestPosition^ do begin
            Positions.BestPosition:=Parent;
            SetPosition(Positions.BestPosition);
            ShowBoard;
            Write('Pushes: ',PushCount,SPACE,Game.HashValue);
            Readln;
            end;
}
        end;
//}
     Game.History.Count:=0;
     end;

  //CloseFile(F);

  Solver.SearchLimits:=OriginalSearchLimits; {restore search limits}
  Solver.SearchMethod:=OriginalSearchMethod; {restore search method}
  Game.DeadlockSets.BoxLimitForDynamicSets:=OriginalBoxLimitForDynamicSets; {restore dynamic deadlock sets box limit}
  MovePlayer(OldPlayerPos); {the search destroys the original player position; repair it before exiting}
  Solver.TimeMS:=CalculateElapsedTimeMS(Solver.StartTimeMS,GetTimeMS);

  PerformSokobanCallBackFunction;                {fill in the final statistics and send it to the call-back function, if any}

  {$IFDEF CONSOLE_APPLICATION}
    if Game.InitializationTimeMS+Solver.TimeMS+Optimizer.TimeMS<>0 then begin
       s:=IntToStrWithPluralDependentText((Game.InitializationTimeMS+Solver.TimeMS+Optimizer.TimeMS+500) div 1000,'second');
       Writeln('Time: ',s);
       end;
  {$ENDIF}

  if Result and Optimizer.Enabled then
     ReduceBoxChanges; {performing small optimizations isn't included in the search time}
end; {Search}

{-----------------------------------------------------------------------------}

{Optimizer}

function  OptimizeGame(MovesAsTextBufferByteSize__:Integer; MovesAsText__:PChar):Boolean;
// precondition: the game has been initialized by calling 'InitializeGame', and the game state is the start position

  type
    TOptimizerPositionVector     = array[0..(MaxInt div SizeOf(TOptimizerPosition))-1] of TOptimizerPosition;
    POptimizerPositionVector     = ^TOptimizerPositionVector;
    TPlayerPositionMatch         = (ppmAccessAreaFirst,ppmAccessAreaNext,ppmExact,ppmBetter,ppmNearest); // order must not change; e.g., see 'TTLookup'
  var
    OriginalSolverTimeMS         : TTimeMS;

  //function  TTIndexOf(Position__:PPosition):Integer; forward;
  function  TTLookup(Depth__:Integer; PlayerPositionMatch__:TPlayerPositionMatch; Direction__:TDirection; var Position__:PPosition):Boolean; forward;
  procedure TTRemove(Position__:PPosition); forward;
  procedure MakeSuccessorChainForNodesOnPath(Position__:PPosition); forward;
  procedure SetGameMetrics(Position__:PPosition); forward;
  procedure SetPosition(Position__:PPosition); forward;
  //procedure ShowPath(Position__:PPosition); forward;
  function  WasALegalPush (Position__:PPosition):Boolean; forward;
  function  WriteBestPathToLogFile:Boolean; forward;

  function  CompareMovesFromSquare(const MFS__:TMovesFromSquare):Boolean;
//var SquareNo:Integer; Direction:TDirection;
  begin // not in production
    Result:=True;
//  for SquareNo:=0 to Pred(Game.BoardSize) do
//      for Direction:=Low(Direction) to High(Direction) do
//          if Optimizer.MovesFromSquare[SquareNo,Direction]<>MFS__[SquareNo,Direction] then begin
//             Result:=False;
//             Writeln(SquareNo:5,DIRECTION_TO_TEXT[Direction]:10,Optimizer.MovesFromSquare[SquareNo,Direction]:10,MFS__[SquareNo,Direction]:10);
//             end;
//  if not Result then Msg(TEXT_INTERNAL_ERROR+': "CompareMovesFromSquare"',TEXT_APPLICATION_TITLE);
  end; // OptimizeGame.CompareMovesFromSquare

  function  CheckMovesFromSquare:Boolean;
//var MFS:TMovesFromSquare;
  begin // not in production
    Result:=True;
//  FillChar(MFS,SizeOf(MFS),0);
//  Result:=CompareMovesFromSquare(MFS);
  end; // OptimizeGame.CheckMovesFromSquare

  procedure DoPull(BoxNo__:Integer; Direction__:TDirection);   {reverse mode: pulling boxes instead of pushing them}
  begin
    Direction__:=OPPOSITE_DIRECTION[TDirection(Ord(Direction__) and DIRECTION_BIT_MASK)];
    // Dec(Optimizer.MovesFromSquare[Game.BoxPos[BoxNo__]-Game.SquareOffsetForward[Direction__],Direction__]); // update move map; note that pulls count down, that is, they "erase" the trail rather than leaving a new trail
    YASS.UndoPush(BoxNo__,Direction__);
  end; // OptimizeGame.DoPull

  procedure DoPush(BoxNo__:Integer; Direction__:TDirection);
  begin
    if BoxNo__<>0 then with Optimizer.GameMetrics do begin
       if Ord(Direction__)<>Ord(Direction__) and DIRECTION_BIT_MASK then
          Msg(TEXT_INTERNAL_ERROR,'Optimize.DoPush');
       //Inc(Optimizer.MovesFromSquare[Game.BoxPos[BoxNo__],TDirection(Ord(Direction__) and DIRECTION_BIT_MASK)]); // update move map

       YASS.DoPush(BoxNo__,Direction__,-1); // update board

       // update move/push metrics
       if      (LastPushingMoveNo<>MoveCount) or (MoveCount=0) then Inc(PushingSessions);
       if      BoxNo__<>LastPushedBoxNo then begin
               Inc(BoxChanges); Inc(BoxLines);
               LastPushedBoxNo:=BoxNo__; LastPushedDirection:=Direction__;
               end
       else if Direction__<>LastPushedDirection then begin
               Inc(BoxLines); LastPushedDirection:=Direction__;
               end;
       if      (Direction__<>LastPlayerDirection) or (MoveCount=0) then begin
               Inc(PlayerLines); LastPlayerDirection:=Direction__;
               end;
       Inc(MoveCount); Inc(PushCount); LastPushingMoveNo:=MoveCount;
       end;
  end; // OptimizeGame.DoPush

  procedure UndoPull(BoxNo__:Integer; Direction__:TDirection); {reverse mode: pulling boxes instead of pushing them}
  begin
    Direction__:=OPPOSITE_DIRECTION[TDirection(Ord(Direction__) and DIRECTION_BIT_MASK)];
    //Inc(Optimizer.MovesFromSquare[Game.BoxPos[BoxNo__],Direction__]); // update move map; note that pulls count down, that is, they "erase" the trail rather than leaving a new trail
    YASS.DoPush  (BoxNo__,Direction__,-1);
  end; // OptimizeGame.UndoPull

  procedure UndoPush(BoxNo__:Integer; Direction__:TDirection; ParentPosition__:PPosition);
  begin
    if BoxNo__<>0 then begin
       Direction__:=TDirection(Ord(Direction__) and DIRECTION_BIT_MASK);
       //Dec(Optimizer.MovesFromSquare[Game.BoxPos[BoxNo__]-Game.SquareOffsetForward[Direction__],Direction__]); // update move map
       YASS.UndoPush (BoxNo__,Direction__); // update board
       if ParentPosition__^.PlayerPos<>Game.PlayerPos then MovePlayer(ParentPosition__^.PlayerPos);
       SetGameMetrics(ParentPosition__);    // restore game metrics
       end;
  end; // OptimizeGame.UndoPush

  function  GameMetricsAsText:String;
  begin
    with Optimizer.GameMetrics do
      Result:='Moves: '            +IntToStr(MoveCount      )+
              ' Pushes: '          +IntToStr(PushCount      )+
              ' BoxLines: '        +IntToStr(BoxLines       )+
              ' BoxChanges: '      +IntToStr(BoxChanges     )+
              ' Pushing sessions: '+IntToStr(PushingSessions)+
              ' Pusher lines: '    +IntToStr(PlayerLines    )
              ;
  end; // OptimizeGame.GameMetricsAsText

  function  ComparePositionScores(Position1__,Position2__:PPosition):Integer;
  begin // returns the score for 'Position1__' minus the score for 'Position2__'
    with POptimizerPosition(Position1__)^ do with Position do begin
      if      (Optimizer.Optimization=opPushesMoves) or (Optimizer.Optimization=opPushesOnly) then begin // optimize pushes/moves or pushes
              Result:=Integer(PushCount)-Integer(POptimizerPosition(Position2__)^.Position.PushCount);
              if Result=0 then Result:=Integer(MoveCount)-Integer(POptimizerPosition(Position2__)^.MoveCount);
              end
      else if Optimizer.Optimization=opMovesPushes then begin                   // optimize moves
              Result:=Integer(MoveCount)-Integer(POptimizerPosition(Position2__)^.MoveCount);
              if Result=0 then Result:=Integer(PushCount)-Integer(POptimizerPosition(Position2__)^.Position.PushCount);
              end
           else begin // optimize boxlines
              Result:=Integer(BoxLines)-Integer(POptimizerPosition(Position2__)^.BoxLines);
              if Result=0 then begin
                 if Optimizer.Optimization=opBoxLinesMoves then begin
                    Result:=Integer(MoveCount)-Integer(POptimizerPosition(Position2__)^.MoveCount);
                    if Result=0 then Result:=Integer(PushCount)-Integer(POptimizerPosition(Position2__)^.Position.PushCount);
                    end
                 else begin // optimize boxlines/pushes
                    Result:=Integer(PushCount)-Integer(POptimizerPosition(Position2__)^.Position.PushCount);
                    if Result=0 then Result:=Integer(MoveCount)-Integer(POptimizerPosition(Position2__)^.MoveCount);
                    end;
                 end;
              end;
      if Result=0 then begin
         Result:=Integer(BoxLines)-Integer(POptimizerPosition(Position2__)^.BoxLines);
         if Result=0 then begin
            Result:=Integer(BoxChanges)-Integer(POptimizerPosition(Position2__)^.BoxChanges);
            if Result=0 then begin
               Result:=Integer(PushingSessions)-Integer(POptimizerPosition(Position2__)^.PushingSessions);
               if (Result=0) and Optimizer.GameMetrics.HasPlayerLines then
                  Result:=Integer(PlayerLines)-Integer(Position2__^.PlayerLines);
               end;
            end;
         end;
      end;
  end; // OptimizeGame.ComparePositionScores

  function  HasABetterMovesPushesBoxLinesScore(Position__:PPosition; MoveCount__,PushCount__,BoxLines__:Integer):Boolean;
  var CompareResult:Integer;
  begin // returns 'True' if 'Position__' has a moves/pushes score better than ['MoveCount__', 'PushCount__'];
        // as an exception, if the optimization method is boxlines/moves or boxlines/pushes, then the number of boxlines is used as the first comparison criteria
    if        (Optimizer.Optimization=opPushesMoves) or (Optimizer.Optimization=opPushesOnly) then
              with POptimizerPosition(Position__)^ do with Position do          // optimize pushes/moves or pushes
                if   PushCount<=PushCount__ then
                     if   PushCount=PushCount__ then
                          Result:=MoveCount<MoveCount__
                     else Result:=True
                else Result:=False
    else if   Optimizer.Optimization=opMovesPushes then
              with POptimizerPosition(Position__)^ do with Position do          // optimize moves/pushes
                if   MoveCount<=MoveCount__ then
                     if   MoveCount=MoveCount__ then
                          Result:=PushCount<PushCount__
                     else Result:=True
                else Result:=False
         else with POptimizerPosition(Position__)^ do with Position do begin    // optimize boxlines
                CompareResult                              :=Integer(BoxLines )-BoxLines__;
                if CompareResult=0 then begin
                   if Optimizer.Optimization=opBoxLinesMoves then begin         // optimize boxlines/moves
                      CompareResult                        :=Integer(MoveCount)-MoveCount__;
                      if CompareResult=0 then CompareResult:=Integer(PushCount)-PushCount__;
                      end
                   else begin                                                   // optimize boxlines/pushes
                      CompareResult                        :=Integer(PushCount)-PushCount__;
                      if CompareResult=0 then CompareResult:=Integer(MoveCount)-MoveCount__;
                      end;
                   end;
                Result:=CompareResult<0;
                end;
  end; // OptimizeGame.HasABetterMovesPushesScore

  function  HasABetterOrEqualScore(Position__:PPosition):Boolean;
  var CompareResult:Integer;
  begin // returns 'True' if 'Position__' has a score <= the score for the current game position
    with POptimizerPosition(Position__)^ do with Position do begin
      if      (Optimizer.Optimization=opPushesMoves) or (Optimizer.Optimization=opPushesOnly) then begin // optimize pushes/moves or pushes
              CompareResult                              :=Integer(PushCount)-Optimizer.GameMetrics.PushCount;
              if CompareResult=0 then CompareResult      :=Integer(MoveCount)-Optimizer.GameMetrics.MoveCount;
              end
      else if Optimizer.Optimization=opMovesPushes then begin // optimize moves/pushes
              CompareResult                              :=Integer(MoveCount)-Optimizer.GameMetrics.MoveCount;
              if CompareResult=0 then CompareResult      :=Integer(PushCount)-Optimizer.GameMetrics.PushCount;
              end
           else begin // optimize boxlines
              CompareResult                              :=Integer(BoxLines )-Optimizer.GameMetrics.BoxLines;
              if CompareResult=0 then begin
                 if Optimizer.Optimization=opBoxLinesMoves then begin
                    CompareResult                        :=Integer(MoveCount)-Optimizer.GameMetrics.MoveCount;
                    if CompareResult=0 then CompareResult:=Integer(PushCount)-Optimizer.GameMetrics.PushCount;
                    end
                 else begin // optimize boxlines/pushes
                    CompareResult                        :=Integer(PushCount)-Optimizer.GameMetrics.PushCount;
                    if CompareResult=0 then CompareResult:=Integer(MoveCount)-Optimizer.GameMetrics.MoveCount;
                    end;
                 end;
              end;
      if   CompareResult=0 then begin
           CompareResult:=Integer(BoxLines)-Optimizer.GameMetrics.BoxLines;
           if CompareResult=0 then begin
              CompareResult:=Integer(BoxChanges)-Optimizer.GameMetrics.BoxChanges;
              if CompareResult=0 then begin
                 CompareResult:=Integer(PushingSessions)-Optimizer.GameMetrics.PushingSessions;
                 if (CompareResult=0) and Optimizer.GameMetrics.HasPlayerLines then
                    CompareResult:=Integer(PlayerLines)-Optimizer.GameMetrics.PlayerLines;
                 end;
              end;
           end;
      Result:=CompareResult<=0;
      end;
  end; // OptimizeGame.HasABetterOrEqualScore

  function  LastBoxSessionPosition(Position__:PPosition):PPosition;
  begin // precondition: the positions on the path are linked forwards, using the 'TPosition.Successor' field
    Result:=Position__;
    if Result<>nil then
       while (Result^.Successor<>nil) and
             (Result^.Successor^.Move.BoxNo=Result^.Move.BoxNo) do
             Result:=Result^.Successor;
  end; // OptimizeGame.LastBoxSessionPosition

  function  CalculateMetricsForPositionsOnBestPath(var BestPositionMetricsChanged__:Boolean):Boolean;
  // update metrics for all positions on the path to the best found position;
  // they may be out of sync if the search stopped prematurely, e.g., as the result of a user intervention, a time limit, or a full transposition table
  var NewBoxNo,PlayerFromSquare,PlayerPathMoveCount,PlayerPathLineCount:Integer; NewDirection:TDirection;
      PreviousPosition:PPosition; PlayerPathMoves:TSingleStepMoves;
  begin
    Result:=True; BestPositionMetricsChanged__:=False;
    if Positions.BestPosition<>nil then with Positions do begin
       SetPosition(StartPosition);

       MakeSuccessorChainForNodesOnPath(BestPosition);

       PreviousPosition:=StartPosition; {'PreviousPosition' is the last performed move}
       CurrentPosition:=PreviousPosition^.Successor;
       while (CurrentPosition<>nil) and Result do with POptimizerPosition(CurrentPosition)^ do with Position do
         with Solver.SearchStates[0].PlayersReachableSquares do begin
           if HasALegalPush(PPosition(Addr(Position)),NewBoxNo,NewDirection) then begin
              Move.BoxNo:=NewBoxNo; {update the move with the box number; it may differ from the original one}
              Move.Direction:=TDirection((Ord(Move.Direction) and (not DIRECTION_BIT_MASK)) or Ord(NewDirection)); {update the move with the direction, but keep the move flags, if any}
              //CalculatePlayersDistanceToReachableSquares(0);
              {'CurrentPosition^.PlayerPos' contains the 'box-from-square-number' part of the move}
              PlayerFromSquare:=PlayerPos-Game.SquareOffsetForward[TDirection(Ord(Move.Direction) and DIRECTION_BIT_MASK)];
              if   ((Game.Board[PlayerFromSquare] and (WALL+BOX))=0) and
                   //(Squares[PlayerFromSquare]>TimeStamp) and {'True': the player can reach the neighbor square next to the box just before the push}
                   (Game.BoxPos[Move.BoxNo]=PlayerPos) and {'True': there is a box on the board at the square where the player is located after the push represented by 'CurrentPosition'}
                   ((Game.Board[PlayerPos+Game.SquareOffsetForward[TDirection(Ord(Move.Direction) and DIRECTION_BIT_MASK)]] and (WALL+BOX))=0) and {'True': pushing the box in this direction is not blocked by a wall or another box}
                   CalculatePlayerPath(PlayerFromSquare,TDirection(Ord(Move.Direction) and DIRECTION_BIT_MASK),(PreviousPosition=StartPosition) and (Game.TubeFillingMoveCount<>0),PlayerPathMoveCount,PlayerPathLineCount,NewDirection,PlayerPathMoves)
                   {'True': the player can reach the neighbor square next to the box just before the push}
                   then begin
                   if (PreviousPosition=StartPosition) and (Game.TubeFillingMoveCount<>0) and (PlayerPathLineCount<>0) and (Game.History.Moves[0].Direction=PlayerPathMoves[1].Direction) then
                      Dec(PlayerPathLineCount); {discount the first player line; it's a continuation of a tubefilling sequence of player moves}
                   Inc(Optimizer.GameMetrics.PlayerLines,PlayerPathLineCount);  {update the number of player lines with the non-pushing in-between player moves}

                   if PlayerPathMoveCount<>0 then begin
                      Inc(Optimizer.GameMetrics.MoveCount,PlayerPathMoveCount); {update the number of player moves with the non-pushing in-between player moves}
                      Optimizer.GameMetrics.LastPlayerDirection:=NewDirection;  {update the current player direction}
                      end;
                   DoPush(Move.BoxNo,TDirection(Ord(Move.Direction) and DIRECTION_BIT_MASK));
                   Move.Direction:=TDirection(Cardinal(Ord(Move.Direction)) or POSITION_PATH_TAG); {the position must be marked as being on the current path so 'SetPosition()' later can undo the push normally}

                   if Optimizer.GameMetrics.MoveCount<=High(MoveCount) then begin

                      if (CurrentPosition=BestPosition)
                         and
                         ((PushCount       <>Optimizer.GameMetrics.PushCount)
                          or
                          (MoveCount       <>Optimizer.GameMetrics.MoveCount)
                          or
                          (BoxChanges      <>Optimizer.GameMetrics.BoxChanges)
                          or
                          (BoxLines        <>Optimizer.GameMetrics.BoxLines)
                          or
                          (PushingSessions <>Optimizer.GameMetrics.PushingSessions)
                          or
                          ((PlayerLines    <>Optimizer.GameMetrics.PlayerLines)
                           and
                           Optimizer.GameMetrics.HasPlayerLines
                          )
                         ) then
                         {typically, this means a new better path has been found,}
                         {but under weird circumstances, the best path may}
                         {deteriorate; this possibility is currently ignored}
                         {and the program saves the new path, no matter if it's}
                         {better or worse}
                         BestPositionMetricsChanged__:=True;

                      PushCount            :=Min(High(PushCount      ),Optimizer.GameMetrics.PushCount); {'Min()': unnecessary with the enclosing 'MoveCount<High(MoveCount)' guard, but just to be be sure}
                      MoveCount            :=Min(High(MoveCount      ),Optimizer.GameMetrics.MoveCount);
                      BoxChanges           :=Min(High(BoxChanges     ),Optimizer.GameMetrics.BoxChanges);
                      BoxLines             :=Min(High(BoxLines       ),Optimizer.GameMetrics.BoxLines);
                      PushingSessions      :=Min(High(PushingSessions),Optimizer.GameMetrics.PushingSessions);
                      PlayerLines          :=Min(High(PlayerLines    ),Optimizer.GameMetrics.PlayerLines);

                      PreviousPosition     :=CurrentPosition;                   {'PreviousPosition' is now the last performed move}
                      {
                      if Optimizer.GameMetrics.PushCount>=54 then begin
                         ShowBoard; Writeln(GameMetricsAsText);
                         Readln;
                         end;
                      }
                      CurrentPosition      :=Successor;
                      end
                   else
                      Result:=False; {numeric overflow of the field holding the number of moves}
                   end
              else Result:=False;
              end
           else Result:=False;
           end;
       CurrentPosition:=PreviousPosition; {adjust 'CurrentPosition' so it matches the last performed move}
       end;
  end; // OptimizeGame.CalculateMetricsForPositionsOnBestPath

  function  OPENAdd(Position__:PPosition; AddToFront__:Boolean):Boolean;
  var BucketIndex:Integer; Root:PPosition;
  begin {open positions: if 'AddToFront__' is 'True' then insert item before other items with the same score}
    Result:=True;
    with Positions.OpenPositions do with Position__^ do begin
      if Score<High(Buckets) then
         BucketIndex:=Score
      else begin
         BucketIndex:=High(Buckets);
         Inc(HighValueItemCount);
         end;
      Inc(Count);
      if BucketIndex<MinValue then MinValue:=BucketIndex;
      if BucketIndex>MaxValue then MaxValue:=BucketIndex;

      Root:=Buckets[BucketIndex];
      if Root<>nil then with ScoreBucket do begin {'<>nil': non-empty list}
         Prev:=Root^.ScoreBucket.Prev;
         Next:=Root;
         Prev^.ScoreBucket.Next:=Position__;
         Next^.ScoreBucket.Prev:=Position__;
         if AddToFront__ then Buckets[BucketIndex]:=Position__; {new first item}
         end
      else with ScoreBucket do begin {create new circular list with 1 item}
         Prev:=Position__;
         Next:=Position__;
         Buckets[BucketIndex]:=Position__;
         end;

      if (Ord(Move.Direction) and POSITION_OPEN_TAG)<>0 then
         Msg(TEXT_INTERNAL_ERROR,'OPENAdd');
      Inc(UInt8(Move.Direction),POSITION_OPEN_TAG);

      if (WorstUnprotectedPosition<>nil) and
         (Score>=WorstUnprotectedPosition^.Score) then
         WorstUnprotectedPosition:=nil; {invalidate the 'worst unprotected node' information}
      end;
  end; // OptimizeGame.OPENAdd

  procedure OPENAddPositionsOnPath(Position__:PPosition; AddTaggedPositionsOnly__:Boolean);
  begin {adds positions on the path to (and including) 'Position__' to the open-queue; precondition: these positions aren't already on the queue}
    while Position__<>nil do begin                                              {put open positions, if any, back on the open-queue}
      if (not AddTaggedPositionsOnly__) or                                      {'True': add all positions on the path}
         ((Ord(Position__^.Move.Direction) and POSITION_OPEN_TAG)<>0) then      {'True': add positions having the 'OPEN' tag; see also 'OPENRemovePositionsOnPath'}
         with Position__^.Move do begin
           Direction:=TDirection(Ord(Direction) and (not POSITION_OPEN_TAG));   {remove an existing 'OPEN' tag, if any; 'OPENAdd' adds this tag to the position}
           OPENAdd(Position__,True);
           end;
       Position__:=Position__^.Parent;
       end;
  end; // OptimizeGame.OPENAddPositionsOnPath

  procedure OPENClearEverythingButDelayUpdatePositions;
  var i:Integer; Position:POptimizerPosition;
  begin
    if Positions.OpenPositions.HighValueItemCount<>0 then begin
       Position:=POptimizerPosition(Positions.Positions);
       for i:=0 to Integer(Pred(Positions.Capacity-Cardinal(Positions.UninitializedItemCount))) do with Position^.Position do begin
           if (Score<High(Positions.OpenPositions.Buckets)) then
              Move.Direction:=TDirection(Ord(Move.Direction) and (not POSITION_OPEN_TAG));
           Inc(Position);
           end;

       with Positions.OpenPositions do begin
         Position:=POptimizerPosition(Buckets[High(Buckets)]);
         i:=HighValueItemCount;
         OPENClear;
         Buckets[High(Buckets)]:=PPosition(Position);
         Count:=i; HighValueItemCount:=Count;
         MinValue:=High(Buckets); MaxValue:=MinValue;
         end;
       end
    else OPENClear;
  end; // OptimizeGame.OPENClearEverythingButDelayUpdatePositions;

  procedure OPENLoadPath(Position__:PPosition);
  begin {put all nodes on the path to 'Position__' on the open-queue}
    while Position__<>nil do begin
      with Position__^ do begin
        if (Ord(Move.Direction) and POSITION_OPEN_TAG)<>0 then
           OPENRemove(Position__); // remove the node from its old position on the open-queue
        Score:=0; // '0': so 'OPENAdd' puts the node before other nodes
        if (Ord(Move.Direction) and POSITION_TARGET_TAG)=0 then
           OPENAdd(Position__,True);
        Position__:=Parent; // backtrack to the parent node on the path
        end;
      end;
  end; // OptimizeGame.OPENLoadPath

  procedure OPENRemove(Position__:PPosition);
  var BucketIndex:Integer;
  begin {open positions: remove item}
    with Positions.OpenPositions do with Position__^ do with ScoreBucket do begin
      if Score<High(Buckets) then
         BucketIndex:=Score
      else begin
         Dec(HighValueItemCount);                {update the number of positions on the delay update queue}
         BucketIndex:=High(Buckets);
         Dec(Score,High(Buckets));               {restore the original score; the original score has been saved as 'High(Buckets)+Score'}
         if Score>=High(Buckets) then Score:=High(Buckets)-1; {'>=': the highest bucket index is reserved for positions on the delay update queue}
         end;
      Dec(Count);                                {update the number of positions on the open-queue}
      Prev^.ScoreBucket.Next:=Next;
      Next^.ScoreBucket.Prev:=Prev;
      if Position__=Buckets[BucketIndex] then    {'True': removing the root item in this bucket}
         if   Next<>Position__ then
              Buckets[BucketIndex]:=Next         {promote the next item to root item in this bucket}
         else Buckets[BucketIndex]:=nil;         {removing the last item in this bucket}
      Prev:=nil; Next:=nil;                      {mark that the position isn't on the open-queue anymore}
      if (Ord(Move.Direction) and POSITION_OPEN_TAG)=0 then
         Msg(TEXT_INTERNAL_ERROR,'OPENRemove');
      Dec(UInt8(Move.Direction),POSITION_OPEN_TAG);
      if Position__=WorstUnprotectedPosition then WorstUnprotectedPosition:=nil;
      end;
  end; // OptimizeGame.OPENRemove

  function  OPENRemoveBest(var Position__:PPosition):Boolean;
  begin {open positions: remove best item}
    with Positions.OpenPositions do begin
      while (MinValue<=MaxValue) and (Buckets[MinValue]=nil) do Inc(MinValue);
      Result:=MinValue<=MaxValue;
      if Result then begin
         Position__:=Buckets[MinValue];
         OPENRemove(Position__);
         end;
      end;
  end; // OptimizeGame.OPENRemoveBest

  function  OPENRemovePositionsOnPath(Position__:PPosition; KeepOpenTags__:Boolean):PPosition;
  begin {removes positions on the path to (and including) 'Position__' from the open-queue; returns the last of the positions on the path that was on the open-queue}
    Result:=nil;
    while Position__<>nil do begin
      if (Ord(Position__^.Move.Direction) and POSITION_OPEN_TAG)<>0 then begin  {'True': the position is a member of the open-queue}
         OPENRemove(Position__);
         if KeepOpenTags__ then with Position__^.Move do                        {'True': keep the 'OPEN' tag even though the position isn't on the open-queue anymore}
            Direction:=TDirection(Cardinal(Ord(Direction)) or POSITION_OPEN_TAG); {mark that this position was on the open-queue; 'OPENAddPositionsOnPath(...,True)' can put these positions back on the queue later}
         if Result=nil then Result:=Position__;                                 {return the last position on the path that was on the open-queue}
         end;
      Position__:=Position__^.Parent;
      end;
  end; //OptimizeGame.OPENRemovePositionsOnPath

  function  OPENRemoveWorst(var Position__:PPosition):Boolean;
  begin {open positions: remove worst item}
    with Positions.OpenPositions do begin
      while (MinValue<=MaxValue) and (Buckets[MaxValue]=nil) do Dec(MaxValue);
      Result:=MinValue<=MaxValue;
      if Result then begin
         Position__:=Buckets[MaxValue]^.ScoreBucket.Prev;
         OPENRemove(Position__);
         end;
      end;
  end; // OptimizeGame.OPENRemoveWorst

  function  OPENWorstUnprotected:PPosition;
  var RoverValue:Integer; Rover:PPosition;
  begin {open positions: worst un-protected item}
    with Positions.OpenPositions do begin
      Result:=WorstUnprotectedPosition;
      if Result=nil then begin
         while (MinValue<=MaxValue) and (Buckets[MaxValue]=nil) do Dec(MaxValue);
         RoverValue:=MaxValue;
         repeat
           while (MinValue<=RoverValue) and (Buckets[RoverValue]=nil) do Dec(RoverValue);
           if MinValue<=RoverValue then begin
              Rover:=Buckets[RoverValue]^.ScoreBucket.Prev;                     {'Prev': last item in the bucket; it's normally the shallowest item, i.e., the item with lowest search-depth}
              repeat
                with Rover^ do
                  if ((Move.BoxNo=0)                                            {'0': probably the root-item}
                      or
                      ((Ord(Move.Direction) and POSITION_PATH_TAG)<>0)          {'<>0': the item is on current path}
                      or
                      (SuccessorCount<>0)                                       {'True': the node has successors, i.e., other nodes in the transposition table have this node as parent}
                     )
                     then begin                                                 {'True': it's a protected item; search for another}
                     if Rover<>Buckets[Score] then Rover:=ScoreBucket.Prev      {back to previous item in the bucket}
                     else begin                                                 {back to a bucket with a lower score}
                        Rover:=nil; Dec(RoverValue);
                        end;
                     end
                  else begin                                                    {this is an unprotected item; return it}
                     Result:=Rover; Rover:=nil;
                     end;
              until Rover=nil;                                                  {until done with this bucket}
              end;
         until (Result<>nil) or (MinValue>RoverValue);                          {until found or until all items on the open-queue have been visited}
         WorstUnprotectedPosition:=Result;
         end;
      end;
  end; // OptimizeGame.OPENWorstUnprotected

  procedure ForceUpdatingOfImprovedPositions;
  var Position:PPosition;
  begin
    with Positions.OpenPositions do begin
      while HighValueItemCount<>0 do begin
        Position:=Buckets[High(Buckets)]; {dequeue the first item on the delay update queue}
        Buckets[High(Buckets)]:=Position^.ListLinks.Next;
        Dec(Count); Dec(HighValueItemCount);
        Dec(Position^.Score, High(Buckets)); {restore the original score; the original score has been saved as 'High(Buckets)+Score'}
        if  Position^.Score>=High(Buckets) then Position^.Score:=High(Buckets)-1; {'>=': the highest bucket index is reserved for positions on the delay update queue}
        Dec(UInt8(Position^.Move.Direction),POSITION_OPEN_TAG); // reset the open-tag before adding the position to the open-queue at its proper position
        OPENAdd(Position,{Position^.Score=0}True);
        end;
      Buckets[High(Buckets)]:=nil;
      end;
  end; // OptimizeGame.ForceUpdatingOfImprovedPositions;

  function  TTAdd(BoxNo__:Integer;
                  Direction__:TDirection;
                  Depth__:Integer;
                  Score__:Integer;
                  Parent__,
                  NextInHashChain__:PPosition;
                  var Position__:PPosition):Boolean;
  var HashBucketIndex:Integer;
  begin // TTAdd: add item to the transposition table
        // precondition 1: the board has been updated with the push ['BoxNo__', 'Direction__'];
        // precondition 2: the position is new, i.e., it's not a member of the transposition table;
        // precondition 3: 'NextInHashChain__' is the result from calling 'TTLookup' on the current game state;
    Result:=False; Position__:=nil;
    with Positions do begin
         if      Parent__<>nil then begin
                 Inc(Parent__^.SuccessorCount);                                 {protect the parent against destruction by updating it successor count before any pruning of the items in the transposition table takes place}
                 if (Ord(Parent__^.Move.Direction) and POSITION_OPEN_TAG)<>0 then
                    OPENRemove(Parent__);
                 end;

         if UninitializedItemCount<=0 then begin                                {'True': all items in memory are either in use or on the free-list}
            if      FreeList<>nil then begin
                    Position__:=FreeList;                                       {get next free item}
                    FreeList  :=FreeList^.HashBucket.Next;                      {the free-list uses 'HashBucket.Next' for linking}
                    end
            else if False and                                                   {'False': recycling the nodes one by one is disabled; the time overhead is too big, so it's better to purge all positions and start a new search based upon the best position}
                    (OpenPositions.Count<>0) and
                    (SearchStatistics.ReuseCount<High(SearchStatistics.ReuseCount)) then begin
                    Position__:=OPENWorstUnprotected;

                    if (Position__<>nil)
                       and
                       (Position__^.Score<=Score__) then                        {'True': the old position has a better/equal score, hence, don't overwrite it}
                       Position__:=nil;

                    if Position__<>nil then begin
                       {having 'TTRemove' in both forks of the following 'if'-statement}
                       {may look strange but the rationale is that an 'if' fork}
                       {cannot be avoided here, and therefore the normal case should}
                       {at least 'fall through' so it avoids cpu stalling}
                       if Position__<>NextInHashChain__ then                    {'True': 'NextInHashChain__' wasn't the first item on the open-queue}
                          TTRemove(Position__)                                  {remove 'Position__' from the transposition-table}
                       else begin                                               {'NextInHashChain__' will disappear from the transposition-table because it's the first item on the open-queue}
                          TTRemove(Position__);                                 {remove 'Position__' from the transposition-table}
                          TTLookup(Depth__,ppmExact,dUp,NextInHashChain__);     {find new 'NextInHashChain__'}
                          end;

                       Inc(SearchStatistics.ReuseCount);

                       Position__:=FreeList;                                    {get next free item ('TTRemove' may recurse, in effect putting several nodes on the free-list}
                       FreeList  :=FreeList^.HashBucket.Next;                   {the free-list uses 'HashBucket.Next' for linking}
                       end;
                    end
            else    begin Position__:=nil;                                      {the transposition-table is full}
                          //if Optimizer.IterationResult then
                          //   OPENClear;                                       {restart the search with a purged transposition table}
                          //OPENClear;                                          {restart the search with a purged transposition table}
                          //{
                          if UninitializedItemCount=0 then begin                // 'True': this is the first time that the allocation of a position fails
                             if   OpenPositions.HighValueItemCount<>0 then begin
                                  OPENClearEverythingButDelayUpdatePositions;
                                  ForceUpdatingOfImprovedPositions;
                                  end
                             else OPENClear;                                    // restart the search with a purged transposition table
                             UninitializedItemCount:=-1;
                             end;
                          //}
                    end;
            end
         else begin {not all items have been used yet, hence, get the next free item from the allocated memory}
            Position__:=PPosition(Addr(POptimizerPositionVector(Positions)^[Capacity-Cardinal(UninitializedItemCount)]));
            Dec(UninitializedItemCount);
            end;

         if Position__<>nil then with POptimizerPosition(Position__)^ do with Position do begin     {'True': got a free slot: save the new item}
            HashBucketIndex       :=Game.HashValue and HashBucketMask;
            if    NextInHashChain__<>nil then begin                             {'True': insert the new position before 'NextInHashChain__'}
                  HashBucket.Prev :=NextInHashChain__^.HashBucket.Prev;
                  HashBucket.Next :=NextInHashChain__;
                  HashBucket.Prev^.HashBucket.Next:=Position__;
                  NextInHashChain__^.HashBucket.Prev:=Position__;
                  if HashBuckets^[HashBucketIndex]=NextInHashChain__ then       {'True': 'NextInHashChain__' is the first item in its bucket}
                     HashBuckets^[HashBucketIndex]:=Position__;                 {set the new item to be the first item in its bucket}
                  end
            else
               if HashBuckets^[HashBucketIndex]=nil then begin                  {'True': the bucket is empty}
                  HashBuckets^[HashBucketIndex]:=Position__;                    {put this item in the bucket}
                  HashBucket.Prev :=Position__;                                 {make single-item circular list}
                  HashBucket.Next :=Position__;
                  end
               else begin                                                       {insert this item as the last one in this bucket}
                  HashBucket.Next :=HashBuckets^[HashBucketIndex];
                  HashBucket.Prev :=HashBucket.Next^.HashBucket.Prev;
                  HashBucket.Prev^.HashBucket.Next:=Position__;
                  HashBucket.Next^.HashBucket.Prev:=Position__;
                  end;

            HashValue             :=Game.HashValue;
            Move.BoxNo            :=BoxNo__;
            Move.Direction        :=Direction__;
            Parent                :=Parent__;
            PlayerPos             :=Game.PlayerPos;
            PushCount             :=Optimizer.GameMetrics.PushCount;
            Score                 :=Score__;
            SuccessorCount        :=0; {a node generated backwards isn't linked to the tree so it's still a leaf-node, hence, 'SuccessorCount' = 0 also for backward nodes}

            MoveCount             :=Optimizer.GameMetrics.MoveCount;
            BoxChanges            :=Optimizer.GameMetrics.BoxChanges;
            BoxLines              :=Optimizer.GameMetrics.BoxLines;
            PushingSessions       :=Optimizer.GameMetrics.PushingSessions;
            PlayerLines           :=Optimizer.GameMetrics.PlayerLines;

            SmallBoxSet           :=[];
            //ListLinks.Prev      :=nil;
            ListLinks.Next        :=nil;                                        {mark that the position neither is on the open-queue nor on the backward-positions list}

            Result                :=True;
            Inc(Count);
            {
            if HashValue=2207141885250126254 then begin
               ShowBoard;
               Write('Added position');
               //Readln;
               end;
            }

            {
            // test that the positions in this hash-bucket are sorted in ascending order
            NextInHashChain__     :=HashBuckets^[HashBucketIndex];
            repeat
                   if (NextInHashChain__^.HashBucket.Next<>HashBuckets^[HashBucketIndex]) and
                      (NextInHashChain__^.HashValue>NextInHashChain__^.HashBucket.Next^.HashValue) then
                      Msg(TEXT_INTERNAL_ERROR,'TTAdd');
                   NextInHashChain__     :=NextInHashChain__^.HashBucket.Next;
            until  NextInHashChain__     = HashBuckets^[HashBucketIndex];
            }
            end
         else {transposition table full; undo the premature update}
            if Parent__   <>nil then begin
               Dec(Parent__^.SuccessorCount);
               end;
         end;
  end; // OptimizeGame.TTAdd

  procedure TTClear;
  begin
    YASS.TTClear;
    Positions.Capacity :=
      ( Cardinal( Positions.EndOfPositions ) - Cardinal( Positions.Positions ) ) div SizeOf( TOptimizerPosition ); {the optimizer uses an extended position data structure, hence, there is room for fewer nodes in the transposition table}
    Positions.UninitializedItemCount := Integer( Positions.Capacity );
    OPENClear;                                                                  {clearing the transposition table entails that the open-queue is empty too}
  end; // OptimizeGame.TTClear

  function  TTIndexOf(Position__:PPosition):Integer;
  begin {transposition table: returns vector index for the item at 'Position__'}
    Result:=(UInt(Position__)-UInt(Positions.Positions)) div SizeOf(TOptimizerPosition);
  end;

  function  TTLoadGame(MovesAsTextBufferByteSize__:Integer; MovesAsText__:PChar):Boolean;
  var BoxNo,CharCount,NewBoxPos,NewPlayerPos:Integer;
      BestPositionMetricsChanged:Boolean;
      Ch:Char; Direction:TDirection; NewPosition,Position:PPosition;
      RepetitionMetrics:TOptimizerGameMetrics;
  begin // 'TTLoadGame' puts the game-path in the transposition table
    Result:=MovesAsText__<>nil;
    Optimizer.Result:=prUnsolved;
    TTClear; {clear transposition table and open-queue}

    Game.History.Moves[0].BoxNo:=0; {'Game.History.Moves[0].Direction' contains the direction of the last tubefilling move, if any}
    Game.History.Count:=Game.TubeFillingPushCount;
    Game.EndPlayerPos:=0;

    SetGameMetrics(nil);
    Optimizer.GameMetrics.HasPlayerLines:=False;
    Optimizer.OriginalMetrics:=Optimizer.GameMetrics;
    FillChar(RepetitionMetrics,SizeOf(RepetitionMetrics),0);
    //FillChar(Optimizer.MovesFromSquare,SizeOf(Optimizer.MovesFromSquare),0);

    {add the start-position to the transposition table}
    if   TTAdd(0,                                                               {moved box (none in this case)}
               dUp,                                                             {box direction (none in this case)}
               0,                                                               {search depth}
               0,                                                               {score}
               nil,                                                             {parent node}
               nil,                                                             {next node in hash chain}
               Positions.StartPosition) then begin                              {'StartPosition': the created position}
               Positions.CurrentPosition:=Positions.StartPosition;
               Inc(UInt8(Positions.CurrentPosition^.Move.Direction),POSITION_PATH_TAG); // set 'on current path' tag;
               // note that storing flags together with the direction is very dirty; 'Direction' is out of bounds now; use "TDirection(Ord(Direction__) and DIRECTION_BIT_MASK)" to extract the direction
               end
    else begin Result:=False; Optimizer.Result:=prFailed;
         end;

    Optimizer.GameMetrics.MoveCount:=0; CharCount:=0; NewPosition:=nil;
    while Result and (CharCount<MovesAsTextBufferByteSize__) and (MovesAsText__^<>NULL_CHAR) do begin
      Ch:=MovesAsText__^; Inc(MovesAsText__); Inc(CharCount);
      if (Ch<>LEFT_PAREN) and (Ch<>RIGHT_PAREN) and (Ch<>'*') then begin
         Result:=CharToDirection(Ch,Direction);
         if Result then begin
            Inc(Optimizer.GameMetrics.MoveCount);
            if Optimizer.GameMetrics.MoveCount>Game.TubeFillingMoveCount then begin
               NewPlayerPos:=Game.PlayerPos+Game.SquareOffsetForward[Direction];
               if   (Game.Board[NewPlayerPos] and WALL)=0 then
                    if (Game.Board[NewPlayerPos] and BOX)=0 then begin          // '0': a non-pushing player move
                       MovePlayer(NewPlayerPos);
                       if (Direction<>Optimizer.GameMetrics.LastPlayerDirection) or (Optimizer.GameMetrics.MoveCount=1) then begin
                          Inc(Optimizer.GameMetrics.PlayerLines);
                          Optimizer.GameMetrics.LastPlayerDirection:=Direction;
                          end;
                       end
                    else begin // a box push
                       NewBoxPos:=NewPlayerPos+Game.SquareOffsetForward[Direction];
                       if (Game.Board[NewBoxPos] and (WALL+BOX))=0 then begin   // '0': an empty square
                          Result:=False; BoxNo:=0; // find box number
                          while (not Result) and (BoxNo<Game.BoxCount) do begin
                            Inc(BoxNo);
                            if Game.BoxPos[BoxNo]=NewPlayerPos then begin       // 'True': found the box at this position
                               //Result:=IsALegalPush(BoxNo,Direction);         // don't check for deadlocks, the user is allowed to move into a deadlocked position
                               Result:=True;
                               if Result then begin
                                  Dec(Optimizer.GameMetrics.MoveCount);         // adjust the number of moves before calling 'DoPush' which also updates it; the number of moves was updated above, right after 'CharToDirection' succeeded
                                  DoPush(BoxNo,Direction);
                                  CalculatePlayersDistanceToReachableSquares(0);

                                  //ShowBoard;
                                  //Write(Optimizer.GameMetrics.MoveCount,SLASH,Optimizer.GameMetrics.PushCount);
                                  //Readln;

                                  if Optimizer.GameMetrics.MoveCount<High(POptimizerPosition(NewPosition)^.MoveCount) then begin // '<': reserves highvalue (e.g., 65535 when the move count is a 16 bit unsigned number) for internal use
                                     if TTLookup(0,ppmExact,dUp,Position) then begin // 'True':  the position already exists
                                        if WasALegalPush(Position) or (Position^.PushCount=0) then with Positions do begin
                                           with RepetitionMetrics do begin
                                             Inc(MoveCount      ,Optimizer.GameMetrics.MoveCount      -POptimizerPosition(Position)^.MoveCount);
                                             Inc(PushCount      ,Optimizer.GameMetrics.PushCount      -Position^.PushCount);
                                             Inc(BoxLines       ,Optimizer.GameMetrics.BoxLines       -POptimizerPosition(Position)^.BoxLines);
                                             Inc(BoxChanges     ,Optimizer.GameMetrics.BoxChanges     -POptimizerPosition(Position)^.BoxChanges);
                                             Inc(PushingSessions,Optimizer.GameMetrics.PushingSessions-POptimizerPosition(Position)^.PushingSessions);
                                             Inc(PlayerLines    ,Optimizer.GameMetrics.PlayerLines    -Position^.PlayerLines);
                                             end;
                                           //ShowBoard;
                                           Optimizer.Result:=prOK;              // mark that the optimizer has found improvements
                                           YASS.UndoPush(BoxNo,Direction);      // first undo the move leading to the duplicate position
                                           while (CurrentPosition<>Position) and (CurrentPosition<>nil) do begin {recycle unused nodes}
                                             with CurrentPosition^.Move do YASS.UndoPush(BoxNo,Direction); // undo all the unnecessary moves back to 'Position'; otherwise 'SetPosition' receives wrong box numbers
                                             with CurrentPosition^.Move do Direction:=TDirection(Ord(Direction) and (not POSITION_PATH_TAG)); // remove the 'on current path' tag from the pruned positions
                                             NewPosition:=CurrentPosition^.Parent; // use 'NewPosition' as temporary
                                             TTRemove(CurrentPosition);
                                             CurrentPosition:=NewPosition;
                                             end;
                                           MovePlayer(Position^.PlayerPos);     // restore the correct player position for position 'Position'
                                           CurrentPosition:=Position;
                                           CurrentPosition^.SuccessorCount:=0;  // cut the looping moves
                                           SetGameMetrics(Position);            // update game metrics
                                           //ShowBoard; Writeln(GameMetricsAsText);
                                           end
                                        else begin
                                           // loading the game failed because of multiple positions
                                           // with the same hashvalue;
                                           // note that the optimizer cannot handle solutions/snapshots
                                           // where start position = terminal position
                                           Result:=False; Optimizer.Result:=prFailed;
                                           end;
                                        end
                                     else begin // new position
                                        {
                                        //if Game.HashValue=7677719296446123441 then begin
                                          ShowBoard;
                                          Writeln(Optimizer.GameMetrics.MoveCount,SLASH,Optimizer.GameMetrics.PushCount);
                                          Readln;
                                        //end;
                                        }
                                        if  TTAdd(BoxNo,Direction,0,0,Positions.CurrentPosition,Position,NewPosition) then begin
                                            Positions.CurrentPosition:=NewPosition;
                                            Inc(UInt8(NewPosition^.Move.Direction),POSITION_PATH_TAG); // set 'on current path' tag;
                                            // note that this is very dirty because 'Direction' is now out of bounds; use "TDirection(Ord(Direction__) and DIRECTION_BIT_MASK)" to extract the direction

                                            if Game.SimpleLowerBound=0 then begin // 'True': the puzzle has been solved
                                               CharCount:=MovesAsTextBufferByteSize__; // stop parsing the moves; it's unlikely that there are more moves, but theoretically there can be more; better safe than sorry
                                               Positions.SolutionPosition:=Positions.CurrentPosition;
                                               end;
                                            end
                                        else begin
                                            Result:=False; Optimizer.Result:=prFailed; // transposition table full
                                            end;
                                        end;
                                     end
                                  else begin
                                     Result:=False; Optimizer.Result:=prGameTooLong; // too many moves
                                     end;
                                  end;
                               end;
                               end;
                          end
                       else Result:=False; // non-empty square
                       end
               else Result:=False; // a wall
               end;
            end;
         end;
      end;

    if Result then with Positions do begin
       Optimizer.OriginalMetrics:=Optimizer.GameMetrics;
       BestPosition:=CurrentPosition;
       //Write('Game: ',OptimizerMetricsAsText(BestPosition));
       if BestPosition<>nil then with BestPosition^ do begin
          Move.Direction:=TDirection(Cardinal(Ord(Move.Direction)) or POSITION_TARGET_TAG);
          if (Ord(Move.Direction) and POSITION_OPEN_TAG)<>0 then OPENRemove(BestPosition);
          Game.EndPlayerPos:=Game.PlayerPos; // save the end player position; the player must end here if the optimizer returns a snapshot which isn't a solution; 
          Optimizer.GameMetrics.HasPlayerLines:=True; // the raw solution contains correct player lines information at this point, hence, it's all right to compare statistics for the existing player lines and the optimized player lines
          Result:=CalculateMetricsForPositionsOnBestPath(BestPositionMetricsChanged); // the raw solution may contain non-optimal intermediate non-pushing player-moves
          Optimizer.GameMetrics.HasPlayerLines:=False;
          if Result and BestPositionMetricsChanged then Optimizer.Result:=prOK; // recalculating the metrics for the positions on the best path removes non-optimal player-moves, if any
          end;
       if Optimizer.Result=prOK then begin
          SetPosition(nil);                                                     // if the game contained repetitions, the game state and 'Optimizer.MovesFromSquare' are out of sync; synchronize them now
          //FillChar(Optimizer.MovesFromSquare,SizeOf(Optimizer.MovesFromSquare),0);
          with Optimizer.OriginalMetrics do begin
            Inc(MoveCount      ,RepetitionMetrics.MoveCount      );
            Inc(PushCount      ,RepetitionMetrics.PushCount      );
            Inc(BoxLines       ,RepetitionMetrics.BoxLines       );
            Inc(BoxChanges     ,RepetitionMetrics.BoxChanges     );
            Inc(PushingSessions,RepetitionMetrics.PushingSessions);
            Inc(PlayerLines    ,RepetitionMetrics.PlayerLines    );
            end;
          WriteBestPathToLogFile;
          //Writeln;
          //with Optimizer.OriginalMetrics do Write('Original metrics: ',MoveCount,SLASH,PushCount,SLASH,BoxLines,SLASH,BoxChanges,SLASH,PushingSessions,SLASH,PlayerLines);
          end;
       //Readln;
       end
    else
       if Optimizer.Result=prOK then Optimizer.Result:=prUnsolved;              // reset optimization result; repetitions may have changed the result to 'prOK'
  end; // OptimizeGame.TTLoadGame

  function  TTLookup(Depth__:Integer; PlayerPositionMatch__:TPlayerPositionMatch; Direction__:TDirection; var Position__:PPosition):Boolean;
  var HashBucketIndex,PlayerDistance,ResultPositionPlayerDistance:Integer;
      BasePosition,ResultPosition:PPosition;
  begin {transposition table: test if the current game position already exists}
    {when the function returns, 'Position__' = 'nil' either means "key >= all keys in its bucket" or "empty bucket"}
    {the direction is only taken into account when the matching is 'ppmBetter'}
    Result:=False;
    with Positions do with Solver.SearchStates[Depth__].PlayersReachableSquares do begin
      HashBucketIndex:=Game.HashValue and HashBucketMask;
      BasePosition:=HashBuckets^[HashBucketIndex];
      if PlayerPositionMatch__<>ppmAccessAreaNext then
         Position__:=BasePosition
      else begin
        Position__:=Position__^.HashBucket.Next;                                {try next item in this bucket}
        if Position__=BasePosition then Position__:=nil;                        {'True': all items in the chain have been tested}
        end;
      if Position__<>nil then with Solver.SearchStates[Depth__].PlayersReachableSquares do begin
         ResultPosition:=nil; ResultPositionPlayerDistance:=0;
         Inc(SearchStatistics.Lookup1Count);
         repeat Inc(SearchStatistics.Lookup2Count);

                if        Position__^.HashValue=Game.HashValue then
                          if (Position__^.PlayerPos=Game.PlayerPos)
                             and
                             ((PlayerPositionMatch__<>ppmBetter)
                              or
                              (TDirection(Ord(Position__^.Move.Direction) and DIRECTION_BIT_MASK)=Direction__)
                             ) then begin
                             Result:=True; exit;                                {found an exact match: quick-and-dirty exit}
                             end
                          else {found a hashvalue match, but the player positions differ}
                             if PlayerPositionMatch__>=ppmBetter then begin     {'True': search for a better position or the nearest position}
                                if not Calculated then
                                   if   Position__^.PlayerPos<>Game.PlayerPos then
                                        CalculatePlayersDistanceToReachableSquares(Depth__) {if the player's distance to the reachable squares haven't been calculated, then do it now}
                                   else Squares[Position__^.PlayerPos]:=Succ(TimeStamp); {it's a matching player position, i.e., the distance is 0}
                                if Squares[Position__^.PlayerPos]>TimeStamp then {'True': the player-position for this position is in the current player access area}
                                   with POptimizerPosition(Position__)^ do with Position do
                                     if (Parent<>nil) or (Move.BoxNo=0) then begin {'Move.BoxNo=0': this is the start position}
                                        PlayerDistance:=Pred(Squares[Position__^.PlayerPos]-TimeStamp);
                                        if High(MoveCount)-PlayerDistance>=MoveCount then begin {'True': no overflow}
                                           Inc(MoveCount,PlayerDistance);       {add the player moves}

                                           if   (ResultPosition=nil) or
                                                (ResultPosition^.Parent=nil) then {'nil': at this point, the search has only found an unlinked backwards-generated position for this access area}
                                                if (PlayerPositionMatch__=ppmNearest)
                                                   or                           {'or': at this point PlayerPositionMatch__=ppmBetter', hence, check if this position is better than the current position}
                                                   HasABetterMovesPushesBoxLinesScore(Position__,Optimizer.GameMetrics.MoveCount,Optimizer.GameMetrics.PushCount,Optimizer.GameMetrics.BoxLines) then begin
                                                   {the current game state can be reached from 'Position__' with a lower cost}
                                                   ResultPosition:=Position__;  {remember this position and continue search}
                                                   ResultPositionPlayerDistance:=PlayerDistance; {remember the number of non-pushing player moves it takes to get to this position}
                                                   Result:=True;                {found a candidate, but continue search for a closer position or an exact match}
                                                   end
                                                else begin
                                                   end
                                           else if HasABetterMovesPushesBoxLinesScore(Position__,POptimizerPosition(ResultPosition)^.MoveCount+ResultPositionPlayerDistance,ResultPosition^.PushCount,POptimizerPosition(ResultPosition)^.BoxLines) then begin
                                                   {the current game state can be reached from 'Position__' with a lower cost}
                                                   ResultPosition:=Position__;  {remember this position and continue search}
                                                   ResultPositionPlayerDistance:=PlayerDistance; {remember the number of non-pushing player moves that it takes to get to this position}
                                                   Result:=True;                {found a candidate, but continue search for a closer position or an exact match}
                                                   end;
                                           Dec(MoveCount,PlayerDistance);       {restore the number of moves}
                                           end;
                                        end
                                     else {'Position__' is either an unlinked node from a backward search or the start position}
                                        if ResultPosition=nil then begin
                                           ResultPosition:=Position__;          {remember this position and continue search}
                                           Result:=True;
                                           end;
                                end
                             else {it's a search for an exact match, or for a position in the player's access area}
                                if PlayerPositionMatch__<=ppmAccessAreaNext then begin
                                   if not Calculated then
                                      CalculatePlayersDistanceToReachableSquares(Depth__);
                                   if Squares[Position__^.PlayerPos]>TimeStamp then begin  {'True': the player-position for this position is in the current player access area}
                                      //ResultPosition:=Position__;             {remember this position and continue search}
                                      //Result:=True;                           {found a candidate, but continue search for an exact match}
                                      Result:=True; exit;                       {found: quick-and-dirty exit}
                                      end;
                                   end;

                if   Game.HashValue>=Position__^.HashValue then begin
                     Position__:=Position__^.HashBucket.Next;                   {try next item in this bucket}
                     if Position__=BasePosition then begin                      {'True': all items in the chain have been tested}
                        Position__:=ResultPosition;                             {return the selected position, if any}
                        exit;                                                   {quick-and-dirty exit}
                        end;
                     end
                else begin if Result then Position__:=ResultPosition;
                           exit;                                                {stop searching; the items are sorted in ascending order on keys}
                     end;
         until  False;                                                          {see the body of the loop for quick-and-dirty exit-statements}
         end
      else begin {empty slot}
          end;
      end;
  end; // OptimizeGame.TTLookup

  function  TTNodesOnTargetPathCount:Integer;
  var i:Cardinal; p:PPosition;
  begin
    Result:=0;
    with Positions do begin {count the nodes in memory with the target path flag}
      for i:=0 to Pred(Capacity-Cardinal(Max(0,UninitializedItemCount))) do
          with PPosition(POptimizerPosition(Addr(POptimizerPositionVector(Positions)^[i])))^ do
            if (UInt8(Move.Direction) and POSITION_TARGET_PATH_TAG)<>0 then Inc(Result);

      p:=FreeList;
      while p<>nil do begin {discount nodes on the free list with target the path flag}
        if (UInt8(p^.Move.Direction) and POSITION_TARGET_PATH_TAG)<>0 then Dec(Result);
        p:=p^.HashBucket.Next;
        end;
      end;
  end; // OptimizeGame.TTNodesOnTargetPathCount

  function  TTPurge(AlignedItemsCount__:Integer; Show__:Boolean):Integer;       {returns the number of purged positions, or -1 if purging fails}
  var HashBucketIndex,OldCount:Cardinal; b:Boolean;
      p,q,BasePosition,NextInHashChain:PPosition;
      Next,Top:POptimizerPosition;
  begin {transposition table: cleanse the table for anything but the best path  }

    {'AlignedItemsCount__' specifies which portion of the memory that contains  }
    {normal left-justified vector-items; in order to append additional items,   }
    {the function must know when to stop checking for occupied slots, hence,    }
    {this parameter provides the necessary information;                         }
    {preconditions:                                                             }
    {  1. 'AlignedItemsCount__' > 0;                                            }
    {  2. additional positions after the normal left-justified items must be in }
    {     ascending memory address order;                                       }

    Result:=0;
    with Positions do with SearchStatistics do
      if (BestPosition<>nil) and                                                {'<>nil': this also ensures that the transposition table really exists, meaning that memory has been allocated and that the table vector isn't a nil-pointer}
         (Optimizer.PurgeCount<High(Optimizer.PurgeCount)) and
         (AlignedItemsCount__>0) then begin
         Inc(Optimizer.PurgeCount);

         SetPosition(BestPosition);                                             {mark nodes on the best path}

         p:=BestPosition; q:=nil;                                               {build forward links between the nodes on the best path}
         repeat p^.SuccessorCount:=0;                                           {mark that the position hasn't any successors in the transposition table yet}
//>>>           p^.BoxCountDown:=0;
                UInt8(p^.Move.Direction):=UInt8(p^.Move.Direction) and (not (POSITION_OPEN_TAG+POSITION_VISITED_TAG)); {mark the position as not being on the open-queue}
                p^.Successor:=q; q:=p; p:=p^.Parent;
         until  p=nil;
         p:=q;                                                                  {get ready to process the positions on the path in forward order}

         if p<>StartPosition then begin
            Msg(TEXT_INTERNAL_ERROR,'TTPurge: Path error'); Result:=-1;
            end;

         OldCount:=Count;
         Count:=0;
         UninitializedItemCount:=Integer(Capacity);
         FreeList:=nil;
         if HashBuckets<>nil then FillChar(HashBuckets^,HashBucketCount*SizeOf(HashBuckets^[Low(HashBuckets^)]),0); {actually, 'HashBuckets' cannot be 'nil' here; in that case, there would not be any best path in the transposition table}

         {compact the transposition table, keeping only the positions on the best found path;}
         {'Next' and 'Top' initially point to the first and the last item on the (left-justified items part of the) transposition table vector respectively}
         Next:=POptimizerPosition(Positions);
         Top :=Next; Inc(Top,Pred(Min(Capacity,AlignedItemsCount__)));          {'Inc': it's easier to let the compiler calculate the address of the last item than doing it manually}

         repeat while (Cardinal(Next)<=Cardinal(Top)) and                       {find leftmost free node in the transposition table, only looking at the left-justified items}
                      ((Ord(Next^.Position.Move.Direction) and POSITION_PATH_TAG)<>0) do {'<>0': this slot already contains a position which is a member of the best path}
                      Inc(Next);

                if    (Cardinal(p)>Cardinal(Next)) and
                      (UninitializedItemCount>0) then begin                     {'True': move this position to the first free slot to the left}
                      if p^.Parent   <>nil then p^.Parent   ^.Successor:=PPosition(Next);
                      if p^.Successor<>nil then p^.Successor^.Parent   :=PPosition(Next);
                      Next^:=POptimizerPosition(p)^;                            {copy the position's data to the free slot}
                      p^.Move.Direction:=dUp;                                   {clear the 'POSITION_PATH_TAG' in the old position so the slot is ready for recycling}
                      if p=BestPosition     then BestPosition    :=PPosition(Next);
                      if p=StartPosition    then StartPosition   :=PPosition(Next);
                      if p=CurrentPosition  then CurrentPosition :=PPosition(Next);
                      if p=SolutionPosition then SolutionPosition:=PPosition(Next);
                      p:=PPosition(Next);
                      Inc(Next);                                                {advance to the next slot}
                      end;

                HashBucketIndex:=p^.HashValue and HashBucketMask;               {add this position to the transposition table's double-linked lists of items}
                BasePosition:=HashBuckets^[HashBucketIndex];
                q:=BasePosition; NextInHashChain:=nil;
                if q<>nil then
                   repeat if        (p^.HashValue=q^.HashValue) and (p^.PlayerPos=q^.PlayerPos) then begin
                                    q:=p; Result:=-1;                           {this shouldn't happen, i.e., there cannot be 2 identical positions on the transposition table}
                                    end
                          else if   p^.HashValue>=q^.HashValue then begin
                                    q:=q^.HashBucket.Next;                      {try next item in this bucket}
                                    end
                               else begin NextInHashChain:=q; q:=BasePosition;  {stop searching; the items are sorted in ascending order on keys}
                                    end;
                   until  (p=q) or (q=BasePosition);                            {see the body of the loop for pointer manipulations that terminate the loop}

                if p<>q then begin                                              {'<>': the position isn't already in the table (it should never happen that it's already in the table here)}
                   if    NextInHashChain<>nil then begin                        {'True': insert the new position before 'NextInHashChain__'}
                         p^.HashBucket.Prev :=NextInHashChain^.HashBucket.Prev;
                         p^.HashBucket.Next :=NextInHashChain;
                         p^.HashBucket.Prev^.HashBucket.Next:=p;
                         NextInHashChain^.HashBucket.Prev:=p;
                         if HashBuckets^[HashBucketIndex]=NextInHashChain then  {'True': 'NextInHashChain__' is the first item in its bucket}
                            HashBuckets^[HashBucketIndex]:=p;                   {set the new item to be the first item in its bucket}
                         end
                   else
                        if HashBuckets^[HashBucketIndex]=nil then begin         {'True': the bucket is empty}
                           HashBuckets^[HashBucketIndex]:=p;                    {put this item in the bucket}
                           p^.HashBucket.Prev :=p;                              {make single-item circular list}
                           p^.HashBucket.Next :=p;
                           end
                        else begin                                              {insert this item as the last one in this bucket}
                           p^.HashBucket.Next :=HashBuckets^[HashBucketIndex];
                           p^.HashBucket.Prev :=p^.HashBucket.Next^.HashBucket.Prev;
                           p^.HashBucket.Prev^.HashBucket.Next:=p;
                           p^.HashBucket.Next^.HashBucket.Prev:=p;
                           end;

                   Inc(Count); Dec(UninitializedItemCount);
                   end;

                //{
                // test that the positions in this hash-bucket are sorted in ascending order
                NextInHashChain:=HashBuckets^[HashBucketIndex];
                repeat
                       if (NextInHashChain^.HashBucket.Next<>HashBuckets^[HashBucketIndex]) and
                          (NextInHashChain^.HashValue>NextInHashChain^.HashBucket.Next^.HashValue) then begin
                          Msg(TEXT_INTERNAL_ERROR,'TTPurge: Sorting error'); Result:=-1;
                          end;
                       NextInHashChain:=NextInHashChain^.HashBucket.Next;
                until  NextInHashChain= HashBuckets^[HashBucketIndex];
                //}

                if   p^.Successor<>nil then
                     p^.SuccessorCount:=1                                       {mark that the position has exactly 1 successor in the transposition table (the best path successor position)}
                else p^.SuccessorCount:=0;                                      {mark that the position hasn't any successors in the transposition table}
//>>>           if   p<>StartPosition then
//>>>                p^.BoxCountDown:=0
//>>>           else p^.BoxCountDown:=High(p^.BoxCountDown);                    {'High': never expand the root position if it's reached again deeper in the tree}
                UInt8(p^.Move.Direction):=(UInt8(p^.Move.Direction) or (POSITION_BEST_PATH_TAG+POSITION_TARGET_PATH_TAG)) and (not POSITION_OPEN_TAG); {mark that the position isn't on the open-queue, and that it's on the path to a target position}
                p^.SmallBoxSet:=[];

                p:=p^.Successor;                                                {get ready to process the successor position, if any}

                //if Cardinal(p)>=Cardinal(UnalignedItems) then begin           {'True': this item wasn't created by 'TTAdd'; precondition: the root item cannot be an unaligned one, and all unaligned items must be in ascending memory address order}
                //   Inc(Next); Top:=Next;                                      {advance to the next free slot}
                //   Top:=Next;                                                 {disable the search for a free slot at the top of the loop}
                //   end;

         until  p=nil;                                                          {until all positions on the best path have been processed}

         if Result=0 then begin                                                 {'0': no errors have been detected}
            if   OldCount>Count then Result:=Cardinal(OldCount-Count)
            else Result:=0;
            if   High(DroppedCount)-Cardinal(Result)>=DroppedCount then
                 DroppedCount:=DroppedCount+Cardinal(Result)
            else DroppedCount:=High(DroppedCount);

            {$IFDEF CONSOLE_APPLICATION}
              if Show__ and (Result<>0) then
                 Writeln('Purging ',Result,' of ', {Optimizer.PositionCapacity} OldCount,' position(s).');
            {$ENDIF}
            end;

         {update metrics for all positions on the best path; they may be out of sync at this time}
         if not CalculateMetricsForPositionsOnBestPath(b) then Result:=-1;      {'-1': something is wrong with the best path, such as 2 positions accidentally having the same hash value}
         if UninitializedItemCount<0 then Result:=-1;                           {'True': the best path is longer than the transposition table capacity; this should never happen}

         SetPosition(nil);

         if (Result>=0)                                                         {'>=0' verification and recalculation of the metrics for the positions on best path succeeded}
            and
            ((not CheckMovesFromSquare) or
             (Count<>Cardinal(Succ(BestPosition^.PushCount)-StartPosition^.PushCount))
            ) then begin {'StartPosition^.PushCount' is non-zero if the level has forced first moves; see 'Game.TubeFillingPushCount'}
            Msg(TEXT_INTERNAL_ERROR+': "TTPurge"',TEXT_APPLICATION_TITLE); Result:=-1;
            end;
         end;
  end; // Optimize.TTPurge

  procedure TTRemove(Position__:PPosition);
  begin {transposition table: remove item; precondition: 'Position__' is a leaf-node, i.e., not an interior node (no 'Parent' pointers back to this item)}
    if Position__<>nil then with POptimizerPosition(Position__)^ do with Position do begin
       if SuccessorCount<>0 then
          Msg(TEXT_INTERNAL_ERROR,'TTRemove');
       if (Ord(Move.Direction) and POSITION_OPEN_TAG)<>0 then                   {'True': the position is a member of the open-queue; remove it from the queue before it's removed from the transposition table}
          OPENRemove(Position__);

       if Parent<>nil then begin                                                {note that 'Parent' here in reality is the successor if the node is a backwards-generated node which isn't on a path from the starting position to the terminal position}
          Dec(Parent^.SuccessorCount);
          if (Parent^.SuccessorCount=0) and                                     {'True': the last successor was removed}
             ((Ord(Parent^.Move.Direction) and (POSITION_OPEN_TAG+POSITION_PATH_TAG))=0) then begin {'True': the parent isn't on the open-list or a member of the current path}
             if Parent^.Score>=Score then                                       {'True': 'UpdateTree' only updates leaf-nodes on the OPEN-queue; interior nodes must be updated here when they are put back on the OPEN-queue}
                if   Score>0 then Parent^.Score:=Pred(Score)
                else Parent^.Score:=0;
             OPENAdd(Parent,False)
             end;
//>>>     Parent^.BoxCountDown:=Max(Parent^.BoxCountDown,BoxCountDown+2);       {'+2': ensure that the search goes deeper next time the parent node is expanded}
          end;

       Parent:=nil;                                                             {so 'YASS.TTRemove' doesn't update the parent as if it was a solver-node instead of an optimizer-node}
       YASS.TTRemove(Position__);
       end;
  end; // OptimizeGame.TTRemove

  function  PostProcessBestPosition:Boolean;
  var MoveCount,LineCount:Integer; Direction:TDirection; Moves:TSingleStepMoves;
  begin {update statistics and path to the best found solution/snapshot}
    {ensure that the metrics for the best position are correct;}
    {they may be out of sync if the search has destroyed the best path,}
    {or if the search stopped prematurely, e.g., as the result of}
    {a user intervention, a time limit, or a full transposition table}
    Result:=CalculateMetricsForPositionsOnBestPath(Optimizer.IterationResult);

    if Result and  (Optimizer.Result=prOK) and (Game.SimpleLowerBound<>0) then begin
       {a snaphot which isn't a solution has been processed; the final player
        position must match the original; otherwise, the improved move sequence
        doesn't match the caller's continuation moves, if any}
       Result:=CalculatePlayerPath(Game.EndPlayerPos,dUp,True,MoveCount,LineCount,Direction,Moves);
       if Result then begin
          Result:=High(POptimizerPosition(Positions.BestPosition)^.MoveCount)-Optimizer.GameMetrics.MoveCount>=MoveCount; {'True': no overflow}
          if   Result then begin
               if Assigned(Positions.BestPosition) and (MoveCount>0) then begin
                  if (Positions.BestPosition<>Positions.StartPosition) and
                     (TDirection(Ord(Positions.BestPosition^.Move.Direction) and DIRECTION_BIT_MASK)=TDirection(Ord(Moves[0].Direction) and DIRECTION_BIT_MASK)) then
                     Dec(LineCount); {'True': the first of the additional moves continues in the current direction; adjust the player lines count accordingly}
                  Inc(POptimizerPosition(Positions.BestPosition)^.MoveCount,MoveCount);
                  Inc(POptimizerPosition(Positions.BestPosition)^.Position.PlayerLines,LineCount);
                  end;
               end
          else Optimizer.Result:=prGameTooLong;
          end
       else {no path to the original player position, i.e., the player ended up}
            {in a different access area; there is nothing else to do but to    }
            {discard the result;                                               }
            Optimizer.Result:=prFailed;
       end;

    if Result and
       (Game.SimpleLowerBound=0) and (Optimizer.Result=prOK) then {the moves returned by the optimizer is a solution; update the return flags}
       with Solver.SokobanStatusPointer^ do Flags:=Flags or SOKOBAN_PLUGIN_FLAG_SOLUTION;
  end; // OptimizeGame.PostProcessBestPosition

  procedure SetGameMetrics(Position__:PPosition);
  begin // set the game metrics so they match the state after performing the move represented by 'Position__'
    if (Position__<>nil) and
       (Position__<>YASS.Positions.StartPosition) then with POptimizerPosition(Position__)^ do with Position do begin
       Optimizer.GameMetrics.BoxChanges            :=BoxChanges;
       Optimizer.GameMetrics.BoxLines              :=BoxLines;
       Optimizer.GameMetrics.MoveCount             :=MoveCount;
       Optimizer.GameMetrics.PlayerLines           :=PlayerLines;
       Optimizer.GameMetrics.PushCount             :=PushCount;
       Optimizer.GameMetrics.PushingSessions       :=PushingSessions;
       Optimizer.GameMetrics.LastPlayerDirection   :=TDirection(Ord(Move.Direction) and DIRECTION_BIT_MASK);
       Optimizer.GameMetrics.LastPushedBoxNo       :=Move.BoxNo;
       Optimizer.GameMetrics.LastPushedDirection   :=Optimizer.GameMetrics.LastPlayerDirection;
       Optimizer.GameMetrics.LastPushingMoveNo     :=MoveCount;
       end
    else with Optimizer.GameMetrics do begin
       MoveCount                                   :=Game.TubeFillingMoveCount;
       PushCount                                   :=Game.TubeFillingPushCount;
       BoxLines                                    :=Min(1,PushCount); {the tubefiller can only push a box in one direction}
       BoxChanges                                  :=BoxLines;
       PlayerLines                                 :=Game.TubeFillingPlayerLines;
       PushingSessions                             :=BoxLines;
       LastPlayerDirection                         :=Game.History.Moves[PushCount].Direction; {the tubefiller may have moved the player, but no boxes (i.e., 'PushCount=0'); in that case 'Moves[0].Direction' contains the last player direction}
       LastPushedBoxNo                             :=Game.History.Moves[PushCount].BoxNo;
       LastPushedDirection                         :=LastPlayerDirection;
       if   PushCount <> 0 then LastPushingMoveNo  :=MoveCount
       else LastPushingMoveNo                      :=0;
       end;
  end; // OptimizeGame.SetGameMetrics

  procedure SetPosition(Position__:PPosition);
  // do/undo moves so the board matches the position represented by the tree-node 'Position__'
  var NewBoxNo,SquareNo:Integer; NewDirection:TDirection; p,Next,Temp:PPosition;
  begin // precondition: 'Position__' is a member of the transposition-table
    with Positions do begin
      Inc(SearchStatistics.SetPosition1Count);

      // find path back to common ancestor of new position and current position
      p:=Position__; Next:=nil;
      while (p<>nil) and
            ((Ord(p^.Move.Direction) and POSITION_PATH_TAG)=0) do with p^ do begin // '0': the position isn't a member of current path
        Temp:=Parent; Parent:=Next; Next:=p; p:=Temp; // pointer reversal; 'Parent' is temporarily used for a forward chain
        end;

      // undo old moves not on common path
      while (CurrentPosition<>p) and
            (CurrentPosition<>nil) do with CurrentPosition^ do begin
        Dec(UInt8(Move.Direction),POSITION_PATH_TAG); // reset 'on current path' tag
        if   not Game.ReverseMode then
             with Move do YASS.UndoPush(BoxNo,Direction)
        else with Move do YASS.UndoPull(BoxNo,Direction);
        //if   Move.BoxNo<>0 then
        //     Dec(Optimizer.MovesFromSquare[Game.BoxPos[Move.BoxNo],TDirection(Ord(Move.Direction) and DIRECTION_BIT_MASK)]); // update move map
        CurrentPosition:=CurrentPosition^.Parent;
        Inc(SearchStatistics.SetPosition2Count);
        end;

      // perform new moves, starting with common ancestor's successor
      if Next<>nil then begin
         repeat
           with Next^ do begin
             if  (Game.Board[PlayerPos] and BOX)<>0 then begin
                 SquareNo:=Game.BoxPos[Move.BoxNo];
                 if   SquareNo<>PlayerPos then begin
                      if HasALegalPush(PPosition(Addr(POptimizerPosition(Next)^.Position)),NewBoxNo,NewDirection) then begin
                         Move.BoxNo:=NewBoxNo;
                         UInt8(Move.Direction):=(UInt8(Move.Direction) and (not DIRECTION_BIT_MASK))+Ord(NewDirection);
                         //SquareNo:=Game.BoxPos[NewBoxNo]; // set the correct square number for updating 'MovesFromSquare' below
                         end
                      else begin
                        //Msg(TEXT_INTERNAL_ERROR,'SetPosition');
                        TerminateSearch; Optimizer.Result:=prFailed;
                        end;
                      end;
                 //Inc(Optimizer.MovesFromSquare[SquareNo,TDirection(Ord(Move.Direction) and DIRECTION_BIT_MASK)]); // update move map; note the updating in the line "SquareNo:=Game.BoxPos[NewBoxNo];" above
                 if   not Game.ReverseMode then
                      with Move do YASS.DoPush(BoxNo,Direction,-1)
                 else with Move do YASS.DoPull(BoxNo,Direction);
                 end
             else if Move.BoxNo<>0 then begin
                     TerminateSearch; Optimizer.Result:=prFailed;               {something is wrong, such as 2 different positions accidentally having identical hashvalues}
                     end;
             Inc(UInt8(Move.Direction),POSITION_PATH_TAG); // set 'on current path' tag; note that this is very dirty because 'Direction' is now out of bounds; use "TDirection(Ord(Move.Direction) and DIRECTION_BIT_MASK)" to extract the direction
             Temp:=Parent; Parent:=CurrentPosition; CurrentPosition:=Next; Next:=Temp; // pointer reversal so 'Parent' again contains a parent list instead of a forward list
             Inc(SearchStatistics.SetPosition2Count);
             end;
         until Next=nil;
         end
      else begin // no new moves, but the player must be placed correctly on the board
         if Position__<>nil then with Position__^ do begin
            MovePlayer(PlayerPos);
            UInt8(Move.Direction):=UInt8(Move.Direction) or POSITION_PATH_TAG;    // set 'on current path' tag
            end
         else begin
            MovePlayer(StartPosition^.PlayerPos);
            end;
         CurrentPosition:=Position__; // save new current position
         end;

      // update game metrics
      SetGameMetrics(CurrentPosition);
      end;
  end; // OptimizeGame.SetPosition

  function  SearchStatePromptText:String;
  begin
    {$IFDEF CONSOLE_APPLICATION}

      Result:=IntToStr(Reader.LevelCount)+PERIOD;

      if   Positions.CurrentPosition<>nil then
           Result:=Result+IntToStr(Positions.CurrentPosition^.Score)+PERIOD+IntToStr(Positions.CurrentPosition^.PushCount)+COLON+SPACE
      else Result:=Result+COLON+SPACE;

    {$ELSE}

      Result:='';

    {$ENDIF}
  end; // OptimizeGame.SearchStatePromptText

  procedure ShowPath(Position__:PPosition);
  var OldPlayerPos:Integer; p,Next:PPosition;
  begin
    p:=Position__; OldPlayerPos:=Game.PlayerPos;

    Next:=nil;
    while p<>nil do with p^ do begin
     if (Ord(Move.Direction) and POSITION_OPEN_TAG)<>0 then OPENRemove(p);
     Successor:=Next; Next:=p;
     p:=Parent;
     end;

    p:=Position__;
    //p:=Positions.StartPosition;
    while p<>nil do with POptimizerPosition(p)^ do with Position do begin
      SetPosition(p);
      ShowBoard;
      Writeln(Game.HashValue,COLON,Game.PlayerPos,SPACE,SPACE,Cardinal(p),COLON,TTIndexOf(p));
      Write(GameMetricsAsText);
      Readln;
      p:=Parent;
      //p:=Successor;
      end;
    SetPosition(Position__);
    MovePlayer(OldPlayerPos);
  end; // OptimizeGame.ShowPath

  procedure ShowStatus;
  begin
    if Positions.BestPosition<>nil then
       Optimizer.SearchResultStatusText:=OptimizerMetricsAsText(Positions.BestPosition)+SPACE+SPACE+
                                           LEFT_PAREN+OptimizerImprovementAsText(Positions.BestPosition)+RIGHT_PAREN;
    SetSokobanStatusText(SearchStatePromptText+
                        {$IFDEF CONSOLE_APPLICATION}
                          TEXT_BEST_RESULT_SO_FAR+
                        {$ENDIF}
                        Optimizer.SearchResultStatusText
                        {$IFDEF CONSOLE_APPLICATION}
                          {$IFDEF WINDOWS}
                            +' Time: '+IntToStr((CalculateElapsedTimeMS(Solver.StartTimeMS,GetTimeMS)+500) div 1000)
                          {$ENDIF}
                        {$ELSE}
                          +Optimizer.SearchStateStatusText
                        {$ENDIF}
                        {+' (Positions: '+IntToStr(Positions.Count+Positions.SearchStatistics.DroppedCount)+' Open: '+IntToStr(Positions.OpenPositions.Count)+RIGHT_PAREN}
                        );

    if Assigned(Solver.SokobanCallBackFunction) then begin
       Solver.TimeMS:=CalculateElapsedTimeMS(Solver.StartTimeMS,GetTimeMS);
       PerformSokobanCallBackFunction;
       end;
  end; // OptimizeGame.ShowStatus

  function  RemoveCyclesFromBestPath(MakeSuccessorChain__:Boolean):Boolean;
  // the cycle removal is based on the assumption that different positions
  // have different hash values and/or different player positions;
  // in case this assumption doesn't hold, the optimizer fails
  // gracefully when either 'CalculateMetricsForPositionsOnBestPath' or
  // 'SetPosition' detect that the best path contains illegal pushes;
  var CurrentPosition,p,q:PPosition;
  begin // precondition: the game state matches the starting position
    Result:=False;
    if MakeSuccessorChain__ then MakeSuccessorChainForNodesOnPath(YASS.Positions.BestPosition);
    CurrentPosition:=YASS.Positions.StartPosition;
    while CurrentPosition^.Successor<>nil do begin                              // repeat until the last position on the path has been selected
      p:=CurrentPosition^.Successor;
      while (p<>nil) and
            ( (p^.PlayerPos<>CurrentPosition^.PlayerPos) or (p^.HashValue<>CurrentPosition^.HashValue)) do // search for a duplicate position on the remaining part of the path; matching values are not 100% trustworthy though
            p:=p^.Successor;
      if p=nil then begin                                                       // 'True': no duplicate position was found on the remaining part of the path, hence, advance to the next position on the best path
         CurrentPosition:=CurrentPosition^.Successor;                           // when the 'while' loop terminates, 'CurrentPosition' contains the last position on the path
         end
      else begin                                                                // a cycle has been detected, i.e., a duplicate position; remove the redundant pushes from the path now
         q:=CurrentPosition;
         repeat  q:=q^.Successor;                                               // remove the 'path' tag from the dropped nodes
                 q^.Move.Direction:=TDirection(Ord(q^.Move.Direction) and (not POSITION_PATH_TAG));
         until   q=p;

         CurrentPosition^.Successor:=p^.Successor;
         if CurrentPosition^.Successor<>nil then CurrentPosition^.Successor^.Parent:=CurrentPosition;
         Result:=True;                                                          // return 'True' if one or more cycles are removed
         end;
      end;
  end; // OptimizeGame.RemoveCyclesFromBestPath

  procedure MakeSuccessorChainForNodesOnPath(Position__:PPosition);
  var Next:PPosition;
  begin // create a forward chain from the start position to the position 'Position__'}
    if YASS.Positions.StartPosition<>nil then YASS.Positions.StartPosition.Successor:=nil;
    Next:=nil;
    while Position__<>nil do with Position__^ do begin
      Successor:=Next; Next:=Position__; Position__:=Parent;
      end;
  end; // OptimizeGame.MakeSuccessorChainForNodesOnPath

  procedure UpdateBestPosition(BestPosition__:PPosition);
  begin
    with YASS.Positions do begin
      BestPosition:=BestPosition__;
      if BestPosition<>nil then with BestPosition^ do begin
         if (Ord(Move.Direction) and POSITION_OPEN_TAG)<>0 then OPENRemove(BestPosition); {ensure that the best position isn't on the open-queue because its members may be candidates for recycling}
         Successor:=nil; //to do: consider what happens here if the best position happens to be (a loop back to) the starting position
         Optimizer.PruningNode:=BestPosition;
         end;
      end;
  end; // OptimizeGame.UpdateBestPosition

  function  Search:Boolean;
  var  BoxPermutationsCount,MethodIndex,
       OldPlayerPos,SuccessiveGlobalSearchesCountDown:Integer;
       TimeMS:TTimeMS;
       OriginalSearchLimits:TSearchLimits;
       FullGameSearch{,IsFirstVicinitySearch}:Boolean;
       BoxSet:TBoxSet; //BoxVisitedSquares:TBoardOfBoxSets;
       ActiveMethodSet:TOptimizationMethodSet;
       MethodEnabled:TOptimizationMethodEnabled; MethodOrder:TOptimizationMethodOrder;

    function  RecalculateMetricsForPositionsOnBestPath(BoxNo__:Integer; Direction__:TDirection):Boolean;
    var BestPositionMetricsChanged:Boolean; LastOpenPositionOnPath,Position:PPosition; GameMetrics:TOptimizerGameMetrics;
    begin {recalculates the metrics for the positions on the best path, in particular the player lines; this metric is not calculated during the search; it's only calculated here so the user can get the correct status information}
      //Result:=True; exit;

      GameMetrics:=Optimizer.GameMetrics;

      Position:=Positions.CurrentPosition; {remember the current position}
      UndoPush(BoxNo__,Direction__,Position); {take back the currently investigated move, i.e., update the board}

      LastOpenPositionOnPath:=OPENRemovePositionsOnPath(Positions.BestPosition,True); {temporarily remove open positions on the path from the open-queue; 'CalculateMetricsForPositionsOnBestPath' uses the overlapping 'TPosition.Successor' field}

      Result:=CalculateMetricsForPositionsOnBestPath(BestPositionMetricsChanged);

      OPENAddPositionsOnPath(LastOpenPositionOnPath,True);                      {put open positions, if any, back on the open-queue}

      SetPosition(Position); {put the position currently selected for expansion back on the board}
      DoPush(BoxNo__,Direction__); {redo the currently investigated move, i.e., update the board}

      Optimizer.GameMetrics:=GameMetrics;

      if not Result then begin
         Optimizer.Result         :=prFailed;
         Optimizer.IterationResult:=False;
         TerminateSearch; {something is wrong, such as 2 different positions accidentally having identical hashvalues}
         end;
    end;

    function  SearchHasTerminated:Boolean;
    begin
      Result:=(Solver.SearchLimits.DepthLimit<0)                                {'<0': the search has terminated}
              or
              (Optimizer.Result=prFailed);                                      {'prFailed': the search has failed, for instance if 2 different positions have the same hash-value}
    end; // OptimizeGame.Search.SearchHasTerminated

    function  RearrangementOptimization(Purge__,KeepExistingBoxSessions__,TryAllBoxes__,TryPushSequences__,TrySymmetryOptimization__:Boolean):Boolean;
    // optimizes the game by permuting the existing pushes;

    // precondition: if 'Purge__' is 'False' then the caller must have prepared
    // the best path by a call to 'TTPurge()' beforehand, e.g., to
    // update successor-links between the nodes, and to clear some of the
    // position flags;

    // if 'KeepExistingBoxSessions__' is 'True' then the function keeps the
    // existing box-sessions and it doesn't try to inject other box-sessions
    // between the individual push-members of the existing box-sessions;
    // keeping the existing box-sessions is much faster, in particular for
    // long solutions where the exponential growth otherwise becomes a problem;

    // if 'TryAllBoxes__' is 'True' then the function tries to promote pushes
    // for all the boxes;
    // if 'TryAllBoxes__' is 'False' then the function only tries to promote
    // pushes of the same box as the one currently under investigation;

    // if 'TryPushSequences__' is 'True' then the function tries to promote
    // whole sequences of moves; e.g., if the original solution is:
    // ...aaa.....a...a...axyz...
    // then the function tries promotions like:
    // ...aaaaaaxyz...
    // all "xyz..." successors are tested as long as they are legal pushes at
    // their new positions after "...aaaaaa"

    // the following pseudo-code describes what the function does when the
    // most thorough analysis is selected;

    //..for each push "A" along the best path
    //....for each box "B"
    //......while there are more pushes "Bn" of box "B" on the rest of the path
    //.......while "... A B1 B2 B3...Bn Ss Xs ..." is a legal transformation of the path
    //.........where "Xs" are all the non-B pushes in the interval [A..Bn]
    //.........where "Ss" is zero or more of the immediate successors of "Bn"
    //.........if this transformation is better than the existing best path then
    //............make this transformation the new best path

    const MAX_PATH_LENGTH=High(Positions.Positions^[0].PushCount); // currently, the path length is "unlimited"; if the exponential growth in the number of box-session permutations makes the function too slow, then a limit can be defined here
    var   StartTimeMS:TTimeMS;

      // forward declarations
      function  IsALegalPush(BoxNo__:Integer; Direction__:TDirection; BoxSquare__:Integer):Boolean; forward;

      procedure DoPushUpdatingGameMetrics(Position__:PPosition; CalculatePlayersDistances__,UpdatePosition__:Boolean);
      var PlayerFromSquare:Integer;
      begin
        with Solver.SearchStates[0].PlayersReachableSquares do
          with Position__^ do begin
            if CalculatePlayersDistances__ then CalculatePlayersDistanceToReachableSquares(0);
            PlayerFromSquare:=PlayerPos-Game.SquareOffsetForward[TDirection(Ord(Move.Direction) and DIRECTION_BIT_MASK)];
            Inc(Optimizer.GameMetrics.MoveCount,Pred(Squares[PlayerFromSquare]-TimeStamp)); // update the number of moves in the game with the non-pushing player-moves
            DoPush(Move.BoxNo,TDirection(Cardinal(Move.Direction) and DIRECTION_BIT_MASK));
            if UpdatePosition__ then with POptimizerPosition(Position__)^ do with Position do begin // 'True': update the information stored for this position, e.g., its game metrics
               PushCount             :=Optimizer.GameMetrics.PushCount;         // update the game-metrics for the position
               MoveCount             :=Optimizer.GameMetrics.MoveCount;
               BoxChanges            :=Optimizer.GameMetrics.BoxChanges;
               BoxLines              :=Optimizer.GameMetrics.BoxLines;
               PushingSessions       :=Optimizer.GameMetrics.PushingSessions;
               PlayerLines           :=Optimizer.GameMetrics.PlayerLines;       // note that the player lines value is incorrect here; the player lines metric has not been calculated at this point
               HashValue             :=Game.HashValue;                          // update the hash value for the position
               if Successor          <>nil then Successor^.Parent:=Position__;  // update the parent chain for the positions on the best path
               end;
            end;
      end; // DoPushUpdatingGameMetrics

      function  DoPushes(Start__,Stop__:PPosition; BoxNo__:Integer; UpdatePositions__:Boolean; var Last__:PPosition):Integer;
      var Position:PPosition;
      begin // performs pushes from the position 'Start__' up to, but not including the position 'Stop__'; if 'BoxNo' <> 0 then only a sequence of pushes with that box-number is performed
        Result:=0; Last__:=Start__^.Parent; Position:=Start__;
        CalculatePlayersDistanceToReachableSquares(0); // 'IsALegalPush()' requires that the player's distance to all reachable squares has been calculated, using index = 0
        while (Position<>Stop__) and
              (Position<>nil) and
              ((BoxNo__=0) or (BoxNo__=Position^.Move.BoxNo)) and
              IsALegalPush(Position^.Move.BoxNo,Position^.Move.Direction,Position^.PlayerPos) do begin
              DoPushUpdatingGameMetrics(Position,False,UpdatePositions__);
              CalculatePlayersDistanceToReachableSquares(0);
              Inc(Result); Last__:=Position; Position:=Position^.Successor;
              end;
      end; // DoPushes

      function  IsALegalPush(BoxNo__:Integer; Direction__:TDirection; BoxSquare__:Integer):Boolean;
      begin // precondition: player's distance to reachable squares has been calculated, using index = 0}
        Direction__:=TDirection(Ord(Direction__) and DIRECTION_BIT_MASK);
        with Game do with Solver.SearchStates[0].PlayersReachableSquares do
           Result:={inline simple checks for legal moves}
                   (BoxPos[BoxNo__]=BoxSquare__) and {'=': the box is located at the correct square}
                   ((Board [BoxPos[BoxNo__]-SquareOffsetForward[Direction__]] and (BOX+WALL))=0) {'=0' the opposite neighbor-square is not blocked by a wall or another box}
                   and
                   (Squares[BoxPos[BoxNo__]-SquareOffsetForward[Direction__]]>TimeStamp){'>TimeStamp': the player can reach the square (or the square is a wall, which is isn't at this point)}
                   and
                   ((Board [BoxPos[BoxNo__]+SquareOffsetForward[Direction__]] and (BOX+WALL+FLAG_ILLEGAL_BOX_SQUARE))=0) {'=0' the square is legal and not blocked by a wall or another box}
                   and
                   {extended checks for legal moves}
                   YASS.IsALegalPush(BoxNo__,Direction__,-1);
      end; // IsALegalPush

      procedure UndoAllPushes(CurrentPosition__:PPosition);
      begin // undo all pushes from the current position 'CurrentPosition__' back to the start position; precondition: the game-state (e.g., the board) matches the position 'CurrentPosition__'
        while CurrentPosition__<>nil do with CurrentPosition__^ do begin        // undo all pushes
          YASS.UndoPush(Move.BoxNo,Move.Direction);
          CurrentPosition__:=Parent;                                            // backtrack to the previous position on the path
          end;
        MovePlayer(Positions.StartPosition^.PlayerPos);                         // reset player position
        SetGameMetrics(nil);                                                    // reset game metrics
      end; // UndoAllPushes

      function  UpdatePositionsOnBestPath(var CurrentPosition__:PPosition):Boolean;
      var LastPositionSimpleLowerBound:Integer; BestPositionMetricsChanged:Boolean;
          LastPosition:PPosition;
      begin // updates game-metrics, hash-values, and parent-chain for all positions on the best path
            // precondition: 'Positions.CurrentPosition = nil'; otherwise 'CalculateMetricsForPositionsOnBestPath()' tries to undo the pushes on the path leading to 'Positions.CurrentPosition', and 'UndoAllPushes()' has already done that
        Result:=Positions.CurrentPosition=nil;
        if Result then begin
           UndoAllPushes(CurrentPosition__);                                    // backtrack to the start position

           DoPushes(Positions.StartPosition^.Successor,nil,0,True,LastPosition); // replay all pushes on the best path and update game-metrics, hash-values, and parent-chain for each position on the path
           Result:=(LastPosition<>nil) and (LastPosition^.Successor=nil) and Result; // 'True': all pushes on the path have been performed, i.e., all pushes on the path were legal
           LastPositionSimpleLowerBound:=Game.SimpleLowerBound;
           UndoAllPushes(LastPosition);                                         // backtrack to the start position

           if Result then begin
              if LastPositionSimpleLowerBound=0 then                            // '0': the game is solved, i.e., the best found path is a solution
                 Positions.SolutionPosition:=LastPosition;                      // the last position on the path may have changed; in that case the solution position must be updated accordingly if the best path is a solution
              if Positions.BestPosition<>nil then with Positions.BestPosition^.Move do
                 Direction:=TDirection(Ord(Direction) and (not POSITION_TARGET_TAG)); // remove the 'target' tag from the best existing position; maybe it isn't the last position on the path anymore
              UpdateBestPosition(LastPosition);
              with LastPosition^.Move do Direction:=TDirection(Cardinal(Ord(Direction)) or POSITION_TARGET_TAG); // ensure that the last position on the best path is tagged as a target position

              if RemoveCyclesFromBestPath(False) then begin                     // changing the push sequence may have introduced cycles; remove them, if any
                 // theoretically, cycle removal can destroy the solution if two
                 // different positions have matching hash values and player positions;
                 // this is unlikely to happen in practice, but the optimizer must
                 // handle it gracefully

                 // cycle removal may invalidate box numbers and push directions for
                 // the positions on the best path;
                 // CalculateMetricsForPositionsOnBestPath()' recalculates them
                 // provided the path hasn't been destroyed by the cycle removal;

                 while (LastPosition<>nil) and (LastPosition<>CurrentPosition__) do LastPosition:=LastPosition^.Parent; // check if the current position still is a member of the path
                 if LastPosition=nil then CurrentPosition__:=Positions.StartPosition^.Successor; // if the current position dropped out of the path then re-start the optimization from the first position
                 end;

              {recalculate metrics for positions on the best path, in particular the player lines; this metric is not calculated during the search; it's only calculated here so the user can get the correct status information}
              Result:=CalculateMetricsForPositionsOnBestPath(BestPositionMetricsChanged); // this fails if a cycle-removal made a mistake by assuming that positions are identical when they have the same hash values and the same player positions
              SetPosition(nil);                                                 // backtrack to the starting position; 'CalculateMetricsForPositionsOnBestPath()' replays the legal pushes on the best path
              end;

           if Result then begin
              ShowStatus;
              WriteBestPathToLogFile;
              end
           else begin
              //Msg(TEXT_INTERNAL_ERROR,'Box-changes Optimization');
              TerminateSearch; Optimizer.Result:=prFailed;
              end;

           if CurrentPosition__<>nil then
              DoPushes(Positions.StartPosition^.Successor,CurrentPosition__^.Successor,0,False,LastPosition); // replay pushes so the game-state again matches the position 'CurrentPosition__'
           end
        else
           Msg(TEXT_INTERNAL_ERROR+': "OptimizeGame.RearrangementOptimization.UpdatePositionsOnBestPath"',TEXT_APPLICATION_TITLE);
      end; // UpdatePositionsOnBestPath

      function  RearrangementOptimization__(KeepExistingBoxSessions__,TryAllBoxes__,TryPushSequences__:Boolean):Boolean;
      type
        TNextBoxPosition=array[TBoxNo] of PPosition;               // roots of the per-box position-chains
      var
        PromoteBoxNo:Integer; OK:Boolean; LastStatusTimeMS,TimeMS:TTimeMS;
        CurrentPosition,LastPromoteBoxPosition,BestPushSequenceCandidate,LastPushSequenceCandidate,q,r,s,t,u:PPosition;
        GameMetrics1,GameMetrics2,GameMetrics3:TOptimizerGameMetrics;
        NextBoxPosition:TNextBoxPosition;
        ////SquareVisitedByPushes:TBoard;

        procedure MakePerBoxPositionChains(CurrentPosition__:PPosition; var NextBoxPosition__:TNextBoxPosition);
        var Position:PPosition;
        begin // makes per-box chains of positions on the remaining part of the best path after the position 'CurrentPosition__'
           FillChar(NextBoxPosition__,SizeOf(NextBoxPosition__),0);             // on exit from the function, 'NextBoxPosition__' contains the roots of the per-box position-chains

           Position:=Positions.StartPosition;
           while Position^.Successor<>nil do Position:=Position^.Successor;     // find the last position on the best path

           while Position<>CurrentPosition__ do with Position^ do begin         // process each position on the best path after the current position, building chains of positions for each box
             HashBucket.Next:=NextBoxPosition__[Move.BoxNo];                    // use 'HashBucket.Next' for the forward chain of positions per box; 'TTPurge()' is later called in order to rebuild the correct hash-chains
             NextBoxPosition__[Move.BoxNo]:=Position;                           // remember the most recently seen position where this box is pushed
             Position:=Parent;
             end;
        end; // MakePerBoxPositionChains

        procedure MovePositions(First__,Last__,After__:PPosition);
        begin // moves the positions 'First__' .. 'Last__' (both included) after the position 'After__'
          if First__^.Parent<>nil then begin
             First__^.Parent^.Successor:=Last__^.Successor;
             if First__^.Parent^.Successor<>nil then
                First__^.Parent^.Successor^.Parent:=First__^.Parent;
             end;
          Last__^.Successor:=After__^.Successor;
          if Last__^.Successor<>nil then Last__^.Successor^.Parent:=Last__;
          First__^.Parent:=After__;
          After__^.Successor:=First__;
        end; // MovePositions
{
        procedure ShowPath(CurrentPosition__:PPosition);
        var Position:PPosition;
        begin // precondition: the game state matches the start position
          if Positions.StartPosition<>nil then begin
             UndoAllPushes(CurrentPosition__);
             Position:=Positions.StartPosition;

             while Position^.Successor<>nil do begin
               Position:=Position^.Successor;
               DoPushUpdatingGameMetrics(Position,True,False);
               ShowBoard;
               Writeln(GameMetricsAsText);
//             if Position^.PushCount>=45 then
                  Readln;
               end;

             while Position<>CurrentPosition__ do with Position^ do begin
               YASS.UndoPush(Move.BoxNo,Move.Direction);
               Position:=Parent;
               end;
             MovePlayer(CurrentPosition__^.PlayerPos);
             SetGameMetrics(CurrentPosition__);

             ShowBoard;
             Writeln(GameMetricsAsText);
             Readln;
             end;
        end;
}
      begin // RearrangementOptimization__
        Result:=False; LastStatusTimeMS:=0;

        if (not SearchHasTerminated) and
           (Positions.StartPosition<>nil) and
           (Positions.BestPosition <>nil) and
           (Positions.StartPosition<>Positions.BestPosition) then begin         // 'StartPosition' = 'BestPosition': in that case the level has a trivial 0-push solution
           SetPosition(nil);
           CurrentPosition:=Positions.StartPosition;
           PromoteBoxNo:=0;
           MakePerBoxPositionChains(CurrentPosition,NextBoxPosition);
           ////FillChar(SquareVisitedByPushes,SizeOf(SquareVisitedByPushes),0); // all code lines related to the visited squares are commented out with "////"

           while (CurrentPosition^.Successor<>nil)                              // for each position on the best path...
                 and
                 (Solver.SearchLimits.DepthLimit>=0) do begin                   // '>=0': the search hasn't been terminated

             if (not TryAllBoxes__)
                or
                (PromoteBoxNo=Game.BoxCount) then begin                         // '=': pushes for all boxes on the board have been tested
                repeat CurrentPosition:=CurrentPosition^.Successor;             // advance to the next position on the best path
                       DoPushUpdatingGameMetrics(CurrentPosition,True,False);   // perform the next push on the path
                       with CurrentPosition^ do NextBoxPosition[Move.BoxNo]:=HashBucket.Next; // update the root of the per-box position-chain for the current box
                until  (not KeepExistingBoxSessions__) or                       // 'not KeepExistingBoxSessions__': advance only one push at a time, thereby searching more thoroughly for box-session-permutations that can improve the metrics
                       ((CurrentPosition^.Successor=nil) or                     // 'nil': it's the last push on the path
                       (CurrentPosition^.Move.BoxNo<>CurrentPosition^.Successor.Move.BoxNo)); // '<>' the path changes focus from one box to another
                if     TryAllBoxes__ then
                       PromoteBoxNo:=1                                          // start enumerating the box-numbers [1..'Game.BoxCount']
                else   PromoteBoxNo:=CurrentPosition^.Move.BoxNo;               // 'not TryAllBoxes__': only search for improvements by grouping same-box-pushes together, e.g., by changing pushes "aabcd...a...a.." to "aaaabcd..."

                TimeMS:=CalculateElapsedTimeMS(StartTimeMS,GetTimeMS);
                if     (((TimeMS>LastStatusTimeMS)
                         and
                         (TimeMS-LastStatusTimeMS>=SOKOBAN_PLUGIN_CALL_BACK_FUNCTION_THRESHOLD_TIME_MS)
                        )
                        or
                        ((LastStatusTimeMS=0)                                   // '0': except the rare case where the time really is 0, this typically means that the program has been compiled without a working 'GetTimeMS()' function
                         and
                         TryAllBoxes__                                          // if 'TryAllBoxes__' is 'False', then the search is assumed to be fast enough, and there is no reason to trigger a time-check too often
                         and
                         ((CurrentPosition^.PushCount and 127)=0)
                        )
                       )
                       and
                       (CurrentPosition^.Successor<>nil)                        // '<>': this isn't the last push on the best path; (avoid updating the screen with a push-sequence text like 'Pushes: N..N' where 'N' is the push-path-length)
                       then begin
                       {$IFDEF CONSOLE_APPLICATION}
                         Writeln(SearchStatePromptText,
                                 TEXT_SEARCH_STATUS_REARRANGEMENT_OPTIMIZATION,
                                 CurrentPosition^.PushCount,
                                 LAZY_COLON,
                                 Positions.BestPosition.PushCount,
                                 RIGHT_PAREN
                                 {$IFDEF WINDOWS}
                                   ,' Time: ',(CalculateElapsedTimeMS(Solver.StartTimeMS,GetTimeMS)+500) div 1000
                                 {$ENDIF}
                                );
                       {$ELSE}
                         Optimizer.SearchStateStatusText:=TEXT_SEARCH_STATUS_REARRANGEMENT_OPTIMIZATION+IntToStr(CurrentPosition^.PushCount)+LAZY_COLON+IntToStr(Positions.BestPosition^.PushCount)+RIGHT_PAREN;
                         SetSokobanStatusText(Optimizer.SearchResultStatusText+Optimizer.SearchStateStatusText);
                       {$ENDIF}

                       TimeCheck;

                       LastStatusTimeMS:=CalculateElapsedTimeMS(StartTimeMS,GetTimeMS);
                       if LastStatusTimeMS>=MAX_BOX_CHANGES_OPTIMIZATION_TIME_LIMIT_MS then
                          TerminateSearch;                                      // guard against large wide open levels where the algorithm may run 'forever'
                       if Solver.SearchLimits.DepthLimit<0 then begin           {'True': the time limit has been exceeded, or the search has been terminated manually}
                          Solver.SearchLimits.PushCountLimit:=High(Solver.SearchLimits.PushCountLimit); {'High': allow the search to run to its completion, but only visit existing positions, without creating new ones}
                          PromoteBoxNo:=0;                                      {'0': don't promote any boxes in the 'repeat' loop below}
                          end;
                       end;
                end
             else begin
                Inc(PromoteBoxNo);                                              // iterate through the box-numbers 1..'Game.BoxCount', trying to promote box-sessions by placing them right after the current position
                end;
             GameMetrics1:=Optimizer.GameMetrics;                               // save the game metrics for the current position
             LastPromoteBoxPosition:=CurrentPosition; OK:=False;                // remember the position with the most recent push of the box currently under investigation

             repeat
               q:=LastPromoteBoxPosition; BestPushSequenceCandidate:=nil; ////LastPushSequenceCandidate:=nil;

               //repeat q:=q^.Successor;                                        // find the next promote-box push, if any
               //until  (q=nil) or (q^.Move.BoxNo=PromoteBoxNo);
               if   q=CurrentPosition then                                      // 'True': find the first promote-box push after the current position, if any
                    q:=NextBoxPosition[PromoteBoxNo]                            // the next promote-box push, if any, can be found in the 'NextBoxPosition' vector
               else q:=q^.HashBucket.Next;                                      // the next push of the same box, if any, is stored in the 'HashBucket.Next' field

               // check if it's legal to perform the next promote-box-push after the current sequence of promote-box-pushes
               if     (q<>nil) and
                      ((Game.Board[Game.BoxPos[q^.Move.BoxNo]] and FLAG_NOT_SELECTED_SQUARE)=0) and // 'True': the box square is a member of the set of squares selected for optimization (typically all the squares)
                      (DoPushes(q,nil,PromoteBoxNo,False,r)<>0) then begin      // 'True': the next promote-box-push is legal after the current sequence of promote-box-pushes
                      GameMetrics2:=Optimizer.GameMetrics;                      // save the game metrics for the last performed promote-box push
                      LastPromoteBoxPosition:=r;                                // remember the position with the most recent push of the box currently under investigation
                      q:=CurrentPosition;
                      with CurrentPosition^ do begin                            // compensate for the unwanted contribution from the current position to the calculation of the visited squares inside the following loop
                        ////Dec(SquareVisitedByPushes[PlayerPos]);
                        ////Dec(SquareVisitedByPushes[PlayerPos+Game.SquareOffsetForward[TDirection(Ord(Move.Direction) and DIRECTION_BIT_MASK)]]);
                        end;
                      repeat with q^ do begin                                   // test if all different-box-pushes in [current-push + 1 .. last-promote-box-push] still are legal, now that the next sequence of promote-box-pushes have been performed
                               ////Inc(SquareVisitedByPushes[PlayerPos]);       // mark the squares directly affected by the pushes on the path from the current position to the promote-box-push; non-pushing player-moves are not taken into account
                               ////Inc(SquareVisitedByPushes[PlayerPos+Game.SquareOffsetForward[TDirection(Ord(Move.Direction) and DIRECTION_BIT_MASK)]]);
                               end;
                             q:=q^.Successor;
                      until  (q=LastPromoteBoxPosition) or
                             ((q^.Move.BoxNo<>PromoteBoxNo) and (DoPushes(q,q^.Successor,0,False,r)=0)); // 'DoPushes(...)=0': the move is illegal

                      if q=LastPromoteBoxPosition then begin                    // 'True': all different-box-pushes between [current-push + 1 .. last-promote-box-push] are still legal
                         CalculatePlayersDistanceToReachableSquares(0);
                         if  (LastPromoteBoxPosition^.Successor=nil)            // 'nil': this is the last push on the path
                             or                                                 // if it isn't the last push on the path, then check that the next push after the last promote-box-push still is legal
                             IsALegalPush(LastPromoteBoxPosition^.Successor^.Move.BoxNo,LastPromoteBoxPosition^.Successor^.Move.Direction,LastPromoteBoxPosition^.Successor^.PlayerPos)
                             then begin

                             r:=LastPromoteBoxPosition;
                             if r^.Successor<>nil then begin                    // 'True': there are more pushes on the path; perform the next one before checking whether the new path is better
                                r:=r^.Successor;                                // advance to the next push after the most recent push of the box currently under investigation
                                DoPushUpdatingGameMetrics(r,True,False);        // perform the next push on the best path
                                end;

                             // note that the metrics calculation is not as good
                             // as it could be because it doesn't take any newly
                             // introduced cycles into account;
                             // however, if an improvement is found despite of
                             // this shortcoming, then cycles are removed from
                             // the path before this function returns;
                             if not HasABetterOrEqualScore(r) then begin        // 'True': changing the order of the box-pushes improves the score
                                OK:=True;
                                end;

                             while r<>LastPromoteBoxPosition do begin           // restore the game state after the most recent push of the box currently under investigation, i.e., 'PromoteBoxNo'
                               YASS.UndoPush(r^.Move.BoxNo,r^.Move.Direction);
                               r:=r^.Parent;
                               end;
                             end;
                         end;

                      ////if TryPushSequences__ and
                      ////   (TryAllBoxes__ or (PromoteBoxNo=CurrentPosition^.Move.BoxNo)) and
                      ////   (not OK) then begin
                      ////   r:=LastPromoteBoxPosition^.Successor;                  // find the sequence of pushes after 'promote-box-push', if any, that potentially can be moved together with 'promote-box-push'
                      ////   while (r<>nil)
                      ////         and
                      ////         (SquareVisitedByPushes[r^.PlayerPos]=0)
                      ////         and
                      ////         (SquareVisitedByPushes[r^.PlayerPos+Game.SquareOffsetForward[TDirection(Ord(r^.Move.Direction) and DIRECTION_BIT_MASK)]]=0)
                      ////         do begin
                      ////         LastPushSequenceCandidate:=r;
                      ////         r:=r^.Successor;
                      ////         end;
                      ////   end;

                      r:=q^.Parent;                                             // undo all performed different-box-pushes in [current-push + 1 .. last-performed-different-box-push]
                      while r<>CurrentPosition do begin
                        with r^ do begin                                        // undo the visited squares calculation for this push
                          ////Dec(SquareVisitedByPushes[PlayerPos]);
                          ////Dec(SquareVisitedByPushes[PlayerPos+Game.SquareOffsetForward[TDirection(Ord(Move.Direction) and DIRECTION_BIT_MASK)]]);
                          end;
                        if r^.Move.BoxNo<>PromoteBoxNo then YASS.UndoPush(r^.Move.BoxNo,r^.Move.Direction);
                        r:=r^.Parent;
                        end;

                      if //// LastPushSequenceCandidate<>nil
                         TryPushSequences__ and
                         (TryAllBoxes__ or (PromoteBoxNo=CurrentPosition^.Move.BoxNo)) and
                         (LastPromoteBoxPosition^.Successor<>nil) and
                         (not OK)
                         then begin
                         LastPushSequenceCandidate:=Positions.BestPosition;

                         // test if it improves the solution if a whole sequence
                         // of pushes starting with 'last-promote-box-push' is
                         // moved right after the current position
                         Optimizer.GameMetrics:=GameMetrics2;                   // restore the game metrics      after the most recent push of the box currently under investigation, i.e., 'PromoteBoxNo'
                         MovePlayer(LastPromoteBoxPosition^.PlayerPos);         // restore the player's position after the most recent push of the box currently under investigation, i.e., 'PromoteBoxNo'

                         r:=LastPromoteBoxPosition; s:=r;
                         repeat r:=r^.Successor;                                // repeat as long as the next successor after the investigated same-box-push is legal
                                if   DoPushes(r,r^.Successor,0,False,s)<>0 then with Solver.SearchStates[0].PlayersReachableSquares do begin

                                     GameMetrics3:=Optimizer.GameMetrics;

                                     // check if all intermediate different-box-pushes are legal now that one of more successors have been promoted
                                     t:=CurrentPosition;
                                     repeat t:=t^.Successor;
                                     until  (t=LastPromoteBoxPosition) or
                                            ((t^.Move.BoxNo<>PromoteBoxNo) and (DoPushes(t,t^.Successor,0,False,u)=0));

                                     if t=LastPromoteBoxPosition then begin     // 'True': all intermediate different-box-pushes are legal after the promotion
                                        CalculatePlayersDistanceToReachableSquares(0);
                                        // check if the rest of the pushes legally can be hooked up after the now performed pushes
                                        if  (r^.Successor=nil)                  // 'nil': this is the last push on the path
                                            or                                  // if it isn't the last push on the path, then check that the next push after the last promote-box-push still is legal
                                            IsALegalPush(r^.Successor^.Move.BoxNo,r^.Successor^.Move.Direction,r^.Successor^.PlayerPos)
                                            then begin
                                            u:=r;
                                            if u^.Successor<>nil then begin     // 'True': there are more pushes on the path; perform the next one before checking whether the new path is better
                                               u:=u^.Successor;                 // advance to the next push
                                               DoPushUpdatingGameMetrics(u,True,False); // perform the next push on the path
                                               end;

                                            // note that the metrics calculation is not as good
                                            // as it could be because it doesn't take any newly
                                            // introduced cycles into account;
                                            // however, if an improvement is found despite of
                                            // this shortcoming, then cycles are removed from
                                            // the path before this function returns;
                                            if not HasABetterOrEqualScore(u) then begin // 'True': changing the order of the box-pushes improves the score
                                               OK:=True;
                                               BestPushSequenceCandidate:=r;
                                               end;

                                            while u<>r do begin                 // restore the game state after the most recent push under investigation
                                              YASS.UndoPush(u^.Move.BoxNo,u^.Move.Direction);
                                              u:=u^.Parent;
                                              end;
                                            end;
                                        end;

                                     // undo the performed intermediate different-box-pushes
                                     t:=t^.Parent;
                                     while t<>CurrentPosition do begin
                                       if t^.Move.BoxNo<>PromoteBoxNo then YASS.UndoPush(t^.Move.BoxNo,t^.Move.Direction);
                                       t:=t^.Parent;
                                       end;

                                     Optimizer.GameMetrics:=GameMetrics3;       // restore the game metrics
                                     MovePlayer(r^.PlayerPos);                  // restore the player's position
                                     end
                                else r:=LastPushSequenceCandidate;
                         until  r=LastPushSequenceCandidate;
                         // undo the performed successor pushes after last-promote-box-push
                         while s<>LastPromoteBoxPosition do begin
                           YASS.UndoPush(s^.Move.BoxNo,s^.Move.Direction);
                           s:=s^.Parent;
                           end;
                         end;

                      Optimizer.GameMetrics:=GameMetrics2;                      // restore the game metrics      after the most recent push of the box currently under investigation, i.e., 'PromoteBoxNo'
                      MovePlayer(LastPromoteBoxPosition^.PlayerPos);            // restore the player's position after the most recent push of the box currently under investigation, i.e., 'PromoteBoxNo'
                      end
               else   q:=nil;                                                   // 'nil': stop searching for more pushes with box-number 'PromoteBoxNo''
             until (q=nil) or OK; // until all 'promote-box-number' pushes on the best path have been tested, or until the current sequence of promote-box-pushes can be performed after the current position and thereby improve the metrics

             r:=LastPromoteBoxPosition;                                         // undo all promote-box-pushes in [current-push + 1 .. last-promote-box-push]
             while r<>CurrentPosition do begin
               if r^.Move.BoxNo=PromoteBoxNo then YASS.UndoPush(r^.Move.BoxNo,r^.Move.Direction);
               r:=r^.Parent;
               end;
             Optimizer.GameMetrics:=GameMetrics1;                               // restore the game metrics after the current position
             MovePlayer(CurrentPosition^.PlayerPos);                            // restore the player's position after the current position

             if OK then begin                                                   // 'True': the sequence of promote-box-pushes in [current-push + 1, last-promote-box-push] can be performed after the current position and improve the metrics
                Result:=True;
                q:=CurrentPosition; r:=CurrentPosition; s:=LastPromoteBoxPosition^.Successor; // 's': save the first successor after the last-promote-box-push in case last-promote-box-push is the first of a sequence of pushes to be promoted
                //ShowBoard; Writeln(GameMetricsAsText);
                repeat r:=r^.Successor;                                         // find the promote-box pushes in [current-push + 1 .. last-promote-box-push] that should be moved after the current position
                       if r^.Move.BoxNo=PromoteBoxNo then begin                 // 'True': this is one of the promote-box positions that should be moved, unless it already is at the right place
                          if r<>q^.Successor then begin                         // '<>': the position isn't already at the right place in the sequence, hence, move it now
                             MovePositions(r,r,q); Inc(Result);
                             end;
                          q:=q^.Successor;
                          end;
                until  r=LastPromoteBoxPosition;                                // until all promote-box-pushes in the sequence [current-pushs + 1 .. last-promote-box-push] have been visited
                if     BestPushSequenceCandidate<>nil then                      // 'True': move one or more last-promote-box-push successors too
                       MovePositions(s,BestPushSequenceCandidate,r);
                if not UpdatePositionsOnBestPath(CurrentPosition) then begin;   // update game-metrics, hash-values, and parent-chain for all positions on the best path
                   Result:=False; TerminateSearch; Optimizer.Result:=prFailed;
                   end;
                MakePerBoxPositionChains(CurrentPosition,NextBoxPosition);      // rebuild the per-box position-chains now that the best path has changed
                PromoteBoxNo:=0;                                                // retry all boxes after the current position now that an improvement has been found
                end;
             end; // end of the iteration through the positions on the best found path

           UndoAllPushes(CurrentPosition); CurrentPosition:=nil;                // undo all moves again, i.e., reset the game

           DoPushes(Positions.StartPosition^.Successor,nil,0,True,CurrentPosition); // replay all pushes on the best path and update game-metrics, hash-values, and parent-chain for each position on the path
           if (CurrentPosition=nil) or (CurrentPosition^.Successor<>nil) then begin // 'True': some of the pushes on the best are illegal, i.e., the cycle removal may have destroyed the path
              Result:=False; TerminateSearch; Optimizer.Result:=prFailed;
              end;
           UndoAllPushes(CurrentPosition);                                      // backtrack to the start position

           if (not (TTPurge(Positions.Capacity,False)>=0)) then begin           // 'TTPurge()' must be called even if no improvements were found; it rebuilds the hash-chains which temporarily have been overwritten by the per-box position chains
              // Msg(TEXT_INTERNAL_ERROR,'Box-changes Optimization');
              Result:=False; TerminateSearch; Optimizer.Result:=prFailed;
              end;
           end;
      end; // RearrangementOptimization__

      function  SymmetryOptimization:Boolean;
      // optimizes the game by selecting the shortest player paths in
      // symmetrical positions;
      // precondition: none of the pushes on the best path is a member of any
      // lists, such as the  open queue; this function uses the overlapping
      // 'Successor' slot in each position on the best path
      type
         TBoard__            = record // a local board type including width and height
          Directions         : TDirectionMap; // mapping the original directions to the transformed directions
          DirectionOffsets   : TDirectionArrayOfIntegers; // mapping the original directions (not the transformed directions) directly to relative movements on the transformed board
          Height             : Integer;
          PlayerPos          : Integer;
          Squares            : TBoard;
          Width              : Integer;
        end;
        TTransformation2D    = (t2DRotate0DegreesClockwise, {order must not change}
                                t2DRotate90DegreesClockwise,
                                t2DRotate180DegreesClockwise,
                                t2DRotate270DegreesClockwise,
                                t2DRotate0DegreesClockwiseFlipHorizontally,
                                t2DRotate90DegreesClockwiseFlipHorizontally,
                                t2DRotate180DegreesClockwiseFlipHorizontally,
                                t2DRotate270DegreesClockwiseFlipHorizontally);
        TTransformation2DSet = set of TTransformation2D;
      const
        TRANSFORMATION_2D_INVERSE
                             : array[TTransformation2D] of TTransformation2D =
                               (t2DRotate0DegreesClockwise,
                                t2DRotate270DegreesClockwise,
                                t2DRotate180DegreesClockwise,
                                t2DRotate90DegreesClockwise,
                                t2DRotate0DegreesClockwiseFlipHorizontally,
                                t2DRotate90DegreesClockwiseFlipHorizontally,
                                t2DRotate180DegreesClockwiseFlipHorizontally,
                                t2DRotate270DegreesClockwiseFlipHorizontally
                               );

      var
        Boards:array[TTransformation2D] of TBoard__;
        Direction:TDirection;
        BoxSquare,BoxSquareCol,BoxSquareRow:Integer;
        //StartTimeMS:TTimeMS;
        T:TTransformation2D;
        Position:PPosition;

        procedure ShowBoard(Board__:TBoard__);
        var OldBoard:TBoard__;
        begin
          OldBoard.Width:=Game.BoardWidth; OldBoard.Height:=Game.BoardHeight; OldBoard.Squares:=Game.Board; // save the current game board
          Game.BoardWidth:=Board__.Width; Game.BoardHeight:=Board__.Height; Game.Board:=Board__.Squares; // put the transformed board on the game board
          if Board__.PlayerPos<>0 then Game.Board[Board__.PlayerPos]:=Game.Board[Board__.PlayerPos] or PLAYER;
          Writeln; YASS.ShowBoard; Write(Ord(T),SPACE,Game.BoardWidth,'x',Game.BoardHeight); Readln; // display the board
          Game.BoardWidth:=OldBoard.Width; Game.BoardHeight:=OldBoard.Height; Game.Board:=OldBoard.Squares; // restore the game board
        end;

        function  ColRowToSquare(Col__,Row__,BoardWidth__:Integer):Integer;
        begin
          Result:=Row__ * (BoardWidth__+2) + Col__;
        end;

        procedure SquareToColRow(Square__,BoardWidth__:Integer; var Col__,Row__:Integer);
        begin
          Row__:=Square__   div   (BoardWidth__+2);
          Col__:=Square__ - Row__*(BoardWidth__+2);
        end;

        procedure TransformDirections(Initialize__:Boolean; Transformation2D__:TTransformation2D; var NewDirections__:TDirectionMap);
        var Direction:TDirection;

          procedure FlipVertically;
          var Direction:TDirection;
          begin
            for Direction:=Low(NewDirections__) to High(NewDirections__) do
                case NewDirections__[Direction] of
                  dUp    : NewDirections__[Direction]:=dDown;
                  dDown  : NewDirections__[Direction]:=dUp;
                end; {case}
          end;

          procedure FlipHorizontally;
          var Direction:TDirection;
          begin
            for Direction:=Low(NewDirections__) to High(NewDirections__) do
                case NewDirections__[Direction] of
                  dLeft  : NewDirections__[Direction]:=dRight;
                  dRight : NewDirections__[Direction]:=dLeft;
               end; {case}
          end;

          procedure RotateClockwise(Count__:Integer);
          var i:Integer; Direction:TDirection;
          begin
            for Direction:=Low(NewDirections__) to High(NewDirections__) do
                for i:=1 to Count__ do
                    NewDirections__[Direction]:=PREVIOUS_DIRECTION[NewDirections__[Direction]];
          end;

        begin {TransformDirections}
          if Initialize__ then // 'True': initialize the new directions; the alternative is that the transformation updates the existing mapping, typically when a transformation is composed by more than one transformation
             for Direction:=Low(NewDirections__) to High(NewDirections__) do
                 NewDirections__[Direction]:=Direction;
          case Transformation2D__ of
            t2DRotate0DegreesClockwise                   :;
            t2DRotate90DegreesClockwise                  : RotateClockwise(1);
            t2DRotate180DegreesClockwise                 : RotateClockwise(2);
            t2DRotate270DegreesClockwise                 : RotateClockwise(3);
            t2DRotate0DegreesClockwiseFlipHorizontally   : FlipHorizontally;
            t2DRotate90DegreesClockwiseFlipHorizontally  : begin RotateClockwise(1); FlipHorizontally; end;
            t2DRotate180DegreesClockwiseFlipHorizontally : begin RotateClockwise(2); FlipHorizontally; end;
            t2DRotate270DegreesClockwiseFlipHorizontally : begin RotateClockwise(3); FlipHorizontally; end;
          end; {case}
        end; {TransformDirections}

        procedure TransformColRow(Transformation2D__:TTransformation2D; Col__,Row__,Width__,Height__:Integer; var NewCol__,NewRow__:Integer);
        begin
          case Transformation2D__ of
            t2DRotate0DegreesClockwise           : begin NewCol__:=Col__;                NewRow__:=Row__; end;
            t2DRotate90DegreesClockwise          : begin NewCol__:=Succ(Height__)-Row__; NewRow__:=Col__; end;
            t2DRotate180DegreesClockwise         : begin NewCol__:=Succ(Width__ )-Col__; NewRow__:=Succ(Height__)-Row__; end;
            t2DRotate270DegreesClockwise         : begin NewCol__:=Row__;                NewRow__:=Succ(Width__ )-Col__; end;
            t2DRotate0DegreesClockwiseFlipHorizontally
                                                 : begin NewCol__:=Succ(Width__ )-Col__; NewRow__:=Row__; end;
            t2DRotate90DegreesClockwiseFlipHorizontally
                                                 : begin TransformColRow(t2DRotate90DegreesClockwise ,Col__   ,Row__   ,Width__ ,Height__,NewCol__,NewRow__);
                                                         TransformColRow(t2DRotate0DegreesClockwiseFlipHorizontally,NewCol__,NewRow__,Height__,Width__ ,NewCol__,NewRow__);
                                                   end;
            t2DRotate180DegreesClockwiseFlipHorizontally
                                                 : begin TransformColRow(t2DRotate180DegreesClockwise,Col__   ,Row__   ,Width__ ,Height__,NewCol__,NewRow__);
                                                         TransformColRow(t2DRotate0DegreesClockwiseFlipHorizontally,NewCol__,NewRow__,Width__ ,Height__,NewCol__,NewRow__);
                                                   end;
            t2DRotate270DegreesClockwiseFlipHorizontally
                                                 : begin TransformColRow(t2DRotate270DegreesClockwise,Col__   ,Row__   ,Width__ ,Height__,NewCol__,NewRow__);
                                                         TransformColRow(t2DRotate0DegreesClockwiseFlipHorizontally,NewCol__,NewRow__,Height__,Width__ ,NewCol__,NewRow__);
                                                         end;
            else                                   begin NewCol__:=Col__;                NewRow__:=Row__; end;
          end; {case}
        end; {TransformColRow}

        function  TransformSquare(T__:TTransformation2D; Square__:Integer):Integer;
        var Col,Row:Integer;
        begin
          SquareToColRow(Square__,Game.BoardWidth,Col,Row);
          TransformColRow(T__,Col,Row,Game.BoardWidth,Game.BoardHeight,Col,Row);
          Result:=ColRowToSquare(Col,Row,Boards[T__].Width);
        end; {TransformSquare}

        function  TransformDirection(T__:TTransformation2D; Direction__:TDirection):TDirection;
        begin
          Result:=Boards[T__].Directions[Direction__];
        end;

        function  TransformDirectionAndFlags(T__:TTransformation2D; DirectionAndFlags__:TDirection):TDirection;
        var Direction:TDirection;
        begin // positions store flags together with the direction, hence, the field 'TPosition.Move.Direction' is 'dirty' and doesn't contain a clean direction
          Direction:=TDirection( Ord(DirectionAndFlags__) and      DIRECTION_BIT_MASK); // get the direction for the push; the direction is stored together with various flags, hence, the bit masking
          Result   :=TDirection((Ord(DirectionAndFlags__) and (not DIRECTION_BIT_MASK)) // get the flags stored together with the direction
                                +
                                Ord(TransformDirection(T__,Direction))); // set the transformed direction
        end;

        procedure TransformBoard(T__:TTransformation2D;
                                 SourceBoardWidth__          :Integer;
                                 SourceBoardHeight__         :Integer;
                                 const SourceBoard__         :TBoard;
                                 var TargetBoardWidth__      :Integer;
                                 var TargetBoardHeight__     :Integer;
                                 var TargetBoard__           :TBoard;
                                 var TargetPlayerPos__       :Integer;
                                 var TargetDirections__      :TDirectionMap;
                                 var TargetDirectionOffsets__:TDirectionArrayOfIntegers;
                                 SquareMask__                :Integer);
        var Col,Row,NewCol,NewRow,NewSquare,SquareValue:Integer;
            Direction:TDirection;
            SquareOffsetForward:TDirectionArrayOfIntegers;
        begin // each square on the transformed board contains the original value masked with 'SquareMask__'
          if T__ in [t2DRotate0DegreesClockwise,
                     t2DRotate180DegreesClockwise,
                     t2DRotate0DegreesClockwiseFlipHorizontally,
                     t2DRotate180DegreesClockwiseFlipHorizontally] then begin
             TargetBoardWidth__ :=SourceBoardWidth__;
             TargetBoardHeight__:=SourceBoardHeight__;
             end
          else begin
             TargetBoardWidth__ :=SourceBoardHeight__;
             TargetBoardHeight__:=SourceBoardWidth__;
             end;

          TargetPlayerPos__:=0;

          for Col:=0 to Succ(SourceBoardWidth__) do {0..dimension+1: transform the 1-cell border around the board too}
              for Row:=0 to Succ(SourceBoardHeight__) do begin
                  SquareValue:=SourceBoard__[ColRowToSquare(Col,Row,SourceBoardWidth__)];
                  TransformColRow(T__,Col,Row,SourceBoardWidth__,SourceBoardHeight__,NewCol,NewRow);
                  NewSquare:=ColRowToSquare(NewCol,NewRow,TargetBoardWidth__);
                  TargetBoard__[NewSquare]:=SquareValue and SquareMask__;
                  if (SquareValue and PLAYER)<>0 then TargetPlayerPos__:=NewSquare;
                  end;

          TransformDirections(True,T__,TargetDirections__); // calculate the transformed directions

          SquareOffsetForward[dUp   ]:=-(TargetBoardWidth__+2);
          SquareOffsetForward[dLeft ]:=-1;
          SquareOffsetForward[dDown ]:=+(TargetBoardWidth__+2);
          SquareOffsetForward[dRight]:=+1;

          for Direction:=Low(Direction) to High(Direction) do // note that the square offsets are mapped directly from the original directions (not the transformed directions) to the offsets on the transformed board
              TargetDirectionOffsets__[Direction]:=SquareOffsetForward[TargetDirections__[Direction]];
        end;

        procedure MakeAllBoardTransformations;
        var T:TTransformation2D;
        begin // makes all 8 transformations of the existing game state
          for T:=Low(T) to High(T) do
              TransformBoard(T,Game.BoardWidth,Game.BoardHeight,Game.Board,
                             Boards[T].Width,Boards[T].Height,Boards[T].Squares,
                             Boards[T].PlayerPos,Boards[T].Directions,Boards[T].DirectionOffsets,WALL+FLOOR+BOX);  // the symmetry tests only deals with walls, floors, and boxes, hence, the transformed boards don't contain the player or the goals
        end;

        function  DoPushOnTransformedBoard(T__:TTransformation2D; BoxSquareCol__,BoxSquareRow__:Integer; Direction__:TDirection):Boolean;
        var Col,Row,BoxSquare:Integer;
        begin // for efficiency, the function only deals with board transformations having the same dimensions as the game board;
          Result:=True;
          with Boards[T__] do
            if (Width=Game.BoardWidth) and (Height=Game.BoardHeight) then begin // 'True': matching board dimensions
               TransformColRow(T__,BoxSquareCol__,BoxSquareRow__,Game.BoardWidth,Game.BoardHeight,Col,Row);
               BoxSquare:=ColRowToSquare(Col,Row,Width);
               if (Squares[BoxSquare] and BOX)<>0 then begin
                  Dec(Squares[BoxSquare],BOX); // remove the box from its current position
                  Inc(Squares[BoxSquare+DirectionOffsets[Direction]],BOX); // put the box on the board at the new position
                  PlayerPos:=BoxSquare; // update the player's position

                  // test: show the board after the push has been made
                  //Inc(Squares[BoxSquare],PLAYER);
                  //if T__= t2DRotate0DegreesClockwise then ShowBoard(Boards[T__]);
                  //Dec(Squares[BoxSquare],PLAYER);
                  end
               else 
                  Result:=Msg(TEXT_INTERNAL_ERROR+': "Optimize.Search.RearrangementOptimization.SymmetryOptimization.DoPushOnTransformedBoard',TEXT_APPLICATION_TITLE);
               end;
        end;

        function  IsSymmetricalBoard(T__:TTransformation2D):Boolean;
        var BoxNo:Integer;
        begin // returns 'True' is the transformed board and the game state are symmetrical with respect to boxes
          Result:=(Game.BoardWidth=Boards[T__].Width) and (Game.BoardHeight=Boards[T__].Height);
          if Result then
             for BoxNo:=1 to Game.BoxCount do with Boards[T__] do
                 if (Squares[Game.BoxPos[BoxNo]] and BOX)=0 then begin
                    Result:=False;
                    exit; // 'exit': quick-and-dirty exit when it has been proven that the board isn't symmetrical with the current game board
                    end;
        end;

        function  IsPlayerPathToNextPushShorterOnTransformedBoard(T__:TTransformation2D):Boolean;
        var NeighborSquare,TransformedNeighborSquare:Integer;
        begin
          Result:=False;
          if Positions.CurrentPosition^.Successor<>nil then with Positions.CurrentPosition^.Successor^ do begin // 'True': the current position isn't the last push on the best path
             // calculate the player's position on the board right before the next push, i.e., the box neighbor square opposite the push direction
             NeighborSquare:=PlayerPos-Game.SquareOffsetForward[TDirection(Ord(Move.Direction) and DIRECTION_BIT_MASK)]; // 'PlayerPos': after the push, the player is located at the square where the box was before the push

             CalculatePlayersDistanceToReachableSquares(0);
             with Solver.SearchStates[0].PlayersReachableSquares do begin // since the game board and the transformed board has the same dimensions, the distances to the two neighbor squares can be compared directly
               TransformedNeighborSquare:=TransformSquare(T__,NeighborSquare);
               Result:=(Squares[TransformedNeighborSquare]>TimeStamp) and // 'True': the player can reach the transformed square
                       (Squares[TransformedNeighborSquare]<Squares[NeighborSquare]); // 'True': the player distance to the transformed square is shorter
               end;
             end;
        end;

        function  AreRemainingPushesLegalAndBetterAfterTransformation(T__:TTransformation2D):Boolean;
        var BoxNo:Integer; InverseTransformation:TTransformation2D;
            LastPosition,NextPosition:PPosition;
            NewBoxNumbers,OldBoxNumbers:TBoxNumbers;
        begin // side-effect: if the transformed path is legal and better, then the path is transformed accordingly
          Result:=True;

          // map old box numbers to new ones after the transformation, and map new numbers back to old numbers
          for BoxNo:=1 to Game.BoxCount do begin
              NewBoxNumbers[BoxNo]:=BoxNoAtSquare(TransformSquare(T__,Game.BoxPos[BoxNo])); // maps old box numbers to new numbers after the transformation
              OldBoxNumbers[NewBoxNumbers[BoxNo]]:=BoxNo; // maps new box numbers back to the original numbers;
              Result:=Result and (NewBoxNumbers[BoxNo]<>0); // '<>0': if 'False', then there isn't a box at the transformed square, meaning the boxes aren't symmetrical
              end;

          InverseTransformation   :=TRANSFORMATION_2D_INVERSE[T__];
          LastPosition            :=Positions.CurrentPosition; // last position is the last one on the path which has been performed on the board
          NextPosition            :=LastPosition^.Successor;
          while (NextPosition<>nil) and Result do with NextPosition^ do begin
            PlayerPos             :=TransformSquare(T__,PlayerPos); // set the new player position (the box position before the push)
            Move.BoxNo            :=NewBoxNumbers[Move.BoxNo]; // set the new box number
            Move.Direction        :=TransformDirectionAndFlags(T__,Move.Direction); // set the new push direction

            Result:=DoPushes(NextPosition,Successor,0,False,LastPosition)<>0;
            //YASS.ShowBoard; Write('Pushes: ',NextPosition^.PushCount); Readln;

            if not Result then begin // 'True': the next push on the path is invalid after the transformation
               PlayerPos          :=TransformSquare(InverseTransformation,PlayerPos); // restore the old player position (the box position before the push)
               Move.BoxNo         :=OldBoxNumbers[Move.BoxNo]; // restore the old box number
               Move.Direction     :=TransformDirectionAndFlags(InverseTransformation,Move.Direction); // restore the old push direction
               end;

            NextPosition          :=Successor;
            end;

          Result:=Result and
                  (not HasABetterOrEqualScore(Positions.BestPosition)) and // 'True': the new path is better
                  (Game.SimpleLowerBound=0); // 'True': the new path is a solution; for conveniency, the symmetry optimizer only deals with solutions

          // undo the transformed moves again;
          // the transformation is undone too, unless a new better path has been found
          if LastPosition<>Positions.CurrentPosition then begin // 'True': some positions have been transformed and performed on the board; they need to be taken back
             while LastPosition<>Positions.CurrentPosition do with LastPosition^ do begin
               YASS.UndoPush(LastPosition^.Move.BoxNo,LastPosition^.Move.Direction);
               //YASS.ShowBoard; Write('Pushes after undo: ',LastPosition^.Parent^.PushCount); Readln;
               if not Result then begin // 'True': the transformation didn't produce a new better path; undo the transformation
                  PlayerPos       :=TransformSquare(InverseTransformation,PlayerPos); // restore the old player position (the box position before the push)
                  Move.BoxNo      :=OldBoxNumbers[Move.BoxNo]; // restore the old box number
                  Move.Direction  :=TransformDirectionAndFlags(InverseTransformation,Move.Direction); // restore the old push direction
                  end;
               LastPosition       :=Parent;
               end;

             SetGameMetrics(Positions.CurrentPosition); // restore game metrics
             if   Positions.CurrentPosition<>nil then
                  MovePlayer(Positions.CurrentPosition^.PlayerPos) // restore player position
             else MovePlayer(Positions.StartPosition  ^.PlayerPos);
             end;

          if Result then begin // 'True': the new path is better; update the metrics for the positions on the path
             SetPosition(nil); // reset the game before calling 'UpdatePositionsOnBestPath', which depends on that
             LastPosition:=nil;
             if not UpdatePositionsOnBestPath(LastPosition) then begin; // update game-metrics, hash-values, and parent-chain for all positions on the best path
                Result:=False; TerminateSearch; Optimizer.Result:=prFailed;
                end;
             end;
        end;

      begin // 'SymmetryOptimization'
        Result:=False;
        //StartTimeMS:=GetTimeMS;

        // make all 8 transformations of the board
        SetPosition(nil); // go back to the start of the game
        MakeAllBoardTransformations;

        // test: show all 8 transformed boards
        //for T:=Low(Boards) to High(Boards) do ShowBoard(Boards[T]);

        // first replay all pushes on the best path; this verifies they are valid, and it ensures that they all contain the correct box numbers and push directions
        SetPosition(Positions.BestPosition);
        SetPosition(Positions.StartPosition); // go back to the start of the game
        MakeSuccessorChainForNodesOnPath(Positions.BestPosition); // make successor links so the positions on the path can be visited in forward order
        if (Positions.CurrentPosition<>nil) // 'True': there is a root position for the path; the root position doesn't contain a push like the rest of the nodes of the path
           and
           (not SearchHasTerminated) then // 'True': the optimizer is still allowed to run
           repeat // replay all the pushes on the best path, checking each position to see if it is symmetrical
                  // get the push information for the current push,
                  // i.e., its box position and the push direction;
                  Position:=Positions.CurrentPosition; // remember the current position
                  BoxSquare:=Positions.CurrentPosition^.PlayerPos; // 'PlayerPos': after the push, the player is located at the square where the box was before the push
                  SquareToColRow(BoxSquare,Game.BoardWidth,BoxSquareCol,BoxSquareRow); // calculate column and row for the box square, so it only is done once; the alternative is to let 'DoPushOnTransformedBoard' do it by itself on each invocation
                  Direction:=TDirection(Ord(Positions.CurrentPosition^.Move.Direction) and DIRECTION_BIT_MASK);

                  //YASS.ShowBoard; Write('Position: ',Position^.PushCount,SPACE,BoxSquareCol,SPACE,BoxSquareRow); Readln;

                  // perform the push on the transformed boards; for efficiency, only the transformations with the same dimensions as the original game are taken into account
                  for T:=Succ(Low(Boards)) to High(Boards) do // 'Succ(Low))': the first transformation is the identity transformation which doesn't need to be taken into account here
                      if Position=Positions.CurrentPosition then // 'True': the game hasn't been reset after finding an improvement in this position, and the search hasn't been terminated for other reasons, e.g., an internal error
                         if ((Positions.CurrentPosition^.Move.BoxNo=0) // '0': the root node doesn't contain a push
                            or
                            DoPushOnTransformedBoard(T,BoxSquareCol,BoxSquareRow,Direction) // 'True': the push succeeds on the transformed board too; this should always be true, so this is merely a sanity check
                           ) then begin
                           if IsSymmetricalBoard                                 (T) and // 'True': this transformation of the board is symmetrical with the current game state, with respect to boxes
                              IsPlayerPathToNextPushShorterOnTransformedBoard    (T) and
                              (not (Optimizer.Result=prFailed)) and // 'True': a previous run through the enclosing 'for T' loop hasn't terminated the search as the result of an internal error
                              AreRemainingPushesLegalAndBetterAfterTransformation(T) then begin // if 'True' then the function has made the transformation as a side-effect
                              Result:=True;
                              SetPosition(Positions.StartPosition); // restart the symmetry optimization from the beginning
                              MakeAllBoardTransformations;
                              Position:=nil; // ensure that the 'for T' loop doesn't do more work on the game state represented by 'Position'; the data has changed
                              end;
                           end
                        else begin
                           // something is wrong, such as 2 different positions accidentally having identical hashvalues; exit the function
                           Result:=False; TerminateSearch; Optimizer.Result:=prFailed;
                           end;

                  if (Positions.CurrentPosition<>nil) and (Position<>nil) then // if 'Position = nil' then the search restarts from the beginning; the starting position must be analyzed again, hence, don't advance to the next position
                     SetPosition(Positions.CurrentPosition^.Successor); // advance to the next push on the best path
           until  (Positions.CurrentPosition=nil) or SearchHasTerminated; // until all positions have been tested, or until the search has been terminated

        SetPosition(nil); // go back to the start of the game

        //Writeln('Time: ',CalculateElapsedTimeMS(StartTimeMS,GetTimeMS)); Readln;
      end; // Optimize.Search.RearrangementOptimization.SymmetryOptimization

    begin // RearrangementOptimization
      StartTimeMS:=GetTimeMS; //Optimizer.TimeMS:=0;
      Result:=False; Optimizer.IterationResult:=False;

      if (YASS.Positions.BestPosition<>nil) and
         {$WARNINGS OFF}
           {warning: Comparison always evaluates to True}
           (YASS.Positions.BestPosition^.PushCount<=MAX_PATH_LENGTH) and
         {$WARNINGS ON}
         ((not Purge__) or (TTPurge(Positions.Capacity,False)>=0)) then begin

         {$IFDEF PLUGIN_MODULE}
           Optimizer.SearchStateStatusText:='';
           ShowStatus;
         {$ENDIF}

         Result:=RearrangementOptimization__(KeepExistingBoxSessions__,TryAllBoxes__,TryPushSequences__);

         if TrySymmetryOptimization__ and SymmetryOptimization then Result:=True;

         if Result then begin
            Optimizer.Result:=prOK;
            Optimizer.IterationResult:=True;
            end;

         {//$IFDEF PLUGIN_MODULE}
           Optimizer.SearchStateStatusText:='';
           ShowStatus;
         {//$ENDIF}
         end;
      //Optimizer.TimeMS:=CalculateElapsedTimeMS(StartTimeMS,GetTimeMS);

      // Write('Rearrangement: ',Result,' Time: ',CalculateElapsedTimeMS(StartTimeMS,GetTimeMS)); Readln;
    end; // Optimize.Search.RearrangementOptimization

//  function  SearchBackwards(PullBoxNo__:Integer; PullDirection__:TDirection; Depth__,BoxCountDown__:Integer; SuccessorPosition__:PPosition):Boolean; forward;
    function  SearchBackwards(PullBoxNo__:Integer; PullDirection__:TDirection; Depth__,BoxCountDown__:Integer; var Position__:PPosition):Boolean; forward;

    function  EnumerateTargetPositions(Position__:PPosition; DepthLimit__:Integer):Boolean;
    var BoxNo,SquareNo,OldDepthLimit,OldPlayerPos,NeighborSquareNo,
        SuccessorDepth,SuccessorBoxCountDown,SuccessorScore:Integer;
        OldPositionCount:Cardinal; Direction:TDirection;
        SuccessorPosition:PPosition;
    begin
      Result:=False; //exit;

      SetPosition(Position__);
      OldPlayerPos:=Game.PlayerPos; OldPositionCount:=Positions.Count;
      OldDepthLimit:=Solver.SearchLimits.DepthLimit; Solver.SearchLimits.DepthLimit:=DepthLimit__;
      SuccessorDepth:=2; SuccessorBoxCountDown:=Solver.SearchLimits.DepthLimit; SuccessorScore:=1;
      if Game.SimpleLowerBound<>0 then CalculatePlayersDistanceToReachableSquares(0);

      with Solver.SearchStates[0].PlayersReachableSquares do
        for BoxNo:=1 to Game.BoxCount do begin
            SquareNo:=Game.BoxPos[BoxNo];
            for Direction:=Low(Direction) to High(Direction) do begin
                NeighborSquareNo:=SquareNo+Game.SquareOffsetForward[Direction];
                if ((Game.Board[NeighborSquareNo] and (WALL+BOX))=0) and
                   ((Game.Board[NeighborSquareNo+Game.SquareOffsetForward[Direction]] and (WALL+BOX))=0) and
                   ((Game.SimpleLowerBound=0)                                   {for solutions, the player's access-area doesn't matter}
                    or
                    (Squares[NeighborSquareNo]>TimeStamp)                       {for an unsolved snapshot, the player must end it the proper access-area}
                   )
                   then begin
                   MovePlayer(NeighborSquareNo);
                   CalculatePlayersDistanceToReachableSquares(1);

                   if TTLookup(1,ppmExact,dUp,SuccessorPosition) then with SuccessorPosition^ do begin
                      if WasALegalPush(SuccessorPosition) then begin
                         if Position__=Positions.BestPosition then
                            Move.Direction:=TDirection(Integer(Ord(Move.Direction)) or POSITION_TARGET_TAG); {mark the node as a target position}
//>>>                    SuccessorPosition^.BoxCountDown:=SuccessorBoxCountDown; {mark the position as visited with this count-down value}
                         //ShowBoard; Write('Old:'); Readln;
                         CalculatePlayersDistanceToReachableSquares(SuccessorDepth);
                         Result:=SearchBackwards(BoxNo,Direction,SuccessorDepth,SuccessorBoxCountDown,SuccessorPosition) or Result;
                         end
                      else if Move.BoxNo<>0 then begin                          {'<>': it's not the start position}
                              TerminateSearch; Optimizer.Result:=prFailed;      {something is wrong, such as 2 different positions accidentally having identical hashvalues}
                              end;
                      end
                   else
                      if TTAdd(BoxNo,OPPOSITE_DIRECTION[Direction],1,SuccessorScore,nil,{next position in hash chain =}SuccessorPosition,SuccessorPosition) then
                         with SuccessorPosition^ do begin
                           if (Ord(Move.Direction) and POSITION_OPEN_TAG)<>0 then OPENRemove(SuccessorPosition);
                           if Position__=Positions.BestPosition then
                              Move.Direction:=TDirection(Integer(Ord(Move.Direction)) or POSITION_TARGET_TAG); {mark the node as a target position}
                           Move.Direction:=TDirection(Integer(Ord(Move.Direction)) or POSITION_TARGET_PATH_TAG); {mark the node as a position on a path to the target position (this procedure is only applied to positions where this holds)}
                           //ShowBoard; Write('New:'); Readln;
                           CalculatePlayersDistanceToReachableSquares(SuccessorDepth);
                           Result:=SearchBackwards(BoxNo,Direction,SuccessorDepth,SuccessorBoxCountDown,SuccessorPosition) or Result;
                           end;
                   end;
                end;
            end;
      Solver.SearchLimits.DepthLimit:=OldDepthLimit;
      MovePlayer(OldPlayerPos);
      if OldPositionCount<>Positions.Count then begin
         {$IFDEF CONSOLE_APPLICATION}
           //ShowBoard;
           Writeln('Backward positions: ',Positions.Count-OldPositionCount);
           //Readln;
         {$ENDIF}
         end;
    end; // OptimizeGame.Search.EnumerateTargetPositions

    function  SearchBackwards(PullBoxNo__:Integer; PullDirection__:TDirection; Depth__,BoxCountDown__:Integer; var Position__:PPosition):Boolean;
    {precondition: 'Solver.SearchStates[Depth__].PlayersReachableSquares.Calculated' indicates whether the calculation has been performed for this depth}
    var BoxNo,SetBoxNo,SquareNo,NeighborSquareNo,
        SuccessorBoxCountDown,SuccessorDepth:Integer;
        Direction:TDirection; SuccessorPosition:PPosition;
    begin // OptimizeGame.Search.SearchBackwards
      Result:=False; //exit;
      {
      ShowBoard;
      Write(': ',PullBoxNo__,SPACE,DIRECTION_TO_TEXT[PullDirection__],' Depth: ',Depth__,' Count down: ',BoxCountDown__,' Positions: ',YASS.Positions.Count);
      Readln;
      }
      with Solver.SearchStates[Depth__].PlayersReachableSquares do begin
        MovePlayer(Game.BoxPos[PullBoxNo__]+Game.SquareOffsetForward[PullDirection__]);
        if not Calculated then CalculatePlayersDistanceToReachableSquares(Depth__);
        if Position__=nil then
           if        TTLookup(Depth__,ppmNearest,dUp,Position__) then begin
                     if      WasALegalPush(Position__) then begin
                             end
                     else if Position__^.Move.BoxNo<>0 then begin               {'<>': it's not the start position}
                             {
                             ShowBoard;
                             Write('Fail: ',PullBoxNo__,SPACE,DIRECTION_TO_TEXT[PullDirection__],' Depth: ',Depth__,' Backward position ',YASS.Positions.Count);
                             Readln;
                             }
                             TerminateSearch; Optimizer.Result:=prFailed;       {something is wrong, such as 2 different positions accidentally having identical hashvalues}
                             end;
                     end
           else if   TTAdd(PullBoxNo__,OPPOSITE_DIRECTION[PullDirection__],Depth__,{Score=}0,nil,{next position in hash chain =}Position__,Position__) then begin
                     {
                     ShowBoard;
                     Write('Add: ',PullBoxNo__,SPACE,DIRECTION_TO_TEXT[OPPOSITE_DIRECTION[PullDirection__]],' Depth: ',Depth__,' Count down: ',BoxCountDown__,' Positions: ',YASS.Positions.Count);
                     Readln;
                     }
                     end
                else Position__:=nil;

        if (Position__<>nil) and
           (BoxCountDown__>0) and
           (Depth__<MAX_HISTORY_BOX_MOVES) then begin
           with Position__^ do Move.Direction:=TDirection(Integer(Ord(Move.Direction)) or POSITION_TARGET_PATH_TAG); {mark the node as a position on a path to the target position (this procedure is only applied to positions where this holds)}
           SuccessorDepth:=Succ(Depth__); SuccessorPosition:=nil;
           DoPull(PullBoxNo__,PullDirection__);
           CalculatePlayersDistanceToReachableSquares(SuccessorDepth);

           if TTLookup(SuccessorDepth,ppmNearest,dUp,SuccessorPosition) then
              if      WasALegalPush(SuccessorPosition) then begin
                      end
              else if SuccessorPosition^.Move.BoxNo<>0 then begin               {'<>': it's not the start position}
                      {
                      ShowBoard;
                      Write('Fail: ',PullBoxNo__,SPACE,DIRECTION_TO_TEXT[PullDirection__],' Depth: ',Depth__,' Backward position ',YASS.Positions.Count);
                      Readln;
                      }
                      TerminateSearch; Optimizer.Result:=prFailed;              {something is wrong, such as 2 different positions accidentally having identical hashvalues}
                      SuccessorPosition:=nil;
                      end;

           with Solver.SearchStates[SuccessorDepth].PlayersReachableSquares do begin
             {
             ShowBoard;
             Write('Visit: ',PullBoxNo__,SPACE,DIRECTION_TO_TEXT[PullDirection__],' Depth: ',Depth__,' Count down: ',BoxCountDown__,' Positions: ',YASS.Positions.Count);
             Readln;
             }
             if   BoxCountDown__=1 then
                  BoxNo:=PullBoxNo__                                            {generate moves for this box only}
             else BoxNo:=1;
             while BoxNo<=Game.BoxCount do begin
               SquareNo:=Game.BoxPos[BoxNo];
               SetBoxNo:=Pred(BoxNo) and (MAX_SMALL_BOX_SET_COUNT-1);           {there is only room for registering boxnumbers modulo maximum box numbers}
               if (Squares[SquareNo]=TimeStamp) and                             {'=TimeStamp': the player can reach the box}
                  ((SuccessorPosition=nil)
                   or
                   (not (SetBoxNo in SuccessorPosition^.SmallBoxSet))
                  )
                  then begin
                  if   SuccessorPosition<>nil then Include(SuccessorPosition^.SmallBoxSet,SetBoxNo);

                  if   Positions.Count<=MAX_OPTIMIZER_BACKWARD_SEARCH_POSITIONS_COUNT then
                       if   BoxNo<>PullBoxNo__ then
                            SuccessorBoxCountDown:=Pred(BoxCountDown__)
                       else SuccessorBoxCountDown:=BoxCountDown__
                  else SuccessorBoxCountDown:=1;                                {limit the time spent in the backward search by switching to a 1-box search}

                  for Direction:=Low(Direction) to High(Direction) do begin
                      NeighborSquareNo:=SquareNo+Game.SquareOffsetForward[Direction];
                      if {inline simple checks for legal moves}
                         ((Game.Board[NeighborSquareNo] and (BOX+WALL))=0)      {'0': the square is not blocked by a wall or another box}
                         and
                         (Squares[NeighborSquareNo]>TimeStamp)                  {'>TimeStamp': the player can reach this square}
                         and
                        ((Game.Board[NeighborSquareNo+Game.SquareOffsetForward[Direction]] and (BOX+WALL))=0) {'0': the square is not blocked by a wall or another box}
                        then
                        if Solver.PushCount<Solver.SearchLimits.PushCountLimit then begin {limit not exceeded}
                           Inc(Solver.PushCount);                               {update statistics}
                           if (Solver.PushCount and (ONE_MEBI-1))=0 then begin
                              {$IFDEF CONSOLE_APPLICATION}
                                Writeln(SearchStatePromptText,
                                        'Pushes: ',Solver.PushCount div ONE_MILLION,' million Positions: ',Positions.Count,'+',Positions.SearchStatistics.DroppedCount
                                        {$IFDEF WINDOWS}
                                          ,' Time: ',(CalculateElapsedTimeMS(Solver.StartTimeMS,GetTimeMS)+500) div 1000
                                        {$ENDIF}
                                       );
                              {$ENDIF}

                              TimeCheck;
                              end;

                           Result:=SearchBackwards(BoxNo,Direction,SuccessorDepth,SuccessorBoxCountDown,SuccessorPosition) or Result;
                           if SuccessorPosition<>nil then Include(SuccessorPosition^.SmallBoxSet,SetBoxNo);
                           end
                        else begin                                              {push count limit exceeded}
                             end;
                      end;
                  end;

               if   BoxCountDown__=1 then
                    BoxNo:=Succ(Game.BoxCount)
               else Inc(BoxNo); {next box}
               end;
             end;
           UndoPull(PullBoxNo__,PullDirection__);
           end;
        end;
    end; // OptimizeGame.Search.SearchBackwards

    {the current version of 'SearchForwards()' is only a template and not ready for production anymore;}
    {it requires a supporting 'UpdateSearchTree' function which has been removed from the source because}
    {it wasn't justifiable to retain that many unused and complex (potentially "rotting") code-lines in the program}
    function  SearchForwards(Position__:PPosition; Depth__,BoxCountDown__{///,BoxesNotOnBestPathCountDown__}:Integer; var BoxSet__:TBoxSet):Boolean;
    {precondition: 'Solver.SearchStates[Depth__].PlayersReachableSquares.Calculated' indicates whether the calculation has been performed for this depth}
    var BoxNo,NeighborOffset,PlayerDistance,SquareNo,
        SuccessorBoxCountDown,///SuccessorBoxesNotOnBestPathCountDown,
        SuccessorDepth,SuccessorScore:Integer;
        Direction:TDirection;
        SuccessorPosition:PPosition;

    begin // Search.SearchForwards
      Result:=False;

      if (BoxCountDown__>0) and
         ///(BoxesNotOnBestPathCountDown__>=0) and
         (Depth__<MAX_HISTORY_BOX_MOVES) and
         ((Game.SimpleLowerBound<>0) or (Optimizer.GameMetrics.PushCount=0)) then
         with Solver.SearchStates[Depth__].PlayersReachableSquares do begin
           SuccessorDepth:=Succ(Depth__);
           if Position__^.PlayerPos<>Game.PlayerPos then MovePlayer(Position__^.PlayerPos);
           if not Calculated then {'not Calculated': the caller didn't do the calculation; do it now}
              CalculatePlayersDistanceToReachableSquares(Depth__);

           if   BoxCountDown__=1 then
                BoxNo:=Position__^.Move.BoxNo                                   {generate moves for this box only}
           else BoxNo:=1;
           while BoxNo<=Game.BoxCount do begin
             SquareNo:=Game.BoxPos[BoxNo];
             if (not (BoxNo in BoxSet__)) and
                (Squares[SquareNo]=TimeStamp) then begin                        {'=TimeStamp': the player can reach the box}
                if BoxNo<>Position__^.Move.BoxNo then begin
                   SuccessorBoxCountDown:=Pred(BoxCountDown__);
                   end
                else begin
                   SuccessorBoxCountDown:=BoxCountDown__;
                   end;
                SuccessorScore:=Succ(Position__^.Score);

                for Direction:=Low(Direction) to High(Direction) do begin
                    NeighborOffset:=Game.SquareOffsetForward[Direction];
                    if {inline simple checks for legal moves}
                       ((Game.Board[SquareNo-NeighborOffset] and (BOX+WALL))=0) {'=0' the square is not blocked by a wall or another box}
                       and
                       (Squares    [SquareNo-NeighborOffset]>TimeStamp)        {'>TimeStamp': the player can reach the neighbor-square}
                       and
                       ((Game.Board[SquareNo+NeighborOffset] and (BOX+WALL+FLAG_ILLEGAL_BOX_SQUARE))=0) {'=0' the square is legal and not blocked by a wall or another box}
                       and
                       {extended checks for legal moves}
                       IsALegalPush(BoxNo,Direction,SuccessorDepth) then
                       if Solver.PushCount<Solver.SearchLimits.PushCountLimit then begin {limit not exceeded}
                          Inc(Solver.PushCount);                                {update statistics}

                          if (Solver.PushCount and (ONE_MEBI-1))=0 then begin
                             {$IFDEF CONSOLE_APPLICATION}
                               Writeln(SearchStatePromptText,
                                       'Pushes: ',Solver.PushCount div ONE_MILLION,' million Positions: ',Positions.Count,'+',Positions.SearchStatistics.DroppedCount
                                       {$IFDEF WINDOWS}
                                         ,' Time: ',(CalculateElapsedTimeMS(Solver.StartTimeMS,GetTimeMS)+500) div 1000
                                       {$ENDIF}
                                      );
                             {$ENDIF}

                             TimeCheck;
                             end;

                          PlayerDistance:=Pred(Squares[SquareNo-NeighborOffset]-TimeStamp);
                          Inc(Solver.MoveCount,Succ(PlayerDistance));           {update statistics; 'Succ()': sum of non-pushing player moves + 1 push}

                          Inc(Optimizer.GameMetrics.MoveCount,PlayerDistance);  {update game state}
                          DoPush(BoxNo,Direction);                              {do the move, i.e., update the board}
                          SuccessorPosition:=nil;

                          //ShowBoard;
                          //Write(GameMetricsAsText); Readln;

                          if (Optimizer.GameMetrics.MoveCount<=High(POptimizerPosition(Position__)^.MoveCount)) {guard against move overflow}
                             and
                             (not HasABetterOrEqualScore(Optimizer.PruningNode{Positions.BestPosition})) then
                             with Solver.SearchStates[SuccessorDepth].PlayersReachableSquares do begin
                               Calculated:=False; {the player's reachable squares haven't been calculated yet}

                               /// update number of boxes not on best path
                               ///if   BoxNo in BoxVisitedSquares[SquareNo] then
                               ///     if   BoxNo in BoxVisitedSquares[SquareNo+NeighborOffset] then
                               ///          SuccessorBoxesNotOnBestPathCountDown:=BoxesNotOnBestPathCountDown__
                               ///     else SuccessorBoxesNotOnBestPathCountDown:=Pred(BoxesNotOnBestPathCountDown__)
                               ///else if   BoxNo in BoxVisitedSquares[SquareNo+NeighborOffset] then
                               ///          SuccessorBoxesNotOnBestPathCountDown:=Succ(BoxesNotOnBestPathCountDown__)
                               ///     else SuccessorBoxesNotOnBestPathCountDown:=BoxesNotOnBestPathCountDown__;

                               if TTLookup(SuccessorDepth,ppmBetter,Direction,SuccessorPosition) then with POptimizerPosition(SuccessorPosition)^ do with Position do begin
                                  SuccessorBoxCountDown:=Abs(SuccessorBoxCountDown);
                                  if (UInt8(Move.Direction) and POSITION_TARGET_PATH_TAG)<>0 then
                                     UInt8(Position__^.Move.Direction):=UInt8(Position__^.Move.Direction) or POSITION_TARGET_PATH_TAG;

                                  if WasALegalPush(SuccessorPosition) then begin
                                     if      Parent=nil then begin              {'nil': a position from the backward search}
                                             {the function 'UpdateSearchTree' must update the complete tree below the current position}
                                             {---Result:=UpdateSearchTree(BoxNo,Direction,Position__,SuccessorPosition,SuccessorDepth) or Result;---}
                                             end
                                     else if (PlayerPos<>Game.PlayerPos) then begin
                                             SuccessorBoxCountDown:=-SuccessorBoxCountDown; {negated: don't expand this node now; another parent node is responsible for expanding it with the current count-down limit}
                                             end
                                     else if HasABetterOrEqualScore(SuccessorPosition) then begin {'True': old path to 'SuccessorPosition' is better/equal}
                                             if Parent<>Position__ then
                                                SuccessorBoxCountDown:=-SuccessorBoxCountDown; {negated: don't expand this node now; another parent node is responsible for expanding it with the current count-down limit}
                                             end
                                          else begin
                                             {$IFDEF CONSOLE_APPLICATION}
                                               if ((Ord(Move.Direction) and POSITION_PATH_TAG)<>0) then begin
                                                  ShowBoard;
                                                  Writeln(GameMetricsAsText);
                                                  Write('New best path; old path: ',OptimizerMetricsAsText(SuccessorPosition));
                                                  if   UserInterface.Prompt then Readln
                                                  else Writeln;
                                                  end;
                                             {$ENDIF}

                                             {the function 'UpdateSearchTree' must update the complete tree below the current position}
                                             {---Result:=UpdateSearchTree(BoxNo,Direction,Position__,SuccessorPosition,SuccessorDepth) or Result;---}
                                             end;

                                     if   {---(SuccessorBoxCountDown>BoxCountDown) and ---}// '>': the height of the tree rooted at this node is lower than the current depth limit
                                          (SuccessorBoxCountDown>0) then begin

                                          if Parent<>Position__ then begin
                                             if Parent<>nil then begin          {update old parent}
                                                Dec(Parent^.SuccessorCount);
                                                if (Parent^.SuccessorCount=0) and
                                                  ((Ord(Parent^.Move.Direction) and (POSITION_OPEN_TAG+POSITION_PATH_TAG+POSITION_TARGET_TAG))=0) then
                                                  OPENAdd(Parent,False);
                                                end;
                                             Inc(Position__^.SuccessorCount);   {update new parent}
                                             if (Ord(Position__^.Move.Direction) and POSITION_OPEN_TAG)<>0 then
                                                OPENRemove(Position__);
                                             Parent              :=Position__;
                                             end;

                                          Move.BoxNo          :=BoxNo;
                                          UInt8(Move.Direction):=(Ord(Move.Direction) and (not DIRECTION_BIT_MASK)) or Ord(Direction); // keep any existing flags and save the direction
                                          {---BoxCountDown__:=SuccessorBoxCountDown;---}  // the tree rooted at this node will be analysed to this depth

                                          Result:=SearchForwards(SuccessorPosition,SuccessorDepth,SuccessorBoxCountDown{///,SuccessorBoxesNotOnBestPathCountDown},BoxSet__) or Result;
                                          end;
                                     end
                                  else
                                     if Move.BoxNo<>0 then begin                {'<>': it's not the start position}
                                        {$IFDEF CONSOLE_APPLICATION}
                                          ShowBoard;
                                          Writeln(Solver.PushCount,COLON,SPACE,
                                                  BoxNo,SLASH,DIRECTION_TO_CHAR[Direction],
                                                  ' - ',
                                                  Move.BoxNo,SLASH,DIRECTION_TO_CHAR[TDirection(Ord(Move.Direction) and DIRECTION_BIT_MASK)]
                                                 );
                                          if UserInterface.Prompt then Readln;
                                        {$ENDIF}
                                        TerminateSearch; Optimizer.Result:=prFailed; {something is wrong, such as 2 different positions accidentally having identical hashvalues}
                                        end;
                                  end
                               else begin                                       {the position was not found in the transposition table; add it now}
                                  if TTAdd(BoxNo,Direction,Depth__,SuccessorScore,Position__,SuccessorPosition,SuccessorPosition) then
                                     with POptimizerPosition(SuccessorPosition)^ do with Position do begin
                                       if SuccessorBoxCountDown>0 then begin
                                          Result:=SearchForwards(SuccessorPosition,SuccessorDepth,SuccessorBoxCountDown{///,SuccessorBoxesNotOnBestPathCountDown},BoxSet__) or Result;
                                          end;
                                       end;
                                  end;
                               end;

                          if (Game.SimpleLowerBound=0) and                      {'0': this is a solved position}
                             (SuccessorPosition<>nil) then begin                {'<>nil': the start-position in a level with a trivial 0-push solution has successors (if there are any legal moves)}
                             with SuccessorPosition^.Move do Direction:=TDirection(Integer(Ord(Direction)) or POSITION_TARGET_TAG);
                             if (Positions.SolutionPosition=nil)
                                or
                                (not HasABetterOrEqualScore(Positions.SolutionPosition))
                                then begin
                                Positions.SolutionPosition                 :=SuccessorPosition;
                                UpdateBestPosition(SuccessorPosition);
                                Result                                     :=True;
                                Optimizer.Result                           :=prOK;
                                Optimizer.IterationResult                  :=True;
                                end;
                             end;

                          UndoPush(BoxNo,Direction,Position__);                 {take back the move, i.e., update the board}
                          end
                       else begin                                               {push count limit exceeded}
                          end;
                    end;
                end;

             if   BoxCountDown__=1 then
                  BoxNo:=Succ(Game.BoxCount)
             else Inc(BoxNo); {next box}
             end;

           end;
    end; // OptimizeGame.Search.SearchForwards

    function  BoxPermutationsSearch(var BoxPermutationsCount__:Integer; MaxBoxPermutationsCount__:Integer; StopAfterSuccessfulIteration__:Boolean; var TimeMS__:TTimeMS):Boolean;
    var SliceResult:Boolean; BoxNumberSet:TBoxNumberSet; SliceStart,SliceEnd:PPosition;

      function  InitializeSlicing(var BoxPermutationsCount__,MaxBoxPermutationsCount__:Integer):Boolean;
      begin
        Optimizer.IterationResult:=False;
        MaxBoxPermutationsCount__:=Min(MaxBoxPermutationsCount__,Game.BoxCount );
        Result:=(Positions.BestPosition<>nil) and
                (BoxPermutationsCount__>=1) and
                (BoxPermutationsCount__<=MaxBoxPermutationsCount__);
      end; // OptimizeGame.Search.BoxPermutationsSearch.InitializeSlicing

      function  LastBoxSessionPosition(Position__:PPosition):PPosition;
      begin // precondition: the positions on the path are linked forwards, using the 'TPosition.Successor' field
        Result:=Position__;
        if Result<>nil then
           while (Result^.Successor<>nil) and
                 (Result^.Successor^.Move.BoxNo=Result^.Move.BoxNo) do
                 Result:=Result^.Successor;
      end; // OptimizeGame.Search.BoxPermutationsSearch.LastBoxSessionPosition

      function  GetNextSlice(BoxPermutationsCount__:Integer; var SliceStart__,SliceEnd__:PPosition; var BoxNumberSet__:TBoxNumberSet; SliceResult__:Boolean):Boolean;
      var //SliceBoxCountDown:Integer;
          OldSliceEnd,p:PPosition; BoxSet:TBoxSet;
      begin
        Result:=(not SearchHasTerminated) and (TTPurge(Positions.Capacity,False)>=0);
        if Result then begin
           if   BoxNumberSet__.Count<>1 then begin
                if SliceResult__  then begin // 'True': backtrack and run the search again on the previous slices which may have a chance of further improvements now
                   {$IFDEF CONSOLE_APPLICATION}
                     ShowStatus;
                   {$ENDIF}
                   OldSliceEnd:=SliceStart__^.Parent; // 'OldSliceEnd':  ensure that the previous slice isn't repeated
                   FillChar(BoxSet,SizeOf(BoxSet),0); BoxNumberSet__.Count:=0;
                   repeat SliceStart__:=SliceStart__^.Parent;
                          if   not (SliceStart__^.Move.BoxNo in BoxSet) then with BoxNumberSet__ do begin
                               Include(BoxSet,SliceStart__^.Move.BoxNo);
                               Inc(Count); Numbers[Count]:=SliceStart__^.Move.BoxNo;
                               end;
                   until  (SliceStart__=Positions.StartPosition) or (BoxNumberSet__.Count>BoxPermutationsCount__);
                   if (SliceStart__^.Successor<>nil) and
                      (SliceStart__^.Move.BoxNo=SliceStart__^.Successor^.Move.BoxNo) then
                      Msg(TEXT_INTERNAL_ERROR+': GetNextSlice',TEXT_APPLICATION_TITLE);
                   end
                else
                   OldSliceEnd:=SliceEnd__;
                end
           else OldSliceEnd:=SliceStart__;

           repeat // ... until the slice contains a box that wasn't a member of the previously processed slice, or until all slices have been processed
             repeat SliceStart__:=SliceStart__^.Successor;                      // find next moved box number
             until  (SliceStart__=nil) or (SliceStart__^.Move.BoxNo<>SliceStart__^.Parent^.Move.BoxNo);
             Result:=(SliceStart__<>nil) and (SliceStart__^.Parent<>nil);       // 'SliceStart__^.Parent<>nil': the graph contains a root node before the actual nodes with pushes
             if Result then begin
                //Writeln('Slize: ',BoxPermutationsCount__,': ');
                with SliceStart__^.Parent^ do begin Score:=1; end; //>>>BoxCountDown:=BoxPermutationsCount__; end;
                // 'Score='1': note that it's set to '0' later on in this procedure;
                // here it's set to '1' so all slice nodes are added to the open-queue
                // one step below (worse than) their real depth, in effect making them
                // them the last members of the depth set to which they belongs;
                // why this is necessary is unclear, but otherwise, a lot of
                // optimizations are lost if the optimizer only generates moves like
                // "aabbbccc", and not moves like "aabbbaaacc".
                // Currently, the latter is what the program does, and here it
                // doesn't  matter whether the moves are put first or last on
                // their depth sets.

                FillChar(BoxSet,SizeOf(BoxSet),0); BoxNumberSet__.Count:=0;
                SliceEnd__:=SliceStart__; //SliceBoxCountDown:=BoxPermutationsCount__;

                while (BoxPermutationsCount__>=BoxNumberSet__.Count) and (SliceEnd__<>nil) do with SliceEnd__^ do begin
//              while (SliceBoxCountDown>0) and (SliceEnd__<>nil) do with SliceEnd__^ do begin
                  Score:=Succ(Parent^.Score);                                   // prepare the node for the open-queue by calculating 'Score' and 'BoxCountDown'
{//>>>

                  if Move.BoxNo=Parent^.Move.BoxNo then
                     BoxCountDown:=Parent^.BoxCountDown
                  else begin
                     if   Parent^.BoxCountDown>1 then
                          BoxCountDown:=Pred(Parent^.BoxCountDown)
                     else BoxCountDown:=0;
                     //Dec(SliceBoxCountDown);
                     end;
}
                  if Move.BoxNo in BoxSet then                                  // 'True': this box already belongs to the box-set
                     SliceEnd__:=Successor                                      // get ready to process the next node
                  else with BoxNumberSet__ do
                     if   Count<BoxPermutationsCount__ then begin               // 'True': there aren't enough boxes in the box-set yet
                          Include(BoxSet,Move.BoxNo);                           // update the box-set
                          Inc(Count); Numbers[Count]:=Move.BoxNo;
                          SliceEnd__:=Successor;                                // get ready to process the next node
                          end
                     else BoxPermutationsCount__:=-BoxPermutationsCount__;      // exit the 'while' loop, i.e., the boxes in the new slice has been found

                  end;
                if   (SliceEnd__<>nil) and (BoxNumberSet__.Count<>1) then
                     SliceEnd__:=SliceEnd__^.Parent                             // adjust 'SliceEnd__' so it points to the last position in the slice rather than the next position
                else SliceEnd__:=Positions.BestPosition;                        // this is the last slice
                BoxPermutationsCount__:=Abs(BoxPermutationsCount__);            // restore the box permutations count; it may have been negated in order to exit the 'while' loop above
                end;

           until (not Result) or (SliceEnd__<>OldSliceEnd);                     // until the slice contains a box that wasn't a member of the previously processed slice, or until all slices have been processed

           if Result then begin
              Optimizer.PruningNode:=SliceEnd__;
              with SliceStart__^.Parent^ do begin Score:=0; end; //>>>BoxCountDown:=Abs(BoxPermutationsCount__); end; // prepare the root node for the open-queue

              p:=SliceEnd__^.Successor;
              while (p<>nil) and (BoxNumberSet__.Count<BoxPermutationsCount__+0) do begin // add extra boxes ('+0': disabled)
                if not (p^.Move.BoxNo in BoxSet) then with BoxNumberSet__ do begin
                   Include(BoxSet,p^.Move.BoxNo);
                   Inc(Count); Numbers[Count]:=p^.Move.BoxNo;
                   end;
                p:=LastBoxSessionPosition(p)^.Successor;
                end;
              end;

           Result:=Result and
                   (SliceStart__<>SliceEnd__) and
                   ((SliceEnd__<>SliceStart__^.Successor) or (BoxNumberSet__.Count>=2));

           {$IFDEF CONSOLE_APPLICATION}
             if Result then
                Writeln(Reader.LevelCount,'. Permutations: ',Abs(BoxPermutationsCount__),' boxes  Pushes: ',SliceStart__.PushCount,LAZY_COLON,SliceEnd__.PushCount);
             //Readln;
           {$ELSE}
             if SliceResult__ then ShowStatus;
           {$ENDIF}
           end;
      end; // OptimizeGame.Search.BoxPermutationsSearch.GetNextSlice

      function  GetFirstSlice({var} BoxPermutationsCount__:Integer; var SliceStart__,SliceEnd__:PPosition; var BoxNumberSet__:TBoxNumberSet):Boolean;
      begin
        //BoxPermutationsCount__:=3;
        SliceStart__:=Positions.StartPosition; SliceEnd__:=SliceStart__; BoxNumberSet__.Count:=0;
        Result:=GetNextSlice(BoxPermutationsCount__,SliceStart,SliceEnd,BoxNumberSet__,False);
        {
        while Result and (SliceStart__^.PushCount<=110) do
          Result:=GetNextSlice(BoxPermutationsCount__,SliceStart,SliceEnd,BoxSet__,False);
        SetPosition(SliceStart__^.Parent);
        ShowBoard;
        Writeln(OptimizerMetricsAsText(SliceStart__^.Parent));
        Readln;
        }
      end; // OptimizeGame.Search.BoxPermutationsSearch.GetFirstSlice

      function  IncreaseBoxPermutationsCount(var BoxPermutationsCount__:Integer; MaxSlizeSize__:Integer; IterationResult__,StopAfterSuccessfulIteration__:Boolean):Boolean;
      begin
        Result:=(not SearchHasTerminated) and
                (not (IterationResult__ and StopAfterSuccessfulIteration__)) and
                (BoxPermutationsCount__<MaxBoxPermutationsCount__);
        if Result then Inc(BoxPermutationsCount__);
      end; // OptimizeGame.Search.BoxPermutationsSearch.IncreaseBoxPermutationsCount

      function  SearchSlice(BoxPermutationsCount__:Integer; SliceStart__,SliceEnd__:PPosition; const BoxNumberSet__:TBoxNumberSet):Boolean;
      var p:PPosition;

        function  BreadthFirstSearch(const BoxNumberSet__:TBoxNumberSet):Boolean;
        var BoxIndex,BoxNo,NeighborOffset,PlayerDistance,
            SquareNo,{SuccessorBoxCountDown,}SuccessorScore{,PositionSimpleLowerBound}:Integer;
            Direction:TDirection;
            Position,SuccessorPosition{,P}:PPosition;

          procedure UpdateTree;
          var NewScore,Score:Integer; p,q,Root:PPosition;
          begin // precondition: 'SetPosition' has been called to set the game state to the best position found so far
            // 'UpdateTree' is called to update the tree after a new best path has been found;
            // the open nodes are re-sorted, so nodes closest to the new best path have first priority
            with Positions.OpenPositions do
              for Score:=MinValue to MaxValue do begin
                  Root:=Buckets[Score];
                  if Root<>nil then begin
                     p:=Root^.ScoreBucket.Prev;                                 {'Prev': process the items in reverse order, so the bucket root is processed as the last item}
                     repeat
                            if p^.Score>=2 then begin
                               q:=p; NewScore:=0;
                               while (Ord(q^.Move.Direction) and POSITION_PATH_TAG)=0 do begin
                                 //if (q^.Parent<>nil) and (q^.Move.BoxNo<>q^.Parent^.Move.BoxNo) then
                                 Inc(NewScore);                                 {calculate the distance (measured in pushes) to the "spine", i.e., the current best path}
                                 q:=q^.Parent;
                                 end;

                               q:=p;                                            {'q': remember the latest processed item}
                               p:=p^.ScoreBucket.Prev;                          {'p': get ready to process the next (or rather the previous) item}

                               if NewScore<>Score then begin                    {'True': the score has changed, hence, re-sort the node}
                                  OPENRemove(q);
                                  q^.Score:=NewScore;
                                  OPENAdd(q,False);
                                  end;
                               end
                            else begin                                          {'Score<2': the node is close to the old best path which still may have its merits; therefore leave the score as it is}
                               q:=p;
                               p:=p^.ScoreBucket.Prev;                          {'p': get ready to process the next (or rather the previous) item}
                               end;
                     until  q=Root;                                             {until all items in the bucket have been processed}
                     end;
                  end;
          end; // OptimizeGame.Search.BoxPermutationsSearch.SearchSlice.BreadthFirstSearch.UpdateTree

          function  UpdatePosition(BoxNo__:Integer; Direction__:TDirection; BoxCountDown__:Integer; Parent__,Position__:PPosition):Boolean;
          var p:PPosition;
          begin
            Result:=False;

            with POptimizerPosition(Position__)^ do with Position do begin
              {check for a new best solution/snapshot}
              if ((Ord(Move.Direction) and POSITION_TARGET_TAG)<>0) and         {'True': the current game state is a terminal position}
                 (not HasABetterOrEqualScore(Positions.BestPosition)) then begin  {'True': this is a new best path to a terminal position}
                 p:=Parent; Parent:=Parent__; UpdateBestPosition(Position__); Parent:=p;
                 if Game.SimpleLowerBound=0 then Positions.SolutionPosition:=Position__;{'True': this is a new better solution}
                 Optimizer.Result:=prOK;                                        {'prOK': the optimizer improved the caller's solution/snapshot}
                 Result:=True;
                 Optimizer.IterationResult:=True;
                 UpdateTree;                                                    {re-sort the open nodes}
                 end
              else
                 {check for a new better path}
                 if ((Ord(Move.Direction) and POSITION_BEST_PATH_TAG)<>0) and   {'True': the current game state matches a position on the best path}
                    (not HasABetterOrEqualScore(Position__)) then begin         {'True': this is a new best path to this position}
                    Optimizer.Result:=prOK;                                     {'prOK': the optimizer improved the caller's solution/snapshot}
                    Result:=True;
                    Optimizer.IterationResult:=True;
                    end;

              {update the node}
              if Parent<>Parent__ then begin
                 if Parent<>nil then begin                                      {update old parent}
                    Dec(Parent^.SuccessorCount);
                    if (Parent^.SuccessorCount=0) and
                       ((Ord(Parent^.Move.Direction) and (POSITION_OPEN_TAG+POSITION_PATH_TAG+POSITION_TARGET_TAG))=0) then
                       OPENAdd(Parent,False);
                    end;
                 if Parent__<>nil then begin                                    {update new parent}
                    Inc(Parent__^.SuccessorCount);
                    if (Ord(Parent__^.Move.Direction) and POSITION_OPEN_TAG)<>0 then
                       OPENRemove(Parent__);
                      if (UInt8(Move.Direction) and POSITION_TARGET_PATH_TAG)<>0 then
                       UInt8(Parent__^.Move.Direction):=UInt8(Parent__^.Move.Direction) or POSITION_TARGET_PATH_TAG;
                    end;
                 Parent            :=Parent__;
                 end;

              PlayerPos            :=Game.PlayerPos;
              Move.BoxNo           :=BoxNo__;
              Move.Direction       :=TDirection((Ord(Move.Direction) and (not DIRECTION_BIT_MASK))+Ord(Direction__)); {insert the new direction but keep the existing flags, if any}
//>>>         __BoxCountDown__     :=BoxCountDown__;

              PushCount            :=Optimizer.GameMetrics.PushCount;
              MoveCount            :=Optimizer.GameMetrics.MoveCount;
              BoxChanges           :=Optimizer.GameMetrics.BoxChanges;
              BoxLines             :=Optimizer.GameMetrics.BoxLines;
              PushingSessions      :=Optimizer.GameMetrics.PushingSessions;
              PlayerLines          :=Optimizer.GameMetrics.PlayerLines;

              if (Parent__<>nil)
                 and
                 (Score>Succ(Parent__^.Score)) then begin
                 if ((Ord(Move.Direction) and POSITION_OPEN_TAG)<>0) then
                    OPENRemove(Position__);
                 Position__^.Score:=Succ(Parent__^.Score);                      {'Score' is really 'Depth', that is, the distance measured in pushes from the best path to a leaf position}
                 end;

              if ((Ord(Move.Direction) and POSITION_OPEN_TAG)=0)
                  and
                 (Game.SimpleLowerBound<>0) then
                 OPENAdd(Position__,Position__^.Score=0);

              if (Position__=Positions.BestPosition) and
                 RecalculateMetricsForPositionsOnBestPath(BoxNo__,Direction) then begin
                 ShowStatus;
                 WriteBestPathToLogFile;
                 end;

              end;
          end; // OptimizeGame.Search.BoxPermutationsSearch.SearchSlice.BreadthFirstSearch.UpdatePosition

        begin // OptimizeGame.Search.BoxPermutationsSearch.SearchSlice.BreadthFirstSearch
          Result:=False;

          with Positions do
            while OPENRemoveBest(Position) do begin
              if (Solver.SearchLimits.DepthLimit>=0) // 'True': the search hasn't been terminated}
                 or
                 (Position^.SuccessorCount>0) then {'True': the position might have improved its score, in which case its successors, if any, may need an update too}
                 with Solver.SearchStates[1].PlayersReachableSquares do begin
                   SetPosition(Position);
                   {
                   ShowBoard;
                   Write('Visit: ',Solver.PushCount,': ',YASS.Positions.Count,': ',GameMetricsAsText);
                   Readln;
                   }
                   CalculatePlayersDistanceToReachableSquares(1);
                   SuccessorScore:=Succ(Position^.Score);                       {this makes it a plain breadth first search}

                   for BoxIndex:=1 to BoxNumberSet__.Count do begin
                       BoxNo:=BoxNumberSet__.Numbers[BoxIndex];
                       SquareNo:=Game.BoxPos[BoxNo];

//                     if   BoxNo<>Position^.Move.BoxNo then
//                          SuccessorBoxCountDown:=Pred(Position^.BoxCountDown)
//                     else SuccessorBoxCountDown:=Position^.BoxCountDown;

                       if (Squares[SquareNo]=TimeStamp)                         {'=TimeStamp': the player can reach the box}
                          //and
                          //(SuccessorBoxCountDown>=0)
                          then begin
                          for Direction:=Low(Direction) to High(Direction) do begin
                              NeighborOffset:=Game.SquareOffsetForward[Direction];
                              if {inline simple checks for legal moves}
                                 ((Game.Board[SquareNo-NeighborOffset] and (BOX+WALL))=0) {'=0' the square is not blocked by a wall or another box}
                                 and
                                 (Squares    [SquareNo-NeighborOffset]>TimeStamp) {'>TimeStamp': the player can reach the neighbor-square}
                                 and
                                 ((Game.Board[SquareNo+NeighborOffset] and (BOX+WALL+FLAG_ILLEGAL_BOX_SQUARE+FLAG_NOT_SELECTED_SQUARE))=0) {'=0' the square is legal and not blocked by a wall or another box}
                                 and
                                 {extended checks for legal moves}
                                 IsALegalPush(BoxNo,Direction,-1) then
                                 if Solver.PushCount<Solver.SearchLimits.PushCountLimit then begin {limit not exceeded}
                                    Inc(Solver.PushCount);                      {update statistics}

                                    if (Solver.PushCount and (ONE_MEBI-1))=0

                                       // the speed drops dramatically if nodes are recycled one at a time;
                                       // in that case, trigger a time-check for each ~16000 legal pushes
                                       //((Solver.PushCount and (SIXTEEN_KIBI-1))=0)
                                       //and
                                       //(((Solver.PushCount and (ONE_MEBI-1))=0)
                                       // or
                                       // (YASS.Positions.SearchStatistics.DroppedCount<>0)
                                       //)

                                       then begin
                                       {$IFDEF CONSOLE_APPLICATION}
                                         if (Solver.PushCount and (ONE_MEBI-1))=0 then begin
                                            Writeln(SearchStatePromptText,
                                                   'Pushes: ',Solver.PushCount div ONE_MILLION,' million Positions: ',YASS.Positions.Count,'+',YASS.Positions.SearchStatistics.DroppedCount,
                                                   ' Open: ',YASS.Positions.OpenPositions.Count
                                                   {$IFDEF WINDOWS}
                                                     ,' Time: ',(CalculateElapsedTimeMS(Solver.StartTimeMS,GetTimeMS)+500) div 1000
                                                   {$ENDIF}
                                                   );
                                            end;
                                         {else Write(PERIOD)};
                                       {$ENDIF}


                                       TimeCheck;
                                       if Solver.SearchLimits.DepthLimit<0 then {'True': the time limit has been exceeded}
                                          Solver.SearchLimits.PushCountLimit:=High(Solver.SearchLimits.PushCountLimit); {'High': allow the search to run to its completion, but only visit existing positions, without creating new ones}
                                       end;

                                    PlayerDistance:=Pred(Squares[SquareNo-NeighborOffset]-TimeStamp);
                                    Inc(Solver.MoveCount,Succ(PlayerDistance)); {update statistics; Succ()': sum of non-pushing player moves + 1 push}

                                    Inc(Optimizer.GameMetrics.MoveCount,PlayerDistance); {update game state}
                                    DoPush(BoxNo,Direction);                    {do the move, i.e., update the board}
                                    SuccessorPosition:=nil;
                                    {
                                    if Game.HashValue=3749783270909373860 then begin
                                    ShowBoard;
                                    Write(GameMetricsAsText);
                                    Readln;
                                    end;
                                    }
                                    if (Optimizer.GameMetrics.MoveCount<=High(POptimizerPosition(SuccessorPosition)^.MoveCount)) {guard against move overflow}
                                       and
                                       (not HasABetterOrEqualScore(Optimizer.PruningNode))
                                       then
                                       with Solver.SearchStates[2].PlayersReachableSquares do begin
                                         Calculated:=False; {the player's reachable squares haven't been calculated yet}

                                         if TTLookup(2,ppmBetter,Direction,SuccessorPosition) then with POptimizerPosition(SuccessorPosition)^ do with Position do begin
                                            if (UInt8(Move.Direction) and POSITION_TARGET_PATH_TAG)<>0 then {'True': the successor position is on a path to a target position, hence, this also applies to the current position}
                                               UInt8(CurrentPosition^.Move.Direction):=UInt8(CurrentPosition^.Move.Direction) or POSITION_TARGET_PATH_TAG;
                                            if WasALegalPush(SuccessorPosition) then begin
                                               if      Parent=nil then with SuccessorPosition^ do begin
                                                       // 'SuccessorPosition' is a position from the backward search; install it as a successor of 'CurrentPosition'
                                                       Score:=0; // ensure that newly discovered paths to the terminal position are expanded first
                                                       Result:=UpdatePosition(BoxNo,Direction,{SuccessorBoxCountDown}0,CurrentPosition,SuccessorPosition) or Result;
                                                       end
                                               else if (PlayerPos<>Game.PlayerPos) then begin
                                                       // there is a better path to 'SuccessorPosition' than
                                                       // making the move [BoxNo, Direction] from 'CurrentPosition'
                                                       end
                                               else if HasABetterOrEqualScore(SuccessorPosition) then begin
                                                       // the old score for 'SuccessorPosition' is better than
                                                       // or equal to the current path score

                                                       {
                                                       // check whether the new path to the position has a better box count-down
                                                       if SuccessorBoxCountDown>BoxCountDown then with SuccessorPosition^ do begin
                                                          BoxCountDown:=SuccessorBoxCountDown;
                                                          if (Ord(Move.Direction) and POSITION_OPEN_TAG)<>0 then
                                                             // tests have shown that it makes a difference to remove
                                                             // the node from the open-queue and re-insert it,
                                                             // even when the old score is best; reason unknown
                                                             OPENRemove(SuccessorPosition);
                                                          if Score>SuccessorScore then begin
                                                             //if (Ord(Move.Direction) and POSITION_OPEN_TAG)<>0 then
                                                             //   see comment a few lines up
                                                             //   OPENRemove(SuccessorPosition);
                                                             Score:=SuccessorScore;
                                                             end;
                                                          if (Ord(Move.Direction) and (POSITION_OPEN_TAG+POSITION_PATH_TAG+POSITION_TARGET_TAG))=0 then begin
                                                             OPENAdd(SuccessorPosition,False);
                                                             end;
                                                          end;
                                                       }

                                                       end
                                                    else begin
                                                       // the score for 'SuccessorPosition' has improved; update it now
                                                       Result:=UpdatePosition(BoxNo,Direction,{SuccessorBoxCountDown}0,CurrentPosition,SuccessorPosition) or Result;
                                                       end;
                                               end
                                            else                                {the matching position found in the transposition table cannot be a successor of the current position}
                                               if Move.BoxNo<>0 then begin      {'<>': it's not the start position}
                                                  {$IFDEF CONSOLE_APPLICATION}
                                                    ShowBoard;
                                                    Writeln(Solver.PushCount,COLON,SPACE,
                                                            BoxNo,SLASH,DIRECTION_TO_CHAR[Direction],SPACE,SquareToColRowAsText(Game.BoxPos[BoxNo]),SPACE,
                                                            ' - ',
                                                            Move.BoxNo,SLASH,DIRECTION_TO_CHAR[TDirection(Ord(Move.Direction) and DIRECTION_BIT_MASK)],SPACE,SquareToColRowAsText(Game.BoxPos[Move.BoxNo])
                                                            );
                                                    Readln;
                                                  {$ENDIF}
                                                  TerminateSearch; Optimizer.Result:=prFailed; {something is wrong, such as 2 different positions accidentally having identical hashvalues}
                                                  end;
                                            end
                                         else                                   {the position was not found in the transposition table; add it now}
                                            if //(not HasABetterOrEqualScore(Optimizer.PruningNode))
                                               //and
                                               (CurrentPosition^.Score<Solver.SearchLimits.DepthLimit)
                                               and
                                               (Solver.SearchLimits.DepthLimit>=0) {'True': the search hasn't been terminated}
                                               then begin
                                               //if   (BoxNo<>CurrentPosition^.Move.BoxNo) or
                                               //     (CurrentPosition^.Score>1) then
                                               //     SuccessorScore:=Succ(CurrentPosition^.Score)
                                               //else SuccessorScore:=CurrentPosition^.Score;
                                               if TTAdd(BoxNo,Direction,2,SuccessorScore{Succ(CurrentPosition^.Score)}{-Ord(Game.SimpleLowerBound=PositionSimpleLowerBound)},CurrentPosition,SuccessorPosition,SuccessorPosition)
                                                  and
                                                  (Game.SimpleLowerBound<>0) then begin
                                                  OPENAdd(SuccessorPosition,False);
                                                  {
                                                  ShowBoard;
                                                  Writeln('Add: ',BoxNo,SPACE,DIRECTION_TO_TEXT[TDirection(Ord(Direction) and DIRECTION_BIT_MASK)]);
                                                  Readln;
                                                  }
                                                  end;
                                               end;
                                         end;

                                    if (Game.SimpleLowerBound=0) and            {'0': this is a solved position}
                                       (SuccessorPosition<>nil) and             {'<>nil': the start-position in a level with a trivial 0-push solution has successors (if there are any legal pushes)}
                                       (SuccessorPosition^.PushCount<>0) then begin {'<>0': this isn't the start position; if the start position was updated to be the best position, then the result would be a 0-push solution}
                                       with SuccessorPosition^.Move do Direction:=TDirection(Integer(Ord(Direction)) or POSITION_TARGET_TAG);
                                       if (YASS.Positions.SolutionPosition=nil)
                                          or
                                          (not HasABetterOrEqualScore(YASS.Positions.SolutionPosition))
                                          then begin
                                          YASS.Positions.SolutionPosition       :=SuccessorPosition;
                                          UpdateBestPosition(SuccessorPosition);
                                          {recalculate the metrics so the user can get the correct status information, in particular the 'player lines' metric which isn't calculated during the search}
                                          Result:=RecalculateMetricsForPositionsOnBestPath(BoxNo,Direction);
                                          if Result then begin
                                             Optimizer.Result                   :=prOK;
                                             Optimizer.IterationResult          :=True;
                                             UpdateTree;
                                             WriteBestPathToLogFile;
                                             end;
                                          end;
                                       end;

                                    UndoPush(BoxNo,Direction,CurrentPosition);  {take back the move, i.e., update the board}
                                    end
                                 else begin                                     {push count limit exceeded}
                                    end;
                              end;
                          end;
                       end;
                   end;
              end;
          SetPosition(nil); {otherwise, cycle removal may leave dangling 'POSITION_PATH_TAG' tags for positions which aren't on the current path any longer; 'TTPurge()' needs correct tags to left-justify the best path positions}
        end; // OptimizeGame.Search.BoxPermutationsSearch.SearchSlice.BreadthFirstSearch

      begin // OptimizeGame.Search.BoxPermutationsSearch.SearchSlice
        //Result:=False; exit;

        {$IFDEF PLUGIN_MODULE}
          Optimizer.SearchStateStatusText:=SPACE+SPACE+LEFT_PAREN+IntToStr(BoxNumberSet__.Count)+TEXT_SEARCH_STATUS_BOX_PERMUTATIONS+IntToStr(SliceStart__^.PushCount)+LAZY_COLON+IntToStr(SliceEnd__^.PushCount)+RIGHT_PAREN;
          ShowStatus;
        {$ENDIF}

        SetPosition(SliceStart__^.Parent);
        Optimizer.PruningNode:=SliceEnd__;
        OPENClear;
        OPENAdd(Positions.CurrentPosition,False);                               // put the root position on the open-queue, i.e., the position before the slice
        p:=SliceEnd__^.Parent;
        while p<>Positions.CurrentPosition do begin                             // put all slice positions on the open-queue
          OPENAdd(p,False);
          p:=p^.Parent;
          end;
        {
        with SliceStart__^.Parent^ do
          if (PushCount>=1000) and (PushCount<=1100) then begin
             ShowBoard;
             Writeln(OptimizerMetricsAsText(SliceStart__^.Parent));
             Readln;
             end;
        }
        Result:=BreadthFirstSearch(BoxNumberSet__);
        if Result then RemoveCyclesFromBestPath(True);
      end; // OptimizeGame.Search.BoxPermutationsSearch.SearchSlice

    begin // OptimizeGame.Search.BoxPermutationsSearch
      Result:=False; TimeMS__:=GetTimeMS; Optimizer.IterationResult:=False;
      //BoxPermutationsCount__:=5; MaxBoxPermutationsCount__:=5;
      if InitializeSlicing(BoxPermutationsCount__,MaxBoxPermutationsCount__) then
         repeat if GetFirstSlice(BoxPermutationsCount__,SliceStart,SliceEnd,BoxNumberSet) then
                   repeat  SliceResult:=SearchSlice(BoxPermutationsCount__,SliceStart,SliceEnd,BoxNumberSet);
                           Result:=SliceResult or Result;
                   until   not GetNextSlice(BoxPermutationsCount__,SliceStart,SliceEnd,BoxNumberSet,SliceResult);
         until  not IncreaseBoxPermutationsCount(BoxPermutationsCount__,MaxBoxPermutationsCount__,Result,StopAfterSuccessfulIteration__);
      TTPurge(Positions.Capacity,False); Optimizer.PurgeCount:=0;
      TimeMS__:=CalculateElapsedTimeMS(TimeMS__,GetTimeMS);
    end; // OptimizeGame.Search.BoxPermutationsSearch

    function  IterativeBoxPermutationsSearch(var BoxPermutationsCount__:Integer; TimeLimitMS__:TTimeMS; var TimeMS__:TTimeMS):Boolean;
    begin
      Result:=False; BoxPermutationsCount__:=1;
      repeat  Inc(BoxPermutationsCount__);
              Result:=BoxPermutationsSearch(BoxPermutationsCount__,BoxPermutationsCount__,True,TimeMS__) or Result;
      until   (TimeMS__>=TimeLimitMS__)
              or
              (TimeMS__=0)                                                      {'0': the program is probably compiled without a working 'get-time-from-the-operating-system' function, or the level is so small that an exhaustive search is possible}
              or
              ((BoxPermutationsCount__>=OPTIMIZER_BOX_PERMUTATIONS_SEARCH_SMALL_LEVEL_THRESHOLD_BOXES)
               and
               (TimeMS__   < OPTIMIZER_BOX_PERMUTATIONS_SEARCH_SMALL_LEVEL_THRESHOLD_TIME_MS)) {'True': the level is probably so small that it's better to spend the time on global optimization search instead of the box permutations search}
              or
              (BoxPermutationsCount__>=Game.BoxCount)
              //or
              //(BoxPermutationsCount__>=2)
              or
              SearchHasTerminated;
      Optimizer.IterationResult:=Optimizer.IterationResult or Result;
    end; // OptimizeGame.Search.IterativeBoxPermutationsSearch

    function  GlobalOptimizationSearch:Boolean;
    var //BoxNo,NeighborOffset,PlayerDistance,SquareNo,SuccessorScore{,PositionSimpleLowerBound}:Integer;
        //Direction:TDirection;
        NewBestResult:Boolean;
        Position{,SuccessorPosition{,P}:PPosition;

      function  AStarSearch:Boolean;
      var BoxNo,NeighborOffset,PlayerDistance,SquareNo,SuccessorScore{,PositionSimpleLowerBound}:Integer;
          Direction:TDirection;
          Position,SuccessorPosition{,P}:PPosition;

        procedure UpdateTree;
        var NewScore,Score:Integer; p,q,Root:PPosition;
        begin // precondition: 'SetPosition' has been called to set the game state to the best position found so far
          // 'UpdateTree' is called to update the tree after a new best path has been found;
          // the open nodes are re-sorted, so nodes closest to the new best path have first priority
          with Positions.OpenPositions do
            for Score:=MinValue to MaxValue do begin
                Root:=Buckets[Score];
                if Root<>nil then begin
                   p:=Root^.ScoreBucket.Prev;                                   {'Prev': process the items in reverse order, so the bucket root is processed as the last item}
                   repeat
                          if p^.Score>=2 then begin
                             q:=p; NewScore:=0;
                             while (Ord(q^.Move.Direction) and POSITION_PATH_TAG)=0 do begin
                               if (q^.Parent<>nil) and (q^.Move.BoxNo<>q^.Parent^.Move.BoxNo) then
                                  Inc(NewScore);                                {calculate the distance (measured in box-changes) to the "spine", i.e., the current best path}
                               q:=q^.Parent;
                               end;

                             q:=p;                                              {'q': remember the latest processed item}
                             p:=p^.ScoreBucket.Prev;                            {'p': get ready for the next item to process}

                             if NewScore<>Score then begin                      {'True': the score has changed, hence, re-sort the node}
                                OPENRemove(q);
                                q^.Score:=NewScore;
                                OPENAdd(q,False);
                                end;
                             end
                          else begin                                            {'Score<2': the node is close to the old best path which still may have its merits; therefore leave the score as it is}
                             q:=p;
                             p:=p^.ScoreBucket.Prev;                            {'p': get ready for the next item to process}
                             end;
                   until  q=Root;                                               {until all items in the bucket have been processed}
                   end;
                end;
        end; // OptimizeGame.Search.GlobalOptimizationSearch.AStarSearch.UpdateTree

        function  UpdatePosition(BoxNo__:Integer; Direction__:TDirection; Parent__,Position__:PPosition):Boolean;
        var OldMoveCount:Integer; p:PPosition;
        begin // updates a position when a new better path (or a first forward path) to this position has been found
          Result:=False;
          {
          Write('New best path');
          if Position__^.Parent<>nil then
             Write(': old metrics: ',OptimizerMetricsAsText(Position__))
          else Write(' to a backwards generated position');
          Readln;
          }
          with POptimizerPosition(Position__)^ do with Position do begin
            {check for a new best solution/snapshot}
            if ((Ord(Move.Direction) and POSITION_TARGET_TAG)<>0) and           {'True': the current game state is a terminal position}
               (not HasABetterOrEqualScore(Positions.BestPosition)) then begin  {'True': this is a new best path to a terminal position}
               p:=Parent; Parent:=Parent__; UpdateBestPosition(Position__); Parent:=p;
               if Game.SimpleLowerBound=0 then Positions.SolutionPosition:=Position__;{'True': this is a new better solution}
               Optimizer.Result:=prOK;                                          {'prOK': the optimizer improved on the caller's solution/snapshot}
               Result:=True;
               Optimizer.IterationResult:=True;
               UpdateTree;                                                      {re-sort the open nodes}
               end;

            {update the node}
            if Parent<>Parent__ then begin
               if Parent<>nil then begin                                        {update old parent}
                  Dec(Parent^.SuccessorCount);
                  if (Parent^.SuccessorCount=0) and
                     ((Ord(Parent^.Move.Direction) and (POSITION_OPEN_TAG+POSITION_PATH_TAG+POSITION_TARGET_TAG))=0) then
                     OPENAdd(Parent,False);
                  end;
               if Parent__<>nil then begin                                      {update new parent}
                  Inc(Parent__^.SuccessorCount);
                  if (Ord(Parent__^.Move.Direction) and POSITION_OPEN_TAG)<>0 then
                     OPENRemove(Parent__);
                  if (UInt8(Move.Direction) and POSITION_TARGET_PATH_TAG)<>0 then
                     UInt8(Parent__^.Move.Direction):=UInt8(Parent__^.Move.Direction) or POSITION_TARGET_PATH_TAG;
                  end;
               Parent            :=Parent__;
               end;

            OldMoveCount         :=MoveCount;

            PlayerPos            :=Game.PlayerPos;
            Move.BoxNo           :=BoxNo__;
            Move.Direction       :=TDirection((Ord(Move.Direction) and (not DIRECTION_BIT_MASK))+Ord(Direction__)); {insert the new direction but keep the existing flags, if any}

            PushCount            :=Optimizer.GameMetrics.PushCount;
            MoveCount            :=Optimizer.GameMetrics.MoveCount;
            BoxChanges           :=Optimizer.GameMetrics.BoxChanges;
            BoxLines             :=Optimizer.GameMetrics.BoxLines;
            PushingSessions      :=Optimizer.GameMetrics.PushingSessions;
            PlayerLines          :=Optimizer.GameMetrics.PlayerLines;

            if (Parent__<>nil)
               and
               (Score>Succ(Parent__^.Score)) then begin
               if (Ord(Move.Direction) and POSITION_OPEN_TAG)<>0 then
                  OPENRemove(Position__);
               Position__^.Score:=Succ(Parent__^.Score);                        {'Score' is really 'Depth', that is, the distance measured in pushes from the best path (the "spine") to a leaf position}
               end;

            if ((Ord(Move.Direction) and POSITION_OPEN_TAG)=0)                  {'=0' : the position isn't already on the open-list}
               and
               (Game.SimpleLowerBound<>0)                                       {'<>0': this is not a solved position}
               and
               ((YASS.Positions.UninitializedItemCount>=0)                      {'>=0': the search is still adding nodes, i.e., it hasn't changed to "update-existing-nodes-only" mode}
                or
                (((Ord(Move.Direction) and POSITION_TARGET_PATH_TAG)<>0)        {'<>0': the node is on a path to a target position, hence, it must be updated because the position could be a member of a new best path}
                )
               )
               then
               if (Positions.OpenPositions.HighValueItemCount<OPTIMIZER_GLOBAL_OPTIMIZATION_UPDATE_DELAY_POSITIONS) // 'True': the delay update queue isn't full yet
                  then with Position__^ do begin
                  if   OldMoveCount-MoveCount<OPTIMIZER_GLOBAL_OPTIMIZATION_UPDATE_IMMIDIATELY_THRESHOLD then begin  // 'True': this is a minor improvement of the score; delay updating the successors of this position
                       if Score<High(Positions.OpenPositions.Buckets) then Inc(Score,High(Positions.OpenPositions.Buckets)); // '+High(Buckets)': the original score can be reconstructed later by deducting 'High(Buckets)'
                       OPENAdd(Position__,False);
                       end
                  else OPENAdd(Position__,Position__^.Score=0);
                  end
               else begin
                  OPENAdd(Position__,Position__^.Score=0);
                  if Positions.OpenPositions.HighValueItemCount>0 then ForceUpdatingOfImprovedPositions;
                  end;

            if (Position__=Positions.BestPosition) and
               RecalculateMetricsForPositionsOnBestPath(BoxNo__,Direction__) then begin {recalculate the metrics so the user can get the correct status information; contrary to the other metrics, 'player lines' is only calculated here}
               ShowStatus;
               WriteBestPathToLogFile;
               end;
            end;
        end; // OptimizeGame.Search.GlobalOptimizationSearch.AStarSearch.UpdatePosition

      begin // OptimizeGame.Search.GlobalOptimizationSearch.AStarSearch
        Result:=False;
        with Positions do
          while OPENRemoveBest(Position) do begin
            if (Solver.SearchLimits.DepthLimit>=0) // 'True': the search hasn't been terminated}
               or
               (Position^.SuccessorCount>0) then {'True': the position might have improved its score, in which case its successors, if any, may need an update too}
               with Solver.SearchStates[1].PlayersReachableSquares do begin
                 SetPosition(Position);
                 CalculatePlayersDistanceToReachableSquares(1);
                 {
                 if       Game.HashValue=... then with Position^ do begin
                          YASS.Positions.DebugPosition:=Position;
                          ShowBoard;
                          Writeln('Expand debug position: ',YASS.Positions.Count,SPACE,Solver.PushCount,' Pushes: ',PushCount,' Score: ',Score,SPACE,Game.SimpleLowerBound);
                          Readln;
                          end;
                 }
                 for BoxNo:=1 to Game.BoxCount do begin
                     SquareNo:=Game.BoxPos[BoxNo];
                     if Squares[SquareNo]=TimeStamp then begin                  {'=TimeStamp': the player can reach the box}
                        for Direction:=Low(Direction) to High(Direction) do begin
                            NeighborOffset:=Game.SquareOffsetForward[Direction];
                            if {inline simple checks for legal moves}
                               ((Game.Board[SquareNo-NeighborOffset] and (BOX+WALL))=0) {'=0' the square is not blocked by a wall or another box}
                               and
                               (Squares    [SquareNo-NeighborOffset]>TimeStamp) {'>TimeStamp': the player can reach the neighbor-square}
                               and
                               ((Game.Board[SquareNo+NeighborOffset] and (BOX+WALL+FLAG_ILLEGAL_BOX_SQUARE+FLAG_NOT_SELECTED_SQUARE))=0) {'=0' the square is legal and not blocked by a wall or another box}
                               and
                               {extended checks for legal moves}
                               IsALegalPush(BoxNo,Direction,-1) then
                               if Solver.PushCount<Solver.SearchLimits.PushCountLimit then begin {limit not exceeded}
                                  Inc(Solver.PushCount);                        {update statistics}

                                  if (Solver.PushCount and (ONE_MEBI-1))=0

                                     // the speed drops dramatically if nodes are recycled one at a time;
                                     // in that case, trigger a time-check for each ~16000 legal pushes
                                     //((Solver.PushCount and (SIXTEEN_KIBI-1))=0)
                                     //and
                                     //(((Solver.PushCount and (ONE_MEBI-1))=0)
                                     // or
                                     // (YASS.Positions.SearchStatistics.DroppedCount<>0)
                                     //)

                                     then begin
                                     {$IFDEF CONSOLE_APPLICATION}
                                       if (Solver.PushCount and (ONE_MEBI-1))=0 then begin
                                          Writeln(SearchStatePromptText,
                                                 'Pushes: ',Solver.PushCount div ONE_MILLION,' million Positions: ',YASS.Positions.Count,'+',YASS.Positions.SearchStatistics.DroppedCount,
                                                 ' Open: ',YASS.Positions.OpenPositions.Count
                                                 {$IFDEF WINDOWS}
                                                   ,' Time: ',(CalculateElapsedTimeMS(Solver.StartTimeMS,GetTimeMS)+500) div 1000
                                                 {$ENDIF}
                                                 );
                                          end;
                                       {else Write(PERIOD)};
                                     {$ELSE}
                                       Optimizer.SearchStateStatusText:=TEXT_SEARCH_STATUS_GLOBAL_OPTIMIZATION+IntToStr((YASS.Positions.Count*100) div YASS.Positions.Capacity)+'%)';
                                       SetSokobanStatusText(Optimizer.SearchResultStatusText+Optimizer.SearchStateStatusText);
                                     {$ENDIF}

                                     TimeCheck;
                                     if Solver.SearchLimits.DepthLimit<0 then   {'True': the time limit has been exceeded}
                                        Solver.SearchLimits.PushCountLimit:=High(Solver.SearchLimits.PushCountLimit); {'High': allow the search to run to its completion, but only visit existing positions, without creating new ones}
                                     end;

                                  PlayerDistance:=Pred(Squares[SquareNo-NeighborOffset]-TimeStamp);
                                  Inc(Solver.MoveCount,Succ(PlayerDistance));   {update statistics; Succ()': sum of non-pushing player moves + 1 push}
                                  Inc(Optimizer.GameMetrics.MoveCount,PlayerDistance); {update game state}
                                  DoPush(BoxNo,Direction);                      {do the move, i.e., update the board}
                                  SuccessorPosition:=nil;
                                  {
                                  if Solver.PushCount>=0 then begin // YASS.Positions.Count>=0 then begin
                                     ShowBoard;
                                     Write('Try: ',Solver.PushCount,': ',YASS.Positions.Count,': ',GameMetricsAsText);
                                     Readln;
                                     end;
                                  }
                                  if (Optimizer.GameMetrics.MoveCount<=High(POptimizerPosition(SuccessorPosition)^.MoveCount)) {guard against move overflow}
                                     and
                                     (not HasABetterOrEqualScore(Optimizer.PruningNode)) then
                                     with Solver.SearchStates[2].PlayersReachableSquares do begin
                                       Calculated:=False; {the player's reachable squares haven't been calculated yet}

                                       if TTLookup(2,ppmBetter,Direction,SuccessorPosition) then with POptimizerPosition(SuccessorPosition)^ do with Position do begin
                                          if (UInt8(Move.Direction) and POSITION_TARGET_PATH_TAG)<>0 then {'True': the successor position is on a path to a target position, hence, this also applies to the current position}
                                             UInt8(CurrentPosition^.Move.Direction):=UInt8(CurrentPosition^.Move.Direction) or POSITION_TARGET_PATH_TAG;

                                          if WasALegalPush(SuccessorPosition) then begin
                                             if      Parent=nil then begin
                                                     // 'SuccessorPosition' is a position from the backward search; install it as a successor of 'CurrentPosition'
                                                     SuccessorPosition^.Score:=0; // ensure that newly discovered paths to the terminal position are expanded first
                                                     Result:=UpdatePosition(BoxNo,Direction,CurrentPosition,SuccessorPosition) or Result;
                                                     end
                                             else if (PlayerPos<>Game.PlayerPos) then begin
                                                     // there is a better path to 'SuccessorPosition' than
                                                     // making the move [BoxNo, Direction] from 'CurrentPosition',
                                                     // hence, no change is necessary
                                                     end
                                             else if HasABetterOrEqualScore(SuccessorPosition) then begin
                                                     // the old score for 'SuccessorPosition' is better than or equal to
                                                     // the current path score, hence, no change is necessary
                                                     end
                                                  else begin
                                                     // the score for 'SuccessorPosition' has improved; update it now
                                                     Result:=UpdatePosition(BoxNo,Direction,CurrentPosition,SuccessorPosition) or Result;
                                                     end;
                                             end
                                          else                                  {the matching position in the transposition table cannot be a successor of the current position}
                                             if Move.BoxNo<>0 then              {'<>': it's not the start position}
                                                if Parent=nil then begin
                                                   // 'SuccessorPosition' is a position from the backward search; install it as a successor of 'CurrentPosition'
                                                   SuccessorPosition^.Score:=0; // ensure that newly discovered paths to the terminal position are expanded first
                                                   Result:=UpdatePosition(BoxNo,Direction,CurrentPosition,SuccessorPosition) or Result;
                                                   end
                                                else begin
                                                   {$IFDEF CONSOLE_APPLICATION}
                                                     ShowBoard;
                                                     Writeln(Solver.PushCount,COLON,SPACE,
                                                            BoxNo,SLASH,DIRECTION_TO_CHAR[Direction],SPACE,SquareToColRowAsText(Game.BoxPos[BoxNo]),SPACE,
                                                            ' - ',
                                                            Move.BoxNo,SLASH,DIRECTION_TO_CHAR[TDirection(Ord(Move.Direction) and DIRECTION_BIT_MASK)],SPACE,SquareToColRowAsText(Game.BoxPos[Move.BoxNo])
                                                            );
                                                     Readln;
                                                   {$ENDIF}
                                                   TerminateSearch; Optimizer.Result:=prFailed; {something is wrong, such as 2 different positions accidentally having identical hashvalues}
                                                   end;
                                          end
                                       else                                     {the position was not found in the transposition table; add it now}
                                          if (CurrentPosition^.Score<Solver.SearchLimits.DepthLimit)
                                             and
                                             (Solver.SearchLimits.DepthLimit>=0) {'True': the search hasn't been terminated}
                                             then begin
                                             SuccessorScore:=CurrentPosition^.Score;
                                             if   ((BoxNo<>CurrentPosition^.Move.BoxNo)
                                                   or
                                                   (SuccessorScore>1)
                                                  )
                                                  and
                                                  (SuccessorScore<High(YASS.Positions.OpenPositions.Buckets)-1) {'<': the highest value is reserved for the delay update queue}
                                                  then
                                                  Inc(SuccessorScore);
                                             if   TTAdd(BoxNo,Direction,2,SuccessorScore{Succ(CurrentPosition^.Score)}{-Ord(Game.SimpleLowerBound=PositionSimpleLowerBound)},CurrentPosition,SuccessorPosition,SuccessorPosition)
                                                  and
                                                  (Game.SimpleLowerBound<>0) then begin
                                                  OPENAdd(SuccessorPosition,False);
                                                  {
                                                  if       (Game.HashValue=...) and (YASS.Positions.DebugPosition=nil) then begin
                                                           YASS.Positions.DebugPosition:=SuccessorPosition;
                                                           ShowBoard;
                                                           Writeln('Added debug position: ',YASS.Positions.Count,SPACE,Solver.PushCount,' Pushes: ',SuccessorPosition^.PushCount,' Score: ',SuccessorScore,SPACE,Game.SimpleLowerBound);
                                                           Readln;
                                                           end;
                                                  }
                                                  end;
                                             end;
                                       end;

                                  if (Game.SimpleLowerBound=0) and              {'0': this is a solved position}
                                     (SuccessorPosition<>nil) then begin        {'<>nil': the start-position in a level with a trivial 0-push solution has successors (if there are any legal moves)}
                                     with SuccessorPosition^.Move do Direction:=TDirection(Integer(Ord(Direction)) or POSITION_TARGET_TAG);
                                     if (YASS.Positions.SolutionPosition=nil)
                                        or
                                        (not HasABetterOrEqualScore(YASS.Positions.SolutionPosition))
                                        then begin
                                        YASS.Positions.SolutionPosition         :=SuccessorPosition;
                                        UpdateBestPosition(SuccessorPosition);
                                        Result:=RecalculateMetricsForPositionsOnBestPath(BoxNo,Direction); {recalculate the metrics so the user can get the correct status information; contrary to the other metrics, 'player lines' is only calculated here}
                                        if Result then begin
                                           Optimizer.Result                     :=prOK;
                                           Optimizer.IterationResult            :=True;
                                           UpdateTree;
                                           WriteBestPathToLogFile;
                                           end;
                                        end;
                                     end;

                                  UndoPush(BoxNo,Direction,CurrentPosition);    {take back the move, i.e., update the board}
                                  end
                               else begin                                       {push count limit exceeded}
                                  end;
                            end;
                        end;
                     end;
                 end;
            end;
      end; // OptimizeGame.Search.GlobalOptimizationSearch.AStarSearch

      function  OPENAddBestPathPermutations:Integer;
      var PositionsLimit:Cardinal; Position,Next:PPosition;

        function  AddToList(Position__,List__:PPosition):PPosition;
        begin // OptimizeGame.Search.GlobalOptimizationSearch.OPENAddBestPathPermutations.AddToList
          Position__^.ListLinks.Prev:=List__;
          Result:=Position__;
        end; // OptimizeGame.Search.GlobalOptimizationSearch.OPENAddBestPathPermutations.AddToList

        function  IsALegalPush(Depth__:Integer; Position__:PPosition; var BoxNo__:Integer; var Direction__:TDirection):Boolean;
        var NeighborOffset,SquareNo:Integer;
        begin // OptimizeGame.Search.GlobalOptimizationSearch.OPENAddBestPathPermutations.IsALegalPush
          with Solver.SearchStates[Depth__].PlayersReachableSquares do with Position__^ do begin
            Result             :=False;
            SquareNo           :=PlayerPos;
            Direction__        :=TDirection(Ord(Move.Direction) and DIRECTION_BIT_MASK);
            if Squares[SquareNo]=TimeStamp then begin                           {'=TimeStamp': there is a box at 'PlayerPos', and the player can reach it}
               if   SquareNo    =Game.BoxPos[Move.BoxNo] then
                    BoxNo__    :=Move.BoxNo
               else BoxNo__    :=BoxNoAtSquare(PlayerPos);
               NeighborOffset :=Game.SquareOffsetForward[Direction__];
               if (BoxNo__<>0)                                                  {'True': there is a box at the square}
                  and
                  (Solver.PushCount<Solver.SearchLimits.PushCountLimit)         {'True': limit not exceeded}
                  and
                  {inline simple checks for legal moves}
                  ((Game.Board[SquareNo-NeighborOffset] and (BOX+WALL))=0)      {'=0' the square is not blocked by a wall or another box}
                  and
                  (Squares    [SquareNo-NeighborOffset]>TimeStamp)              {'>TimeStamp': the player can reach the neighbor-square}
                  and
                  ((Game.Board[SquareNo+NeighborOffset] and (BOX+WALL+FLAG_ILLEGAL_BOX_SQUARE+FLAG_NOT_SELECTED_SQUARE))=0) {'=0' the square is legal and not blocked by a wall or another box}
                  and
                  {extended checks for legal moves}
                  YASS.IsALegalPush(BoxNo__,Direction__,-1) then
                  if Solver.PushCount<Solver.SearchLimits.PushCountLimit then   {'True': limit not exceeded}
                     Result:=True;
               end;
            end;
        end; // OptimizeGame.Search.GlobalOptimizationSearch.OPENAddBestPathPermutations.IsALegalPush

        procedure DoMove(Depth__,BoxNo__:Integer; Direction__:TDirection;
                         var OldGameMetrics__:TOptimizerGameMetrics;
                         var OldPlayerPos__:Integer);
        var PlayerDistance:Integer;
        begin // OptimizeGame.Search.GlobalOptimizationSearch.OPENAddBestPathPermutations.DoMove
          OldGameMetrics__:=Optimizer.GameMetrics; OldPlayerPos__:=Game.PlayerPos;
          with Solver.SearchStates[Depth__].PlayersReachableSquares do
             PlayerDistance:=Pred(Squares[Game.BoxPos[BoxNo__]-Game.SquareOffsetForward[Direction__]]-TimeStamp);
          Inc(Solver.MoveCount,Succ(PlayerDistance));                           {update statistics; Succ()': sum of non-pushing player moves + 1 push}
          Inc(Solver.PushCount);                                                {update statistics}
          Inc(Optimizer.GameMetrics.MoveCount,PlayerDistance);                  {update game state}
          DoPush(BoxNo__,Direction__);

          if (Solver.PushCount and (ONE_MEBI-1))=0 then begin
             {$IFDEF CONSOLE_APPLICATION}
               if (Solver.PushCount and (ONE_MEBI-1))=0 then begin
                  Writeln(SearchStatePromptText,
                          'Pushes: ',Solver.PushCount div ONE_MILLION,' million Positions: ',YASS.Positions.Count,'+',YASS.Positions.SearchStatistics.DroppedCount,
                          ' Open: ',YASS.Positions.OpenPositions.Count
                          {$IFDEF WINDOWS}
                            ,' Time: ',(CalculateElapsedTimeMS(Solver.StartTimeMS,GetTimeMS)+500) div 1000
                          {$ENDIF}
                          );
                    end;
               {else Write(PERIOD)};
             {$ELSE}
               Optimizer.SearchStateStatusText:=TEXT_SEARCH_STATUS_GLOBAL_OPTIMIZATION+IntToStr((YASS.Positions.Count*100) div YASS.Positions.Capacity)+'%)';
               SetSokobanStatusText(Optimizer.SearchResultStatusText+Optimizer.SearchStateStatusText);
             {$ENDIF}
             TimeCheck;
             if Solver.SearchLimits.DepthLimit<0 then                           {'True': the time limit has been exceeded}
                Solver.SearchLimits.PushCountLimit:=High(Solver.SearchLimits.PushCountLimit); {'High': allow the search to run to its completion, but only visit existing positions, without creating new ones}
             end;
        end; //OptimizeGame.Search.GlobalOptimizationSearch.OPENAddBestPathPermutations.DoMove

        procedure UndoMove(BoxNo__:Integer; Direction__:TDirection; const OldGameMetrics__:TOptimizerGameMetrics; OldPlayerPos__:Integer);
        begin // OptimizeGame.Search.GlobalOptimizationSearch.OPENAddBestPathPermutations.UndoMove
          //Dec(Optimizer.MovesFromSquare[Game.BoxPos[BoxNo__]-Game.SquareOffsetForward[Direction__],Direction__]); // update move map
          YASS.UndoPush(BoxNo__,Direction__); // update board
          if OldPlayerPos__<>Game.PlayerPos then MovePlayer(OldPlayerPos__);
          Optimizer.GameMetrics:=OldGameMetrics__; //restore game metrics
        end; // OptimizeGame.Search.GlobalOptimizationSearch.OPENAddBestPathPermutations.UndoMove

        procedure DelayPushesSearch(Position__,PendingPositions__,Parent__:PPosition; Depth__:Integer);
        var BoxNo,OldPlayerPos:Integer; Direction,OldDirection:TDirection;
            p,SuccessorPosition:PPosition; OldGameMetrics:TOptimizerGameMetrics;
        begin // OptimizeGame.Search.GlobalOptimizationSearch.OPENAddBestPathPermutations.DelayPushesSearch
          if (Depth__<=MAX_OPTIMIZER_SEARCH_DEPTH_FOR_ADDING_BEST_PATH_PERMUTATIONS) and
             (Depth__< MAX_HISTORY_BOX_MOVES) and
             (Solver.PushCount<Solver.SearchLimits.PushCountLimit) and          {'True': limit not exceeded}
             (Position__<>nil) then with Position__^ do begin
             CalculatePlayersDistanceToReachableSquares(Depth__);

             {check each of the pending positions and see if they contain legal pushes for the current game state}
             p:=PendingPositions__;
             while p<>nil do begin
               if (p<>Parent__) and
                  IsALegalPush(Depth__,p,BoxNo,Direction) then begin
                  DoMove(Depth__,BoxNo,Direction,OldGameMetrics,OldPlayerPos);

                  if (Optimizer.GameMetrics.MoveCount<=High(POptimizerPosition({SuccessorPosition}Position__)^.MoveCount)) {guard against move overflow}
                     and
                     (not HasABetterOrEqualScore(Optimizer.PruningNode)) and
                     (Positions.Count<PositionsLimit) and
                     (Solver.SearchLimits.DepthLimit>=0) then                   {'True': the search hasn't been terminated}
                     if not TTLookup(Depth__,ppmBetter,Direction,SuccessorPosition) then begin
                        OldDirection:=Parent__^.Move.Direction; Parent__^.Move.Direction:=dUp; {'dUp': clear any flags stored together with the direction for the parent position}
                        if TTAdd(BoxNo,Direction,Depth__,1,Parent__,SuccessorPosition,SuccessorPosition)
                           and
                           (Game.SimpleLowerBound<>0) then begin
                           OPENAdd(SuccessorPosition,False); Inc(Result);
                           //ShowBoard;
                           //Write('Added: ',SuccessorPosition^.PushCount); Readln;
                           DelayPushesSearch(Position__,PendingPositions__,SuccessorPosition,Succ(Depth__));
                           end;
                        Parent__^.Move.Direction:=OldDirection;                 {restore direction and flags, e.g., 'POSITION_OPEN_TAG'}
                        end;

                  UndoMove(BoxNo,Direction,OldGameMetrics,OldPlayerPos);
                  end;
               p:=p^.ListLinks.Prev;                                            {get ready for the next pending position, if any}
               end;

             {check if 'Position__' contains a legal push for the current game state}
             if IsALegalPush(Depth__,Position__,BoxNo,Direction) then begin
                DoMove(Depth__,BoxNo,Direction,OldGameMetrics,OldPlayerPos);

                if (Optimizer.GameMetrics.MoveCount<=High(POptimizerPosition(SuccessorPosition)^.MoveCount)) {guard against move overflow}
                   and
                   (not HasABetterOrEqualScore(Optimizer.PruningNode)) and
                   (Positions.Count<PositionsLimit) and
                   (Solver.SearchLimits.DepthLimit>=0) then                     {'True': the search hasn't been terminated}
                   if not TTLookup(Depth__,ppmBetter,Direction,SuccessorPosition) then begin
                      OldDirection:=Parent__^.Move.Direction; Parent__^.Move.Direction:=dUp; {'dUp': clear any flags stored together with the direction for the parent position}
                      if TTAdd(BoxNo,Direction,Depth__,1,Parent__,SuccessorPosition,SuccessorPosition)
                         and
                         (Game.SimpleLowerBound<>0) then begin
                         OPENAdd(SuccessorPosition,False); Inc(Result);
                         //ShowBoard;
                         //Write('Added: ',SuccessorPosition^.PushCount); Readln;
                         DelayPushesSearch(Successor,PendingPositions__,SuccessorPosition,Succ(Depth__));
                         end;
                      Parent__^.Move.Direction:=OldDirection;                   {restore direction and flags, e.g., 'POSITION_OPEN_TAG'}
                      end;

                UndoMove(BoxNo,Direction,OldGameMetrics,OldPlayerPos);
                end
             else
                DelayPushesSearch(Successor,AddToList(Position__,PendingPositions__),Parent__,Succ(Depth__));
             end;
        end; // OptimizeGame.Search.GlobalOptimizationSearch.OPENAddBestPathPermutations.DelayPushesSearch

      begin // OPENAddBestPathPermutations; postcondition: no best path positions are on the open-queue
         Result:=0; //exit;
         PositionsLimit:=Positions.Capacity div 2;
         Position:=Positions.BestPosition; Next:=nil;                           {build forward links between the nodes on the best path}
         while Position<>nil do with Position^ do begin
           if ((Ord(Move.Direction) and POSITION_OPEN_TAG)<>0) then OPENRemove(Position); {ensure that the position isn't on the open-queue; the forwards linked list uses the 'Successor' field which overlaps the open-queue item links}
           Successor:=Next; Next:=Position; Position:=Parent;
           end;

         {add permutations by delaying pushes}
         Position:=Next;                                                        {get ready to process the positions on the best path in forward order}
         while Position<>nil do with Position^ do begin                         {for each position on the best path, try to delay the push}
           SetPosition(Position);
           if Successor<>nil then begin                                         {'True': this isn't the last position on the best found path}
              DelayPushesSearch(Successor^.Successor,AddToList(Successor,nil),Position,1);
              end;

           Position:=Successor;
           end;

         {$IFDEF CONSOLE_APPLICATION}
           Writeln('Best path permutations: ',Result,' Positions: ',Positions.Count,' Open: ',Positions.OpenPositions.Count);
         {$ENDIF}

         SetPosition(nil);
         if not CheckMovesFromSquare then
            Msg(TEXT_INTERNAL_ERROR+': OptimizeGame.Search.GlobalOptimizationSearch.OPENAddBestPathPermutations',TEXT_APPLICATION_TITLE);
      end; // OptimizeGame.Search.GlobalOptimizationSearch.OPENAddBestPathPermutations

    begin // OptimizeGame.Search.GlobalOptimizationSearch
      Result:=False; Optimizer.IterationResult:=False;
      if not SearchHasTerminated then with Positions do begin
         Optimizer.PruningNode:=BestPosition;
         Result:=EnumerateTargetPositions(BestPosition,1) or Result;
         SetPosition(nil);
         if not CheckMovesFromSquare then Msg(TEXT_INTERNAL_ERROR+': OptimizeGame.Search.GlobalOptimizationSearch',TEXT_APPLICATION_TITLE);
         SetPosition(BestPosition);
         Optimizer.PruningNode:=BestPosition;
         if BestPosition<>nil then BestPosition^.Successor:=nil;

         OPENClear;
         OPENAddBestPathPermutations;

         Position:=BestPosition; // put the game path on the open-queue
         while Position<>nil do with Position^ do begin
           Move.Direction:=TDirection(Cardinal(Ord(Move.Direction)) or POSITION_TARGET_PATH_TAG);
           Score:=0; OPENAdd(Position,True); Position:=Parent;
           end;

         // repeat expanding nodes (mostly in breadth-first order) until the search terminates, e.g., when the user terminates the search manually
         Result:=AStarSearch or Result;

         if CalculateMetricsForPositionsOnBestPath(NewBestResult) and NewBestResult then begin
            Optimizer.Result:=prOK; // 'prOK': the optimizer improved the caller's solution/snapshot
            Optimizer.IterationResult:=True;
            ShowStatus;
            end;

         SetPosition(nil);
         CheckMovesFromSquare;
         end;
    end; // OptimizeGame.Search.GlobalOptimizationSearch

    function  VicinitySearch(var FullGameSearch__:Boolean):Boolean;
    const
      GAME_STATE_MULTIPLICATION_FACTOR_FOR_BOXLINES_SEARCH=1+AXIS_COUNT;        // optimizing boxlines requires that the 'Visited' data structure keeps track of the last push direction for all visited game-states
      MAX_BOX_CONFIGURATION_COUNT=10*ONE_MILLION;                               // the vicinity search is a simple breadth-first search so it's best to limit the number of nodes to a reasonable small number
      MEMORY_ALIGNMENT_BYTES=8;                                                 // must be a 2^n number where 'n' is an integer > 0 so '2^n-1' can be used as a bit mask ('n>0', not 'n>=0' because the minimum alignment is 2 bytes here)
      NONE=-1;                                                                  // note that even though 'NONE' is defined as a symbolic constant, its value cannot change; the value must be '-1'
      RED_BLACK_TREE_ITEM_COLOR_RED=1;                                          // the 'red' flag is stored in the 'left' link pointer for binary search tree item, i.e., 'TBinaryTreeItem.Left'
    type
      PByte=^Byte;
      TByteVector=array[0..MaxInt-1] of Byte;
      PByteVector=^TByteVector;
      TBloomFilter=record                                                       // note that a lookup in a Bloom filter can return false positives but never false negatives (currently, the Bloom filter is not in production)
        ByteSize:Integer;
        Memory:PByteVector;
      end;
      TBoxConfiguration=array[0..(MAX_BOARD_SIZE+BITS_PER_BYTE-1) div BITS_PER_BYTE] of Byte; // bit-set representation of the boxes on the board; must be a 0-based vector
      PBoxConfiguration=^TBoxConfiguration;
      TBoxConfigurations=record
        Count:Integer;                                                          // number of box configurations in the collection
        First:PBoxConfiguration;                                                // pointer to the first box configuration in the collection
      end;
      PBinaryTreeItem=^TBinaryTreeItem;
      TBinaryTreeItem=record
        BoxConfiguration:PBoxConfiguration;                                     // note that it's a pointer to a box configuration, not the box configuration itself
        Key:Integer;
        case Boolean of
          False : (Left :PBinaryTreeItem;                                       // left/right order cannot change; see the overlapping 'Links' declaration
                   Right:PBinaryTreeItem;
                   );
          True  : (Links:array[Boolean] of PBinaryTreeItem);                    // 'left' = 'False'; 'right' = 'True'; this must hold, e.g., for the red-black tree updating
      end;
      BinaryTreeItemPointerVector=array[0..(MaxInt div SizeOf(PBinaryTreeItem))-1] of PBinaryTreeItem; // array of pointers to binary tree items; must be a 0-based vector
      PBinaryTreeItemPointerVector=^BinaryTreeItemPointerVector;                // pointer to an array of pointers to binary tree items
      TBinaryTree=record
        Count:Integer;                                                          // number of items in the tree
        Root:PBinaryTreeItem;
      end;
      TDataStructureType=(dstVicinitySquares,dstBinaryTree,dstPointerVector,dstBoxConfigurationVector,dstVisitedBitSet,dstBloomFilter,dstPositionVector);
      TDataStructureTypeSet=set of TDataStructureType;
      TGameState=UInt32;                                                        // a game-state is a [box-configuration, player-square] tuple; the concrete representation is "BoxConfigurationIndex*PlayerSquareCount+PlayerSquare"
      PMemoryBlock=^TMemoryBlock;
      TMemoryBlock=record
        ByteSize:Cardinal;
        Memory:Pointer;
        Next:PMemoryBlock;                                                      // memory-blocks are linked together as a circular list, using the fields 'Next' and 'Previous'
        Previous:PMemoryBlock;
      end;
      TMemoryPool=record
        FreeBlock:TMemoryBlock;                                                 // next free address and number of remaining free bytes
        MemoryBlock:TMemoryBlock;                                               // total allocated memory
      end;
      PTernarySearchTreeItem=^TTernarySearchTreeItem;                           // pointer to a ternary search tree item
      TTernarySearchTreeItem=record                                             // ternary search tree item (not in production)
        Left:PTernarySearchTreeItem;
        Mid:PTernarySearchTreeItem;
        Right:PTernarySearchTreeItem;
        SplitChar:Integer;
        Value:Integer;
      end;
      TTernarySearchTree=record                                                 // ternary search tree (not in production)
        Count:Integer;
        MaxDepth:Integer;
        Root:PTernarySearchTreeItem;
      end;
      TVicinitySquaresVector=array[0..MAX_BOARD_SIZE*MAX_BOARD_SIZE] of UInt16; // vicinity squares for all the box-squares organized as a flat vector
      PVicinitySquaresVector=^TVicinitySquaresVector;                           // only the necessary vector size is allocated on the heap, not the full data-structure
      TVicinitySquares=record
        DirectionVisitOrder:TDirectionMap;                                      // direction visit order
        FirstIndex:TBoardOfIntegers;                                            // for each box-square, the index of the first element in the span containing its vicinity-squares
        Squares:PVicinitySquaresVector;                                         // a flat vector with the vicinity-squares for all box-squares; only the necessary vector size is allocated on the heap, not the full data-structure
        end;

    var
//    BloomFilter:TBloomFilter;                                                 // using a Bloom filter only speeds up box configuration lookups by approx. 5%; this doesn't seem to be worth the memory footprint, hence, the filter is not in use
      BoxConfigurationByteSize:Integer;                                         // number of bytes required to hold a bit-set representation of a box configuration
      BoxConfigurations:TBoxConfigurations;                                     // the box configurations considered by the vicinity search
//    BoxConfigurationsTernarySearchTree:TTernarySearchTree;                    // the box configurations considered by the vicinity search, stored as a ternary search tree
      BoxExternalToInternalSquare:TBoardOfIntegers;                             // maps external game square numbers to internal box  square numbers
      BoxInternalToExternalSquare:TBoardOfIntegers;                             // maps internal box  square numbers to external game square numbers
      BoxSquareCount:Cardinal;                                                  // number of box squares, reachable squares only
      BoxSquareNeighbor:array[0..MAX_BOARD_SIZE,TDirection] of Integer;         // square neighbors for each direction, using internal box square numbers; 'NONE' indicates an unreachable square, e.g., a wall square
      BoxSquareToPlayerSquare:TBoardOfIntegers;                                 // maps internal box square numbers to internal player square numbers
      Deadlocks:TBoxConfigurations;                                             // bit-set representations of the player-independent members of the pre-calculated deadlocks (not in production)
      DeadlockSetInternalToExternalNo:array[0..MAX_DEADLOCK_SETS] of Integer;   // maps bit-set deadlock numbers to external numbers (not in production)
      MaxBoxConfigurationCount:Integer;                                         // maximum number of box configurations that may be generated for the currently analyzed slice of the game
      MaxSearchDepth:Integer;                                                   // maximum search depth for the currently analyzed slice of the game
      MemoryPool:TMemoryPool;                                                   // the memory available for the vicinity-search
      NewPathPositions:POptimizerPositionVector;                                // memory area allocated for a new best path found by the vicinity search
      PreallocatedTreeItemsMemoryBlock:TMemoryBlock;                            // preallocated tree items for the binary search tree(s), i.e., a free-list of items
      PlayerExternalToInternalSquare:TBoardOfIntegers;                          // maps external game   square numbers to internal player square numbers
      PlayerInternalToExternalSquare:TBoardOfIntegers;                          // maps internal player square numbers to external game   square numbers
      PlayerSquareCount:Cardinal;                                               // number of player squares, reachable squares only
      PlayerSquareNeighbor:array[0..MAX_BOARD_SIZE,TDirection] of Integer;      // square neighbors for each direction, using internal player square numbers; 'NONE' indicates an unreachable square, e.g., a wall square
      PlayerSquareToBoxSquare:TBoardOfIntegers;                                 // maps internal player square numbers to internal box square numbers; 'NONE' indicates the square isn't a box square
      SliceEndPosition:POptimizerPosition;                                      // the search slices the game up in small sections if the game is too big to handle as a whole
      SliceStartPosition:POptimizerPosition;                                    // the search slices the game up in small sections if the game is too big to handle as a whole
      StartTimeMS:TTimeMS;
      VicinitySquares:TVicinitySquares;                                         // the nearest squares for each box-square
      VicinitySettingsAsText:String;
      VisitedMultiplicationFactor:Cardinal;                                     // the size of 'Visited' depends on the optimization type; optimizing boxlines requires saving the last push direction for all visited game-states

      // forward declarations, i.e., functions that are referenced before they are defined in the source code
      function  CalculateDataStructuresByteSize(Count__:Cardinal; DataStructureTypeSet__:TDataStructureTypeSet):Cardinal; forward;
      function  CalculateMaximumNumberOfVicinitySquaresPerSquare(BoxSquareCount__:Integer; const VicinitySettings__:TVicinitySettings):Integer; forward;
      function  CalculateMaximumSearchDepth(StartPosition__,EndPosition__:POptimizerPosition):Integer; forward;
      function  CompareBoxConfigurations(const BoxConfiguration1__,BoxConfiguration2__:TBoxConfiguration):Integer; forward;
      function  GetMemory(ByteSize__:Cardinal; AllocateMemoryFromTheTop__:Boolean):Pointer; forward;
      function  HashValuePJW(Key__:PByteVector; KeyByteSize__:Integer):Cardinal; forward;
      function  HashValueDEK(Key__:PByteVector; KeyByteSize__:Integer):Cardinal; forward;
      function  InitializeMemoryPool(var MemoryPool__:TMemoryPool; ProtectedUpperMemoryArea__:Pointer):Boolean; forward;
      function  InternalError(const FunctionName__:String):Boolean; forward;
      function  IsABoxSquare(SquareNo__:Cardinal; const BoxConfiguration__:TBoxConfiguration):Boolean; forward;
      procedure LoadBoxConfigurationFromGame(var BoxConfiguration__:TBoxConfiguration); forward;
      procedure MarkMemory(var MemoryMark__:TMemoryBlock); forward;
      procedure ReleaseMemory(const MemoryMark__:TMemoryBlock); forward;
      procedure RemoveBox(SquareNo__:Cardinal; var BoxConfiguration__:TBoxConfiguration); forward;
      procedure SavePlayerAndBoxConfigurationToGame(InternalPlayerSquare__:Integer; const BoxConfiguration__:TBoxConfiguration); forward;

      procedure AddBox(SquareNo__:Cardinal; var BoxConfiguration__:TBoxConfiguration);
      begin
        Inc(BoxConfiguration__[SquareNo__ div BITS_PER_BYTE],1 shl (SquareNo__ mod BITS_PER_BYTE));
      end; // AddBox

      // Bloom filter (not in production)

      function  BFAdd(const BoxConfiguration__:TBoxConfiguration; var BloomFilter__:TBloomFilter):Cardinal;
      var BitIndex:Cardinal;
      begin // adds item to Bloom filter
        with BloomFilter__ do begin
          BitIndex:=HashValueDEK(Addr(BoxConfiguration__),BoxConfigurationByteSize) mod Cardinal(ByteSize*BITS_PER_BYTE);
          Memory[BitIndex div BITS_PER_BYTE]:=Memory[BitIndex div BITS_PER_BYTE] or (1 shl (BitIndex mod BITS_PER_BYTE));
          BitIndex:=HashValuePJW(PByteVector(Addr(BoxConfiguration__)),BoxConfigurationByteSize) mod Cardinal(ByteSize*BITS_PER_BYTE);
          Memory[BitIndex div BITS_PER_BYTE]:=Memory[BitIndex div BITS_PER_BYTE] or (1 shl (BitIndex mod BITS_PER_BYTE));
          Result:=BitIndex; // return the primary hash-key value
          end;
      end; // BFAdd

      procedure BFInitialize(Memory__:PByteVector; ByteSize__:Integer; var BloomFilter__:TBloomFilter);
      begin // inititalizes Bloom filter; precondition: 'Memory__^' is a memory area of byte-size 'ByteSize__'
        with BloomFilter__ do begin
          Memory:=Memory__; ByteSize:=ByteSize__;
          FillChar(Memory^,ByteSize,0);                                         // clear the bits
          end;
      end; // BFInitialize

      function  BFLookup(const BoxConfiguration__:TBoxConfiguration; const BloomFilter__:TBloomFilter; var HashKey__:Cardinal):Boolean; // note that a Bloom filter can return false positives but never false negatives
      var BitIndex:Cardinal;
      begin // searches for an item in Bloom filter
        Result:=False;
        with BloomFilter__ do begin
          BitIndex:=HashValuePJW(PByteVector(Addr(BoxConfiguration__)),BoxConfigurationByteSize) mod Cardinal(ByteSize*BITS_PER_BYTE);
          HashKey__:=BitIndex; // return the primary hash-key value
          if (Memory[BitIndex div BITS_PER_BYTE] and (1 shl (BitIndex mod BITS_PER_BYTE)))=0 then exit; // '0': the key isn't in the set; quick-and-dirty exit
          BitIndex:=HashValueDEK(Addr(BoxConfiguration__),BoxConfigurationByteSize) mod Cardinal(ByteSize*BITS_PER_BYTE);
          if (Memory[BitIndex div BITS_PER_BYTE] and (1 shl (BitIndex mod BITS_PER_BYTE)))=0 then exit; // '0': the key isn't in the set; quick-and-dirty exit
          end;
        Result:=True; // note: a Bloom filter can return false positives but never false negatives
      end; // BFLookup

      // end of Bloom filter functions

      // Ternary Search Tree (not in production)

      function  TSTAdd(const BoxConfiguration__:TBoxConfiguration; Value__:Integer; var Tree__:TTernarySearchTree; var Item__:PTernarySearchTreeItem):Boolean;
      var Index,Depth,Char:Integer; Parent:PTernarySearchTreeItem;

        function  MakeNewItem(Char__:Integer; var Item__:PTernarySearchTreeItem):Boolean;
        begin
          Item__:=GetMemory(SizeOf(Item__^),True); // 'True' parameter: allocate the memory from the top of the free memory
          Result:=Item__<>nil;
          if Result then begin
             FillChar(Item__^,SizeOf(Item__^),0);
             Item__^.SplitChar:=Char;
             end;
        end;

      begin // TSTAdd
        Result:=False;
        Depth:=0; Char:=BoxConfiguration__[0]; Index:=1;
        Item__:=Tree__.Root; Parent:=nil;

        while Item__<>nil do with Item__^ do begin
          Parent:=Item__; Inc(Depth);
          if      Char <SplitChar then Item__:=Left
          else if Char >SplitChar then Item__:=Right
          else if Index<BoxConfigurationByteSize then begin // 'True': a matching character, and the key has more characters
                  Item__:=Mid; Char:=BoxConfiguration__[Index]; Inc(Index);
                  end
               else begin // the item already exists in the tree
                  Result:=True; Item__:=nil; // 'nil': this is not a general ternary search tree implementation; all keys have length 'BoxConfigurationByteSize', hence, the bottom of the tree has been reached here
                  end;
          end;

        if   not Result then begin
             Result:=MakeNewItem(Char,Item__);
             if Result then begin
                if   Parent<>nil then begin
                     if        Char<Parent^.SplitChar then Parent^.Left :=Item__
                     else if   Char>Parent^.SplitChar then Parent^.Right:=Item__
                          else Parent^.Mid:=Item__;
                     end
                else Tree__.Root:=Item__;
                Inc(Tree__.Count);
                if Depth>Tree__.MaxDepth then Tree__.MaxDepth:=Depth;

                while (Index<BoxConfigurationByteSize) and Result do begin
                  Parent:=Item__; Inc(Depth);
                  Char:=BoxConfiguration__[Index]; Inc(Index);
                  Result:=MakeNewItem(Char,Item__);
                  if Result then begin
                     Parent^.Mid:=Item__;
                     Inc(Tree__.Count);
                     if Depth>Tree__.MaxDepth then Tree__.MaxDepth:=Depth;
                     end;
                  end;

                Result:=Index=BoxConfigurationByteSize; // 'True': the all characters in the key have been added to the tree
                if Result then Item__^.Value:=Value__;
                end;
             end
        else Item__:=Parent; // the item already exists in the tree; return the existing item
      end;

      procedure TSTInitialize(var Tree__:TTernarySearchTree);
      begin
        FillChar(Tree__,SizeOf(Tree__),0);
      end; // TSTInitialize

      function  TSTLookup(const BoxConfiguration__:TBoxConfiguration; const Tree__:TTernarySearchTree; var Item__:PTernarySearchTreeItem):Boolean;
      var Char,Index:Integer;
      begin // searches item in ternary search tree
        Result:=False; Item__:=Tree__.Root; Index:=1; Char:=BoxConfiguration__[0];
        while (Item__<>nil) {and (not Result)} do with Item__^ do               // 'not Result': this is commented out because it's unnecessary with the "quick-and-dirty" exit a few lines further down
          if      Char <SplitChar then Item__:=Left
          else if Char >SplitChar then Item__:=Right
          else if Index<BoxConfigurationByteSize then begin                     // 'True': a matching character, and the key has more characters
                  Item__:=Mid; Char:=BoxConfiguration__[Index]; Inc(Index);
                  end
               else begin
                  Result:=True; exit;                                           // 'exit': quick-and-dirty exit when a matching box configuration has been found
                  end;
      end; // TSTLookup

      procedure TSTShow(const Tree__:TTernarySearchTree);
      begin
        Writeln('Ternary search tree: ',Tree__.Count,' items = ',Tree__.Count*SizeOf(Tree__.Root),' bytes  Maximum depth: ',Tree__.MaxDepth);
        //Readln;
      end; // TSTShow;

      // end of ternary search tree functions

      function  ByteAlignment(ByteAlignment__:Integer; var Memory__:Pointer):Integer;
      begin // aligns 'Memory__' to the memory alignment boundary; returns the number of bytes added for proper alignment;
           // preconditions: 1) 'ByteAlignment__' is a '2^n' integer where 'n' >=0; 2) Cardinal('Memory__') + 'MemoryAlignment' - 1 is a valid memory address
        Result:=Cardinal(Memory__) and (ByteAlignment__-1);
        if Result<>0 then begin
           Result:=ByteAlignment__-Result;
           Cardinal(Memory__):=Cardinal(Memory__)+Cardinal(Result);
           end;
      end; // ByteAlignment

      function  CalculateDataStructuresByteSize(Count__:Cardinal; DataStructureTypeSet__:TDataStructureTypeSet):Cardinal;

        function  Add(A,B:Cardinal):Cardinal;
        begin // add with saturation and byte alignment
          if   High(Result)-A>=B then begin
               Result:=A+B;
               if   Result<High(Result)-MEMORY_ALIGNMENT_BYTES then
                    ByteAlignment(MEMORY_ALIGNMENT_BYTES,Pointer(Result))
               else Result:=High(Result);
               end
          else Result:=High(Result);
        end;

        function  Divide(A,B:Cardinal):Cardinal;
        begin // divide with saturation
          if   (A<>High(Result)) then Result:=A div B
          else Result:=High(Result);
        end;

        function  Multiply(A,B:Cardinal):Cardinal;
        var LongResult:Int64;
        begin // multiply with saturation
          LongResult:=Int64(A)*Int64(B);
          if   LongResult<High(Result) then Result:=LongResult
          else Result:=High(Result);
        end;

      begin // CalculateDataStructuresByteSize
        Result:=0;
        if dstVicinitySquares in DataStructureTypeSet__ then begin              // vicinity squares; they are organized as a flat vector, with 'VicinitySquaresFirstIndex[]' containing the index of the first neighbor for each of the box-squares
           Result:=Add(Result,BoxSquareCount*
                              Cardinal(CalculateMaximumNumberOfVicinitySquaresPerSquare(
                                         BoxSquareCount,Optimizer.VicinitySettings))*
                              Cardinal(SizeOf(VicinitySquares.Squares^[Low(VicinitySquares.Squares^)])));
           end;
        if dstBinaryTree in DataStructureTypeSet__ then begin
           Result:=Add(Result,Count__*Cardinal(SizeOf(TBinaryTreeItem)));       // binary tree items
           Result:=Add(Result,Count__*Cardinal(BoxConfigurationByteSize));      // the box configurations belonging to the binary tree items
           end;
        if dstPointerVector in DataStructureTypeSet__ then begin
           Result:=Add(Result,Count__*Cardinal(SizeOf(PBinaryTreeItem)));
           end;
        if dstBoxConfigurationVector in DataStructureTypeSet__ then begin
           Result:=Add(Result,Count__*Cardinal(BoxConfigurationByteSize));
           end;
        if dstVisitedBitSet in DataStructureTypeSet__ then begin
           Result:=Add(Result,
                       Add(1,
                           Divide(Multiply(Count__,
                                           Cardinal(PlayerSquareCount)*VisitedMultiplicationFactor),
                                  BITS_PER_BYTE)));
           end;
        if dstBloomFilter in DataStructureTypeSet__ then begin
           Result:=Add(Result,((Count__+(BITS_PER_BYTE div 2)) div BITS_PER_BYTE)*8); // reserve 8 bits per item; this implementation sets 2 bits per item, so by reserving 8 bits the 'false positives' rate is expected to be rather small
           end;
        if dstPositionVector in DataStructureTypeSet__ then begin               // positions (nodes) on a new best path
           Result:=Add(Result,Cardinal(Succ(CalculateMaximumSearchDepth(            // 'Succ': element 0 is not used by the path reconstruction after the search
                                              POptimizerPosition(YASS.Positions.StartPosition), // note that the calculation here conservatively reserves memory for a fully new path; the search may later split the game in smaller pieces
                                              POptimizerPosition(YASS.Positions.BestPosition ))
                                           )*SizeOf(TOptimizerPosition)));
           end;
      end; // CalculateDataStructuresByteSize

      function  CalculateMaximumNumberOfVicinitySquaresPerSquare(BoxSquareCount__:Integer; const VicinitySettings__:TVicinitySettings):Integer;
      var Index:Integer;
      begin // calculates the upper bound on the number of neighbor-squares-per-square used in this search
        Result:=-1;
        for Index:=Low(VicinitySettings__) to High(VicinitySettings__) do
            if VicinitySettings__[Index]<>0 then Result:=Max(Result,VicinitySettings__[Index]);
        Result:=Succ(Min(Result,BoxSquareCount__));                             // 'Succ': +1 because for each square, the square itself is a member of its neighbor-square list
      end; // CalculateMaximumNumberOfVicinitySquaresPerSquare

      function  CalculateMaximumSearchDepth(StartPosition__,EndPosition__:POptimizerPosition):Integer;
      begin // calculates the maximum search depth which depends on the type of optimization
        if   (StartPosition__<>nil) and (EndPosition__<>nil) then
             if Optimizer.Optimization=opMovesPushes then
                Result:=EndPosition__^.         MoveCount-StartPosition__^.         MoveCount
             else begin
                Result:=EndPosition__^.Position.PushCount-StartPosition__^.Position.PushCount;
                if Optimizer.Optimization>=opBoxLinesMoves then
                   Result:=Min(High(StartPosition__^.Position.PushCount),2*Result); // double the number of pushes for boxlines optimization;
                end
        else Result:=0;
      end; // CalculateMaximumSearchDepth

      function  CompareBoxConfigurations(const BoxConfiguration1__,BoxConfiguration2__:TBoxConfiguration):Integer;
      var Index:Integer;
      begin // returns <0, =0, >0 as the result of 'subtracting' the second argument from the first one
        Result:=0;
        for Index:=0 to Pred(BoxConfigurationByteSize) do
            if   Result=0 then
                 Result:=Integer(BoxConfiguration1__[Index]) - Integer(BoxConfiguration2__[Index])
            else exit; // quick-and-dirty exit of the function as soon as the outcome of the comparison has been determined
      end; // CompareBoxConfigurations

      function  GenerateBoxConfigurations(SliceStartPosition__   :POptimizerPosition;
                                          var SliceEndPosition__ :POptimizerPosition;
                                          var BoxConfigurations__:TBoxConfigurations
                                          //var BoxConfigurationsTernarySearchTree__:TTernarySearchTree
                                         ):Boolean;
      var BoxConfiguration:TBoxConfiguration; Position:POptimizerPosition;
          ChangedBoxSquares:TBoxSquares; Tree:TBinaryTree;

        // forward declarations, i.e., functions that are referenced before they are defined in the source code
        function  BTMakeNewItem(const BoxConfiguration__:TBoxConfiguration; const Tree__:TBinaryTree):PBinaryTreeItem; forward;
        procedure BTRebalance(var Tree__:TBinaryTree); forward;
        procedure BTShowTree(const Tree__:TBinaryTree); forward;

        // Binary Search Tree

        function  BTRedBlackTreeCheck(const Tree__:TBinaryTree):Boolean; forward;

        function  BTAdd(const BoxConfiguration__:TBoxConfiguration; ExistingItem__:PBinaryTreeItem; var Tree__:TBinaryTree; var Item__:PBinaryTreeItem):Boolean;
        var i,Depth:Integer; IsRightBranch:Boolean;
            GrandParent,Node,Parent,Uncle:PBinaryTreeItem;
            Parents:array[0..8*BITS_PER_UNSIGNED_INTEGER] of PBinaryTreeItem; // a red-black tree has maximum height 2*log2(n+1) where 'n' is the number of nodes in the tree; '*8': for safety

          function  BTRotate(var Tree__:TBinaryTree; Item__,Parent__:PBinaryTreeItem; RotateRight__:Boolean):PBinaryTreeItem;
          begin // rotates the tree item 'Item__'  left or right, depending on the parameter 'RotateRight__'
                // returns the item which has been rotated upwards; the rotated items are updated with appropriate red/black colors
                // preconditions: the rotated items are present, i.e., non-nil, and 'Parent__' is the parent of 'Item__'
            Result                           := PBinaryTreeItem(Cardinal(Item__^.Links[not RotateRight__]) and (not RED_BLACK_TREE_ITEM_COLOR_RED));
            Item__^.Links[not RotateRight__] := PBinaryTreeItem(Cardinal(Result^.Links[    RotateRight__]) and (not RED_BLACK_TREE_ITEM_COLOR_RED));
            Result^.Links[    RotateRight__] := Item__;

            if   Item__<>Tree__.Root then begin
                 if   Item__=Parent__^.Right then
                      Parent__^.Right:=Result
                 else Parent__^.Left:=PBinaryTreeItem(Cardinal(Result) or (Cardinal(Parent__^.Left) and RED_BLACK_TREE_ITEM_COLOR_RED));
                 end
            else Tree__.Root:=Result; // keep the tree root item updated

            Item__^.Left:=PBinaryTreeItem(Cardinal(Item__^.Left) or       RED_BLACK_TREE_ITEM_COLOR_RED);  // the item which has been rotated downwards is colored red
            Result^.Left:=PBinaryTreeItem(Cardinal(Result^.Left) and (not RED_BLACK_TREE_ITEM_COLOR_RED)); // the item which has been rotated upwards   is colored black
          end; // BTRotate

        begin // 'BTAdd'; returns 'True' if the box configuration is added to the tree; the new item, or the already existing item, is returned in 'Item__'
          Item__:=Tree__.Root; Depth:=0; Parents[0]:=nil; i:=-1;
          while (Item__<>nil) and (i<>0) and (Depth<High(Parents)) do begin     // 'i<>0': the item hasn't been found in the tree
            Inc(Depth); Parents[Depth]:=Item__;                                 // remember what will be the parent item after descending one step further down the tree
            //if (Cardinal(Item__) and RED_BLACK_TREE_ITEM_COLOR_RED)<>0 then
            //   InternalError('BTAdd');
            i:=CompareBoxConfigurations(BoxConfiguration__,Item__^.BoxConfiguration^);
            if        i<0 then Item__:=PBinaryTreeItem(Cardinal(Item__^.Left) and (not RED_BLACK_TREE_ITEM_COLOR_RED))
            else if   i>0 then Item__:=Item__^.Right;
            end;
          Result:=Item__=nil;
          if Result then begin                                                  // 'True': the box configuration was not found in the tree
             if ExistingItem__=nil then
                Item__:=BTMakeNewItem(BoxConfiguration__,Tree__)                // allocate memory for a new item
             else with ExistingItem__^ do begin                                 // re-use the existing node, e.g., when 'BTAdd' is called from 'BTMerge'; precondition: the existing item contains the box configuration 'BoxConfiguration__'
                Left:=nil; Right:=nil;                                          // the item is now a new leaf node, hence, clear any old pointers
                Item__:=ExistingItem__;
                end;
             if Item__<>nil then begin
                Inc(Tree__.Count);                                              // count the number of items in the binary tree
                Item__^.Key:=Tree__.Count;
                Parent:=Parents[Depth];
                if   Parent<>nil then
                     if   i<0 then
                          Parent^.Left :=PBinaryTreeItem(Cardinal(Parent^.Left)+Cardinal(Item__)) // '<0': the new item is less than the parent item; ('Cardinal(...)' keep the red-black tree item color, if any)
                     else Parent^.Right:=Item__                                 // '>0': the new item is bigger than the parent item
                else Tree__.Root:=Item__;                                       // this it the first item added to the tree
//(*
                // red-black tree updating, i.e., set item colors and rotate items to maintain the red-black tree properties
                Item__^     .Left:=PBinaryTreeItem(Cardinal(Item__^     .Left) or       RED_BLACK_TREE_ITEM_COLOR_RED ); // color the new item red
                Node:=Item__;
                while (Node<>Tree__.Root) and
                      ((Cardinal(Parents[Depth]^.Left) and RED_BLACK_TREE_ITEM_COLOR_RED)<>0) do begin // if the parent node is red, then it's necessary to check if any immediate successor nodes also are red
                  Parent     :=Parents[Depth];
                  GrandParent:=Parents[Pred(Depth)]; // the grand parent node is guaranteed to exist because the root node always is black

                  IsRightBranch:=Parent=GrandParent^.Right;
                  Uncle:=PBinaryTreeItem(Cardinal(GrandParent^.Links[not IsRightBranch]) and (not RED_BLACK_TREE_ITEM_COLOR_RED));

                  if (Uncle<>nil) and
                     ((Cardinal(Uncle^.Left) and RED_BLACK_TREE_ITEM_COLOR_RED)<>0) then begin // the parent and its sibling are both red; swap their colors with the grandparent
                     Parent     ^.Left:=PBinaryTreeItem(Cardinal(Parent     ^.Left) and (not RED_BLACK_TREE_ITEM_COLOR_RED)); // color the parent black
                     Uncle      ^.Left:=PBinaryTreeItem(Cardinal(Uncle      ^.Left) and (not RED_BLACK_TREE_ITEM_COLOR_RED)); // color the uncle  black
                     GrandParent^.Left:=PBinaryTreeItem(Cardinal(GrandParent^.Left) or       RED_BLACK_TREE_ITEM_COLOR_RED ); // color the grandparent red
                     Node             :=GrandParent; Dec(Depth,2); // backtrack to the grandparent item on the path down to the new item
                     end
                  else begin
                     if Cardinal(Node)=Cardinal(Parent^.Links[not IsRightBranch]) and (not RED_BLACK_TREE_ITEM_COLOR_RED) then
                        BTRotate(Tree__,Parent,GrandParent,IsRightBranch);
                     BTRotate(Tree__,GrandParent,Parents[Depth-2],not IsRightBranch);
                     Node:=Tree__.Root; // update complete; terminate the 'while' loop
                     end;
                  end;

                Tree__.Root^.Left:=PBinaryTreeItem(Cardinal(Tree__.Root^.Left) and (not RED_BLACK_TREE_ITEM_COLOR_RED)); // color the root item black, thereby ensuring that the 'GrandParent' item exists in the preceding 'while' loop

                //BTShowTree(Tree__);
                //BTRedBlackTreeCheck(Tree__);
//*)
                end
             else Result:=False;                                                // allocation of the new item failed, e.g., the memory is full
             end;
        end; // BTAdd

        function  BTAverageNodeDepth(const Tree__:TBinaryTree):Double;

          function  TreeWalk(TreeNode__:PBinaryTreeItem; Depth__:Cardinal):Cardinal;
          begin
            if   TreeNode__<>nil then with TreeNode__^ do
                 Result:=Depth__+TreeWalk(Left,Succ(Depth__))+TreeWalk(Right,Succ(Depth__))
            else Result:=0;
          end;

        begin // BTAverageNodeDepth
          if   Tree__.Count<>0 then
               Result:=TreeWalk(Tree__.Root,1) / Tree__.Count
          else Result:=0;
        end; // BTAverageNodeDepth

        procedure BTInitialize(var Tree__:TBinaryTree);
        begin // initialize binary tree
          FillChar(Tree__,SizeOf(Tree__),0);
        end; // BTInitialize

        function  BTLookup(const BoxConfiguration__:TBoxConfiguration; const Tree__:TBinaryTree; var Item__:PBinaryTreeItem):Boolean;
        var i:Integer;
        begin // searches item in binary tree
          Result:=False; Item__:=Tree__.Root;
          while (Item__<>nil) {and (not Result)} do begin                       // 'not Result': this is commented out because it's unnecessary with the "quick-and-dirty" exit a few lines further down
            i:=CompareBoxConfigurations(BoxConfiguration__,Item__^.BoxConfiguration^);
            if        i<0 then Item__:=PBinaryTreeItem(Cardinal(Item__^.Left) and (not RED_BLACK_TREE_ITEM_COLOR_RED))
            else if   i>0 then Item__:=Item__^.Right
                 else begin Result:=True; exit;                                 // 'exit': quick-and-dirty exit when a matching box configuration has been found
                      end;
            end;
        end; // BTLookup

        function  BTMakeNewItem(const BoxConfiguration__:TBoxConfiguration; const Tree__:TBinaryTree):PBinaryTreeItem;
        var NewCount,PreallocatedItemsCount,NewDataStructuresByteSize,NewVisitedByteSize:Cardinal;
        begin // makes a new binary tree item, possibly preallocating a new memory block
          with PreallocatedTreeItemsMemoryBlock do begin
            if ByteSize<SizeOf(TBinaryTreeItem)+SizeOf(TBoxConfiguration) then begin // 'SizeOf(TBoxConfiguration)': a static calculation with slightly more efficient machine code than a precise dynamic calculation using 'BoxConfigurationByteSize'
               Memory                           :=nil;
               PreallocatedItemsCount           :=Max(2*ONE_KIBI,Tree__.Count);
               repeat PreallocatedItemsCount    :=PreallocatedItemsCount div 2;     // first try to get 50%, then 25% more items, etc.
                      ByteSize                  :=Max(SizeOf(TBinaryTreeItem)+SizeOf(TBoxConfiguration),
                                                      CalculateDataStructuresByteSize(PreallocatedItemsCount,[dstBinaryTree]));
                      NewCount                  :=Cardinal(Tree__.Count)+PreallocatedItemsCount;
                      NewDataStructuresByteSize :=CalculateDataStructuresByteSize(NewCount,[dstPointerVector,dstBoxConfigurationVector,dstBloomFilter,dstPositionVector]);
                      NewVisitedByteSize        :=CalculateDataStructuresByteSize(NewCount,[dstVisitedBitSet]);


                      if   (NewCount<=Cardinal(MaxBoxConfigurationCount))
                           and
                           (MemoryPool.FreeBlock.ByteSize>=ByteSize)            // '>=': there is room for 'TreeItemPoolFreeCount' new items
                           and
                           (MemoryPool.FreeBlock.ByteSize- ByteSize             // '... - ByteSize': the remaining memory after allocating 'PreallocatedItemsCount' new items
                            >=                                                  // '>=': after allocating the new nodes, there is still room for final datastructures and work areas which will be allocated later
                            NewDataStructuresByteSize
                           )
                           and
                           (High(Cardinal)-NewVisitedByteSize>=NewDataStructuresByteSize)
                           and
                           (MemoryPool.MemoryBlock.ByteSize
                            >=                                                  // '>=': after allocating the new nodes, the total amount of memory is large enough to hold the final datastructures and work areas which will be allocated later
                            NewDataStructuresByteSize+NewVisitedByteSize
                           ) then begin
                           Memory:=GetMemory(ByteSize,False);
                           if ((Cardinal(Memory) and RED_BLACK_TREE_ITEM_COLOR_RED)<>0)
                              or
                              {$WARNINGS OFF}
                                {warning: Comparison always evaluates to True}
                                ((SizeOf(TBinaryTreeItem) and RED_BLACK_TREE_ITEM_COLOR_RED)<>0) // ensure that binary search tree item links can carry the red-black tree item color bit without destroying the actual pointers
                              {$WARNINGS ON}
                              then begin
                              Memory:=nil;
                              PreallocatedItemsCount:=0;
                              InternalError('BTMakeNewItem');
                              end;
                           end
                      else Memory:=nil;

               until  (Memory<>nil) or (PreallocatedItemsCount=0);              // until memory allocation of 'PreallocatedItemsCount' items succeeds, or until memory allocation fails completely
               end;

            Result:=Memory;
            if Result<>nil then with Result^ do begin                           // 'True': there is enough memory for the new item
               Cardinal(Memory):=Cardinal(Memory)+SizeOf(TBinaryTreeItem);      // allocate the new tree item from the bottom of the memory block
               ByteSize:=ByteSize-Cardinal(SizeOf(TBinaryTreeItem))-Cardinal(BoxConfigurationByteSize); // reserve bytes for the tree item as well as the box configuration
               BoxConfiguration:=PBoxConfiguration(Cardinal(Memory)+ByteSize);  // allocate memory for the box configuration from the top of the memory block; that way, proper aligment of tree items nodes aren't destroyed by the box configurations
               Move(BoxConfiguration__,BoxConfiguration^,BoxConfigurationByteSize); // store the box configuration belonging to this tree item
               Left :=nil;                                                      // 'nil': the new item is a leaf node
               Right:=nil;                                                      // 'nil': the new item is a leaf node
               end;
            end;
        end; // BTMakeNewItem

        procedure BTRebalance(var Tree__:TBinaryTree);                          // about the algorithm, see the article "Tree Rebalancing in Optimal Space and Time" by Quentin F. Stout and Bette L. Warren, 1986
        var ListHead:TBinaryTreeItem; // StartTimeMS:TTimeMS;

          procedure TreeToList(ListHead__:PBinaryTreeItem);
          var L,ListTail,Rest:PBinaryTreeItem;
          begin
            ListTail:=ListHead__;           // 'ListTail' points to the last node of the 'flattened' part of the tree, i.e., the part with no left branches
            Rest:=ListTail^.Right;          // 'Rest' always points to 'ListTail^.Right'
            while Rest<>nil do begin        // 'True': there are more nodes which haven't been 'flattened' yet, i.e., there may be more nodes having a left branch
              L:=PBinaryTreeItem(Cardinal(Rest^.Left) and (not RED_BLACK_TREE_ITEM_COLOR_RED)); // get the left branch without its red-black tree item color flag
              Rest^.Left:=L;                // remove any red-black tree item colors from the node
              if L<>nil then begin          // 'True': the node has a left branch, 'flatten' it by rotating the left branch up into to list
//               L:=Rest^.Left;             //  ListTail          ListTail
                 Rest^.Left:=L^.Right;      //      \  rotate right   \
                 L^.Right:=Rest;            //      Rest    =>         L <--- new 'Rest'
                 Rest:=L;                   //      / \               / \
                 ListTail^.Right:=L;        //     L                    Rest
                 end                        //    / \                   / \
              else begin                    //       R                 R
                 // no left branch, hence, proceed to the next node to the right
                 ListTail:=Rest; Rest:=Rest^.Right;
                 end;
              end;
          end; // TreeToList

          procedure ListToBalancedTree(ListHead__:PBinaryTreeItem; Count__:Integer);
          var CompleteTreeCount:Integer;

            procedure Compression(ListHead__:PBinaryTreeItem; Count__:Integer);
            var i:Integer; N,This:PBinaryTreeItem;
            begin // change 'Count__' list-nodes to tree-nodes having both a left subtree and a right subtree
              This:=ListHead__;
              for i:=0 to Pred(Count__) do begin
                  N:=This^.Right;           //  This              This
                  This^.Right:=N^.Right;    //  / \               / \
                  This:=This^.Right;        //     N                 R <--- new 'This'
                  N^.Right:=This^.Left;     //    / \  rotate left  / \
                  This^.Left:=N;            //       R     =>      N
                  end;                      //      / \           / \
            end; // Compression             //     L                 L

          begin // ListToBalancedTree; creates a balanced tree filled from the left, i.e., all the deepest leaves are as far left as possible
            // Log2(k) calls to 'Compression' can fill a complete binary tree
            // with Count=2^k-1 nodes for some integer k>=0;
            // if 'Count+1' isn't a power of 2, then perform an initial pass
            // so the remaining right-linked list length is a 2^k-1 number;
            // the initial pass ensures that the tree is filled from the left
            //LeafCount:=Succ(Count__)-PowerOf2(Log2(Succ(Count__)));           // this is the calculation used in the article; the algoritm is easier to understand with the following alternative calculation
            CompleteTreeCount:=Pred(PowerOf2(Log2(Succ(Count__))));             // the highest 2^k-1 number <= the number of nodes for some integer k>=0
            Compression(ListHead__,Count__-CompleteTreeCount);                  // first pass; it ensures that the tree is filled from the left

            while CompleteTreeCount>1 do begin
              Compression(ListHead__,CompleteTreeCount div 2);
              CompleteTreeCount:=CompleteTreeCount div 2;
              end;
          end; // ListToBalancedTree

        begin // BTRebalance; rebalances the tree to a left-filled balanced tree
          //Write('Rebalance binary tree:  Nodes: ',Tree__.Count);
          //StartTimeMS:=GetTimeMS;
          with Tree__ do
            if Count>1 then begin
               ListHead.Right:=Root;
               TreeToList        (PBinaryTreeItem(Addr(ListHead)));
               ListToBalancedTree(PBinaryTreeItem(Addr(ListHead)),Count);
               Root:=ListHead.Right;
               end;
          //Writeln('  Time: ',CalculateElapsedTimeMS(StartTimeMS,GetTimeMS),' milli seconds');
        end; // BTRebalance

        function  BTRedBlackTreeCheck(const Tree__:TBinaryTree):Boolean;
        var ItemCount,BlackHeight:Integer;

          function  TreeWalk(Item__:PBinaryTreeItem; var ItemCount__,BlackHeight__:Integer):Boolean;
          var i,LeftCount,RightCount,LeftHeight,RightHeight:Integer; L:PBinaryTreeItem;
          begin
            Result:=True; ItemCount__:=0; BlackHeight__:=0;
            if Item__<>nil then with Item__^ do begin
               L:=PBinaryTreeItem(Cardinal(Left) and (not RED_BLACK_TREE_ITEM_COLOR_RED));
               if L<>nil then begin
                  i:=CompareBoxConfigurations(BoxConfiguration^,L^.BoxConfiguration^);
                  if i<=0 then Result:=False;
                  end;
               if Right<>nil then begin
                  i:=CompareBoxConfigurations(BoxConfiguration^,Right^.BoxConfiguration^);
                  if i>=0 then Result:=False;
                  end;

               LeftCount:=0; RightCount:=0; LeftHeight:=0; RightHeight:=0;
               if not TreeWalk(L    ,LeftCount ,LeftHeight ) then Result:=False;
               if not TreeWalk(Right,RightCount,RightHeight) then Result:=False;
               if (LeftHeight<>RightHeight) and (LeftHeight<>0) and (RightHeight<>0) then
                  Result:=False;

               ItemCount__  :=Succ(LeftCount+RightCount);
               BlackHeight__:=Max(LeftHeight,RightHeight);
               if (Cardinal(Left) and RED_BLACK_TREE_ITEM_COLOR_RED)=0 then
                  Inc(BlackHeight__)
               else begin
                  if (L    <>nil) and ((Cardinal(L^    .Left) and RED_BLACK_TREE_ITEM_COLOR_RED)<>0) then
                     Result:=False;
                  if (Right<>nil) and ((Cardinal(Right^.Left) and RED_BLACK_TREE_ITEM_COLOR_RED)<>0) then
                     Result:=False;
                  end;
               end;
          end;

        begin // BTRedBlackTreeCheck
          ItemCount:=0; BlackHeight:=0;
          Result:=TreeWalk(Tree__.Root,ItemCount,BlackHeight) and (Tree__.Count=ItemCount);
          Writeln('Red-black tree:  Nodes: ',Tree__.Count,'  Black nodes height: ',BlackHeight);
          Writeln('Red-black tree properties okay: ',TEXT_NO_YES[Result]);
          //Readln;
          if not Result then InternalError('BTRedBlackTreeCheck');
        end; // BTRedBlackTreeCheck

        procedure BTShowTree(const Tree__:TBinaryTree);

          function  TreeWalk(Item__:PBinaryTreeItem; Depth__:Integer):Integer;
          var i:Integer;
          begin
            if   Item__<>nil then with Item__^ do begin
                 Result:=TreeWalk(Right,Succ(Depth__));
                 for i:=1 to Depth__ do Write(SPACE,SPACE);
                 Write(Item__^.Key);
                 if (Cardinal(Left) and RED_BLACK_TREE_ITEM_COLOR_RED)<>0 then Write('r');
                 Writeln;
                 Result:=TreeWalk(PBinaryTreeItem(Cardinal(Left) and (not RED_BLACK_TREE_ITEM_COLOR_RED)),Succ(Depth__))+Succ(Result);
                 end
            else Result:=0;
          end;

        begin // BTShowTree
          Writeln('-----');
          if   TreeWalk(Tree__.Root,0)<>Tree__.Count then
               InternalError('BTShowTree');
        end; // BTShowTree

        function  GenerateBoxConfigurationsRecursively(var BoxConfiguration__          :TBoxConfiguration;
                                                       var ChangedBoxSquares__         :TBoxSquares;
                                                       VicinitySettingsIndex__         :Integer;
                                                       PreviousDepthBoxNo__            :Integer;
                                                       PreviousDepthBoxOriginalSquare__:Integer; // internal format
                                                       IsBasePosition__                :Boolean):Boolean;
{
Some duplicate box configurations can be pruned already before they are
generated. An example with vicinity settings 10/20 and four boxes A, B, C, and
D:

01. A:10 B:20
02. A:10 C:20
03. A:10 D:20

04. B:10 A:20 only A:11-20 is necessary (see 01)
05. B:10 C:20
06. B:10 D:20

07. C:10 A:20 only A:11-20 is necessary (see 02)
08. C:10 B:20 only B:11-20 is necessary (see 05)
09. C:10 D:20

10. D:10 A:20 only A:11-20 is necessary (see 03)
11. D:10 B:20 only B:11-20 is necessary (see 06)
12. D:10 C:20 only C:11-20 is necessary (see 09)

There is one special case where this duplicate pruning cannot be applied. An
example with vicinity settings 5/5 and two boxes A and B on a 6-square board:

A---B-

01. A:5 B:5
    A moves first. Note that no box configurations are generated with A at B's
    original square because that square is occupied at the time A moves around
    on the board.

02. B:5 A:5
    B moves first. If this leg was pruned entirely, the following box
    configuration would not be generated:
    ----AB
    This type of box configuration occurs when B moves to a square which A
    cannot reach within its limit, and A moves to B's original square.
}
        var BoxNo,i,Index,FirstIndex,ExternalSquareNo,ExternalVicinitySquareNo,
            InternalSquareNo,PreviousDepthVicinitySquaresLimit,VicinitySquareNo:Integer; Item:PBinaryTreeItem;

          function  IsABitSetDeadlock(const BoxConfiguration__:TBoxConfiguration):Integer; // (not in production)
          var Index:Integer;

            function  IsASubSet(const SubSet__,BoxConfiguration__:TBoxConfiguration):Boolean;
            var Index:Integer;
            begin
              Result:=True;
              for Index:=0 to Pred(BoxConfigurationByteSize) do
                  if   Result then
                       Result:=(SubSet__[Index] and BoxConfiguration__[Index])=SubSet__[Index]
                  else exit; // quick-and-dirty exit from the function as soon as the outcome of the subset calculation has been determined
            end; // IsASubSet

          begin // IsABitSetDeadlock; (not in production) returns the external number of the (first) violated player-independent bit-set deadlock, if any, otherwise the return value is 'NONE'
            with Deadlocks do
              for Index:=0 to Pred(Count) do
                  if   IsASubSet(PBoxConfiguration(Cardinal(First)+Cardinal(Index*BoxConfigurationByteSize))^,BoxConfiguration__) then begin
                       Result:=DeadlockSetInternalToExternalNo[Index];
                       exit;                                                    // quick-and-dirty exit when the box configuration has been classified as a deadlock
                       end;
             Result:=NONE;
          end; // IsABitSetDeadlock

          function  IsACapacityCountedDeadlock:Integer;
          begin //returns the number of the (first) violated player-independent deadlock set, if any, otherwise the return value is 'NONE'
            with Game.DeadlockSets do
              for Result:=1 to Count do
                  if (Capacity[Result]<0) and
                     ([dsfPlayerIsInsideSet,dsfPlayerMustBeOutsideSet,dsfControllerSet,dsfFreezeSet]*Flags[Result]=[]) then
                     // if the deadlock depends on the player being outside the set, then the deadlock doesn't apply to the box configurations (without a player)
                     exit; // quick-and-dirty exit the function when the position is known to be a deadlock
            Result:=NONE; // 'NONE': the current box configuration doesn't violate any of the player-independent members of the precalculated deadlocks
          end; // IsACapacityCountedDeadlock

          function  IsAFreezeTestDeadlock(const ChangedBoxSquares__:TBoxSquares; VicinitySettingsIndex__:Integer):Boolean;
          var Index,BoxSquareNo:Integer;
          begin
            for Index:=VicinitySettingsIndex__ to MAX_VICINITY_BOX_COUNT do begin
                BoxSquareNo:=ChangedBoxSquares__[Index];
                if ((Game.Board[BoxSquareNo] and BOX)<>0) and
                   IsAFreezingMove(0,BoxSquareNo,False) then begin
                   Inc(Positions.SearchStatistics.FreezeTestDeadlockCount);
                   //if Positions.SearchStatistics.FreezeTestDeadlockCount mod 100000=0 then begin
                   //   Writeln(Positions.SearchStatistics.FreezeTestDeadlockCount);
                   //   ShowBoard; Readln;
                   //   end;
                   Result:=True; exit;                                          // 'exit': quick-and-dirty exit from the function when a deadlock situation has been found
                   end;
                end;
            Result:=False;
          end; // IsAFreezeTestDeadlock

        begin // GenerateBoxConfigurationsRecursively; returns 'False' if there isn't enough memory for all the box configurations that could be generated with the current vicinity constraints
          Result:=(Solver.SearchLimits.DepthLimit>=0);                          // partial inlining of 'SearchHasTerminated'; the un-optimized statement would be 'Result:=(not SearchHasTerminated);'
          if Result then begin
             PreviousDepthVicinitySquaresLimit:=Optimizer.VicinitySettings[Succ(VicinitySettingsIndex__)];
             for BoxNo:=1 to Game.BoxCount do begin
                 ExternalSquareNo:=Game.BoxPos[BoxNo];
                 InternalSquareNo:=BoxExternalToInternalSquare[ExternalSquareNo];
                 if   (InternalSquareNo<>NONE) and Result then begin

                      Dec(Game.Board[ExternalSquareNo],BOX);                    // remove the box from the board
                      RemoveBox(InternalSquareNo,BoxConfiguration__);
                      with Game.DeadlockSets do                                 // update deadlock set capacities
                        for i:=1 to SquareSetCount[ExternalSquareNo] do Inc(Capacity[SquareSetNumbers[ExternalSquareNo]^[i]]); // leaving these deadlock-sets

                      FirstIndex:=VicinitySquares.FirstIndex[InternalSquareNo];
                      for Index:=FirstIndex to // start from the index of the first vicinity-square for the current box-square
                                 Min(Pred(VicinitySquares.FirstIndex[Succ(InternalSquareNo)]), // 'Pred': the span with vicinity-squares for the current box-square ends where the span for the next box-square begins
                                     FirstIndex+Optimizer.VicinitySettings[VicinitySettingsIndex__]) do // note that one extra square is included, as if the number of vicinity squares in the settings excludes the "self" square
                          if Result then begin
                             VicinitySquareNo:=VicinitySquares.Squares^[Index];
                             ExternalVicinitySquareNo:=BoxInternalToExternalSquare[VicinitySquareNo];
                             if (not IsABoxSquare(VicinitySquareNo,BoxConfiguration)) and // 'True': the vicinity square is empty
                                (not ((BoxNo<PreviousDepthBoxNo__) and          // 'not (...)': when 'True': an identical box configuration hasn't been generated earlier
                                      ((Index-FirstIndex)<PreviousDepthVicinitySquaresLimit) and
                                      (VicinitySquareNo<>PreviousDepthBoxOriginalSquare__))) and
                                (((Game.Board[ExternalVicinitySquareNo] and FLAG_NOT_SELECTED_SQUARE)=0) or //'0': the square is a member of the set of squares selected for optimization (typically all the squares)
                                 (IsBasePosition__ and (Index=FirstIndex)))     // 'IsBasePosition__ and (Index=FirstIndex)': if 'True', this is the base position from the best found path
                                then begin
                                AddBox(VicinitySquareNo,BoxConfiguration__);    // move the box to 'VicinitySquareNo'
                                Inc(Game.Board[ExternalVicinitySquareNo],BOX);
                                with Game.DeadlockSets do                       // update deadlock set capacities
                                  for i:=1 to SquareSetCount[ExternalVicinitySquareNo] do Dec(Capacity[SquareSetNumbers[ExternalVicinitySquareNo]^[i]]); // entering these deadlock-sets
                                ChangedBoxSquares__[VicinitySettingsIndex__]:=ExternalVicinitySquareNo; // update the set of squares with moved boxes

                                if Optimizer.VicinitySettings[Pred(VicinitySettingsIndex__)]<>0 then begin // 'True': this isn't the bottom recursion level
                                   Game.BoxPos[BoxNo]:=ExternalVicinitySquareNo;
                                   Result:=GenerateBoxConfigurationsRecursively(BoxConfiguration__,ChangedBoxSquares__,Pred(VicinitySettingsIndex__),BoxNo,InternalSquareNo,IsBasePosition__ and(Index=FirstIndex));
                                   end
                                else begin // this is the bottom recursion level
                                   if (not IsAFreezeTestDeadlock(ChangedBoxSquares__,VicinitySettingsIndex__)) // 'True': the moved boxes aren't involved in simple deadlocks like 2 adjacent boxes on an edge
                                      and
                                      (IsACapacityCountedDeadlock=NONE)         // 'True': the box configuration doesn't violate any of the player-independent members of the precalculated deadlocks
                                      and
                                      (Tree.Count<MaxBoxConfigurationCount)
                                      then
                                      if BTAdd(BoxConfiguration__,nil,Tree,Item) then begin // 'True': the current box configuration was added to the collection as a new item
                                         if not (IsBasePosition__ and (Index=FirstIndex)) then Inc(YASS.Positions.Count);
                                         if (Tree.Count) and ((1 shl 17)-1)=0 then begin // 'True': update the status and perform a time check
                                            if Tree.Count and (ONE_MEBI-1)=0  then begin
                                               // if the tree is a plain binary search tree instead of
                                               // a dynamically balanced red-black tree, then
                                               // rebalance the binary tree periodically;
                                               // otherwise, the lookup time decays when million of items
                                               // are added to a binary tree;
                                               // BTRebalance(Tree); // not enabled because the tree is rebalanced dynamically as a red-black tree
                                               end;

                                            Optimizer.SearchStateStatusText:={$IFDEF PLUGIN_MODULE}
                                                                               '  ('+
                                                                               VicinitySettingsAsText+
                                                                             {$ENDIF}
                                                                             TEXT_SEARCH_STATUS_VICINITY_3+
                                                                             IntToStr(Positions.MemoryByteSize div ONE_MEBI)+
                                                                             TEXT_SEARCH_STATUS_VICINITY_4+
                                                                             IntToStr(Max(1,Position^.Position.PushCount))+SLASH+IntToStr(YASS.Positions.BestPosition^.PushCount)+': '+
                                                                             IntToStr(Tree.Count)
                                                                             {$IFDEF PLUGIN_MODULE}
                                                                               +RIGHT_PAREN
                                                                             {$ENDIF}
                                                                             ;

                                            {$IFDEF CONSOLE_APPLICATION}
                                              Writeln(SearchStatePromptText,
                                                      Optimizer.SearchStateStatusText
                                                     {$IFDEF WINDOWS}
                                                      ,' Time: ',(CalculateElapsedTimeMS(Solver.StartTimeMS,GetTimeMS)+500) div ONE_THOUSAND
                                                     {$ENDIF}
                                                    );
                                            {$ELSE}
                                              SetSokobanStatusText(Optimizer.SearchResultStatusText+Optimizer.SearchStateStatusText);
                                            {$ENDIF}

                                            TimeCheck;
                                            end;
                                         end
                                      else if Item=nil then begin               // 'True': the box configuration doesn't exist in the collection
                                              Result:=False;                    // allocation of a new tree node failed; the caller may use this information to stop searching for more candidate positions
                                              end;
                                   end;

                                with Game.DeadlockSets do                       // restore deadlock set capacities
                                  for i:=1 to SquareSetCount[ExternalVicinitySquareNo] do Inc(Capacity[SquareSetNumbers[ExternalVicinitySquareNo]^[i]]); // leaving  these deadlock-sets
                                Dec(Game.Board[ExternalVicinitySquareNo],BOX);  // remove the box from the tested square
                                RemoveBox(VicinitySquareNo,BoxConfiguration__);
                                end;
                             end;

                      with Game.DeadlockSets do                                 // restore deadlock set capacities
                        for i:=1 to SquareSetCount[ExternalSquareNo] do Dec(Capacity[SquareSetNumbers[ExternalSquareNo]^[i]]); //entering these deadlock-sets
                      Game.BoxPos[BoxNo]:=ExternalSquareNo;                     // restore box square number
                      Inc(Game.Board[ExternalSquareNo],BOX);                    // restore box configuration
                      AddBox(InternalSquareNo,BoxConfiguration__);
                      end
                 else if Result then InternalError('GenerateBoxConfigurations');
                 end;
             end;
        end; // GenerateBoxConfigurationsRecursively

        function  MakeBloomFilter(Count__:Integer; var BloomFilter__:TBloomFilter):Boolean;
        begin // creates a Bloom filter for 'Count__' items; returns 'False' if the creation fails, e.g., if the necessary memory isn't available
         with BloomFilter__ do begin
           ByteSize:=CalculateDataStructuresByteSize(Count__,[dstBloomFilter]);
           Memory:=GetMemory(ByteSize,True);                                    // 'True': note that the memory is allocated from the top; at this time, the bottom of the memory is occupied by the temporary binary search tree
           Result:=Memory<>nil;
           if Result then BFInitialize(Memory,ByteSize,BloomFilter__);          // 'True': initialize the Bloom filter by zero-filling the memory area
           end;
        end; // MakeBloomFilter

        function  MakeCompactBoxConfigurationsCollection(var Tree__:TBinaryTree; var BoxConfigurations__:TBoxConfigurations):Boolean;
        // compacts the box configurations from 'Tree__' to a contiguous memory
        // area organized as a left-filled balanced binary tree where lookups
        // don't need left/right pointers, but where simple address
        // calculations suffice; the 'left' item for a node n is located at
        // position 2*n+1, and its 'right' item is located at position 2*n+2

          procedure MakeBoxConfigurationVectorRecursively(Item__:PBinaryTreeItem; Index__:Integer);
          begin // the tree has just been balanced before calling this recursive function; therefore, the tree height is guaranteed to be so small that recursion doesn't risk causing a stack overflow here
            if Item__<>nil then
               if   (Index__>=0) and (Index__<Tree__.Count) then begin
                    //BFAdd(Item__^.BoxConfiguration^,BloomFilter);              // add this box configuration to the Bloom filter
                    Move(Item__^.BoxConfiguration^,PBoxConfiguration(Cardinal(BoxConfigurations__.First)+Cardinal(Index__*BoxConfigurationByteSize))^,BoxConfigurationByteSize); // store the current item's box configuration at its final location
                    MakeBoxConfigurationVectorRecursively(Item__^.Left ,Index__*2+1);
                    MakeBoxConfigurationVectorRecursively(Item__^.Right,Index__*2+2);
                    end
               else // 'BTRebalance' probably didn't fill the balanced binary tree from the left, thereby giving some items an index outside the range [0..Count-1]
                    InternalError('BTToBoxConfigurationVector');
          end; // MakeBoxConfigurationVectorRecursively

        begin // MakeCompactBoxConfigurationsCollection; creates a vector containing the box configurations from the binary tree
          Result:=False; FillChar(BoxConfigurations__,SizeOf(BoxConfigurations__),0);
          if Tree__.Count<>0 then with Tree__ do begin
             //Msg(SysUtils.Format('Nodes: %d  Average depth: %f',[Tree__.Count,BTAverageNodeDepth(Tree__)]),'Tree nodes');
             BoxConfigurations__.First:=GetMemory(CalculateDataStructuresByteSize(Count,[dstBoxConfigurationVector]),True); // 'True': allocate from the top of memory; this is a final datastructure which doesn't move
             if   BoxConfigurations__.First<>nil then begin
                  BTRebalance(Tree__);                                          // rebalance the tree
                  //Msg(SysUtils.Format('Nodes: %d  Average depth: %f',[Tree__.Count,BTAverageNodeDepth(Tree__)]),'Tree nodes');
                  MakeBoxConfigurationVectorRecursively(Root,0);                // build a vector containing the balanced items
                  BoxConfigurations__.Count:=Count;
                  Result:=True;
                  end
             else begin //Msg(TEXT_MEMORY_FULL+': "OptimizeGame.Search.VicinitySearch.BTToBoxConfigurations"',TEXT_APPLICATION_TITLE);
                  end;
             end;
        end; // MakeCompactBoxConfigurationsCollection

        function  MakeBoxConfigurationsTernarySearchTree(const Tree__:TBinaryTree; var TernarySearchTree__:TTernarySearchTree):Boolean;

          function  TreeWalk(BinaryTreeItem__:PBinaryTreeItem; Index__:Integer):Boolean;
          var TernarySearchTreeItem:PTernarySearchTreeItem;
          begin
            if   BinaryTreeItem__<>nil then
                 Result:=TSTAdd  (BinaryTreeItem__^.BoxConfiguration^,Index__,TernarySearchTree__,TernarySearchTreeItem) and
                         TreeWalk(BinaryTreeItem__^.Left ,Index__*2+1) and
                         TreeWalk(BinaryTreeItem__^.Right,Index__*2+2)
            else Result:=True;
          end;

        begin // MakeBoxConfigurationsTernarySearchTree
          TSTInitialize(TernarySearchTree__);
          Result:=TreeWalk(Tree__.Root,0);
{
          Writeln('Box configuration byte size: ',BoxConfigurationByteSize);
          Writeln('Binary tree: ',Tree__.Count,' items = ',
                  CalculateDataStructuresByteSize(Tree__.Count,[dstBoxConfigurationVector]),' bytes');
          TSTShow(TernarySearchTree__);
          Readln;
}
        end; // MakeBoxConfigurationsTernarySearchTree

        function  ReserveMemoryForNewPathPositions(Count__:Integer; var Positions__:POptimizerPositionVector):Boolean;
        begin // allocates memory for a new best path found by the vicinity search; this area must be reserved before the search starts because the search uses the rest of the available memory for its open-queue
          Positions__:=POptimizerPositionVector(GetMemory(Succ(Count__)*SizeOf(Positions__^[Low(Positions__^)]),True)); // 'Succ': element 0 is not used by the path reconstruction after the search
          Result:=Positions__<>nil;
        end; // ReserveMemoryForNewPathPositions

        function  CalculateBoxSquareVicinitySquares(var VicinitySquares__:TVicinitySquares):Boolean;
        var CountDown,MaxVicinitySquaresPerSquare,NeighborSquareNo,QueueBottom,QueueTop,
            TimeStamp,SquareNo,VicinitySquareNo:Integer;
            d,Direction:TDirection; Visited:TBoardOfIntegers;
        begin // calculates vicinity-squares for each square; precondition: the memory has been allocated for them, i.e., 'VicinitySquares__.Squares' is non-nil
              // returns 'True' if the vicinity-squares are ready for use;
          Result:=VicinitySquares__.Squares<>nil;
          if Result then with VicinitySquares__ do begin                        // 'True': memory has been allocated for the vicinity-squares
             if FirstIndex[BoxSquareCount]<>0 then begin                        // 'True': the vicinity square has been calculated before, i.e., this isn't the first search
                // change the direction visit order;
                //
                // each search changes the visit order so the calculation of the
                // vicinity-squares doesn't stick to a fixed set of
                // vicinity-squares in those cases where the direction visit
                // order can make a difference;
                //
                // the vicinity-squares are found by a breadth-first search,
                // which in essence "draws" concentric cycles around the square
                // in the center; because of the user-selected limit, the visit
                // direction order (e.g., clock-wise or counter-clockwise) makes
                // a difference for the selection of squares from the outer
                // circle, unless the limit happens to saturate the outer
                // circle;
                //
                // the limit saturates the outer circle if it's of the form
                // "1+(2*n*(n+1))" where "n" is an integer >=0;
                //
                // as examples, here are the 3 first saturating limits, where
                // the vicinity-squares are found in counter-clockwise order:
                //   limit 1         limit 5         limit 13
                //                                      6
                //                      2              728
                //      1              315            9315D
                //                      4              A4C
                //                                      B
                //
                // only floor-squares are counted as vicinity-squares, so in
                // practice the vicinity-squares don't always form a circle; the
                // walls on the board distort the shape of the area, but the
                // logic remains he same;

                d:=DirectionVisitOrder[Low(DirectionVisitOrder)];                             // save the first item
                for Direction:=Low(DirectionVisitOrder) to Pred(High(DirectionVisitOrder)) do
                    DirectionVisitOrder[Direction]:=DirectionVisitOrder[Succ(Direction)];     // move items one step to the left
                DirectionVisitOrder[High(DirectionVisitOrder)]:=d;                            // set the last item to the former first item
                end;

             MaxVicinitySquaresPerSquare:=CalculateMaximumNumberOfVicinitySquaresPerSquare(BoxSquareCount,Optimizer.VicinitySettings);
             FillChar(Visited,SizeOf(Visited),0); TimeStamp:=0; QueueBottom:=0;

             for SquareNo:=0 to Pred(BoxSquareCount) do begin                   // for each box-square, find the nearest reachable squares, using a breadth-first search
                 Inc(TimeStamp);                                                // using a timestamp makes it unnecessary to clear the 'Visited' array for each search
                 Squares^[QueueBottom]                :=SquareNo;               // for conveniency, each square is a member of its own neighbor-squares list
                 FirstIndex[SquareNo]                 :=QueueBottom;            // for the current box-square, remember the index of its first neighbor-square in the flat 'VicinitySquares__' vector
                 Visited[SquareNo]                    :=TimeStamp;
                 QueueTop                             :=QueueBottom;            // at this point, the square itself is the only member of its neighbor-list
                 CountDown                            :=Pred(MaxVicinitySquaresPerSquare); // don't collect more vicinity-squares than the search limit dictates; ('Pred': the square itself is a member of the list)

                 while QueueBottom<=QueueTop do begin
                   VicinitySquareNo:=Squares^[QueueBottom]; Inc(QueueBottom);
                   for Direction:=Low(Direction) to High(Direction) do begin
                       NeighborSquareNo:=BoxSquareNeighbor[VicinitySquareNo,DirectionVisitOrder[Direction]];
                       if (NeighborSquareNo           <>NONE) and
                          (Visited[NeighborSquareNo]  <>TimeStamp) and
                          (CountDown                  > 0) then begin
                          Inc(QueueTop);
                          Squares^[QueueTop]          :=NeighborSquareNo;
                          Visited[NeighborSquareNo]   :=TimeStamp;
                          Dec(CountDown);
                          end;
                       end;
                   end;
                 end;
             if FirstIndex[BoxSquareCount]=0 then                               // 'True': this is the first search
                FirstIndex[BoxSquareCount]            :=QueueBottom             // the span with vicinity-squares for a square 'n' ends where the span for the next square 'n+1' begins, hence, the last span needs a terminator
             else                                                               // this is not the first iteration
                if FirstIndex[BoxSquareCount]<>QueueBottom then                 // 'True': something is wrong; even though the direction visit order has changed, the number of calculated vicinity-squares should be the same
                   Result:=InternalError('Search.CalculateBoxSquareVicinitySquares');
             end;
        end; // CalculateBoxSquareVicinitySquares

      begin // GenerateBoxConfigurations
        Result:=True; StartTimeMS:=GetTimeMS;
        ReleaseMemory(MemoryPool.MemoryBlock);                                  // reset the allocated memory pool
        PreallocatedTreeItemsMemoryBlock.ByteSize:=0;                           // reset the binary tree item pool
        BTInitialize(Tree);                                                     // initialize the binary tree
        FillChar(BoxConfigurations,SizeOf(BoxConfigurations),0);                // clear the box configurations
        Positions.SearchStatistics.FreezeTestDeadlockCount:=0;

        if SliceStartPosition__=POptimizerPosition(YASS.Positions.StartPosition) then // 'True': this is the first/only slice of the game
           Result:=CalculateBoxSquareVicinitySquares(VicinitySquares);          // for each square on the board, calculate its vicinity squares

        // determine the maximum number of box configurations to consider during
        // the search; only approx. 40% of the available memory is used for box
        // configurations; the rest is reserved for the open-queue;
        // despite its name, the open-queue actually contains open (not yet
        // expanded game-states) as well as all the closed (expanded) game-states

        MaxBoxConfigurationCount:=Max(0, // '0': guard against any programming errors where unsigned numbers by mistake are interpreted as negative signed numbers
                                      Min((MAX_BOX_CONFIGURATION_COUNT*10) div 9, // the vicinity search is a simple breadth-first search so it's best to limit the number of nodes to a reasonable small number
                                          Min( (High(MaxBoxConfigurationCount)-2) div          Max(2,PlayerSquareCount), // so 'BoxConfigurationIndex * Max(2,PlayerSquare)' doesn't overflow ('2': for conveniency in 'LookupBoxConfiguration')
                                              ((High(TGameState)                  div Cardinal(Max(2,PlayerSquareCount)))-1)))); // High('TGameState') is reserved for span marks on the queue
        repeat MaxBoxConfigurationCount:=9*(MaxBoxConfigurationCount div 10);    // 9/10: reduce the size slowly so the final result gets close to the target size for the box configurations
        until  CalculateDataStructuresByteSize(Cardinal(MaxBoxConfigurationCount),[dstBoxConfigurationVector,dstVisitedBitSet])
               <=
               2*(MemoryPool.MemoryBlock.ByteSize div 5);                       // '2/5 : reserve approx. 60% of the available memory for the open-queue

        SliceEndPosition__:=SliceStartPosition__;

        if Solver.PushCount<Solver.SearchLimits.PushCountLimit then begin
           Position:=SliceStartPosition__;
           while (Position<>nil) and                                            // for each position on the best found path, generate permuted positions taking the vicinity constraints into account
                 (Tree.Count<MaxBoxConfigurationCount) and
                 (not SearchHasTerminated) and
                 Result
                 do begin
             SetPosition(PPosition(Position));                                  // update the game board so it matches the current position from the game path
             //Write(Position^.MoveCount,SLASH,Position^.Position.PushCount,SPACE);
             LoadBoxConfigurationFromGame(BoxConfiguration);                    // make the bit-set representation of the current position (boxes only, the player position isn't taken into account)

             Result:=GenerateBoxConfigurationsRecursively(
                       BoxConfiguration,ChangedBoxSquares,
                       MAX_VICINITY_BOX_COUNT,0,0,True);                        // 'MAX_VICINITY_BOX_COUNT': the vicinity settings are right-justified and in descending order with first and last element as zero-value sentinels

             SliceEndPosition__:=Position;
             Position:=POptimizerPosition(Position^.Position.Successor);
             end;
           end;

        {$IFDEF CONSOLE_APPLICATION}
          Writeln(Reader.LevelCount,'. Box configurations: ',Tree.Count,' Time: ',CalculateElapsedTimeMS(StartTimeMS,GetTimeMS){,' Freeze-test deadlocks: ',Positions.SearchStatistics.FreezeTestDeadlockCount});
          //BTRedBlackTreeCheck(Tree);
          //Readln;
        {$ENDIF}

        MaxSearchDepth:=CalculateMaximumSearchDepth(SliceStartPosition__,SliceEndPosition__);

        Result:=(Tree.Count<>0) and
                (SliceStartPosition__<>SliceEndPosition__) and                  // '<>': the positions in the vicinity of 1 or more pushes on the best path have been explored and are now ready for the search
                (not SearchHasTerminated) and                                   // 'SearchHasTerminated': if the search has been terminated then don't start the vicinity search
                //MakeBloomFilter(Tree.Count,BloomFilter) and                   // the Bloom filter must be created before the compact box configuration collection (disabled because the filter only saves approx. 5% running time)
                MakeCompactBoxConfigurationsCollection(Tree,BoxConfigurations__) and
                //MakeBoxConfigurationsTernarySearchTree(Tree,BoxConfigurationsTernarySearchTree__) and
                ReserveMemoryForNewPathPositions(MaxSearchDepth,NewPathPositions) and
                (not SearchHasTerminated);                                      // 'SearchHasTerminated': check the terminate state again after creating the box configurations

        // the binary search tree occupies the bottom of the memory, and the
        // only output data structures from this function (the box configurations,
        // the new path positions, and the Bloom filter) are located at the top of
        // the memory; release the bottom memory, now that the binary search tree
        // isn't required anymore
        with MemoryPool do begin
          FreeBlock.ByteSize:=FreeBlock.ByteSize+
                              (Cardinal(FreeBlock.Memory)-Cardinal(MemoryBlock.Memory)); // the difference between 'FreeBlock.Memory' and 'MemoryBlock.Memory' is the size of the area allocated from the bottom of the available memory
          FreeBlock.Memory:=MemoryBlock.Memory;                                 // reset the pointer to the bottom of the allocated memory block
          end;
        PreallocatedTreeItemsMemoryBlock.ByteSize:=0;                           // reset the binary tree item pool
      end; // GenerateBoxConfigurations

      function  GetMemory(ByteSize__:Cardinal; AllocateMemoryFromTheTop__:Boolean):Pointer;
      begin // returns a memory-block from the memory pool; returns 'nil' if there isn't enough memory available
        if   (ByteSize__>0) and
             (ByteSize__<High(ByteSize__)-MEMORY_ALIGNMENT_BYTES) then with MemoryPool.FreeBlock do begin
             ByteAlignment(MEMORY_ALIGNMENT_BYTES,Pointer(ByteSize__));         // ensure that memory always is allocated in multiples of 'MEMORY_ALIGNMENT_BYTES'
             if   ByteSize__<=ByteSize then begin
                  if AllocateMemoryFromTheTop__ then begin
                     Cardinal(Result):=Cardinal(Memory)+Pred(ByteSize)-ByteSize__+1; // 'Pred(ByteSize)...+1': a straightforward calculation like 'Memory+Size-ByteSize' could theoretically overflow after the addition 'Memory+Size'
                     end
                  else begin
                     Result:=Memory;
                     Inc(PByte(Memory),ByteSize__);                             // update the pointer so it points to the remaining free area
                     end;
                  ByteSize:=ByteSize-ByteSize__;                                // update the size of the remaining free area
                  end
             else Result:=nil;
             end
        else Result:=nil;
      end; // GetMemory

      function  HashValuePJW(Key__:PByteVector; KeyByteSize__:Integer):Cardinal; // a hashpjw-based function (Peter J. Weinberger), adding in the length of the key (e.g., the text)
      const BITS_PER_BYTE         = YASS.BITS_PER_BYTE;
            BITS_PER_HASH_KEY     = SizeOf(Cardinal) * BITS_PER_BYTE;
            HIGH_4_BITS           = Cardinal($f) shl (BITS_PER_HASH_KEY-4);
      var   Index:Integer; HighBits:Cardinal;
      begin
        Result:=Cardinal(KeyByteSize__);
        for Index:=0 to Pred(KeyByteSize__) do begin
            Result:=(Result shl 4) + Ord(Key__^[Index]);
            HighBits:=Result and HIGH_4_BITS;
            if HighBits<>0 then Result:=(Result xor (HighBits shr (BITS_PER_HASH_KEY-8))) xor HighBits; // the high-bits are cleared after xor'ing them with the bits 4..7
            end;
      end; // HashValuePJW

      function  HashValueDEK(Key__:PByteVector; KeyByteSize__:Integer):Cardinal; // a hashdek function (Donald E. Knuth, "The Art Of Computer Programming Volume 3", 6.4)
      const BITS_PER_BYTE         = YASS.BITS_PER_BYTE;
            BITS_PER_HASH_KEY     = SizeOf(Cardinal) * BITS_PER_BYTE;
            LEFT_SHIFT            = 5;
            RIGHT_SHIFT           = BITS_PER_HASH_KEY - LEFT_SHIFT;
      var   Index:Integer;
      begin
        Result:=Cardinal(KeyByteSize__);
        for Index:=0 to Pred(KeyByteSize__) do
            Result:=((Result shl LEFT_SHIFT) xor (Result shr RIGHT_SHIFT)) xor Ord(Key__^[Index]);
      end; // HashValueDEK

      function  IsABoxSquare(SquareNo__:Cardinal; const BoxConfiguration__:TBoxConfiguration):Boolean;
      begin
        Result:=(BoxConfiguration__[SquareNo__ div BITS_PER_BYTE] and (1 shl (SquareNo__ mod BITS_PER_BYTE)))<>0;
      end; // IsABoxSquare

      function  Initialize:Boolean;
      var BoxNo,Index,InternalSquareNo,SquareNo:Integer; Direction:TDirection;

        function  ReserveMemoryForBoxSquareVicinitySquares(var VicinitySquares__:TVicinitySquares):Boolean;
        var  Direction:TDirection;
        begin // allocates memory for vicinity-squares and initializes the direction visit order for the calculation of the vicinity-squares for each square on the board;
              // returns 'False' if there isn't enough memory;
              // when the memory has been allocated, the vicinity-squares can be calculated later by the function 'CalculateBoxSquareVicinitySquares'
          FillChar(VicinitySquares__,SizeOf(VicinitySquares__),0);              // clear the vicinity-squares information; precondition: memory hasn't been allocated for the vector at this time

          // initialize the direction visit order for the calculation of the
          // vicinity-squares for each square on the board;
          // the fixed starting visit order ensures reproducible results;
          with VicinitySquares__ do
            for Direction:=Low(DirectionVisitOrder) to High(DirectionVisitOrder) do
                DirectionVisitOrder[Direction]:=Direction;

          // allocate memory for the vicinity-squares
          VicinitySquares__.Squares:=GetMemory(CalculateDataStructuresByteSize(0,[dstVicinitySquares]),True); // 'True' parameter: allocate from the top of the memory pool where it's easier to protect the area against recycling
          Result:=VicinitySquares__.Squares<>nil;
          if Result then                                                        // 'True': allocating memory for the vicinity-squares succeeded
             with MemoryPool do MemoryBlock:=FreeBlock;                         // protect the vicinity squares against memory recycling by hiding them from the memory allocator; this is possible because the vicinity-squares are allocated first
        end; // ReserveMemoryForBoxSquareVicinitySquares

        function  MakeBitSetDeadlocks(var Deadlocks__:TBoxConfigurations):Boolean; // not in production; the normal capacity counting deadlock detection is much faster than bit-set testing
        var ByteSize,Index,SquareNo,SetNo:Integer;
            DeadlockSetExternalToInternalNo:array[0..MAX_DEADLOCK_SETS] of Integer;
        begin // makes bit-set representations of the player-independent members of the pre-calculated deadlocks
          with Deadlocks__ do begin
            FillChar(Deadlocks__,SizeOf(Deadlocks__),0);                        // clear the deadlock bit-sets, e.g., set the count to 0
            for SetNo:=1 to Game.DeadlockSets.Count do
                if   [dsfPlayerIsInsideSet,dsfPlayerMustBeOutsideSet,dsfControllerSet,dsfFreezeSet]*Game.DeadlockSets.Flags[SetNo]=[] then begin
                     DeadlockSetExternalToInternalNo[SetNo]:=Count;             // map external to internal deadlock set numbers
                     DeadlockSetInternalToExternalNo[Count]:=SetNo;
                     Inc(Count);
                     end
                else DeadlockSetExternalToInternalNo[SetNo]:=NONE;

            ByteSize:=CalculateDataStructuresByteSize(Count,[dstBoxConfigurationVector]);
            First:=GetMemory(ByteSize,True);

            if   First<>nil then begin
                 FillChar(First^,ByteSize,0);                                   // clear all the deadlock bit-sets
                 for SquareNo:=1 to Game.BoardSize do
                     for Index:=1 to Game.DeadlockSets.SquareSetCount[SquareNo] do begin
                         SetNo:=Game.DeadlockSets.SquareSetNumbers[SquareNo]^[Index];
                         if DeadlockSetExternalToInternalNo[SetNo]<>NONE then   // 'True': add a box at the current square for the current deadlock set number
                            AddBox(BoxExternalToInternalSquare[SquareNo],
                                   PBoxConfiguration(Cardinal(First)+Cardinal(DeadlockSetExternalToInternalNo[SetNo]*BoxConfigurationByteSize))^);
                        end;
                 end
            else Count:=0;

            Result:=First<>nil;
            end;
        end; // MakeBitSetDeadlocks

      begin // Initialize; initializes the vicinity search; precondition: the game has been initialized by calling 'InitializeGame'
        Result:=False;
        if (Solver.PushCount<Solver.SearchLimits.PushCountLimit)
           and
           (not SearchHasTerminated) then with Positions do begin
           SetPosition(nil);
           if not CheckMovesFromSquare then InternalError('Initialize');

           // the size of the 'Visited' datastructure depends on the
           // optimization type; optimizing boxlines requires saving the last
           // push direction for all visited game-states
           if   Optimizer.Optimization<opBoxLinesMoves then
                VisitedMultiplicationFactor:=1
           else VisitedMultiplicationFactor:=GAME_STATE_MULTIPLICATION_FACTOR_FOR_BOXLINES_SEARCH;

           // make a textual representation of the vicinity settings
           VicinitySettingsAsText:='';
           for Index:=Succ(Low(Optimizer.VicinitySettings)) to MAX_VICINITY_BOX_COUNT do
               if Optimizer.VicinitySettings[Index]<>0 then
                  if   VicinitySettingsAsText<>'' then
                       VicinitySettingsAsText:=VicinitySettingsAsText+SLASH+IntToStr(Optimizer.VicinitySettings[Index])
                  else VicinitySettingsAsText:=IntToStr(Optimizer.VicinitySettings[Index]);
           if (VicinitySettingsAsText<>'') and (System.Pos(SLASH,VicinitySettingsAsText)=0) then
              VicinitySettingsAsText:=VicinitySettingsAsText+SLASH+'0';         // 'True': a single item only; show it as "<number>/0"
           if VicinitySettingsAsText<>'' then VicinitySettingsAsText:=VicinitySettingsAsText+SPACE;

           // allocate memory pool for the vicinity search
           Result:=(TTPurge(Capacity,False)>=0) and                             // 'TTPurge': compact the best game path at the bottom of the transposition table
                   InitializeMemoryPool(MemoryPool,nil);                        //  'InitializeMemoryPool' reserves the rest of the transposition table as work area for the vicinity-search

           FillChar(PreallocatedTreeItemsMemoryBlock,SizeOf(PreallocatedTreeItemsMemoryBlock),0); // initialize the preallocation of nodes for the binary search tree(s)

           // calculate internally used player square numbers, reachable squares only
           for BoxNo:=1 to Game.BoxCount do Dec(Game.Board[Game.BoxPos[BoxNo]],BOX); // remove all  boxes from the board
           CalculatePlayersDistanceToReachableSquares(0);                       // the reachable player squares are the squares the player can reach from the game starting position
           for BoxNo:=1 to Game.BoxCount do Inc(Game.Board[Game.BoxPos[BoxNo]],BOX); // put boxes back on the board
           PlayerSquareCount:=0;
           for SquareNo:=0 to Game.BoardSize do with Solver.SearchStates[0].PlayersReachableSquares do
               if   (not IsAWallSquare(SquareNo)) and
                    (Squares[SquareNo]>=TimeStamp) then begin                   // '>TimeStamp': the player can reach the square
                    PlayerInternalToExternalSquare[PlayerSquareCount]:=SquareNo;
                    PlayerExternalToInternalSquare[SquareNo         ]:=PlayerSquareCount;
                    Inc(PlayerSquareCount);
                    end
               else PlayerExternalToInternalSquare[SquareNo]:=NONE;

           // calculate internally used box square numbers, reachable squares only
           BoxSquareCount:=0;
           for SquareNo:=0 to Game.BoardSize do begin
               InternalSquareNo:=PlayerExternalToInternalSquare[SquareNo];
               if   IsALegalAndBoxReachableSquare(SquareNo) then begin
                    BoxInternalToExternalSquare[BoxSquareCount]:=SquareNo;
                    BoxExternalToInternalSquare[SquareNo      ]:=BoxSquareCount;
                    BoxSquareToPlayerSquare    [BoxSquareCount]:=InternalSquareNo;
                    Inc(BoxSquareCount);
                    end
               else BoxExternalToInternalSquare[SquareNo]:=NONE;
               if   InternalSquareNo<>NONE then                                 // map player squares numbers to box square numbers
                    PlayerSquareToBoxSquare[InternalSquareNo]:=BoxExternalToInternalSquare[SquareNo];
               end;

           // calculate player square neighbors, using the internal numbers
           for SquareNo:=0 to Game.BoardSize do begin
               InternalSquareNo:=PlayerExternalToInternalSquare[SquareNo];
               if InternalSquareNo<>NONE then
                  for Direction:=Low(Direction) to High(Direction) do
                      PlayerSquareNeighbor[InternalSquareNo,Direction]:=PlayerExternalToInternalSquare[SquareNo+Game.SquareOffsetForward[Direction]];
               end;

           // calculate box square neighbors, using the internal numbers
           for SquareNo:=0 to Game.BoardSize do begin
               InternalSquareNo:=BoxExternalToInternalSquare[SquareNo];
               if InternalSquareNo<>NONE then
                  for Direction:=Low(Direction) to High(Direction) do
                      BoxSquareNeighbor[InternalSquareNo,Direction]:=BoxExternalToInternalSquare[SquareNo+Game.SquareOffsetForward[Direction]];
               end;

           // calculate byte size of the bit-set box configuration
           if   (BoxSquareCount>0) and (PlayerSquareCount<>0) then
                BoxConfigurationByteSize:=Succ(Pred(BoxSquareCount) div BITS_PER_BYTE)
           else BoxConfigurationByteSize:=0;                                    // '0': nothing to do

           // allocate memory for squares in the vicinity of all the box-reachable squares
           Result:=Result and ReserveMemoryForBoxSquareVicinitySquares(VicinitySquares);

           // make bit-set representations of the player-independent members of the pre-calculated deadlocks (not in production)
           FillChar(Deadlocks,SizeOf(Deadlocks),0);                             // clear the deadlock bit-sets, e.g., set the count to 0
           // if Result then MakeBitSetDeadlocks(Deadlocks);                    // bit-set deadlocks are not in production; tests have shown that the normal capacity-counting deadlock detection is faster

           SliceStartPosition  :=POptimizerPosition(YASS.Positions.StartPosition);
           SliceEndPosition    :=POptimizerPosition(YASS.Positions.BestPosition);

           Result:=Result and (SliceStartPosition<>SliceEndPosition);
           Result:=Result and (BoxConfigurationByteSize>0) and (not SearchHasTerminated); // 'SearchHasTerminated': if the search has been terminated then don't start the calculation of the box-configurations
           end;
      end; // Initialize

      function  InitializeMemoryPool(var MemoryPool__:TMemoryPool; ProtectedUpperMemoryArea__:Pointer):Boolean;
      begin // 'InitializeMemoryPool'; precondition: 'TTPurge': had been called to compact the best game path at the bottom of the transposition table
        FillChar(MemoryPool__,SizeOf(MemoryPool__),0);
        if (Positions.Positions<>nil) and
           (Cardinal(Positions.EndOfPositions)>Cardinal(Positions.Positions)) and // '>': per square precalculated deadlock set numbers and hash table buckets are allocated after the nodes stored in the transposition table
           (Positions.UninitializedItemCount*SizeOf(TOptimizerPosition)>2*MEMORY_ALIGNMENT_BYTES) then
           with MemoryPool__ do with MemoryBlock do begin
             // preserve the best game path at the bottom of the allocated memory,
             // and per square precalculated deadlock set numbers and hash table
             // buckets at the top of the allocated memory;
             // the sandwiched memory area is used as the available memory pool
             // for the vicinity-search;
             // even though hash buckets at the top of the memory aren't used
             // during the vicinity search, the memory area cannot be a part of
             // the vicinity search memory pool because 'TTPurge' builds a fresh
             // hash bucket table before all positions on the best path have been
             // compacted at the bottom of the memory;
             Memory:=Pointer(System.Addr(POptimizerPositionVector(Positions.Positions)^[Positions.Count])); // this is the address of the next free node in the transposition table
             if   (Positions.BestPosition=nil) or (Cardinal(Positions.BestPosition)+Cardinal(SizeOf(TOptimizerPosition))<=Cardinal(Memory)) then begin
                  ByteAlignment(MEMORY_ALIGNMENT_BYTES,Memory);
                  //ByteSize:=(Cardinal(Positions.Positions)+Cardinal(Pred(Positions.MemoryByteSize))-Cardinal(Memory)) and (not (MEMORY_ALIGNMENT_BYTES-1)); // 'and (not...)': truncate the size to a multiple of 'MEMORY_ALIGNMENT_BYTES'
                  ByteSize:=(Cardinal(Positions.EndOfPositions)-Cardinal(Memory)) and (not (MEMORY_ALIGNMENT_BYTES-1)); // 'and (not...)': truncate the size to a multiple of 'MEMORY_ALIGNMENT_BYTES'

                  if ProtectedUpperMemoryArea__<>nil then // 'ProtectedUpperMemoryArea__' is used for protecting an upper memory area (e.g. vicinity-squares) when the memory-pool is reallocated after a successful call to 'TTPurge'
                     if   (Cardinal(ProtectedUpperMemoryArea__)>=Cardinal(Memory))
                          and
                          (Cardinal(ProtectedUpperMemoryArea__)-Cardinal(Memory)<=ByteSize) then
                          ByteSize:=(Cardinal(ProtectedUpperMemoryArea__)-Cardinal(Memory)) and (not (MEMORY_ALIGNMENT_BYTES-1)) // 'and (not...)': truncate the size to a multiple of 'MEMORY_ALIGNMENT_BYTES'
                     else InternalError('InitializeMemoryPool (A)'
                                        +NL+'Positions: '+IntToStr(Positions.Count)
                                        +NL+'Bytes....: '+IntToStr(ByteSize)
                                        +NL+'Memory...: '+IntToStr(Cardinal(Memory))
                                        +NL+'Protect..: '+IntToStr(Cardinal(ProtectedUpperMemoryArea__))
                                        +NL+'Hash.....: '+IntToStr(Cardinal(Positions.HashBuckets))
                                       );

                  FreeBlock:=MemoryBlock;              // the entire memory block is free at the moment
                  Positions.UninitializedItemCount:=0; // '0'  : ensure that no more positions are added to the transposition table by the normal transposition table functions
                  Positions.FreeList:=nil;             // 'nil': ensure that no more positions are added to the transposition table by the normal transposition table functions
                  //Write(Positions.Count,SPACE,Positions.MemoryByteSize,SPACE,Cardinal(Positions.Positions),SPACE,Cardinal(Positions.HashBuckets),SPACE,Cardinal(MemoryBlock.Addr),SPACE,MemoryBlock.Size);
                  //Readln;
                  end
             else InternalError('InitializeMemoryPool (B)'
                                +NL+'Positions: '+IntToStr(Positions.Count)
                                +NL+'Memory...: '+IntToStr(Cardinal(Memory))
                                +NL+'Best.....: '+IntToStr(Cardinal(Positions.BestPosition))
                               );
             end;
        Result:=MemoryPool__.FreeBlock.ByteSize>0;
      end; // InitializeMemoryPool

      function  InternalError(const FunctionName__:String):Boolean;
      begin
        Msg(TEXT_INTERNAL_ERROR+': "OptimizeGame.Search.VicinitySearch.'+FunctionName__+DOUBLE_QUOTE,TEXT_APPLICATION_TITLE);
        Result:=False;
      end; // InternalError

      procedure LoadBoxConfigurationFromGame(var BoxConfiguration__:TBoxConfiguration);
      var BoxNo,SquareNo:Integer;
      begin // create a bit-set representation of the current game state
        FillChar(BoxConfiguration__,BoxConfigurationByteSize,0);
        for BoxNo:=1 to Game.BoxCount do begin
            SquareNo:=BoxExternalToInternalSquare[Game.BoxPos[BoxNo]];
            if   SquareNo>=0 then
                 AddBox(Cardinal(SquareNo),BoxConfiguration__)
            else InternalError('LoadBoxConfigurationFromGame');
            end;
      end; // LoadBoxConfigurationFromGame

      procedure MarkMemory(var MemoryMark__:TMemoryBlock);
      begin // returns a snapshot of the current memory state
        MemoryMark__:=MemoryPool.FreeBlock;
      end; // MarkMemory

      function  PositionOnBestPathWithPushNumber(Count__:Integer):POptimizerPosition;
      begin // returns the position on the best path with the given push number, if any
        Result:=POptimizerPosition(YASS.Positions.StartPosition);
        while (Result<>nil) and (Result^.Position.PushCount<>Count__) do
          Result:=POptimizerPosition(Result^.Position.Successor);
      end; // PositionOnBestPathWithPushNumber

      procedure ReleaseMemory(const MemoryMark__:TMemoryBlock);
      begin // restores the memory state to a previously stored state
        MemoryPool.FreeBlock:=MemoryMark__;
      end; // ReleaseMemory

      procedure RemoveBox(SquareNo__:Cardinal; var BoxConfiguration__:TBoxConfiguration);
      begin // removes a box from a box configuration
        Dec(BoxConfiguration__[SquareNo__ div BITS_PER_BYTE],1 shl (SquareNo__ mod BITS_PER_BYTE));
      end; // RemoveBox

      procedure SavePlayerAndBoxConfigurationToGame(InternalPlayerSquare__:Integer; const BoxConfiguration__:TBoxConfiguration);
      var InternalSquareNo,SquareNo:Integer;
      begin // updates the external game state, i.e., the board, the player position, and the box positions
        Game.BoxCount:=0; MovePlayer(0);
        for SquareNo:=0 to Game.BoardSize do begin
            Game.Board[SquareNo]:=Game.Board[SquareNo] and (not (BOX+PLAYER)); // remove boxes and the player from the game board
            InternalSquareNo:=BoxExternalToInternalSquare[SquareNo];
            if (InternalSquareNo>=0) and IsABoxSquare(InternalSquareNo,BoxConfiguration__) then begin
               Inc(Game.Board[SquareNo],BOX);
               Inc(Game.BoxCount);
               Game.BoxPos[Game.BoxCount]:=SquareNo;
               end;
            end;
        if InternalPlayerSquare__<>NONE then
           MovePlayer(PlayerInternalToExternalSquare[InternalPlayerSquare__]);
      end; // SavePlayerAndBoxConfigurationToGame

      function  Search:Boolean;
      const
        QUEUE_MEMORY_BLOCK_BYTE_SIZE=ONE_MEBI;                                  // byte size for queue memory blocks
      type
        TMemoryBlockList=record                                                 // memory block collection, organized as a circular list of blocks
          Root:PMemoryBlock;                                                    // the first block in the list
        end;
        PQueueItem=^TQueueItem;
        TQueueItem=packed record                                                // items on the open-queue (despite its name, the 'open-queue' contains visited nodes as well as unvisited nodes)
          GameState:TGameState;
          PushAncestor:PQueueItem;                                              // the most recent push on the path leading to this node
        end;
        // in a breadth-first search, all moves at depth 'n' are visited before
        // the moves at depth 'n+1';
        // a span-datastructure contains the start of a sequence of items having
        // the same number of moves and/or pushes
        PSpanItem=^TSpanItem;
        TSpanItem=packed record
         FirstItem:PQueueItem;                                                  // a span consists of the items from 'FirstItem' up to, but not including the first item for the next span
        end;
        TQueue=record
          Block:PMemoryBlock;                                                   // current block for enqueueing new items; 'Top' points inside this block
          Bottom:Pointer;                                                       // bottom of the unexpanded items on the queue; 'Bottom' points inside 'MemoryBlocks.Root' if the queue recycles memory blocks as soon as their items have been expanded
          ItemByteSize:Cardinal;                                                // byte size of the items on the queue
          MemoryBlocks:TMemoryBlockList;                                        // the memory blocks allocated to the queue
          Top:Pointer;                                                          // top of the queue; it's either the next free memory address in the current memory block, or it points to the end of the current memory block
        end;
        PQueue=^TQueue;
        TQueues=record                                                          // contrary to what the name suggests, the queues contain both visited and unvisited nodes
          BoxLineSpansQueue:TQueue;                                             // queue with boxlines-spans
          BoxLinesQueue:TQueue;                                                 // queue with box-pushes with the same number of boxlines
          FreeMemoryBlocks:TMemoryBlockList;                                    // pool with memory blocks ready for recycling
          MoveSpansQueue:TQueue;                                                // queue with moves-spans
          MovesQueue:TQueue;                                                    // queue with moves, i.e., non-pushing player-moves
          PushesQueue:TQueue;                                                   // queue with box-pushes, as opposed to non-pushing player-moves
          PushSpansQueue:TQueue;                                                // queue with pushes-spans
        end;
      var
        SearchDepth,StartBoxConfigurationIndex,StartPlayerSquare,               // note that 'SearchDepth' for conveniency follows the actual number of moves/pushes in the name; it's not a 0-based relative depth
        TargetBoxConfigurationIndex,TargetPlayerSquare:Integer;
        SearchSliceHasTerminated:Boolean;
        Queues:TQueues;
        VisitedArea:PByteVector;                                                // memory for keeping track of visited game-states, i.e., [box-configurations, player-squares] tuples
        {$IFDEF CONSOLE_APPLICATION}
          LastConsoleStatusMoveCount:Int64;
        {$ENDIF}
        // BC,PS:array[0..1000] of Integer; NextBC:Integer;                     // debugging variables

        // forward declarations, i.e., functions that are referenced before they are defined in the source code
        function  EnlargeQueue(BlockByteSize__:Cardinal; var Queue__:TQueue):Boolean; forward;
        function  DumpPath(Item__:PQueueItem):Boolean; forward;
        function  FirstItemInBlock(Block__:PMemoryBlock; ItemByteSize__:Cardinal):Pointer; forward;
        function  GetBoxConfigurationByIndex(Index__:Integer):PBoxConfiguration; forward;
        function  IsNewBetterPath(QueueItem__:PQueueItem; RestPath__:POptimizerPosition):Boolean; forward;
        function  IsEmptySpan(SpanItem__:PSpanItem; const SpanQueue__,MovesOrPushesQueue__:TQueue):Boolean; forward;
        function  IsVisited(GameState__:TGameState):Boolean; forward;
        function  LastItemOnQueue(const Queue__:TQueue):Pointer; forward;
        function  LookupBoxConfiguration(const BoxConfiguration__:TBoxConfiguration):Integer; forward;
        function  MakeSpan(FirstItem__:PQueueItem; var SpanQueue__:TQueue):Boolean; forward;
        procedure MemoryBlockListRemoveItem(Item__:PMemoryBlock; var List__:TMemoryBlockList); forward;
        procedure ResetVisited(GameState__:TGameState); forward;
        procedure SetVisited(GameState__:TGameState); forward;
        procedure ShowGameState(InternalPlayerSquare__:Integer; const BoxConfiguration__:TBoxConfiguration; const Caption__:String; Log__:Boolean); forward;
        function  ShowSearchStatus:Boolean; forward;
        function  StopSearch:PQueueItem; forward;

        // Memory blocks

        function  AllocateMemoryBlock(MinBlockByteSize__:Cardinal; var Block__:PMemoryBlock; var FreeMemoryBlocks__:TMemoryBlockList):Boolean;

          function  IsBlockBigEnough(Block__:PMemoryBlock):Boolean;
          begin // returns 'True' if the block size is equal to, or bigger than the requested size
            Result:=Block__^.ByteSize>=MinBlockByteSize__;
          end; // IsBlockBigEnough

        begin // AllocateMemoryBlock; tries to allocate a memory block
          Result:=False; Block__:=nil;
          if (not SearchSliceHasTerminated) and                                 // 'True': the search through the current slice of the game hasn't been terminated
             (MinBlockByteSize__>=Cardinal(SizeOf(TMemoryBlock))) then begin
             if Queues.FreeMemoryBlocks.Root<>nil then begin                    // 'True': the free list isn't empty
                Block__:=FreeMemoryBlocks__.Root;
                repeat Block__:=Block__^.Previous;                              // search for a memory block of the requested size, or bigger
                until  IsBlockBigEnough(Block__) or (Block__=FreeMemoryBlocks__.Root); // until all members of the list has been visited
                if     IsBlockBigEnough(Block__) then with Block__^ do begin    // 'True': found a block of the requested size
                       MemoryBlockListRemoveItem(Block__,FreeMemoryBlocks__);   // remove the block from the free-list
                       end
                else   Block__:=nil;                                            // 'nil': no blocks on the free-list matching the requested size could be found
                end;

             if Block__=nil then begin                                          // 'nil': no block matching the requested size was found on the free-list
                Block__:=GetMemory(MinBlockByteSize__,False);                   // try to allocate a new memory block from the pool
                if Block__<>nil then begin
                   Cardinal(Block__):=Cardinal(Block__)+(MinBlockByteSize__-Cardinal(SizeOf(Block__^))); // the block is represented by its links which are located after the data area
                   Block__^.ByteSize:=MinBlockByteSize__;                       // save the block byte size
                   Cardinal(Block__^.Memory):=Cardinal(Block__)-Cardinal(MinBlockByteSize__-Cardinal(SizeOf(Block__^))); // save the memory address where the data area begins
                   end;
                end;

             if Block__<>nil then                                               // 'True': allocating a new memory block succeeded
                Result:=True
             else begin
                {$IFDEF CONSOLE_APPLICATION}
                  Writeln(TEXT_MEMORY_FULL);
                {$ENDIF}
                end;
             end;
        end; // AllocateMemoryBlock

        function  FindMemoryBlockWithItem(Item__:Pointer; const MemoryBlocks__:TMemoryBlockList):PMemoryBlock;
        begin // returns the memory block to which the item belongs; precondition: the item belongs to one of the memory blocks on the list
          Result:=MemoryBlocks__.Root^.Previous;                                // start the search by examining the most recently added memory block; often the item either belongs to this one, or to the root block
          while (Cardinal(Item__)<Cardinal(Result^.Memory)) or
                (Cardinal(Item__)>Cardinal(Result)) do begin
                Result:=Result^.Next;                                           // try the next memory block
                if Result=MemoryBlocks__.Root^.Previous then begin              // 'True': circular list wrap around, i.e., the item does not belong to any of the memory blocks on the list
                   Result:=nil; exit;
                   end;
                end;
        end; // FindMemoryBlockWithItem

        function  FirstItemInBlock(Block__:PMemoryBlock; ItemByteSize__:Cardinal):Pointer;
        var TagBitMask:Cardinal;
        begin // returns the memory address of the first item in the memory block; the items are right-justified, thereby making it more efficient to check if a block is full
          if   ItemByteSize__>DIRECTION_BIT_MASK then                           // 'True': the items are big enough to store a direction in the low bits of an item pointer; this is used for items on the game-state queues
               TagBitMask:=DIRECTION_BIT_MASK                                   // reserve tag bits in the item pointers for a direction
          else TagBitMask:=0;                                                   // no tag bits in the item pointers
          if   (ItemByteSize__ and TagBitMask)=0 then begin                     // '0': it's possible to store tag bits in the low bits of a pointer to an item
               Result:=Block__.Memory;
               while (Result<>Block__)
                     and
                     (((Cardinal(Result) and TagBitMask)<>0)                    // '<>': it's not possible to store tag bits in the low bits of a pointer to an item
                      or
                     ((Cardinal(Block__)-Cardinal(Result)) mod ItemByteSize__<>0) // 'Cardinal(Block__)': the block is represented by its links, and they a placed after the data area; that way, the block is its own end-of-data-area pointer
                     ) do
                     Inc(Cardinal(Result));
               end
          else begin Msg(TEXT_INTERNAL_ERROR+': FirstItemInBlock: Item misalignment. Size: '+IntToStr(ItemByteSize__),TEXT_APPLICATION_TITLE);
                     Result:=Block__;                                           // empty block
               end;
        end; // FirstItemInBlock

        procedure MemoryBlockListAddItem(Item__:PMemoryBlock; var List__:TMemoryBlockList);
        begin // adds a new item to the end of the list
          if List__.Root<>nil then with Item__^ do begin                        // 'True': the list isn't empty; add the new item to the end of the list
             Previous:=List__.Root^.Previous;
             Next    :=List__.Root;
             Previous^.Next:=Item__;
             Next^.Previous:=Item__;
             end
          else with Item__^ do begin                                            // the list is empty
             List__.Root:=Item__; Previous:=Item__; Next:=Item__;               // make a single item circular list
             end;
        end; // MemoryBlockListAddItem

        procedure MemoryBlockListAddList(Head__:PMemoryBlock; var List__:TMemoryBlockList);
        var Last:PMemoryBlock;
        begin // adds a circular linked list of items to the list
          if Head__<>nil then                                                   // 'True': it isn't an empty list that is added
             if   List__.Root<>nil then begin
                  Last                  :=List__.Root^.Previous;                // last member of the original list
                  List__.Root^.Previous :=Head__^.Previous;
                  Head__^.Previous^.Next:=List__.Root;
                  Last  ^.Next          :=Head__;
                  Head__^.Previous      :=Last;
                  end
             else List__.Root:=Head__;
        end; // MemoryBlockListAddList

        function  MemoryBlockListInitialize(var List__:TMemoryBlockList):Boolean;
        begin
          Result:=True; FillChar(List__,SizeOf(List__),0);
        end; // MemoryBlockListInitialize

        procedure MemoryBlockListRemoveItem(Item__:PMemoryBlock; var List__:TMemoryBlockList);
        begin // removes an item from the list; precondition: the item is a member of the list
          with Item__^ do begin
            Next^.Previous:=Previous;                                           // take the item out of the list
            Previous^.Next:=Next;                                               // take the item out of the list
            if Item__=List__.Root then                                          // 'True': the item is the head of the list
               if   Next<>Item__ then                                           // 'True': the list isn't empty after removal of the item
                    List__.Root:=Next                                           // promote the next item to root item
               else List__.Root:=nil;                                           // it's the last item on the list that has been removed
            end;
        end; // MemoryBlockListRemoveItem

        // end of memory block functions

        // Queues

        function  AdvanceToNextMemoryBlock(FreeOldBlock__:Boolean; var Item__:Pointer; var Queue__:TQueue; var EndOfBlock__:PMemoryBlock):Boolean;
        var OldBlock:PMemoryBlock;
        begin // advances to the next memory block after having processed the items on the block given by 'EndOfBlock__'
          OldBlock:=EndOfBlock__;                                               // each block is its own end-of-block pointer
          EndOfBlock__:=EndOfBlock__^.Next;                                     // advance to the next queue memory block
          Item__:=FirstItemInBlock(EndOfBlock__,Queue__.ItemByteSize);          // point to the first item in the block
          if FreeOldBlock__  then begin                                         // 'True': recycle the old block
             MemoryBlockListRemoveItem(OldBlock,Queue__.MemoryBlocks);          // remove the just finished memory block from the queue
             MemoryBlockListAddItem   (OldBlock,Queues .FreeMemoryBlocks);      // add the just finished block to the free-list
             if OldBlock=EndOfBlock__ then EndOfBlock__:=nil;                   // 'True': the last memory block on the circular list has been recycled
             end;
          Result:=EndOfBlock__<>nil;                                            // return 'True' if advancing to the next memory block succeeded, i.e., if the circular list of memory blocks isn't empty
        end; // AdvanceToNextMemoryBlock

        function  CalculateQueueItemPushPathLength(Item__:PQueueItem):Integer;
        begin  // returns the number of pushes on the path to the game-state represented by 'Item__'; the root node (the slice starting position) is not counted
          Result:=-1;                                                           // '-1': // the first node on the path is the slice start position (the root node), and it's not counted; the new path begins with the next node
          while Item__<>nil do begin
            Inc(Result); Item__:=PQueueItem(Cardinal(Item__^.PushAncestor) and (not DIRECTION_BIT_MASK)); // '(not DIRECTION_BIT_MASK)': the push ancestor pointer may contain a direction stored in the low bits
            end;
        end; // CalculateQueueItemPushPathLength

        procedure ClearQueue(var Queue__:TQueue);
        var ItemByteSize:Cardinal;
        begin // clears the queue, recycling any attached memory blocks
          MemoryBlockListAddList(Queue__.MemoryBlocks.Root,Queues.FreeMemoryBlocks); // put any memory blocks allocated to the queue back on the free-list
          ItemByteSize:=Queue__.ItemByteSize;                                   // remember the item byte-size
          FillChar(Queue__,SizeOf(Queue__),0);                                  // clear any old queue information
          Queue__.ItemByteSize:=ItemByteSize;                                   // restore the item byte-size
        end; // ClearQueue

        function  DequeueSpan(var SpanQueue__:TQueue):PQueueItem;
        var OldBlock:PMemoryBlock;
        begin // returns the starting point of the items belonging to the span at the front of the list, and advances to the next span on the queue, freeing the old memory block if the returned span was the last one in its memory block
          with SpanQueue__ do with MemoryBlocks do
            if Bottom<>nil then begin
               Result:=PSpanItem(Bottom)^.FirstItem;
               Inc(PSpanItem(Bottom));                                          // advance to the next span-item
               if Bottom=PSpanItem(Root) then begin                             // 'True': the returned span is the last one in its memory block
                  if   Root^.Next<>Root then                                    // 'True': there are more memory blocks attached to this queue
                       Bottom:=FirstItemInBlock(Root^.Next,ItemByteSize)        // point to the first item in the next memory block
                  else Bottom:=nil;                                             // 'nil': the queue is empty
                  OldBlock:=Root;
                  MemoryBlockListRemoveItem(OldBlock,SpanQueue__.MemoryBlocks); // remove the just finished memory block from the queue
                  MemoryBlockListAddItem   (OldBlock,Queues. FreeMemoryBlocks); // add the just finished block to the free-list
                  end;
               end
            else Result:=nil;                                                   // 'nil': the span queue is empty
        end; // DequeueSpan

        function  EnlargeQueue(BlockByteSize__:Cardinal; var Queue__:TQueue):Boolean;
        var NewBlock:PMemoryBlock;
        begin // adds a new memory block to the queue and prepares the queue for adding items to the new block
          with Queue__ do begin
            Result:=AllocateMemoryBlock(BlockByteSize__,NewBlock,Queues.FreeMemoryBlocks);
            if Result then begin                                                // 'True': allocating a new memory block succeeded
               MemoryBlockListAddItem(NewBlock,MemoryBlocks);                   // add the new block to the list of blocks attached to the queue

               // a memory block is represented by its 'TMemoryBlock'
               // data-structure with the links to other blocks;
               // this data-structure is located at the end of the memory block,
               // after its data area; that way, the memory block is its own
               // end-of-data-area pointer
               Block:=NewBlock;                                                 // make the new block the one in use for enqueueing new items
               Top:=FirstItemInBlock(Block,ItemByteSize);                       // 'Top' is the memory address of the next free item; here it's initialized so it points to the beginning of the new memory block
               Result:=Top<>PQueueItem(Block);                                  // 'True': the memory block has room for at least 1 item
               if Result and (Bottom=nil) then Bottom:=Top;                     // 'True': this is the first block on the list
               end;
            end;
        end; // EnlargeQueue

        function  EnqueueGameState(GameState__:TGameState; PushAncestor__:PQueueItem; var GameStateQueue__:TQueue):Boolean;
        begin // enqueues a game-state and its push-ancestor on a game-state queue, i.e., the moves-queue, the pushes-queue, or the boxlines-queue
          with GameStateQueue__ do begin
            Result:=(Top<>Block) or                                             // 'Block' is both the currently selected memory block and the end of its own data area
                    EnlargeQueue(QUEUE_MEMORY_BLOCK_BYTE_SIZE,GameStateQueue__);
            if Result then with PQueueItem(Top)^ do begin                       // 'True': there is room for a new item on the queue
               GameState:=GameState__; PushAncestor:=PushAncestor__;
               Inc(PQueueItem(Top));                                            // advance to the next free item on the queue, if any (if the memory block is full, then 'Top' is now identical to 'Queue__.Block')
               end;
            end;
        end; // EnqueueGameState

        function  LastItemOnQueue(const Queue__:TQueue):Pointer;
        begin // returns the last item on the queue, if any
          with Queue__ do
            if   Top<>nil then begin
                 Cardinal(Result):=Cardinal(Top)-ItemByteSize;                  // 'Top' points right after the most recently added item on the queue, hence, the last item is located 'ItemByteSize' bytes before the top
                 if Cardinal(Result)<Cardinal(Block.Memory) then Result:=nil;   // 'True': the queue is empty
                 end
            else Result:=nil;
        end; // LastItemOnQueue

        function  MakeSpansForMovesAndPushes(ReuseEmptySpans__:Boolean):Boolean;
        begin // creates new open-ended spans for the moves-queue as well as the pushes-queue
          with Queues do
            Result:=(ReuseEmptySpans__
                     and
                     IsEmptySpan(LastItemOnQueue(PushSpansQueue),PushSpansQueue,PushesQueue)
                     and                                                        // if the last span on both queues are empty, then these spans may be recycled instead of creating new ones
                     IsEmptySpan(LastItemOnQueue(MoveSpansQueue),MoveSpansQueue,MovesQueue)
                    )
                    or
                    (MakeSpan(PushesQueue.Top,PushSpansQueue)                   // make a new span for the pushes-queue, in effect adding a terminator after any pushes added by a previous iteration
                     and
                     MakeSpan(MovesQueue .Top,MoveSpansQueue)                   // make a new span for the moves-queue,  in effect adding a terminator after any moves  added by a previous iteration
                    );
        end; // MakeSpansForMovesAndPushes

        function  MakeSpansForMovesAndPushesAndBoxLines:Boolean;
        begin
          with Queues do
            Result:=MakeSpan(PushesQueue  .Top,PushSpansQueue)
                    and
                    MakeSpan(MovesQueue   .Top,MoveSpansQueue)
                    and
                    MakeSpan(BoxLinesQueue.Top,BoxLineSpansQueue);
          if not Result then StopSearch;
        end; // MakeSpansForMovesAndPushesAndBoxLines

        function  MakeSpan(FirstItem__:PQueueItem; var SpanQueue__:TQueue):Boolean;
        begin // enqueues a span starting point on the span-queue
          with SpanQueue__ do begin
            Result:=(Top<>Block) or                                             // 'Block' is both the currently selected memory block and the end of its own data area
                    EnlargeQueue(QUEUE_MEMORY_BLOCK_BYTE_SIZE,SpanQueue__);
            if Result then with PSpanItem(Top)^ do begin                        // 'True': there is room for a new item on the queue
               FirstItem:=FirstItem__;
               Inc(PSpanItem(Top));                                             // advance to the next free item on the queue, if any (if the memory block is full, then 'Top' is now identical to 'SpansQueue.Block')
               end;
            end;
        end; // MakeSpan

        function  NextItemOnQueue(Item__:Pointer; MemoryBlock__:PMemoryBlock; const Queue__:TQueue):Pointer;
        begin // returns the next item on the queue, if any; precondition: 'Item__' belongs to the given memory block
          if   (Item__<>Queue__.Top) and (Item__<>nil) then begin               // 'True': this isn't the last item on the queue
               Result:=Pointer(Cardinal(Item__)+Queue__.ItemByteSize);
               if Result=MemoryBlock__ then                                     // 'True': 'Item__' is the last item in its memory block
                  Result:=FirstItemInBlock(MemoryBlock__^.Next,Queue__.ItemByteSize); // the next item is the first one in the next memory block
               end
          else Result:=nil;
        end; // NextItemOnQueue

        // end of queue functions

        function  CheckIntermediatePositionsOnBestFoundPath(var LastVisitedPosition__:POptimizerPosition):Boolean;
        var BoxConfigurationIndex,MatchingGameStatesCount:Integer;
            GameState:TGameState;
            BoxConfiguration:TBoxConfiguration;
            Position,OldSliceEndPosition:PPosition;

          function  FindMatchingGameStates(BoxConfigurationIndex__:Integer; Position__:PPosition; var {io:} Queue__:TQueue; var {io:} NewBestPath__:Boolean):Integer;
          var GameState:TGameState; Item:PQueueItem; EndOfBlock:PMemoryBlock;

            function  IsPlayerSquareInPlayersAccessArea(PlayerSquareNo__,BoxConfigurationIndex__:Integer; ClearVisitedAccessArea__:Boolean):Boolean;
            var ExternalSquareNo:Integer; Direction:TDirection; GameState,GameState1:TGameState;
            begin // returns 'True' if  the square 'PlayerSquareNo__' belongs to the player's access area for the current game board;
                  // as a side-effect, the function can clear the 'IsVisited' flag for all squares in the current access area (not used)
              with Solver.SearchStates[0].PlayersReachableSquares do begin
                ExternalSquareNo:=PlayerInternalToExternalSquare[PlayerSquareNo__];
                Result:=(Squares[ExternalSquareNo]>TimeStamp) and (not IsAWallSquare(ExternalSquareNo));
                if ClearVisitedAccessArea__ then
                   for PlayerSquareNo__:=0 to Pred(PlayerSquareCount) do begin
                       ExternalSquareNo:=PlayerInternalToExternalSquare[PlayerSquareNo__];
                       if (Squares[ExternalSquareNo]>TimeStamp) and (not IsAWallSquare(ExternalSquareNo)) then begin
                          GameState:=TGameState(Cardinal(BoxConfigurationIndex__)*PlayerSquareCount+Cardinal(PlayerSquareNo__));
                          if Optimizer.Optimization<opBoxLinesMoves then begin
                             if IsVisited(GameState) then ResetVisited(GameState);
                             end
                          else begin
                             GameState:=GameState*GAME_STATE_MULTIPLICATION_FACTOR_FOR_BOXLINES_SEARCH;
                             if IsVisited(GameState) then ResetVisited(GameState);
                             for Direction:=Low(Direction) to High(Direction) do begin
                                 GameState1:=GameState+Cardinal(Succ(DIRECTION_TO_AXIS[Direction]));
                                 if IsVisited(GameState1) then ResetVisited(GameState1);
                                 end;
                             end;
                          end;
                       end;
                end;
            end; // IsPlayerSquareInPlayersAccessArea

          begin // 'FindMatchingGameStates';
                // searches for game-states on the queue with a matching
                // box configuration, and where the player-position is in the
                // same access area as 'Position.PlayerPos';
                // precondition: the player's access area has been calculated
                // using depth index '0';
                // returns the number of matching game-states;
            Result:=0;
            if Queue__.MemoryBlocks.Root<>nil then with Queue__ do begin
               EndOfBlock:=MemoryBlocks.Root;
               Item:=FirstItemInBlock(EndOfBlock,ItemByteSize); // start the search from the first item on the queue
               while Item<>Top do begin
                 if Item<>PQueueItem(EndOfBlock) then begin // 'True': the item belongs to the current memory block
                    GameState:=Item^.GameState;
                    if   Optimizer.Optimization>=opBoxLinesMoves then
                         GameState:=GameState div GAME_STATE_MULTIPLICATION_FACTOR_FOR_BOXLINES_SEARCH;
                    if   ((GameState div PlayerSquareCount)=Cardinal(BoxConfigurationIndex__)) // 'True': the box positions match
                         and
                         IsPlayerSquareInPlayersAccessArea(GameState mod PlayerSquareCount,
                                                           BoxConfigurationIndex__,
                                                           False) then begin
                         // the player is in the access area for 'Item^.GameState';
                         // now check if 'Item' is a member of a new best path
                         Inc(Result); // count the number of matching game-states
                         if        IsNewBetterPath(Item,POptimizerPosition(Position__^.Successor)) then begin // 'True': found a new better path
                                   NewBestPath__:=True;
                                   Item         :=Top;                          // break out from the 'while' loop
                                   end
                         else if   (PlayerInternalToExternalSquare[GameState mod PlayerSquareCount]=Position__^.PlayerPos) and // 'True': 'Item' is identical to the best path position, with matching box-configuration and player-position
                                   (Optimizer.Optimization<opBoxLinesMoves) then // 'True': this isn't a boxlines optimzation, in which case the same game-state may exist with the player entering its square from a different direction
                                   Item:=Top                                    // break out from the 'while' loop
                              else Inc(Item);                                   // advance to the next item
                         end
                    else Inc(Item);                                             // advance to the next item
                    end
                 else                                                           // advance to the next memory block
                    AdvanceToNextMemoryBlock(False,Pointer(Item),Queue__,EndOfBlock);
                 end;
               end;
          end; // FindMatchingGameStates

        begin // CheckIntermediatePositionsOnBestFoundPath; tests if the search found a better path to any of the intermediate positions on the path
          Result:=False;
          OldSliceEndPosition    :=PPosition(SliceEndPosition);
          Position               :=PPosition(SliceEndPosition);                 // work backwards from the end of the current slice
          LastVisitedPosition__  :=SliceStartPosition;                          // the slice start position has been visited, hence, it's a lower bound

          while (Position<>nil) and (Position<>PPosition(SliceStartPosition)) do begin // search backwards from the last slice position and find the last position on the path that has been visited by the vicinity-search
            SetPosition(Position);
            LoadBoxConfigurationFromGame(BoxConfiguration);
            BoxConfigurationIndex:=LookupBoxConfiguration(BoxConfiguration);    // check if the game position exists in the box configuration collection
            if BoxConfigurationIndex<>NONE then begin                           // 'True': the game position exists in the box configuration collection
               GameState:=TGameState(BoxConfigurationIndex)*PlayerSquareCount+Cardinal(PlayerExternalToInternalSquare[Position^.PlayerPos]);
               if Optimizer.Optimization>=opBoxLinesMoves then
                  GameState:=(GameState*GAME_STATE_MULTIPLICATION_FACTOR_FOR_BOXLINES_SEARCH)+Cardinal(Succ(Ord(DIRECTION_TO_AXIS[TDirection(Ord(Position^.Move.Direction) and DIRECTION_BIT_MASK)])));
               if IsVisited(GameState) then with Queues do begin                // 'True': this position on the existing best found path has been visited during the search
                  //ShowBoard;
                  //Write('Pushes: ',Position^.PushCount);
                  //Write(' Visited'); Readln;
                  if LastVisitedPosition__=SliceStartPosition then
                     LastVisitedPosition__:=POptimizerPosition(Position);       // update the last visited position on the best found path

                  if Position<>OldSliceEndPosition then begin // if it's the end of the slice then the search went all the way, and the check for a new best path has already been done during the search
                     CalculatePlayersDistanceToReachableSquares(0);             // calculate the player's distance to the reachable squares
                     MatchingGameStatesCount:=FindMatchingGameStates(BoxConfigurationIndex,Position,PushesQueue  ,Result)
                                              +
                                              FindMatchingGameStates(BoxConfigurationIndex,Position,BoxLinesQueue,Result);
                     if MatchingGameStatesCount=0 then begin
                        {$IFDEF CONSOLE_APPLICATION}
                          InternalError('Search.CheckIntermediatePositionsOnBestFoundPath');
                        {$ENDIF}
                        end;
                     end
                  else // the position is the end-of-slice position, or there are currently no pushes on the queue
                     Result:=False;                                             // the search went all the way to the end of the slice without finding a new better path

                  Position:=YASS.Positions.StartPosition;                       // break out from the 'while' loop after having found a position on the best path which has been visited by the vicinity-search
                  end;
               end;
            Position:=Position^.Parent;                                         // backtrack to the previous push on the exiting best found path
            end;
        end; // OptimizeGame.Search.VicinitySearch.Search.CheckIntermediatePositionsOnBestFoundPath

        function  DumpPath(Item__:PQueueItem):Boolean; // debugging service function
        var OldBoxCount,OldPlayerSquare:Integer;
            GameState:TGameState;
            OldBoard:TBoard; OldBoxPos:TBoxSquares;
            PathLength:Integer;
        begin
          Result:=False;
          OldBoard:=Game.Board; OldPlayerSquare:=Game.PlayerPos; OldBoxCount:=Game.BoxCount; OldBoxPos:=Game.BoxPos;

          PathLength:=CalculateQueueItemPushPathLength(Item__);

          LogFile.Enabled:=True;
          if CreateLogFile('zzz.txt') then begin
             while Item__<>nil do begin
               GameState:=Item__^.GameState;
               if Optimizer.Optimization>=opBoxLinesMoves then
                 GameState:=GameState div GAME_STATE_MULTIPLICATION_FACTOR_FOR_BOXLINES_SEARCH;
               SavePlayerAndBoxConfigurationToGame(GameState mod PlayerSquareCount,GetBoxConfigurationByIndex(GameState div PlayerSquareCount)^);
               WriteBoardToLogFile(IntToStr(PathLength));
               Item__:=PQueueItem(Cardinal(Item__^.PushAncestor) and (not DIRECTION_BIT_MASK));
               Dec(PathLength);
               end;
             Result:=CloseLogFile;
             end;

          Game.Board:=OldBoard; Game.PlayerPos:=OldPlayerSquare; Game.BoxCount:=OldBoxCount; Game.BoxPos:=OldBoxPos;
        end; // DumpPath

        function  GetBoxConfigurationByIndex(Index__:Integer):PBoxConfiguration;
        begin
          Result:=PBoxConfiguration(Cardinal(BoxConfigurations.First)+Cardinal(Index__*BoxConfigurationByteSize));
        end; // GetBoxConfigurationByIndex

        function  Initialize:Boolean;                                           // initializes searching for a best path through the current slice of the game; don't confuse the search initialization with the vicinity-search method initialization
        var BoxConfiguration:TBoxConfiguration;
            // BoxConfigurationIndex:Integer; Position:POptimizerPosition;
            // i:Integer; p:PBoxConfiguration; t:TTimeMS;

          function  MakeQueues(var Queues__:TQueues):Boolean;
          begin // initializes the open-queue for the (breadth-first) vicinity search
            Result:=True;
            FillChar(Queues__,SizeOf(Queues__),0);
            // queues are implemented using low-level programming-techniques
            // (e.g., no object-oriented programming), and therefore each queue
            // must carry its own item byte-size
            if Optimizer.Optimization>=opBoxLinesMoves then begin // 'True': the search uses a third boxlines-queue together with the moves-queue and the pushes-queue
               Queues__.BoxLinesQueue    .ItemByteSize:=SizeOf(TQueueItem); // the non-zero value indicates that the queue is in use; pushes which don't require one more boxline are stored on the boxlines-queue
               Queues__.BoxLineSpansQueue.ItemByteSize:=SizeOf(TSpanItem );
               end;
            Queues__.MovesQueue          .ItemByteSize:=SizeOf(TQueueItem);
            Queues__.MoveSpansQueue      .ItemByteSize:=SizeOf(TSpanItem );
            Queues__.PushesQueue         .ItemByteSize:=SizeOf(TQueueItem);
            Queues__.PushSpansQueue      .ItemByteSize:=SizeOf(TSpanItem );
          end; // MakeQueues

          function  MakeVisitedArea(var VisitedArea__:PByteVector):Boolean;
          var ByteSize:Integer;
          begin // reserves and initializes a memory area for the bookkeeping of visited game-states, i.e., [box configuration, player square] tuples
            ByteSize:=CalculateDataStructuresByteSize(BoxConfigurations.Count,[dstVisitedBitSet]);
            VisitedArea__:=GetMemory(ByteSize,True);                            // 'True': allocate the memory from the top; it's not strictly necessary, but it doesn't hurt either
            Result:=VisitedArea__<>nil;
            if Result then FillChar(VisitedArea__^,ByteSize,0);                 // clear the bits, i.e., mark all game-states as 'not Visited'
          end; // MakeVisitedArea

        begin // Initialize
{
          t:=GetTimeMS;
          i:=0;
          while LookupLoopCount<120*ONE_MILLION do begin
            p:=GetBoxConfigurationByIndex(i);
            LookupBoxConfiguration(p^);
            if i<BoxConfigurations.Count then Inc(i)
            else i:=0;
            end;
          t:=CalculateElapsedTimeMS(t,GetTimeMS);
          Msg(IntToStr(t),'Time');
}
          {$WARNINGS OFF}                                                       // precondition checks
            {warning: Comparison always evaluates to True}
            Result:=SizeOf(TGameState)=SizeOf(YASS.Positions.BestPosition^.GameState); {the vicinity-search stores the game-state for each position on the best path}
          {$WARNINGS ON}
          if not Result then InternalError('Search.Initialize');                // the queue doesn't work efficiently if the spans embedded in the queue cause havoc to the alignment of the queue items

          Optimizer.SearchStateStatusText:='';
          if   Optimizer.Optimization=opMovesPushes then
               SearchDepth:=SliceStartPosition^.MoveCount                       // instead of a 0-based relative search depth, it's more convenient that the count follows the number of moves/pushes in the game
          else SearchDepth:=SliceStartPosition^.Position.PushCount;
          SearchSliceHasTerminated:=False;

          {$IFDEF CONSOLE_APPLICATION}
            LastConsoleStatusMoveCount:=0;
          {$ENDIF}

          // load the start position
          SetPosition(PPosition(SliceStartPosition));
          LoadBoxConfigurationFromGame(BoxConfiguration);
          StartBoxConfigurationIndex:=LookupBoxConfiguration(BoxConfiguration);
          StartPlayerSquare:=PlayerExternalToInternalSquare[Game.PlayerPos];

          // load the target position
          SetPosition(PPosition(SliceEndPosition));
          LoadBoxConfigurationFromGame(BoxConfiguration);
          TargetBoxConfigurationIndex:=LookupBoxConfiguration(BoxConfiguration);
          TargetPlayerSquare:=PlayerExternalToInternalSquare[Game.PlayerPos];
{
          // calculate the game-state for each position on the path through the
          // current slice
          // (not in production because currently this information isn't used)
          Position:=SliceEndPosition;
          repeat SetPosition(PPosition(Position));
                 LoadBoxConfigurationFromGame(BoxConfiguration);
                 BoxConfigurationIndex:=LookupBoxConfiguration(BoxConfiguration);
                 if   BoxConfigurationIndex<>NONE then                            // 'True': the game position exists in the box configuration collection
                      Position^.Position.GameState:=TGameState(BoxConfigurationIndex)*PlayerSquareCount+Cardinal(PlayerExternalToInternalSquare[Position^.Position.PlayerPos])
                 else Position^.Position.GameState:=0;                          // this shouldn't happen
                 Position:=POptimizerPosition(Position^.Position.Parent);
          until  (Position=nil) or (Position^.Position.Successor=PPosition(SliceStartPosition));
          SetPosition(nil);                                                     // reset the game
}
          // initialize the search for the current slice
          Result:=Result and
                  (StartBoxConfigurationIndex <>NONE) and (StartPlayerSquare <>NONE) and
                  (TargetBoxConfigurationIndex<>NONE) and (TargetPlayerSquare<>NONE) and // 'True': both the start position and the target position exist in the box configuration vector (a sanity check)
                  (SliceStartPosition<>SliceEndPosition) and
                  MakeVisitedArea(VisitedArea) and                              // reserve and initialize a memory area to support the 'IsVisited()' and 'SetVisited()' functions
                  MakeQueues     (Queues     ) and                              // initialize the queues
                  (not SearchHasTerminated);                                    // the search may have been terminated before it starts
        end; // Initialize

        function  IsNewBetterPath(QueueItem__:PQueueItem; RestPath__:POptimizerPosition):Boolean;
        // postcondition: if the new path is  a new best path, then it's saved
        // and thereby it invalidates all the search data for the current slice;
        // therefore, the caller must be careful not to touch any search data
        // if 'IsNewBetterPath()' succeeds
        var OldBestPathPushCount:Integer;
            NewBestPathIsASolution:Boolean; NewGameMetrics:TOptimizerGameMetrics;
            FirstPosition:POptimizerPosition; MemoryMark:TMemoryBlock;

          function  MakeParentLinksFromSuccessorLinks:PPosition; forward;

          function  CalculatePathMetrics(FirstPosition__:POptimizerPosition; var GameMetrics__:TOptimizerGameMetrics; var PathIsASolution__:Boolean):Boolean;
          var b:Boolean; OldSuccessor:PPosition;
          begin
            SetPosition(nil);
            OldSuccessor:=SliceStartPosition^.Position.Successor;
            SliceStartPosition^.Position.Successor:=PPosition(FirstPosition__); // re-direct the game path to go through this path
            YASS.Positions.BestPosition:=MakeParentLinksFromSuccessorLinks;     // install parent links for this path before calling 'CalculateMetricsForPositionsOnBestPath', thereby faking that this path is the best path
            Result:=CalculateMetricsForPositionsOnBestPath(b);                  // 'CalculateMetricsForPositionsOnBestPath' returns 'True' if the new path is legal
            GameMetrics__:=Optimizer.GameMetrics;                               // return the metrics for the path
            PathIsASolution__:=Game.SimpleLowerbound=0;                         // return whether the path is a solution
            SetPosition(nil);                                                   // undo the pushes performed by 'CalculateMetricsForPositionsOnBestPath'

            SliceStartPosition^.Position.Successor:=OldSuccessor;               // restore the existing best path
            YASS.Positions.BestPosition:=MakeParentLinksFromSuccessorLinks;     // restore parent links for the existing best path
            if   CalculateMetricsForPositionsOnBestPath(b) then begin           // recalculate the metrics for the existing best path
                 end
            else Result:=InternalError('Search.IsNewBetterPath.CalculatePathMetrics');
            SetPosition(nil);                                                   // undo the pushes performed by 'CalculateMetricsForPositionsOnBestPath'
          end; // CalculatePathMetrics

          function  MakeParentLinksFromSuccessorLinks:PPosition;
          begin // updates parent links so they match the successor links for the best found path; returns the last position on the path, i.e., the best position
            Result:=YASS.Positions.StartPosition;
            while Result^.Successor<>nil do begin
              Result^.Successor^.Parent:=Result;
              Result:=Result^.Successor;                                        // upon return, 'Result' contains the last position on the path
              end;
          end; // MakeParentLinksFromSuccessorLinks

          function  MakePath(QueueItem__        :PQueueItem;
                             RestPath__         :POptimizerPosition;
                             var FirstPosition__:POptimizerPosition):Boolean;
          var BoxConfigurationIndex,BoxSquareNo,Count,PlayerSquare:Integer;
              GameState:TGameState; BoxConfiguration:PBoxConfiguration;
          begin
            FirstPosition__          :=RestPath__;                              // upon return, 'FirstPosition__' contains the head of the new list of positions leading through the current slice of the game

            // calculate length of the push path leading to the game-state represented by 'QueueItem__^'; the path root node is not counted
            Count:=CalculateQueueItemPushPathLength(QueueItem__);

            Result:=(NewPathPositions<>nil) and (Count<=MaxSearchDepth);        // 'True' the memory area reserved for a new best path is present and big enough enough to hold the new path

            // build the new path through the current slice of the game
            while Result and (QueueItem__<>nil) and (Count>0) do begin
              GameState              :=QueueItem__^.GameState;                  // unpack this push
              if Optimizer.Optimization>=opBoxLinesMoves then
                 GameState           :=GameState div GAME_STATE_MULTIPLICATION_FACTOR_FOR_BOXLINES_SEARCH;
              BoxConfigurationIndex  :=GameState div PlayerSquareCount;
              PlayerSquare           :=GameState mod PlayerSquareCount;
              Dec(Count);                                                       // 'Count' is used as a count-down index into the new positions vector
              with NewPathPositions^[Count] do begin                            // fill in the player position and the hash-value for the new position; later, 'HasALegalPush' uses this information to fill in the correct box number and direction
                FillChar(Position,SizeOf(Position),0);                          // clear the new position, in particular, the hash-value and the box number (box number = 0 forces 'HasALegalPush' to find the box number)
                Position.PlayerPos   :=PlayerInternalToExternalSquare[PlayerSquare];
                BoxConfiguration     :=GetBoxConfigurationByIndex(BoxConfigurationIndex);

                for BoxSquareNo:=0 to Pred(BoxSquareCount) do
                    if IsABoxSquare(BoxSquareNo,BoxConfiguration^) then with Position do
                       HashValue:=HashValue xor YASS.Positions.SquareHashValues[BoxInternalToExternalSquare[BoxSquareNo]];
                Position.Successor   :=PPosition(FirstPosition__);              // link to the next position on the new path
                FirstPosition__      :=Addr(Position);                          // this is now the head of the successor-linked list of positions on the new path
                QueueItem__          :=PQueueItem(Cardinal(QueueItem__^.PushAncestor) and (not DIRECTION_BIT_MASK)); // backtrack to the previous push on the found path
                end;
              end;

            Result:=Result and (Count=0) and (FirstPosition__<>RestPath__) and  // 'True': there is a new non-empty path
                    (QueueItem__<>nil) and
                    (PQueueItem(Cardinal(QueueItem__.PushAncestor) and (not DIRECTION_BIT_MASK))=nil); // 'True': all items on the path were processed
            if (not Result) and
               (not ((Optimizer.Optimization>=opBoxLinesMoves) and (Count>MaxSearchDepth))) then // optimizing boxlines may produce paths with more pushes than the reserved memory can accomodate; in that case silently discard the path
               InternalError('Search.IsNewBetterPath.MakePath');
          end; // MakePath

          function  IsNewPathBetter(FirstPosition__:POptimizerPosition; var NewGameMetrics__:TOptimizerGameMetrics; var NewPathIsASolution__:Boolean):Boolean;
          begin
            Result:=CalculatePathMetrics(FirstPosition__,NewGameMetrics__,NewPathIsASolution__);
            if   Result then begin                                              // 'True': the new path is legal
                 Optimizer.GameMetrics:=NewGameMetrics__;                       // trick 'HasABetterOrEqualScore' to compare scores for the existing best position and the new path (it's unnecessary to save/restore the game metrics here)
                 Optimizer.GameMetrics.HasPlayerLines:=True;
                 Result:=not HasABetterOrEqualScore(YASS.Positions.BestPosition);
                 Optimizer.GameMetrics.HasPlayerLines:=False;
                 end
            else FillChar(NewGameMetrics__,SizeOf(NewGameMetrics__),0);
          end; // IsNewPathBetter

          function  SaveNewBestPath(FirstPosition__:PPosition; NewBestPathIsASolution__:Boolean):Boolean;
          var SliceStartPushCount,SliceEndPushCount:Integer; b:Boolean; {p1,p2,}Position:PPosition;
          begin
            SetPosition(nil);
            OldBestPathPushCount:=YASS.Positions.BestPosition.PushCount;
            {
            p1:=SliceStartPosition^.Position.Successor; p2:=FirstPosition__;
            while Assigned(p1) and Assigned(p2) and
                  (p1^.Move.BoxNo=p2^.Move.BoxNo) and
                  ((Ord(p1^.Move.Direction) and DIRECTION_BIT_MASK)=(Ord(p2^.Move.Direction) and DIRECTION_BIT_MASK)) do begin
              p1:=p1^.Successor; p2:=p2^.Successor;
              end;
            if Assigned(p1) and (p1<>SliceStartPosition^.Position.Successor) then begin
               Writeln;
               Write(SliceStartPosition^.Position.Successor^.PushCount,COLON,SPACE,p1^.PushCount);
               Readln;
               end;
            }
            SliceStartPosition^.Position.Successor:=FirstPosition__;            // install the new first push as the successor of the start position for the currently investigated slice of the game
            MakeParentLinksFromSuccessorLinks;                                  // update parent links so they match successor links for the new best path

            Position:=PPosition(SliceStartPosition);
            while Position^.Successor<>nil do Position:=Position^.Successor;    // find last position on the best path, i.e., the (possibly new) best position
            UpdateBestPosition(Position);                                       // update best position
            if NewBestPathIsASolution__ then YASS.Positions.SolutionPosition:=Position; // update best solution

            Result:=CalculateMetricsForPositionsOnBestPath(b);                  // update the metrics for the positions on the new best path; 'CalculateMetricsForPositionsOnBestPath' returns 'True' if the new path is legal
            if not Result then InternalError('Search.IsNewBetterPath.SaveNewBestPath A');
            SetPosition(nil);                                                   // undo the pushes performed by 'CalculateMetricsForPositionsOnBestPath'
            SliceStartPushCount:=SliceStartPosition^.Position.PushCount;        // remember the number of pushes for the current slice before the purge; it compacts the positions so they may change address
            SliceEndPushCount  :=SliceEndPosition  ^.Position.PushCount;        // remember the number of pushes for the current slice before the purge; it compacts the positions so they may change address

            Result:=Result and
                    // 'TTPurge': purging compacts the best path at the bottom
                    // of the memory; it invalidates the vicinity search memory
                    // pool;
                    // 'Succ(OldBestPathPushCount)': +1 for the start position,
                    // which itself contains the number of tubefilling pushes
                    // performed on the board before the search
                    (TTPurge(Succ(OldBestPathPushCount)-Positions.StartPosition^.PushCount,False)>=0) and
                    InitializeMemoryPool(MemoryPool,                            // reallocate the available memory after the purge
                                         VicinitySquares.Squares);              // protect the upper memory area containing the vicinity squares; the rest of the memory area is available for the search, e.g., box-configurations and open-queues
            if Result then begin
               // check if simple box-changes can improve the game further;
               if (not RearrangementOptimization(False,True,False,False,False)) and // if 'RearrangementOptimization' improves the game then it updates the log, hence, don't update the log twice
                  (Optimizer.Result<>prFailed) then WriteBestPathToLogFile;     // 'prFailed': 'RearrangementOptimization' may have failed and thereby invalidated the solution
               // note that with the current machinery, it's not possible to use
               // 'RearrangementOptimization()' on the raw new candidate before
               // it's calculated whether the new path is better; it could (at
               // least theoretically) violate the 'TTPurge()' constraint that
               // injected new positions for the analyzed slice must be in
               // ascending memory address order; otherwise, overwriting could
               // happen during the path compaction;

               Result:=CalculateMetricsForPositionsOnBestPath(b);               // update the metrics for the positions on the new best path; 'CalculateMetricsForPositionsOnBestPath' returns 'True' if the new path is legal
               if not Result then InternalError('Search.IsNewBetterPath.SaveNewBestPath B');
               SetPosition(nil);                                                // undo the pushes performed by 'CalculateMetricsForPositionsOnBestPath'

               // try to find the slice boundaries after the purge;
               // the positions may have been relocated;
               // the original 'SliceEndPosition' may not be a member of the
               // path anymore;
               // theoretically, the game-state hashvalues aren't guaranteed to
               // be unique; that's why they are not used for the identification
               // of the slice boundary positions;
               // the new 'SliceEndPosition' may be nil, because the new path
               // can be shorter than the original path
               SliceStartPosition:=PositionOnBestPathWithPushNumber(SliceStartPushCount);
               SliceEndPosition  :=PositionOnBestPathWithPushNumber(SliceEndPushCount);
               end
            else begin                                                          // 'not Result': if something goes wrong then stop the search
               TerminateSearch;
               Queues.BoxLinesQueue.MemoryBlocks.Root:=nil;                     // 'nil': avoid that 'CheckIntermediatePositionsOnBestFoundPath' checks positions on the existing best path
               Queues.PushesQueue  .MemoryBlocks.Root:=nil;                     // 'nil': avoid that 'CheckIntermediatePositionsOnBestFoundPath' checks positions on the existing best path
               end;
            StopSearch;                                                         // 'TTPurge()' and 'InitializeMemoryPool' invalidate the existing search data, so the current search must be terminated
            Optimizer.SearchStateStatusText:=''; ShowStatus;
          end; // SaveNewBestPath

        begin // IsNewBetterPath; checks whether the new found path is better than the existing one, in which case the best path is updated
          MarkMemory(MemoryMark);

          Result:=MakePath(QueueItem__,RestPath__,FirstPosition)
                  and
                  IsNewPathBetter(FirstPosition,NewGameMetrics,NewBestPathIsASolution)
                  and
                  SaveNewBestPath(PPosition(FirstPosition),NewBestPathIsASolution);

          ReleaseMemory(MemoryMark);                                            // release any memory allocated by 'MakePath'; if a new best path has been found then it doesn't matter; in that case, the caller must not continue the search anyway
        end; // IsNewBetterPath

        function  IsVisited(GameState__:TGameState):Boolean;
        begin // returns 'True' if the game state [box configuration, player square] represented by 'GameState__' has been visited
          Result:=(VisitedArea^[GameState__ div BITS_PER_BYTE] and (1 shl (GameState__ mod BITS_PER_BYTE)))<>0;
        end; // IsVisited

        function  IsEmptySpan(SpanItem__:PSpanItem; const SpanQueue__,MovesOrPushesQueue__:TQueue):Boolean;
        begin // returns 'True' if the span doesn't contain any queue items; precondition: the last span on the span-queue hasn't been expanded (the program never expands the last open-ended span, so this should not happen)
          if   SpanItem__=LastItemOnQueue(SpanQueue__) then                     // 'True': the span is the last span on the span-queue
               Result:=SpanItem__^.FirstItem=MovesOrPushesQueue__.Top           // 'True': no game-items have been added to the corresponding moves/pushes-queue since the span was created
          else                                                                  // try harder: find out where the next span begins
               Result:=SpanItem__^.FirstItem=PSpanItem(NextItemOnQueue(SpanItem__,
                                                                       FindMemoryBlockWithItem(SpanItem__,SpanQueue__.MemoryBlocks), // find the memory block to which the span-item belongs
                                                                       SpanQueue__
                                                                      ))^.FirstItem; // the span is empty if the next span has the same starting point
        end; // IsEmptySpan
(*
        function  LookupBoxConfiguration(const BoxConfiguration__:TBoxConfiguration):Integer;
        var TernarySearchTreeItem:PTernarySearchTreeItem;
        begin
          if   TSTLookup(BoxConfiguration__,BoxConfigurationsTernarySearchTree,TernarySearchTreeItem) then
               Result:=TernarySearchTreeItem^.Value
          else Result:=NONE;
        end; // LookupBoxConfiguration
*)

        function  LookupBoxConfiguration(const BoxConfiguration__:TBoxConfiguration):Integer;
        var i:Integer; //HashKey:Cardinal;
        begin
//        if BFLookup(BoxConfiguration__,BloomFilter,HashKey) then begin        // 'True': there is a chance that the position exists in the collection (a Bloom filter can return false positives but never false negatives)
             Result:=0;
             while Result<BoxConfigurations.Count do begin
               i:=CompareBoxConfigurations(BoxConfiguration__,PBoxConfiguration(Cardinal(BoxConfigurations.First)+Cardinal(Result*BoxConfigurationByteSize))^);
               if      i<0 then Result:=(Result*2)+1
               else if i>0 then Result:=(Result*2)+2
                    else exit;                                                  // 'exit': quick-and-dirty exit the function when a matching box configuration has been found
               end;
//           end;                                                               // the Bloom filter is commented out because the running time improvement is too small to be worth it, approx. 5%
          Result:=NONE;                                                         // 'NONE': no matching box configuration was found in the collection
        end; // LookupBoxConfiguration

        function  OptimizeMovesOrPushesOrBoxLines(Optimization__:TOptimization):Boolean;
{
          function  Check__:Boolean;
          var p,q:PMemoryBlock;
          begin
            Result:=False; //exit;
            with Queues do with BoxLineSpansQueue do begin
              if (Bottom<>nil) and (PSpanItem(Bottom)^.FirstItem<>nil) then begin
                 p:=FindMemoryBlockWithItem(PSpanItem(Bottom)^.FirstItem,BoxLinesQueue.MemoryBlocks);
                 if p=nil then begin
                    Writeln('Ups: ',Solver.MoveCount);
                    //Writeln(TEXT_NO_YES[IsEmptySpan(PSpanItem(Bottom),BoxLineSpansQueue,BoxLinesQueue)]);
                    Readln;
                    Result:=True;
                    end;
                 end;
(*
              p:=MemoryBlocks.Root;
              if p<>nil then
                 repeat q:=Queues.MoveSpansQueue.MemoryBlocks.Root;
                        if q<>nil then
                           repeat  if p=q then
                                      Writeln('ups');
                           until   q=Queues.MoveSpansQueue.MemoryBlocks.Root;
                        p:=p^.Next;
                 until  p=MemoryBlocks.Root;
*)
              end;
          end;
}
          function  GenerateSuccessors(Item__,EndOfSpan__:PQueueItem;           // first item in the span, and a pointer just after the last item in the span
                                       IsPushesQueue__,
                                       FirstMarkPushesAsVisitedWhenTheyAreExpanded__,
                                       GenerateSuccessors__:Boolean;
                                       var SourceQueue__:TQueue;
                                       var SuccessorCount__:Cardinal):Boolean;
          var BoxNeighborSquare,BoxConfigurationIndex,NextBoxNeighborSquare,
              NewBoxConfigurationIndex,PlayerNeighborSquare,PlayerSquare:Integer;
              Direction:TDirection; GameState:TGameState;
              PushAncestor:PQueueItem; EndOfBlock:PMemoryBlock;
              BoxConfiguration, NewBoxConfiguration:PBoxConfiguration;
              BoxConfigurationCopy:TBoxConfiguration;
              DestinationQueue:PQueue;
              //oPlayerPos:Integer; oBoard:TBoard; oBoxPos:TBoxSquares;

          begin // GenerateSuccessors; generates successor game-states for all nodes on the queue belonging to the specified span
            Result:=False;
            if (Item__<>nil) and
               (not SearchSliceHasTerminated) then begin                        // 'True': the search hasn't been terminated
               //if Item__<>SourceQueue__.Bottom then
               //   InternalError('OptimizeMovesOrPushesOrBoxLines.GenerateSuccessors');

               EndOfBlock:=FindMemoryBlockWithItem(Item__,SourceQueue__.MemoryBlocks); // find the memory block that contains the first item; a memory block is its own end-of-data-area pointer; that's why it's used here as 'EndOfBlock'
               if EndOfBlock=nil then begin
                  {$IFDEF CONSOLE_APPLICATION}
                    InternalError('OptimizeMovesOrPushesOrBoxLines.GenerateSuccessors: '+IntToStr(Solver.MoveCount)+SLASH+IntToStr(Solver.PushCount));
                  {$ENDIF}
                  StopSearch;
                  end;

               if (Item__=PQueueItem(EndOfBlock)) and (Item__<>EndOfSpan__) then // 'True': advance to the next memory block allocated to the queue
                  AdvanceToNextMemoryBlock(not IsPushesQueue__,Pointer(Item__),SourceQueue__,EndOfBlock); // there will always be a next block

               while Item__<>EndOfSpan__ do begin                               // for each item belonging to the span, or until the search terminates, generate successors and store them on one of the game-state queues (moves, pushes, or boxlines)
                 GameState               :=Item__^.GameState;
                 if FirstMarkPushesAsVisitedWhenTheyAreExpanded__ and IsPushesQueue__ then
                    if   not IsVisited(GameState) then begin                    // 'True': the game-state hasn't been expanded yet; it may exist at more than one moves-depth within the current push-depth contour)
                         SetVisited(GameState);
                         if not GenerateSuccessors__ then                       // 'True': the search is over; what remains is to mark all seen pushes as visited as a preparation for 'CheckIntermediatePositionsOnBestFoundPath'
                            GameState    :=High(GameState);                     // skip generating successors for this item and continue to the next item
                         end
                    else GameState       :=High(GameState);                     // 'High(GameState)' is a reserved value and it doesn't occur as a game-state on the queues

                 if GameState<>High(GameState) then begin                       // 'True': generate successors for this game-state
                    if Optimizer.Optimization>=opBoxLinesMoves then             // 'True': the game-state contains the last push direction axis
                       GameState         :=GameState div GAME_STATE_MULTIPLICATION_FACTOR_FOR_BOXLINES_SEARCH; // drop the last push direction axis from the game-state
                    BoxConfigurationIndex:=GameState div PlayerSquareCount;
//                  PlayerSquare         :=GameState mod PlayerSquareCount;
                    PlayerSquare         :=GameState-PlayerSquareCount*Cardinal(BoxConfigurationIndex); // 'mod' may be slow, hence, the player square is calculated this way instead
                    BoxConfiguration     :=PBoxConfiguration(Cardinal(BoxConfigurations.First)+Cardinal(BoxConfigurationIndex*BoxConfigurationByteSize)); // inlined 'GetBoxConfigurationByIndex()'
                    NewBoxConfiguration  :=nil;                                 // 'nil': the current box configuration hasn't been copied to 'BoxConfigurationCopy'

                    if   IsPushesQueue__ then                                   // 'True': this is the pushes-queue or the boxline-queue
                         PushAncestor    :=Item__                               // 'Item__' is a game-state which is the result of a push
                    else PushAncestor    :=Item__^.PushAncestor;                // each item carries its most recent push ancestor on the path leading to the item
{
                    if   Solver.MoveCount>=0 then begin
                         oPlayerPos:=Game.PlayerPos; oBoard:=Game.Board; oBoxPos:=Game.BoxPos;
                         SavePlayerAndBoxConfigurationToGame(PlayerSquare,BoxConfiguration^);
                         ShowBoard;
                         Writeln('Search depth: ',SearchDepth,' Moves: ',Solver.MoveCount,' Pushes: ',Solver.PushCount);
                         Readln;
                         Game.PlayerPos:=oPlayerPos; Game.Board:=oBoard; Game.BoxPos:=oBoxPos;
                         end;
}
                    for Direction:=Low(Direction) to High(Direction) do
                        if not Result then begin                                // 'True': the search data haven't been invalidated by a call to 'TTPurge()' after finding a new best path
                           PlayerNeighborSquare:=PlayerSquareNeighbor[PlayerSquare,Direction];
                           if PlayerNeighborSquare<>NONE then begin             // 'True': the square next to the player in this direction is a floor, possibly with a box
                              BoxNeighborSquare:=PlayerSquareToBoxSquare[PlayerNeighborSquare];
                              if (BoxNeighborSquare<>NONE) and                  // 'True': the square next to the player is a legal box square
                                 IsABoxSquare(BoxNeighborSquare,BoxConfiguration^) then begin // 'True': there is a box next to the player in this direction
                                 NextBoxNeighborSquare:=BoxSquareNeighbor[BoxNeighborSquare,Direction];
                                 if (NextBoxNeighborSquare<>NONE) and
                                    (not IsABoxSquare(NextBoxNeighborSquare,BoxConfiguration^)) then begin // 'True': the box can be pushed in this direction
                                    if Solver.PushCount<Solver.SearchLimits.PushCountLimit then begin  // limit not exceeded
                                       Inc(Solver.MoveCount); Inc(Solver.PushCount); Inc(SuccessorCount__); // update statistics

                                       if (Solver.PushCount and (ONE_MEBI-1))=0 then begin
                                          {$IFDEF CONSOLE_APPLICATION}
                                            Writeln(SearchStatePromptText,
                                                   'Moves/Pushes: ',
                                                   Solver.MoveCount div ONE_MILLION,
                                                   SLASH,
                                                   Solver.PushCount div ONE_MILLION,' million'
                                                   //,SPACE,Cardinal(Queues.MemoryBlock.Memory)+Queues.MemoryBlock.ByteSize-Cardinal(Queues.MovesQueue.Top)
                                                   {$IFDEF WINDOWS}
                                                     ,' Time: ',(CalculateElapsedTimeMS(Solver.StartTimeMS,GetTimeMS)+500) div 1000
                                                   {$ENDIF}
                                                   );
                                          {$ELSE}
                                            SetSokobanStatusText(Optimizer.SearchResultStatusText+Optimizer.SearchStateStatusText);
                                          {$ENDIF}

                                          TimeCheck;
                                          if SearchHasTerminated then StopSearch; // if the search has been terminated then use 'StopSearch' to break out of the main 'while' loop
                                          end;

                                       if NewBoxConfiguration=nil then begin    // 'True': this is the first generated push from the current game state
                                          NewBoxConfiguration:=Addr(BoxConfigurationCopy); // make a copy of the current box configuration
                                          Move(BoxConfiguration^,NewBoxConfiguration^,BoxConfigurationByteSize);
                                          end;
                                       RemoveBox (    BoxNeighborSquare,NewBoxConfiguration^); // push the box in this direction
                                       AddBox    (NextBoxNeighborSquare,NewBoxConfiguration^);

                                       NewBoxConfigurationIndex:=LookupBoxConfiguration(NewBoxConfiguration^);
                                       if NewBoxConfigurationIndex<>NONE then begin // 'True': the new box configuration is in the vicinity of the best found path
                                          GameState:=TGameState(Cardinal(NewBoxConfigurationIndex)*PlayerSquareCount+Cardinal(PlayerNeighborSquare));
                                          if Optimizer.Optimization>=opBoxLinesMoves then
                                             GameState:=GameState*GAME_STATE_MULTIPLICATION_FACTOR_FOR_BOXLINES_SEARCH+Cardinal(Succ(Ord(DIRECTION_TO_AXIS[Direction])));
                                          if not IsVisited(GameState) then begin // 'True': this is the first time this [NewBoxConfigurationIndex, PlayerNeighborSquare] game-state has been found
                                             if   (Optimizer.Optimization<opBoxLinesMoves)
                                                  or
                                                  ((Item__^.GameState mod GAME_STATE_MULTIPLICATION_FACTOR_FOR_BOXLINES_SEARCH)<>Cardinal(Succ(Ord(DIRECTION_TO_AXIS[Direction]))))
                                                  //(Cardinal(Ord(Direction))<>(Cardinal(PushAncestor) and DIRECTION_BIT_MASK)) // 'True': the box direction changes, or it's the root game-state
                                                  //or
                                                  //(Integer(PQueueItem(Cardinal(PushAncestor) and (not DIRECTION_BIT_MASK))^.GameState mod PlayerSquareCount)
                                                  // <> // 'True': the last move didn't push this box in the same direction
                                                  // PlayerSquareNeighbor[PlayerSquare,OPPOSITE_DIRECTION[Direction]]
                                                  //)
                                                  then
                                                  DestinationQueue:=Addr(Queues.PushesQueue)    // pushes which require one more boxline
                                             else DestinationQueue:=Addr(Queues.BoxLinesQueue); // pushes which don't require one more boxline

                                             if EnqueueGameState(GameState,{PQueueItem((Cardinal(PushAncestor) and (not DIRECTION_BIT_MASK)) or Cardinal(Ord(Direction)))}PushAncestor,DestinationQueue^) then begin
                                                if not FirstMarkPushesAsVisitedWhenTheyAreExpanded__ then
                                                   SetVisited(GameState);       // optimizing moves/pushes sets the visited flag the first time the game-state is seen
                                                //if Optimizer.Optimization<>opPushesMoves then // optimizing pushes/moves first sets the visited flag when the game-state is expanded
                                                //   SetVisited(GameState);     // optimizing moves/pushes and boxlines/moves sets the visited flag the first time the game-state is seen
                                                if NewBoxConfigurationIndex=TargetBoxConfigurationIndex then begin // 'True': this is the target position
{
                                                   if   True then begin
                                                        oPlayerPos:=Game.PlayerPos; oBoard:=Game.Board; oBoxPos:=Game.BoxPos;
                                                        SavePlayerAndBoxConfigurationToGame(PlayerNeighborSquare,NewBoxConfiguration^);
                                                        ShowBoard;
                                                        Writeln('Solution? ',SearchDepth,SPACE,Solver.MoveCount,SPACE,Solver.PushCount,SPACE,GameState,SPACE,DIRECTION_TO_TEXT[Direction],SPACE,PlayerInternalToExternalSquare[PlayerNeighborSquare]);
                                                        Readln;
                                                        Game.PlayerPos:=oPlayerPos; Game.Board:=oBoard;; Game.BoxPos:=oBoxPos;
                                                        end;
}
                                                   if (PlayerNeighborSquare=TargetPlayerSquare) // 'True': the player square matches as well as the box configuration
                                                      or
                                                      (PPosition(SliceEndPosition)=YASS.Positions.SolutionPosition) // 'True': this is the final position, and the final position is a solution, in which case the player position doesn't matter
                                                      then begin
                                                      Result:=Result or         // don't call 'IsNewBetterPath()' again if a new better path already has been found; the search data may have been overwritten
                                                              IsNewBetterPath(LastItemOnQueue(DestinationQueue^), // the new game-state is on the top of the pushes-queue or boxlines-queue ('Top' points to the next free item)
                                                                              POptimizerPosition(SliceEndPosition^.Position.Successor));
                                                      if Result then StopSearch;
                                                      end;
                                                   end;
                                                end
                                             else StopSearch;                   // the open-queue is full
                                             end;
                                          end;

                                       RemoveBox(NextBoxNeighborSquare,NewBoxConfiguration^); // undo the push
                                       AddBox   (    BoxNeighborSquare,NewBoxConfiguration^);
                                       end
                                    else StopSearch;                            // push-count limit exceeded
                                    end;
                                 end
                              else begin // the square next to the player in this direction is an empty floor; put this game-state on the open-queue unless it already has been visited
                                 GameState:=TGameState(Cardinal(BoxConfigurationIndex)*PlayerSquareCount+Cardinal(PlayerNeighborSquare));
                                 if Optimizer.Optimization>=opBoxLinesMoves then
                                    GameState:=GameState*GAME_STATE_MULTIPLICATION_FACTOR_FOR_BOXLINES_SEARCH;
                                 if not IsVisited(GameState) then begin
                                    if   EnqueueGameState(GameState,PushAncestor,Queues.MovesQueue) then begin
                                         SetVisited(GameState);
                                         Inc(Solver.MoveCount); Inc(SuccessorCount__); // update statistics

                                         if (BoxConfigurationIndex=TargetBoxConfigurationIndex) and
                                            (PlayerNeighborSquare  =TargetPlayerSquare) then begin  // 'True': the non-pushing player-move leads to the target position for the current slice
                                            if SliceEndPosition^.Position.Successor<>nil then begin // 'True': this isn't the last slice of the game
                                               Result:=Result or                // 'don't call 'IsNewBetterPath()' again if a new better path already has been found; the search data may have been overwritten by the new best path
                                                       IsNewBetterPath(PushAncestor,
                                                                       POptimizerPosition(SliceEndPosition^.Position.Successor));
                                               if Result then StopSearch;
                                               end
                                            else begin
                                               // the machinery outside the vicinity-search
                                               // doesn't handle moves after the last
                                               // box-push in the game, hence, the
                                               // final step to the end of the game
                                               // must be a push and not a move
                                               end;
                                            end;
                                         end
                                    else StopSearch;                            // the open-queue is full; stop the search
                                    end;
                                 end;
                              end;
                           end;
                    end;

                 if        not SearchSliceHasTerminated then begin
                           Inc(Item__);                                         // advance to the next item in the span
                           if (Item__=PQueueItem(EndOfBlock)) and (Item__<>EndOfSpan__) then // 'True': advance to the next memory block allocated to the queue
                              AdvanceToNextMemoryBlock(not IsPushesQueue__,Pointer(Item__),SourceQueue__,EndOfBlock); // there will always be a next block
                           end
                 else if   FirstMarkPushesAsVisitedWhenTheyAreExpanded__ and IsPushesQueue__ then begin // 'True': game-states are first marked as visited when they're expanded
                           GenerateSuccessors__:=False;                         // finish the items in the span and mark them all as visited as a preparation for 'CheckIntermediatePositionsOnBestFoundPath()'
                           Inc(Item__);                                         // advance to the next item in the span
                           if (Item__=PQueueItem(EndOfBlock)) and (Item__<>EndOfSpan__) then // 'True': advance to the next memory block allocated to the queue
                              AdvanceToNextMemoryBlock(not IsPushesQueue__,Pointer(Item__),SourceQueue__,EndOfBlock); // there will always be a next block
                           end
                      else Item__:=EndOfSpan__;                                 // break out from the 'while' loop
                 end;
               SourceQueue__.Bottom:=EndOfSpan__;
               end;
          end; // GenerateSuccessors

          function  ExpandBoxLinePushes(var SuccessorCount__:Cardinal):Boolean;
          var FirstItem:PQueueItem;
          begin // expands pushes in the next span on the boxlines-queue
            with Queues do begin
              FirstItem:=DequeueSpan(BoxLineSpansQueue);                        // 'DequeueSpan()' returns the first item in the current span, and advances to the next span
              Result:=GenerateSuccessors(FirstItem,                             // the first item is de-queued before the function-call because unlike Delphi, some compilers don't impose a strict left-to-right evaluation order of function arguments
                                         PSpanItem(BoxLineSpansQueue.Bottom)^.FirstItem, // the first item in the next span is the boundary for the items belonging to the current span
                                         True,True,True,                        // pushes are first marked as visited when they are expanded
                                         BoxLinesQueue,SuccessorCount__);
              end;
          end; // ExpandBoxLinePushes

          function  ExpandMoves(var SuccessorCount__:Cardinal):Boolean;
          var FirstItem:PQueueItem;
          begin // expands non-pushing player moves in the next span on the moves-queue
            with Queues do begin
              FirstItem:=DequeueSpan(MoveSpansQueue);                           // 'DequeueSpan()' returns the first item in the current span, and advances to the next span
              Result:=GenerateSuccessors(FirstItem,                             // the first item is de-queued before the function-call because unlike Delphi, some compilers don't impose a strict left-to-right evaluation order of function arguments
                                         PSpanItem(MoveSpansQueue.Bottom)^.FirstItem, // the first item in the next span is the boundary for the items belonging to the current span
                                         False,Optimizer.Optimization<>opMovesPushes,True,
                                         MovesQueue,SuccessorCount__);
              end;
          end; // ExpandMoves

          function  ExpandPushes(var SuccessorCount__:Cardinal):Boolean;
          var FirstItem:PQueueItem;
          begin // expands pushes in the next span on the pushes-queue
            with Queues do begin
              FirstItem:=DequeueSpan(PushSpansQueue);                           // 'DequeueSpan()' returns the first item in the current span, and advances to the next span
              Result:=GenerateSuccessors(FirstItem,                             // the first item is de-queued before the function-call because unlike Delphi, some compilers don't impose a strict left-to-right evaluation order of function arguments
                                         PSpanItem(PushSpansQueue.Bottom)^.FirstItem, // the first item in the next span is the boundary for the items belonging to the current span
                                         True,Optimizer.Optimization<>opMovesPushes,True,
                                         PushesQueue,SuccessorCount__);
              end;
          end; // ExpandPushes

          function  OptimizeMovesPushes:Boolean;
          var SuccessorCount:Cardinal; FirstSpanWithOneMoreMove:PSpanItem;
              // Position,p:POptimizerPosition;
          {
          moves/pushes optimizer algorithm

          game-state "queues" or repositories:
            moves-queue:
              game-states where the final step is a move;
              after expansion, moves are not needed anymore and are recycled
              when all moves in a memory-block have been expanded;
            pushes-queue:
              game-states where the final step is a push;
              pushes are kept throughout the search because the final
              path-reconstruction needs them; all saved game-states (also moves)
              carry their most recent push-ancestor; with this information
              available, path-reconstruction is straightforward;

          span-queues:
            move-spans-queue:
              a move-span encompasses a sequence of moves on the moves-queue
              having the same number of moves and pushes;
              after expansion, move-spans are not needed anymore and are
              recycled when all move-spans in a memory-block have been expanded;
            push-spans-queue:
              a push-span encompasses a sequence of pushes on the pushes-queue
              having the same number of moves and pushes;
              after expansion, push-spans are not needed anymore and are
              recycled when all push-spans in a memory-block have been expanded;

          search algorithm:
            the search is a breadth-first search;
            expansion of nodes is governed by the spans;
            expansion of move-spans and push-spans is in lockstep, so:
              1. a move-span with moves/pushes M/P-1 is expanded first;
              2. a push-span with moves/pushes M/P   is expanded next;
            initially, the start position is enqueued as a push-span;
            how to maintain the P-1/P relationship between the move-spans and
            the push-spans is best explained by an example:

                      moves                               pushes
            move M  : P-1_________________________________P_____________________

            step 1: first the span with M/P-1 moves is expanded, producing:
            move M+1: P-1_________________________________P_____________________

            step 2: then the M/P pushes are expanded, resulting in:
            move M+1: P-1,_P______________________________P,_P+1________________
            this completes the generation of moves at depth M+1;

            step 3: at the next move-depth, the expansion begins with the
            M+1/P-1 moves, producing:
            move M+2: P-1_________________________________P_____________________

            step 4: and continues with the expansion of the M+1/P pushes:
            move M+2: P-1,_P______________________________P,_P+1________________

            step 5: then follows the expansion of the second move-span with
            M+1/P moves (see the span in step 2):
            move M+2: P-1,_P,_P___________________________P,_P+1,_P+1___________

            step 6: and finally the second push-span with M+1/P+1 pushes (see
            the span in step 2):
            move M+2: P-1,_P,_P,_P+1______________________P,_P+1,_P+1,_P+2______

            there is clearly a pattern involved here; it boils down to that
            separating the different spans can be accomplished this way:
            1. after expanding a move-span with P pushes, the push-span with P+1
               pushes is complete; see step 3 and 5 above;
            2. a move-span with P pushes begins when the push-span with P pushes
               is selected for expansion; see step 4 and 6 above;
            implementation-wise, this amounts to adding a span-separator for
            each of the span-queues when the search changes from expanding moves
            to expanding pushes;

            game-states are marked as 'visited' the first time they are seen
            by the search;
          }
          begin // OptimizeMovesPushes
            Result:=False;
            with Queues do
              if EnlargeQueue     (QUEUE_MEMORY_BLOCK_BYTE_SIZE,MovesQueue ) and // allocate the first memory block for the moves-queue
                 EnlargeQueue     (QUEUE_MEMORY_BLOCK_BYTE_SIZE,PushesQueue) and // allocate the first memory block for the pushes-queue
                 MakeSpansForMovesAndPushes(False) and                          // make spans for moves and pushes respectively
                 EnqueueGameState (Cardinal(StartBoxConfigurationIndex)*PlayerSquareCount+Cardinal(StartPlayerSquare),nil,PushesQueue) then begin // enqueue the start position on the pushes-queue

                 SetVisited       (Cardinal(StartBoxConfigurationIndex)*PlayerSquareCount+Cardinal(StartPlayerSquare)); // mark the start position as visited
                 FirstSpanWithOneMoreMove:=MoveSpansQueue.Bottom;               // the first span with moves (it's empty at this point; the initial game-state is the only member of the first push-span)

                 // Position:=SliceStartPosition;

                 repeat                                                         // for each move-depth...
                        SuccessorCount:=0;

                        if   MoveSpansQueue.Bottom=FirstSpanWithOneMoreMove then begin // 'True': change move-depth
{
                             // check whether the current search depth found a
                             // better path to one of the positions on the best
                             // path;
                             // this is not in production because it makes the
                             // search slower; it's better to let the search
                             // process the entire game (or slice)
                             //
                             // to see the check in action, it's necessary to
                             // enable the statements in 'Initialize' that
                             // calculate the game-state for each of the
                             // positions on the best path (for the slice)

                             while (Position<>nil) and (Position^.MoveCount<SearchDepth) do
                               Position:=POptimizerPosition(Position^.Position.Successor); // find the first position on the best path using 'SearchDepth' or more moves
                             p:=Position;
                             while (p<>nil) and (PPosition(p)<>SliceEndPosition^.Position.Successor) do begin
                               if   IsVisited(p^.Position.GameState) and
                                    (SearchDepth<p^.MoveCount) then begin       // 'True': there may be a new better path to position 'p'
                                    Result:=CheckIntermediatePositionsOnBestFoundPath(p);
                                    if not Result then Writeln('Failed');
                                    end;
                               if   not Result then
                                    p:=POptimizerPosition(p^.Position.Successor) // advance to the next position on the path
                               else p:=nil;                                     // 'nil': exit the loop
                               end;
}
                             Inc(SearchDepth); SuccessorCount:=0;
                             if   (SliceEndPosition<>nil) and
                                  (SearchDepth<=SliceEndPosition^.MoveCount) and
                                  MakeSpansForMovesAndPushes(False) then begin  // make a pair of spans, in effect adding a terminator after the moves and pushes added by the previous iteration
                                  ShowSearchStatus;
                                  FirstSpanWithOneMoreMove:=LastItemOnQueue(MoveSpansQueue);
                                  end
                             else StopSearch;                                   // stop the search if the memory is full
                             end;

                        if   not SearchSliceHasTerminated then begin
                             if IsEmptySpan(MoveSpansQueue.Bottom,MoveSpansQueue,MovesQueue ) and
                                IsEmptySpan(PushSpansQueue.Bottom,PushSpansQueue,PushesQueue) then begin // avoid multiplying empty spans
                                DequeueSpan(MoveSpansQueue); DequeueSpan(PushSpansQueue); // drop the empty pair of spans
                                end
                             else begin
                                Result:=ExpandMoves(SuccessorCount);            // game-states on the current move-span have m moves and p-1 pushes
                                if   (not (Result or SearchSliceHasTerminated)) and
                                     MakeSpansForMovesAndPushes(True) then begin // make a new pair of spans to enforce the separation of the items on the queues into sets with move-spans (m,p-1) and push-spans (m,p)
                                     Result:=ExpandPushes(SuccessorCount);      // game-states on the current push-span have m moves and p pushes
                                     end
                                else StopSearch;
                                end;
                             end;

                 until  SearchSliceHasTerminated                                // the search terminates after finding a new better path, if the users terminated the task manually, or if one of the limits were reached, e.g., a time limit
                        or
                        ((SliceEndPosition<>nil)
                         and
                         (SearchDepth>SliceEndPosition^.MoveCount)              // stop after having searched the same number of moves as in the original best path through the slice
                        );
                 end;
          end; // OptimizeMovesPushes

          function  OptimizePushesMoves:Boolean;
          var SuccessorCount:Cardinal; FirstSpanWithOneMorePush:PSpanItem;
              // Position,p:POptimizerPosition;
          {
          pushes/moves optimizer algorithm

          game-state "queues" or repositories:
            moves-queue:
              game-states where the final step is a move;
              after expansion, moves are not needed anymore and are recycled
              when all moves in a memory-block have been expanded;
            pushes-queue:
              game-states where the final step is a push;
              pushes are kept throughout the search because the final
              path-reconstruction needs them; all saved game-states (also moves)
              carry their most recent push-ancestor; with this information
              available, path-reconstruction is straightforward;

          span-queues:
            move-spans-queue:
              a move-span encompasses a sequence of moves on the moves-queue
              having the same number of moves and pushes;
              after expansion, move-spans are not needed anymore and are
              recycled when all move-spans in a memory-block have been expanded;
            push-spans-queue:
              a push-span encompasses a sequence of pushes on the pushes-queue
              having the same number of moves and pushes;
              after expansion, push-spans are not needed anymore and are
              recycled when all push-spans in a memory-block have been expanded;

          search algorithm:
            the search is a breadth-first search;
            expansion of nodes is governed by the spans;
            expansion of move-spans and push-spans is in lockstep, so:
              1. a push-span with moves/pushes M/P is expanded first;
              2. a move-span with moves/pushes M/P is expanded next;
            initially, the start position is enqueued as a push-span;

            the search proceeds as follows:

            ..while the maximum search depth (pushes) hasn't been reached do
            ....increase the push search depth from P-1 to P
            ....at this point there are only pushes on the queues; there are no
            ....non-pushing moves; the pushes are sorted into spans in ascending
            ....moves order: M/P, M+1/P, M+2/P, ... M+n/P.
            ....while there are more push-spans with P pushes do (*)
            ......expand next push-span, which has M/P moves and pushes
            ......expand next move-span, which has M/P moves and pushes
            ......increase the moves-depth from M to M+1

            the expansion of game-states with M/P moves and pushes generates two
            types of successors:
              1. moves with M+1/P moves/pushes; they are put on the moves-queue
                 for expansion within the current push search depth; in other
                 words, they are expanded inside the 'while' loop marked by
                 '(*)' above;
              2. pushes with M+1/P+1 moves/pushes; they are put on the
                 pushes-queue for expansion after the outer loop increases the
                 push search depth from P to P+1

            a small illustration helps to clarify the process;
            ......O....    O: root node
            ...../.\...
            ....A...2..    2,3: non-pushing moves
            ......./.\.
            ......3...B    A,B,C: pushes
            .......\...
            ........C..

            the inner loop "flood-fills" the moves behind the contour made by
            the pushes at the next push search depth; when all moves have been
            expanded, the only unexpanded successors are the pushes at the next
            higher push search depth; at that time, the outer loop advances to
            the next higher search depth, starting with the pushes only, like
            this:
            ....A......
            ...........
            ..........B    A,B,C: pushes at move-depth M, M+1, M+2 respectively
            ...........
            ........C..

            game-states resulting from a non-pushing move are marked as
            'visited' the first time they are seen by the search;
            game-states resulting from a push are first marked as 'visited' when
            they are expanded, hence, there may be duplicate game-states on the
            pushes-queue;
          }
          begin // OptimizePushesMoves
            Result:=False;
            with Queues do
              if EnlargeQueue    (QUEUE_MEMORY_BLOCK_BYTE_SIZE,PushesQueue) and // allocate the first memory block for the pushes-queue
                 MakeSpan        (PushesQueue.Top,PushSpansQueue) and           // make a start span for the pushes-queue
                 EnqueueGameState(Cardinal(StartBoxConfigurationIndex)*PlayerSquareCount+Cardinal(StartPlayerSquare),PQueueItem(Cardinal(nil) or DIRECTION_BIT_MASK),PushesQueue) // enqueue the start position on the pushes-queue
                 then begin
                 // Position:=SliceStartPosition;

                 repeat                                                         // for each push-depth...
                   ClearQueue(MoveSpansQueue); ClearQueue(MovesQueue);          // clear the moves-queue before starting this iteration with the next higher number of pushes
{
                             // check whether the current search depth found a
                             // better path to one of the positions on the best
                             // path;
                             // this is not in production because it makes the
                             // search slower; it's better to let the search
                             // process the entire game (or slice)
                             //
                             // to see the check in action, it's necessary to
                             // enable the statements in 'Initialize' that
                             // calculate the game-state for each of the
                             // positions on the best path (for the slice)

                             while (Position<>nil) and (Position^.Position.PushCount<SearchDepth) do
                               Position:=POptimizerPosition(Position^.Position.Successor); // find the first position on the best path using 'SearchDepth' or more pushes
                             p:=Position;
                             while (p<>nil) and (PPosition(p)<>SliceEndPosition^.Position.Successor) do begin
                               if   IsVisited(p^.Position.GameState) and
                                    (SearchDepth<p^.Position.PushCount) then begin // 'True': there may be a new better path to position 'p'
                                    Result:=CheckIntermediatePositionsOnBestFoundPath(p);
                                    //if not Result then Writeln('Failed');
                                    end;
                               if   not Result then
                                    p:=POptimizerPosition(p^.Position.Successor) // advance to the next position on the path
                               else p:=nil;                                     // 'nil': exit the loop
                               end;
}
                   if   EnlargeQueue(QUEUE_MEMORY_BLOCK_BYTE_SIZE,MovesQueue) and // allocate the first memory block for the moves-queue
                        MakeSpansForMovesAndPushes(False) then begin            // make spans for moves and pushes respectively, in effect adding a terminator after the pushes added in the previous iteration
                        Inc(SearchDepth);                                       // advance to the next push-depth
                        ShowSearchStatus;
                        FirstSpanWithOneMorePush:=LastItemOnQueue(PushSpansQueue); // this is the boundary for the spans with pushes at the current push-depth

                        repeat                                                  // for each move-depth within the current push-depth...
                          SuccessorCount:=0;

                          if   MakeSpansForMovesAndPushes(False) then begin     // make spans for moves and pushes respectively, in effect adding a terminator after the pushes and moves added in the previous iteration
                               if PushSpansQueue.Bottom<>FirstSpanWithOneMorePush then
                                  Result:=ExpandPushes(SuccessorCount);
                               if not (Result or SearchSliceHasTerminated) then
                                  Result:=ExpandMoves (SuccessorCount);
                               end
                          else StopSearch;                                      // stop the search if the memory is full

                        until ((PushSpansQueue.Bottom=FirstSpanWithOneMorePush) // 'True': there are no more pushes at the current push-depth
                                and
//                              IsEmptySpan(LastItemOnQueue(MoveSpansQueue),MoveSpansQueue,MovesQueue) // 'True': the last iteration didn't produce any new non-pushing move-successors, hence, all successors are pushes with the next higher number of pushes
                                (SuccessorCount=0)                              // 'True': the last iteration didn't produce new successors, hence, all successors are now on the pushes-queue and are pushes with the next higher number of pushes
                               )
                               or
                               SearchSliceHasTerminated;
                        end
                   else StopSearch;                                             // stop the search if the memory is full

                 until SearchSliceHasTerminated                                 // the search terminates after finding a new better path, if the users terminated the task manually, or if one of the limits were reached, e.g., a time limit
                       or
                       ((SliceEndPosition<>nil)
                        and
                        (SearchDepth=SliceEndPosition^.Position.PushCount)      // stop after having searched the same number of pushes as in the original best path through the slice
                       );

                 if (not Result) and (PushSpansQueue.Bottom<>nil) then begin    // mark any remaining pushes on the pushes-queue as visited
                    SearchSliceHasTerminated:=False;                            // open for processing items in 'GenerateSuccessors()'
                    GenerateSuccessors(PSpanItem(PushSpansQueue.Bottom)^.FirstItem,PushesQueue.Top,True,True,False,PushesQueue,SuccessorCount);
                    if BoxLineSpansQueue.Bottom<>nil then // 'True': optimizing boxlines, ,i.e., the boxlines-queue is in use; mark the pushes on this queue too
                       GenerateSuccessors(PSpanItem(BoxLineSpansQueue.Bottom)^.FirstItem,BoxLinesQueue.Top,True,True,False,BoxLinesQueue,SuccessorCount);
                    end;
                 end;
          end; // OptimizePushesMoves

          function  OptimizeBoxLines:Boolean;
          var SuccessorCount:Cardinal;
              FirstSpanWithOneMorePushAndOneMoreBoxLine:PSpanItem;
          begin
            Result:=False;
            with Queues do
              if EnlargeQueue     (QUEUE_MEMORY_BLOCK_BYTE_SIZE,PushesQueue) and // allocate the first memory block for the pushes-queue
                 EnlargeQueue     (QUEUE_MEMORY_BLOCK_BYTE_SIZE,BoxLinesQueue) and // allocate the first memory block for the pushes-queue
                 MakeSpan         (PushesQueue.Top,PushSpansQueue) and          // make a start span for the pushes-queue
                 EnqueueGameState ((Cardinal(StartBoxConfigurationIndex)*PlayerSquareCount+Cardinal(StartPlayerSquare))*GAME_STATE_MULTIPLICATION_FACTOR_FOR_BOXLINES_SEARCH,
                                   {PQueueItem(Cardinal(nil) or DIRECTION_BIT_MASK)}nil,PushesQueue) // enqueue the start position on the pushes-queue
                 then begin
                 repeat                                                         // for each push-depth...
                   ClearQueue(MoveSpansQueue); ClearQueue(MovesQueue);          // clear the moves-queue before starting this iteration with the next higher number of pushes
                   ClearQueue(BoxLineSpansQueue);                               // clear the boxline-spans before starting this iteration (boxline-pushes are pushes of a box in the same direction)

                   if   EnlargeQueue(QUEUE_MEMORY_BLOCK_BYTE_SIZE,MovesQueue) and // allocate the first memory block for the moves-queue so 'MakeSpan' can create a starting point for the moves-queue
                        MakeSpansForMovesAndPushesAndBoxLines and               // make spans for moves, pushes, and boxlines, in effect adding a terminator after the last push-span added in the previous iteration
                        MakeSpan(MovesQueue   .Top,MoveSpansQueue   ) and       // make empty moves-span,    the only one on the move-spans queue    at this point
                        MakeSpan(BoxLinesQueue.Top,BoxLineSpansQueue)           // make empty boxlines-span, the only one on the boxline-spans queue at this point
                        then begin
                        // at this point, there is at least one push-span from
                        // the previous iteration;
                        // each push-span contains pushes at a given moves-depth;
                        // the pushes increase the number of boxlines;
                        // there is exactly one move-span and one
                        // boxline-pushes-span; both of these spans are empty;
                        // boxline-pushes don't increase the number of boxlines;
                        Inc(SearchDepth);                                       // advance to the next search depth
                        ShowSearchStatus;
                        FirstSpanWithOneMorePushAndOneMoreBoxLine:=LastItemOnQueue(PushSpansQueue); // this is the boundary between the span(s) with pushes at the current push-depth with 'b' boxlines and the pushes which require 'b+1' boxlines

                        repeat

                          SuccessorCount:=0;
                          // expand a push-span at this depth from the previous iteration; the pushes on the pushes-queue increase the number of boxlines
                          if PushSpansQueue.Bottom<>FirstSpanWithOneMorePushAndOneMoreBoxLine then
                             Result:=ExpandPushes(SuccessorCount);

                          // expand a boxline-span at this depth
                          Result:=Result or ExpandBoxLinePushes(SuccessorCount);

                          if   Optimizer.Optimization=opBoxLinesMoves then
                               // optimize boxlines/moves;
                               // expand a move-span at this depth
                               Result:=Result or ExpandMoves(SuccessorCount)
                          else // optimize boxlines/pushes;
                               // expand all non-pushing moves until they dry out
                               while (not (Result or SearchHasTerminated)) and
                                     (MovesQueue.Bottom<>MovesQueue.Top) do
                                     if   MakeSpan(MovesQueue.Top,MoveSpansQueue) then // add a move-span terminator after the most recently produced moves, so 'ExpandMoves' has a stopping point
                                          Result:=ExpandMoves(SuccessorCount)
                                     else StopSearch;
                        until // until all non-pushing moves and all
                              // boxline-pushes have been expanded;
                              // at that point, the only unexpanded items are
                              // the pushes which require one more boxline
                              Result
                              or
                              SearchHasTerminated
                              or
                              ((MovesQueue    .Bottom=MovesQueue   .Top)        // 'True': no more unexpanded non-pushing moves
                               and
                               (BoxLinesQueue .Bottom=BoxLinesQueue.Top)        // 'True': no more unexpanded boxline-pushes
                               and
                               (PushSpansQueue.Bottom=FirstSpanWithOneMorePushAndOneMoreBoxLine) // 'True': all unexpanded pushes require one more boxline
                              )
                              or
                              (not MakeSpansForMovesAndPushesAndBoxLines);
                        end
                   else StopSearch;                                             // stop the search if the memory is full

                 until SearchSliceHasTerminated                                 // the search terminates after finding a new better path, if the users terminated the task manually, or if one of the limits were reached, e.g., a time limit
                       or
                       ((SliceEndPosition<>nil)
                        and
                        (SearchDepth=SliceEndPosition^.Position.PushCount)      // stop after having searched the same number of pushes as in the original best path through the slice
                       );

                 if (not Result) and
                    ((PushSpansQueue.Bottom<>nil) or (BoxLineSpansQueue.Bottom<>nil)) then begin    // mark any remaining pushes on the pushes-queue and boxlines-queue as visited
                    SearchSliceHasTerminated:=False;                            // open for processing items in 'GenerateSuccessors()'
                    if PushSpansQueue.Bottom<>nil then
                       GenerateSuccessors(PSpanItem(PushSpansQueue   .Bottom)^.FirstItem,PushesQueue  .Top,True,True,False,PushesQueue  ,SuccessorCount);
                    if BoxLineSpansQueue.Bottom<>nil then
                       GenerateSuccessors(PSpanItem(BoxLineSpansQueue.Bottom)^.FirstItem,BoxLinesQueue.Top,True,True,False,BoxLinesQueue,SuccessorCount);
                    end;
                 end;
          end; // OptimizeBoxLines

        begin // OptimizeGame.Search.VicinitySearch.Search.OptimizeMovesOrPushesOrBoxLines
          case Optimization__ of
            opMovesPushes      : Result:=OptimizeMovesPushes;                   // optimize moves/pushes
            opPushesMoves      : Result:=OptimizePushesMoves;                   // optimize pushes/moves
            opBoxLinesMoves    : Result:=OptimizeBoxLines;                      // optimize boxlines/moves
            opBoxLinesPushes   : Result:=OptimizeBoxLines;                      // optimize boxlines/pushes
            else                 Result:=False;
          end;
        end; // OptimizeGame.Search.VicinitySearch.Search.OptimizeMovesOrPushesOrBoxLines

        function  OptimizePushesOnly:Boolean;
        // OptimizeGame.Search.VicinitySearch.Search.OptimizePushesOnly
        var SuccessorCount:Cardinal;

          function  Initialize:Boolean;
          var ByteSize,PushCount:Cardinal;
          begin // OptimizeGame.Search.VicinitySearch.Search.OptimizePushesOnly.Initialize
            Result:=False;
            with Queues do begin
              // when optimizing pushes-only, with a pushes-queue only and no
              // queue for moves, it's not necessary to allocate small memory
              // blocks one by one for the queue; instead, all the available
              // memory can be allocated from the beginning;

              PushCount:=Succ(SliceEndPosition^.Position.PushCount-SliceStartPosition^.Position.PushCount);
              ByteSize :=Succ(PushCount)*SizeOf(TSpanItem)+4*MEMORY_ALIGNMENT_BYTES;
              if MemoryPool.FreeBlock.ByteSize>ByteSize+SizeOf(PushesQueue.Block^)+2*MEMORY_ALIGNMENT_BYTES then begin
                 Result:=EnlargeQueue(ByteSize,PushSpansQueue)                  // first allocate the spans-queue
                         and
                         EnlargeQueue(MemoryPool.FreeBlock.ByteSize-MEMORY_ALIGNMENT_BYTES,PushesQueue); // then allocate the rest of the available memory for the pushes-queue
                 end;
              end;
          end; // OptimizeGame.Search.VicinitySearch.Search.OptimizePushesOnly.Initialize

          function  ExpandPushes(var SuccessorCount__:Cardinal):Boolean;
          var FirstItem:PQueueItem;

            function  GenerateSuccessors(Item__,EndOfSpan__:PQueueItem; var SuccessorCount__:Cardinal):Boolean;
            var BoxNeighborSquare,BoxConfigurationIndex,NextBoxNeighborSquare,
                NewBoxConfigurationIndex,PlayerNeighborSquare,PlayerSquare:Integer;
                Direction:TDirection; GameState:TGameState;
                EndOfBlock:PMemoryBlock;
                BoxConfiguration, NewBoxConfiguration:PBoxConfiguration;
                BoxConfigurationCopy:TBoxConfiguration;
                MovesQueue:TBoardOfIntegers; MovesQueueBottom,MovesQueueTop:^Integer;
            begin // OptimizeGame.Search.VicinitySearch.Search.OptimizePushesOnly.GenerateSuccessors;
                  // generates successor game-states for all nodes on the queue belonging to the specified span
              Result:=False;
              if not SearchSliceHasTerminated then begin                        // 'True': the search hasn't been terminated
                 EndOfBlock   :=FindMemoryBlockWithItem(Item__,Queues.PushesQueue.MemoryBlocks); // find the memory block that contains the span mark; a memory block is its own end-of-data-area pointer
                 if (Item__=PQueueItem(EndOfBlock)) and (Item__<>EndOfSpan__) then    // 'True': advance to the next memory block allocated to the queue
                    AdvanceToNextMemoryBlock(False,Pointer(Item__),Queues.PushesQueue,EndOfBlock); // there will always be a next block because there is always a 'next span' mark on the queue before a span is selected for expansion

                 while Item__<>EndOfSpan__ do begin                             // for each item belonging to the span, or until the search terminates, generate push-successors and store them on the pushes-queue
                   GameState            :=Item__^.GameState;                    // get the next game-state on the queue
                   BoxConfigurationIndex:=GameState div PlayerSquareCount;
//                 PlayerSquare         :=GameState mod PlayerSquareCount;
                   PlayerSquare         :=GameState-PlayerSquareCount*Cardinal(BoxConfigurationIndex); // 'mod' may be slow, hence, the player square is calculated this way instead
                   BoxConfiguration     :=PBoxConfiguration(Cardinal(BoxConfigurations.First)+Cardinal(BoxConfigurationIndex*BoxConfigurationByteSize)); // inlined 'GetBoxConfigurationByIndex()'
                   NewBoxConfiguration  :=nil;                                  // 'nil': the current box configuration hasn't been copied to 'BoxConfigurationCopy'

                   MovesQueue[Low(MovesQueue)]:=PlayerSquare;
                   MovesQueueBottom:=Addr(MovesQueue[Low(MovesQueue)]);
                   MovesQueueTop   :=MovesQueueBottom;

                   while Cardinal(MovesQueueBottom)<=Cardinal(MovesQueueTop) do begin // perform a breadth-first search from the current game-state, putting pushes on the pushes-queue that lead to unvisited game-states
                     PlayerSquare:=MovesQueueBottom^; Inc(MovesQueueBottom);

                     for Direction:=Low(Direction) to High(Direction) do
                         if not Result then begin                               // 'True': the search data haven't been invalidated by a call to 'TTPurge()' after finding a new best path
                            PlayerNeighborSquare:=PlayerSquareNeighbor[PlayerSquare,Direction];
                            if PlayerNeighborSquare<>NONE then begin           // 'True': the square next to the player in this direction is a floor, possibly with a box
                               BoxNeighborSquare:=PlayerSquareToBoxSquare[PlayerNeighborSquare];
                               if (BoxNeighborSquare<>NONE) and                // 'True': the square next to the player is a legal box square
                                  IsABoxSquare(BoxNeighborSquare,BoxConfiguration^) then begin // 'True': there is a box next to the player in this direction
                                  NextBoxNeighborSquare:=BoxSquareNeighbor[BoxNeighborSquare,Direction];
                                  if (NextBoxNeighborSquare<>NONE) and
                                     (not IsABoxSquare(NextBoxNeighborSquare,BoxConfiguration^)) then begin // 'True': the box can be pushed in this direction

                                     if Solver.PushCount<Solver.SearchLimits.PushCountLimit then begin  // limit not exceeded
                                        Inc(Solver.MoveCount); Inc(Solver.PushCount); Inc(SuccessorCount__); // update statistics

                                        if (Solver.PushCount and (ONE_MEBI-1))=0 then begin
                                           {$IFDEF CONSOLE_APPLICATION}
                                             Writeln(SearchStatePromptText,
                                                    'Moves/Pushes: ',
                                                    Solver.MoveCount div ONE_MILLION,
                                                    SLASH,
                                                    Solver.PushCount div ONE_MILLION,' million'
                                                    //,SPACE,Cardinal(Queues.PushesQueue.Top)-Cardinal(Queues.MemoryBlock.Memory)
                                                    {$IFDEF WINDOWS}
                                                      ,' Time: ',(CalculateElapsedTimeMS(Solver.StartTimeMS,GetTimeMS)+500) div 1000
                                                    {$ENDIF}
                                                    );
                                           {$ELSE}
                                             SetSokobanStatusText(Optimizer.SearchResultStatusText+Optimizer.SearchStateStatusText);
                                           {$ENDIF}

                                           TimeCheck;
                                           if SearchHasTerminated then StopSearch; // 'if the search has been terminated then call 'StopSearch' to break out of the main 'while' loop
                                           end;

                                        if NewBoxConfiguration=nil then begin   // 'True': this is the first generated push from the current game state
                                           NewBoxConfiguration:=Addr(BoxConfigurationCopy); // make a copy of the current box configuration
                                           Move(BoxConfiguration^,NewBoxConfiguration^,BoxConfigurationByteSize);
                                           end;
                                        RemoveBox (    BoxNeighborSquare,NewBoxConfiguration^); // push the box in this direction
                                        AddBox    (NextBoxNeighborSquare,NewBoxConfiguration^);
                                        //SavePlayerAndBoxConfigurationToGame(PlayerNeighborSquare,NewBoxConfiguration^);
                                        //ShowBoard; Writeln('B '); //Readln;

                                        NewBoxConfigurationIndex:=LookupBoxConfiguration(NewBoxConfiguration^);
                                        if NewBoxConfigurationIndex<>NONE then begin // 'True': the new box configuration is in the vicinity of the best found path
                                           GameState:=TGameState(Cardinal(NewBoxConfigurationIndex)*PlayerSquareCount+Cardinal(PlayerNeighborSquare));
                                           if not IsVisited(GameState) then begin // 'True': this is the first time this [NewBoxConfigurationIndex, PlayerNeighborSquare] game-state has been found
                                              if EnqueueGameState(GameState,Item__,Queues.PushesQueue) then begin
                                                 SetVisited(GameState);
                                                 if NewBoxConfigurationIndex=TargetBoxConfigurationIndex then begin // 'True': this is the target position
                                                    if (PlayerNeighborSquare=TargetPlayerSquare) // 'True': the player square matches as well as the box configuration
                                                       or
                                                       (PPosition(SliceEndPosition)=YASS.Positions.SolutionPosition) // 'True': this is the final position, and the final position is a solution in which case the player position doesn't matter
                                                       then begin
                                                       Result:=Result or        // 'don't call 'IsNewBetterPath()' again if a new better path already has been found; the search data may have been overwritten by the new best path
                                                               IsNewBetterPath(LastItemOnQueue(Queues.PushesQueue), // the new game-state is on the top of the pushes-queue ('Top' points to the next free item)
                                                                               POptimizerPosition(SliceEndPosition^.Position.Successor));
                                                       if Result then StopSearch;
                                                       end;
                                                    end;
                                                 end
                                              else StopSearch;                  // the open-queue is full
                                              end;
                                           end;

                                        RemoveBox(NextBoxNeighborSquare,NewBoxConfiguration^); // undo the push
                                        AddBox   (    BoxNeighborSquare,NewBoxConfiguration^);
                                        end
                                     else StopSearch;                           // push-count limit exceeded
                                     end;
                                  end
                               else begin // the square next to the player in this direction is an empty floor
                                  GameState:=TGameState(Cardinal(BoxConfigurationIndex)*PlayerSquareCount+Cardinal(PlayerNeighborSquare));
                                  if not IsVisited(GameState) then begin
                                     Inc(MovesQueueTop);
                                     MovesQueueTop^:=PlayerNeighborSquare;      // enqueue the non-pushing player moves
                                     SetVisited(GameState);                     // mark that the game-state has been visited
                                     Inc(Solver.MoveCount);                     // update statistics

                                     if (BoxConfigurationIndex=TargetBoxConfigurationIndex) and
                                        (PlayerNeighborSquare =TargetPlayerSquare) then begin // 'True': the non-pushing player-move leads to the target position for the current slice
                                        if (SliceEndPosition^.Position.Successor<>nil) then   // 'True': this isn't the last slice of the game
                                           with Queues.MovesQueue do begin
                                             Result:=Result or                  // 'don't call 'IsNewBetterPath()' if a new better path already has been found because it may have overwritten search data
                                                     IsNewBetterPath(Item__,    // 'Item__': there are only items on the pushes-queue, so the current game-state after the non-pushing player move is not on any of the queues
                                                                     POptimizerPosition(SliceEndPosition^.Position.Successor));
                                             if Result then StopSearch;
                                             end
                                        else begin
                                           // the machinery outside the vicinity-search
                                           // doesn't handle moves after the last
                                           // box-push in the game, hence, the
                                           // final step to the end of the game
                                           // must be a push, and not a move
                                           end;
                                        end;
                                     end;
                                  end;
                               end;
                            end;
                     end;

                   if   not SearchSliceHasTerminated then begin
                        Inc(Item__);                                            // advance to the next item in the span
                        if (Item__=PQueueItem(EndOfBlock)) and (Item__<>EndOfSpan__) then // 'True': advance to the next memory block allocated to the queue
                           AdvanceToNextMemoryBlock(False,Pointer(Item__),Queues.PushesQueue,EndOfBlock); // there will always be a next block
                        end
                   else EndOfSpan__:=Item__;                                    // break out from the 'while' loop
                   end;
                end;
            end; // OptimizeGame.Search.VicinitySearch.Search.OptimizePushesOnly.GenerateSuccessors

          begin // OptimizeGame.Search.VicinitySearch.Search.OptimizePushesOnly.ExpandPushes; expands pushes at depth 'n'
            with Queues do begin
              FirstItem:=DequeueSpan(PushSpansQueue);                           // 'DequeueSpan()' returns the first item in the current span, and advances to the next span
              Result:=GenerateSuccessors(FirstItem,                             // the first item is de-queued before the function-call because unlike Delphi, some compilers don't impose a strict left-to-right evaluation order of function arguments
                                         PSpanItem  (PushSpansQueue.Bottom)^.FirstItem, // the first item in the next span is the boundary for the items belonging to the current span
                                         SuccessorCount__);
              end;
          end; // OptimizeGame.Search.VicinitySearch.Search.OptimizePushesOnly.ExpandPushes

        begin // OptimizeGame.Search.VicinitySearch.Search.OptimizePushesOnly
          Result:=False;
          with Queues do
            if Initialize and
               MakeSpan     (PushesQueue.Top,PushSpansQueue) and                // make a start span for the pushes-queue
               EnqueueGameState(Cardinal(StartBoxConfigurationIndex)*PlayerSquareCount+Cardinal(StartPlayerSquare),nil,PushesQueue) then begin // enqueue the start position on the pushes-queue

               SetVisited(Cardinal(StartBoxConfigurationIndex)*PlayerSquareCount+Cardinal(StartPlayerSquare)); // mark the start position as visited

               repeat
                        Inc(SearchDepth); SuccessorCount:=0;
                        ShowSearchStatus;
                        if   MakeSpan(PushesQueue.Top,PushSpansQueue) then begin // make a span mark for the pushes-queue, in effect adding a terminator after the pushes added in the previous iteration
                             Result:=ExpandPushes(SuccessorCount);
                             end
                        else StopSearch;                                        // stop the search if the memory is full

               until    SearchSliceHasTerminated                                // the search can have terminated after finding a new better path, if the users terminated the task manually, or if one of the limits were reached, e.g., a time limit
                        or                                                      // if both queues are empty, then the search was exhaustive
                        (SuccessorCount=0)                                      // if the last iteration didn't produce new pushes, then the search was exhaustive
                        or
                        ((SliceEndPosition<>nil)
                         and
                         (SearchDepth=SliceEndPosition^.Position.PushCount)     // stop after having searched the same number of pushes as in the original best path through the slice
                        );
               end;

        end; // OptimizeGame.Search.VicinitySearch.Search.OptimizePushesOnly

        procedure ResetVisited(GameState__:TGameState);
        begin // sets the visited state to 'False' for the game state [box configuration, player square] represented by 'GameState__'
          Dec(VisitedArea^[GameState__ div BITS_PER_BYTE],1 shl (GameState__ mod BITS_PER_BYTE)); // precondition: 'Visited' = 'True'  for this game-state
        end; // OptimizeGame.Search.VicinitySearch.Search.ResetVisited

        procedure SetVisited(GameState__:TGameState);
        begin // sets the visited state to 'True' for the game state [box configuration, player square] represented by 'GameState__'
          Inc(VisitedArea^[GameState__ div BITS_PER_BYTE],1 shl (GameState__ mod BITS_PER_BYTE)); // precondition: 'Visited' = 'False' for this game-state
        end; // OptimizeGame.Search.VicinitySearch.Search.SetVisited

        procedure ShowGameState(InternalPlayerSquare__:Integer; const BoxConfiguration__:TBoxConfiguration; const Caption__:String; Log__:Boolean); // debugging service function
        var OldBoxCount,OldPlayerSquare:Integer; OldBoard:TBoard; OldBoxPos:TBoxSquares;
        begin
          OldBoard:=Game.Board; OldPlayerSquare:=Game.PlayerPos; OldBoxCount:=Game.BoxCount; OldBoxPos:=Game.BoxPos;

          SavePlayerAndBoxConfigurationToGame(InternalPlayerSquare__,BoxConfiguration__);

          if Log__ then begin
             WriteBoardToLogFile(Caption__); FlushLogFile;
             end;

          ShowBoard;
          Write(Caption__); Readln;

          Game.Board:=OldBoard; Game.PlayerPos:=OldPlayerSquare; Game.BoxCount:=OldBoxCount; Game.BoxPos:=OldBoxPos;
        end; // ShowGameState

        function  ShowSearchStatus:Boolean;
        var DepthLimitAsText:String;
        begin // shows a search progress message on the screen if it's time to do so; returns 'True' in that case
          Result:=False;
          if (SliceStartPosition<>nil) and (SliceEndPosition<>nil) then begin
             if Optimizer.Optimization=opMovesPushes then begin
                Result:=SearchDepth>Succ(SliceStartPosition^.MoveCount);        // 'Succ': the status refers to the state before the current iteration
                if   SearchDepth<=SliceEndPosition^.MoveCount then
                     DepthLimitAsText:=LAZY_COLON+IntToStr(SliceEndPosition^.MoveCount)
                else DepthLimitAsText:='';
                end
             else begin
                Result:=SearchDepth>Succ(SliceStartPosition^.Position.PushCount); // 'Succ': the status refers to the state before the current iteration
                if   SearchDepth<=SliceEndPosition^.Position.PushCount then
                     DepthLimitAsText:=LAZY_COLON+IntToStr(SliceEndPosition^.Position.PushCount)
                else DepthLimitAsText:='';
                end;

             if Result then begin
                Optimizer.SearchStateStatusText:={$IFDEF PLUGIN_MODULE}
                                                   '  ('+
                                                   VicinitySettingsAsText+
                                                 {$ENDIF}
                                                 TEXT_SEARCH_STATUS_VICINITY_5+
                                                 IntToStr(Pred(SearchDepth))+
                                                 DepthLimitAsText
                                                 {$IFDEF PLUGIN_MODULE}
                                                   +RIGHT_PAREN
                                                 {$ENDIF}
                                                 ;

                {$IFDEF CONSOLE_APPLICATION}
                  if Solver.MoveCount>LastConsoleStatusMoveCount+ONE_MEBI then begin
                     Writeln(SearchStatePromptText,
                             Optimizer.SearchStateStatusText,
                             ' Moves/Pushes: ',Solver.MoveCount div ONE_MILLION,
                             SLASH,
                             Solver.PushCount div ONE_MILLION,' million'
                             {$IFDEF WINDOWS}
                               ,' Time: ',(CalculateElapsedTimeMS(Solver.StartTimeMS,GetTimeMS)+500) div ONE_THOUSAND
                             {$ENDIF}
                            );
                     LastConsoleStatusMoveCount:=Solver.MoveCount;
                     //Readln;
                     end;
                {$ELSE}
                  SetSokobanStatusText(Optimizer.SearchResultStatusText+Optimizer.SearchStateStatusText);
                  TimeCheck; //ShowStatus;
                  if SearchHasTerminated then StopSearch;
                {$ENDIF}
                end;
             end;
        end; // ShowSearchStatus

        function  StopSearch:PQueueItem;
        begin // stops searching through the current slice of the best found path
          Result                  :=nil;                                        // return 'nil' in case it comes in handy for the caller to use the function result, say, to update a loop control variable
          SearchSliceHasTerminated:=True;                                       // 'True': signal that the search through the current slice has terminated, and ensure that 'AllocateMemoryBlock()' fail, i.e., no more memory blocks are allocated
          with Queues do begin                                                  // ensure that no more game-states are added to the queues
            MovesQueue   .Block   :=MovesQueue   .Top;                          // fake that the queue is full; it makes calls to 'EnqueueGameState()' fail because allocating new memory blocks fail when 'SearchSliceHasTerminated' = 'True'
            PushesQueue  .Block   :=PushesQueue  .Top;                          // fake that the queue is full; it makes calls to 'EnqueueGameState()' fail because allocating new memory blocks fail when 'SearchSliceHasTerminated' = 'True'
            BoxLinesQueue.Block   :=BoxLinesQueue.Top;                          // fake that the queue is full; it makes calls to 'EnqueueGameState()' fail because allocating new memory blocks fail when 'SearchSliceHasTerminated' = 'True'
            end;
        end; // OptimizeGame.Search.VicinitySearch.Search.StopSearch
{
        procedure Test1; // debugging service function
        var
          i,Count,FailCount,OldBoxCount,OldPlayerSquare:Integer;
          B:array[Low(BC)..High(BC)] of TBoxConfiguration;
          Dump1:file of TBoxConfiguration; Dump2:file of Integer;
          OldBoard:TBoard; OldBoxPos:TBoxPositions;
        begin
          OldBoard:=Game.Board; OldPlayerSquare:=Game.PlayerPos; OldBoxCount:=Game.BoxCount; OldBoxPos:=Game.BoxPos;

          for i:=Low(BC) to High(BC) do BC[i]:=NONE;
          for i:=Low(PS) to High(PS) do PS[i]:=NONE;
          FillChar(B,SizeOf(B),0);

          Assign(Dump1,'zzz.b'); Reset(Dump1);
          Count:=FileSize(Dump1);
          for i:=0 to Pred(Count) do
              Read(Dump1,B[i]);
          CloseFile(Dump1);

          Assign(Dump2,'zzz.p'); Reset(Dump2);
          Count:=FileSize(Dump2);
          for i:=0 to Pred(Count) do
              Read(Dump2,PS[i]);
          CloseFile(Dump2);

          FailCount:=0;
          for i:=0 to Pred(Count) do begin
              PS[i]:=PlayerExternalToInternalSquare[PS[i]];
              BC[i]:=LookupBoxConfiguration(B[i]);
              if BC[i]=NONE then begin
                 Inc(FailCount);
                 SavePlayerAndBoxConfigurationToGame(PS[i],B[i]);
                 ShowBoard;
                 Write(Pred(i),' (Failed: ',FailCount,')'); Readln;
                 end;
              end;
          Write('Failed: ',FailCount);

          if FailCount<>0 then
             for i:=0 to Pred(Count) do begin
                 if   FailCount<>0 then
                      SavePlayerAndBoxConfigurationToGame(PS[i],B[i])
                 else SavePlayerAndBoxConfigurationToGame(PS[i],GetBoxConfigurationByIndex(BC[i])^);
                 ShowBoard;
                 Write(i); Readln;
                 end;

          if   FailCount=0 then NextBC:=1
          else NextBC:=NONE;

          Game.Board:=OldBoard; Game.PlayerPos:=OldPlayerSquare; Game.BoxCount:=OldBoxCount; Game.BoxPos:=OldBoxPos;
        end; // Test1
}
{
        procedure Test2; // debugging service function
        var i:Integer; Position:POptimizerPosition; BoxConfiguration:TBoxConfiguration;
            Dump1:file of TBoxConfiguration; Dump2:file of Integer;
        begin
          Assign(Dump1,'zzz.b'); Rewrite(Dump1);
          Assign(Dump2,'zzz.p'); Rewrite(Dump2);
          Position:=SliceStartPosition;
          while (Position<>nil) do begin
            SetPosition(PPosition(Position));                                   // update the game board so it matches the current position from the game path
            LoadBoxConfigurationFromGame(BoxConfiguration);
            Write(Dump1,BoxConfiguration);
            i:=Position^.Position.PlayerPos;
            Write(Dump2,i);
            Position:=POptimizerPosition(Position^.Position.Successor);
            end;
          CloseFile(Dump1);
          CloseFile(Dump2);
        end; // Test2
}
      begin // OptimizeGame.Search.VicinitySearch.Search
        Result:=False;
        if Initialize then begin                                                // 'True': initialization succeeded, and the search hasn't been terminated
           if   Optimizer.Optimization=opPushesOnly then
                Result:=OptimizePushesOnly
           else Result:=OptimizeMovesOrPushesOrBoxLines(Optimizer.Optimization);

           if   (not Result) then                                               // 'not Result': the search didn't find a new better path
                // maybe the search didn't run to its completion but even so,
                // it may have discovered a new better path to one of the
                // intermediate positions on the best found path
                Result:=CheckIntermediatePositionsOnBestFoundPath(SliceEndPosition);
           end;
        {$IFDEF CONSOLE_APPLICATION}
          Writeln('Time: ',CalculateElapsedTimeMS(Solver.StartTimeMS,GetTimeMS),' Box configurations: ',BoxConfigurations.Count);
        {$ENDIF}
      end; // OptimizeGame.Search.VicinitySearch.Search

    begin // OptimizeGame.Search.VicinitySearch
      Optimizer.IterationResult:=False; FullGameSearch__:=False;
      if Initialize then begin
         repeat Result:=False;                                                  // repeat until all slices of the game have been processed
                if GenerateBoxConfigurations(SliceStartPosition,SliceEndPosition,BoxConfigurations{,BoxConfigurationsTernarySearchTree}) then begin // generate box configurations in the vicinity of the best found path
                   FullGameSearch__:=(PPosition(SliceStartPosition)=YASS.Positions.StartPosition) and
                                     (PPosition(SliceEndPosition  )=YASS.Positions.BestPosition); // ' FullGameSearch__=True': the (last processed) slice encompasses the entire game
                   Result:=Search;                                              // search for the best path through the current slice of the game, using the generated vicinity box configurations only
                   if      Result then begin                                    // 'True': the search found an improvement; try the same slice again
                           Optimizer.Result:=prOK;
                           Optimizer.IterationResult:=True;
                           end
                   else if (PPosition(SliceEndPosition)<>YASS.Positions.BestPosition) and   // '<>': the current slice isn't the last one
                           (SliceStartPosition<>nil) and (SliceEndPosition<>nil) then begin // '<>nil': if something went wrong, then one of them may have been set to 'nil'
                           if   SliceStartPosition<>SliceEndPosition then with SliceStartPosition^.Position do
                                // start the next slice from the middle of the current slice, thereby ensuring an overlap of the analyzed slices
                                SliceStartPosition:=PositionOnBestPathWithPushNumber(PushCount+Max(1,(SliceEndPosition^.Position.PushCount-PushCount) div 2))
                           else SliceStartPosition:=POptimizerPosition(SliceStartPosition^.Position.Successor); // try the next slice, ensuring some progression by advancing to the next push
                           Result:=True;                                        // 'True': try the next slice, i.e., don't exit the 'repeat' loop
                           end;
                   end;
         until  (not Result) or SearchHasTerminated;
         end;
      Result:=Optimizer.IterationResult;                                        // return 'True' if the vicinity search found any improvements
    end; // OptimizeGame.Search.VicinitySearch

    function  QuickVicinitySearch:Boolean;
    const MIN_LIMIT_STEP_SIZE=5;
    var   Index,BottomIndex:Integer; FullGameSearch:Boolean; OriginalVicinitySettings:TVicinitySettings;
          VicinitySquareLimits:TVicinitySettings;                               // the user's square limits, plus one extra 'MAX_VICINITY_SQUARES' limit

      function  CalculateBoxSquareCount:Integer;
      var SquareNo:Integer;
      begin // calculates the number of reachable squares for the boxes
        Result:=0;
        for SquareNo:=0 to Game.BoardSize do
            if IsALegalAndBoxReachableSquare(SquareNo) then Inc(Result);
      end; // OptimizeGame.Search.QuickVicinitySearch.CalculateBoxSquareCount

    begin // 'QuickVicinitySearch'; begin vicinity search with 1-box searches; this often speeds up a 2-box search
      Result:=False;
      OriginalVicinitySettings:=Optimizer.VicinitySettings;                     // save the vicinity search settings

      try
        // copy the original vicinity search settings
        VicinitySquareLimits:=OriginalVicinitySettings;
        BottomIndex := MAX_VICINITY_BOX_COUNT;
        while (BottomIndex>Low(VicinitySquareLimits)) and (VicinitySquareLimits[BottomIndex]<>0) do Dec(BottomIndex); // find the lowest index with a non-zero vicinity squares limit
        // add an extra 'MAX_VICINITY_SQUARES' limit
        VicinitySquareLimits[BottomIndex]:=MAX_VICINITY_SQUARES;
        // avoid too small steps from one limit to the next; e.g., if the limits are 20/19/18 then only run a 1-box-20-squares search (the user limits have earlier been sorted in descending order)
        for Index:=MAX_VICINITY_BOX_COUNT downto Succ(BottomIndex) do
            if VicinitySquareLimits[Index]+MIN_LIMIT_STEP_SIZE>=VicinitySquareLimits[Pred(Index)] then
               VicinitySquareLimits[Index]:=0;
        // if the user's highest limit covers the entire board, then don't run the search with the extra 'MAX_VICINITY_SQUARES' limit
        if VicinitySquareLimits[Succ(BottomIndex)]>=CalculateBoxSquareCount then
           VicinitySquareLimits[     BottomIndex ]:=0;
        // clear the vicinity settings which the search actually sees; the 1-box square limit will be added to the settings inside the following loop
        FillChar(Optimizer.VicinitySettings,SizeOf(Optimizer.VicinitySettings),0);

        Index:=MAX_VICINITY_BOX_COUNT;
        repeat Optimizer.VicinitySettings[MAX_VICINITY_BOX_COUNT]:=VicinitySquareLimits[Index]; // prepare a 1-box search with this square limit
               if   (VicinitySquareLimits[Index]<>0) and                        // 'True': the limit for this index is non-zero
                    VicinitySearch(FullGameSearch) then                         // 'True': the vicinity search found some improvements
                    Result:=True                                                // run the vicinity search again with the same limit, i.e., the index doesn't change
               else Dec(Index);                                                 // try the next higher limit
        until  SearchHasTerminated or (Index<BottomIndex);                      // until the search has been terminated or until all limits have been used

      finally
        Optimizer.VicinitySettings:=OriginalVicinitySettings;                   // restore the user's vicinity search settings
        Optimizer.IterationResult:=Optimizer.IterationResult or Result;
        if Result and (BoxPermutationsCount>2) then Dec(BoxPermutationsCount);  // 'True': start with a lower number of boxes the next time a box-permutations-search is invoked
      end;
    end; // OptimizeGame.Search.QuickVicinitySearch

    function  SelectNextOptimizationMethod(ActivateAllOtherMethods__:Boolean; var MethodIndex__:Integer; var ActiveMethodSet__:TOptimizationMethodSet):Boolean;
    var Index:Integer;
    begin
      if MethodIndex__=Low(MethodOrder) then                                    {after box permutations, don't run box permutations with a time-limit before the other enabled methods have been tried}
         for Index:=Succ(Low(MethodOrder)) to Pred(High(MethodOrder)) do
             if MethodOrder[Index]=omBoxPermutationsWithTimeLimit then begin
                MethodOrder[Index]:=MethodOrder[Succ(Index)];
                MethodOrder[Succ(Index)]:=omBoxPermutationsWithTimeLimit;
                end;

      if (ActivateAllOtherMethods__) or                                         {'True': typically, the other methods are activated again after a method has found some improvements}
         ((ActiveMethodSet__=[]) and (MethodIndex__<=Low(MethodOrder))) then begin {'True': the fallback strategy was the most recently selected method}
         for Index:=Succ(Low(MethodOrder)) to High(MethodOrder) do              {'Succ': the fallback strategy is not included in the active method set}
             if (Index<>MethodIndex__) and
                (MethodEnabled[MethodOrder[Index]]) and
                (MethodOrder[Index]<>MethodOrder[Low(MethodOrder)]) then        {'Low(MethodOrder)': the fallback strategy is not included in the active method set}
                Include(ActiveMethodSet__,MethodOrder[Index]);
         end;

      if   ActiveMethodSet__<>[] then                                           {'True': there are some active method candidates; choose the next one}
           repeat if   MethodIndex__<High(MethodOrder) then
                       Inc(MethodIndex__)
                  else MethodIndex__:=Succ(Low(MethodOrder));                   {'Succ': the first defined optimization method is the fallback strategy}
           until  MethodOrder[MethodIndex__] in ActiveMethodSet__
      else MethodIndex__:=Low(MethodOrder);                                     {select the fallback strategy, i.e., box-permutations without a time-limit}
      Exclude(ActiveMethodSet__,MethodOrder[MethodIndex__]);                    {remove the selected method from the active set}

      SuccessiveGlobalSearchesCountDown:=MAX_OPTIMIZER_SUCCESSIVE_GLOBAL_OPTIMIZATION_SEARCHES; {initialize the number of successive global optimization searches}

      Result:=MethodEnabled[MethodOrder[MethodIndex__]];                        {'True': the selected method is enabled (the fallback strategy may be selected but not enabled)}
    end; // OptimizeGame.Search.SelectNextOptimizationMethod

  begin // OptimizeGame.Search
    Result:=False;
    Game.ReverseMode:=False;
    Solver.LastCallBackTimeMS:=0; Solver.TimeCheckCount:=0;
    Solver.MoveCount:=0; Solver.PushCount:=0; Solver.LimitExceededPushCount:=0;
    Optimizer.UpdateSearchTreePushCount:=0; Optimizer.UpdateQueueRoot:=nil;
    Optimizer.SearchResultStatusText:=''; Optimizer.SearchStateStatusText:='';

    OldPlayerPos:=Game.PlayerPos;
    OriginalSearchLimits:=Solver.SearchLimits;                                  {save search limits}
    Solver.SearchLimits:=Optimizer.SearchLimits;                                {install optimizer limits as solver limits (they are used throughout the search and by 'Terminate')}

    SetSokobanStatusText(TEXT_OPTIMIZING_GAME);

    BoxSet:=[]; {not in production}
    BoxPermutationsCount:=2; {IsFirstVicinitySearch:=True;}

    MethodEnabled:=Optimizer.MethodEnabled; MethodOrder:=Optimizer.MethodOrder; {use a local copy of the global settings; the order may change during the search}
    ActiveMethodSet:=[];                                                        {[]: 'SelectNextOptimizationMethod' calculates the true active set}
    MethodIndex:=Pred(Low(MethodOrder));                                        {'Pred(Low...'): set 'MethodIndex' just below the lowest valid value to get things started; 'Low(MethodOrder)' is the default strategy}
    SelectNextOptimizationMethod(True,MethodIndex,ActiveMethodSet);

    if   MethodOrder[MethodIndex]<>omRearrangement then
         {check if simple rearrangements of the pushes can improve the game}
         RearrangementOptimization(True,True,False,False,True);

    {$IFDEF CONSOLE_APPLICATION}
      ShowStatus;
    {$ENDIF}

    {iteration loop; each iteration starts with only the best path on the transposition table}
    repeat  case MethodOrder[MethodIndex] of
              omBoxPermutations:                                                {fallback strategy: run the box-permutations method until it finds an improvement, or until the searchs reaches a limit, or the user terminates it manually}
                begin BoxPermutationsSearch(BoxPermutationsCount,Game.BoxCount,True,TimeMS); {'...,True,...': stop iterating when/if an improvement is found, and try the next optimization method}
                      Result:=Optimizer.IterationResult or Result;
                      if   Optimizer.IterationResult and                        {'True': box-permutations-search succeeded and found an improvement}
                           (not SearchHasTerminated) then begin
                           Inc(BoxPermutationsCount);                           {'Inc': if the other optimization methods fails, then the next box-permutations-search should not repeat the search that just has been performed}
                           SelectNextOptimizationMethod(True,MethodIndex,ActiveMethodSet);
                           end
                      else TerminateSearch;                                     {exit the main search loop}
                end;
              omBoxPermutationsWithTimeLimit:
                begin IterativeBoxPermutationsSearch(BoxPermutationsCount,Optimizer.BoxPermutationsSearchTimeLimitMS,TimeMS);
                      Result:=Optimizer.IterationResult or Result;
                      Inc(BoxPermutationsCount);                                {'Inc': if the other optimization methods fails, then the next box-permutations-search should not repeat the search that just has been performed}
                      if   SelectNextOptimizationMethod(Optimizer.IterationResult,MethodIndex,ActiveMethodSet) then begin
                           if MethodIndex=Low(MethodOrder) then                 {'True': the fallback strategy is selected as the next method to run, meaning box-permutations with time-limit is the only enabled non-fallback method}
                              MethodEnabled[omBoxPermutationsWithTimeLimit]:=False; {stop using box-permutations with time-limit; only use the fallback strategy which is box-permutations without a time-limit}
                           end
                      else TerminateSearch;
                end;
              omRearrangement:
                begin {$IFDEF PLUGIN_MODULE}
                        Optimizer.SearchStateStatusText:='';
                        ShowStatus;
                      {$ENDIF}
                      RearrangementOptimization(                                // check if rearrangements can improve the game
                        True,
                        (YASS.Positions.BestPosition=nil)
                        or
                        (YASS.Positions.BestPosition^.PushCount>=REARRANGEMENT_OPTIMIZATION_KEEP_EXISTING_BOX_SESSIONS_PATH_LENGTH_THRESHOLD), // '>' try to limit the exponential growth by keeping the existing box-sessions
                        True,                                                   // 'True': try all box-permutations
                        True,                                                   // 'True': try to move whole sequences of pushes
                        True);                                                  // 'True': try symmetry optimization
                      Result:=Optimizer.IterationResult or Result;

                      if Optimizer.IterationResult then begin
                         if BoxPermutationsCount>2 then Dec(BoxPermutationsCount); {start with a lower number of boxes the next time a box-permutations-search is invoked}
                         repeat  Include(ActiveMethodSet,MethodOrder[MethodIndex]); {put the currently selected method back into the active set}
                                 SelectNextOptimizationMethod(True,MethodIndex,ActiveMethodSet); {select the next method and put all enabled methods (except the currently selected one) into the active set (the 'True' parameter)}
                         until   MethodOrder[MethodIndex]=omRearrangement;      {until rearrangement optimization is selected again; at this point all the other enabled methods are members of the active set}
                         end
                      else begin
                         Exclude(ActiveMethodSet,omRearrangement);              {don't activate the rearrangement optimization again before another method has succeeded}
                         if not SelectNextOptimizationMethod(False,MethodIndex,ActiveMethodSet) then
                            TerminateSearch;
                         end;
                end;
              omVicinitySearch:
                begin {$IFDEF PLUGIN_MODULE}
                        Optimizer.SearchStateStatusText:='';
                        ShowStatus;
                      {$ENDIF}

                      if {IsFirstVicinitySearch} True then begin                {'True': perform quick 1-box searches if they are enabled in the settings}
                         {IsFirstVicinitySearch:=False;}
                         if Optimizer.QuickVicinitySearchEnabled then
                            Result:=QuickVicinitySearch or Result;              {begin vicinity search with 1-box searches; this often speeds up a 2-box search}
                         end;

                      if not SearchHasTerminated then begin
                         VicinitySearch(FullGameSearch);                        {perform the vicinity search with the user settings}
                         Result:=Optimizer.IterationResult or Result;
                         if Optimizer.IterationResult then begin
                            if BoxPermutationsCount>2 then Dec(BoxPermutationsCount); {start with a lower number of boxes the next time a box-permutations-search is invoked}
                            SelectNextOptimizationMethod(True,MethodIndex,ActiveMethodSet);
                            if   FullGameSearch then                            {'True': vicinity search has completed; the last iteration didn't find any further improvements}
                                 Exclude(ActiveMethodSet,omVicinitySearch)      {don't activate the vicinity-search again before some other method has succeeded}
                            else Include(ActiveMethodSet,omVicinitySearch);     {vicinity search has only looped through the entire solution once; activate the vicinity-search again before the fallback strategy}
                            if MethodIndex=Low(MethodOrder) then                {'True: the fallback strategy is selected as the next method to run, meaning vicinity-search is the only enabled non-fallback method}
                               if   FullGameSearch then                         {'True': the last vicinity-search encompassed the entire game, hence, there is no reason to run it again}
                                    if   MethodEnabled[MethodOrder[Low(MethodOrder)]] then {'True': the fallback strategy is enabled: it's OK to run it}
                                    else TerminateSearch                        {the fallback strategy is disabled: stop the search}
                               else SelectNextOptimizationMethod(True,MethodIndex,ActiveMethodSet); {select vicinity search again}
                            end
                         else begin
                            Exclude(ActiveMethodSet,omVicinitySearch);          {don't activate the vicinity-search again before some other method has succeeded}
                            if not SelectNextOptimizationMethod(False,MethodIndex,ActiveMethodSet) then
                               TerminateSearch;
                            end;
                         end;
                end;
              omGlobalSearch:
                begin {$IFDEF PLUGIN_MODULE}
                        Optimizer.SearchStateStatusText:='';
                        ShowStatus;
                      {$ENDIF}
                      {
                      if not MethodEnabled[omRearrangement] then begin          // 'not ...': the rearrangement optimization isn't running as an independent method; therefore activate it now as a part of global optimization
                         RearrangementOptimization(                             // check if simple box-changes can improve the game
                           True,
                           (YASS.Positions.BestPosition=nil)
                           or
                           (YASS.Positions.BestPosition^.PushCount>=BOX_CHANGES_OPTIMIZATION_KEEP_EXISTING_BOX_SESSIONS_PATH_LENGTH_THRESHOLD), // '>' try to limit the exponential growth by keeping the existing box-sessions
                           True,                                                // 'True': try all box-permutations
                           True);                                               // 'True': try to move whole sequences of pushes
                           Result:=Optimizer.IterationResult or Result;
                           end;
                      }
                      GlobalOptimizationSearch;
                      Result:=Optimizer.IterationResult or Result;
                      Dec(SuccessiveGlobalSearchesCountDown);
                      if   (Positions.UninitializedItemCount<=0)                {'<=0' : the transposition table is full (provided the free-list also is empty), i.e., the global-optimization search was not exhaustive}
                           and
                           (Positions.FreeList=nil) then                        {'nil' : the transposition table is full, i.e., the global-optimization search was not exhaustive}
                           if Optimizer.IterationResult then begin
                              if BoxPermutationsCount>2 then Dec(BoxPermutationsCount); {start with a lower number of boxes the next time a box-permutations-search is invoked}
                              if SuccessiveGlobalSearchesCountDown<>0 then begin {continue global-optimization search}
                                 end
                              else begin
                                 SelectNextOptimizationMethod(True,MethodIndex,ActiveMethodSet); {the global optimization succeeded, but change to another method anyway}
                                 Include(ActiveMethodSet,omGlobalSearch);       {activate the global optimization again before the fallback strategy}
                                 if MethodIndex=Low(MethodOrder) then           {'True: the fallback strategy is selected as the next method to run, meaning global-search is the only enabled non-fallback method}
                                    if not SelectNextOptimizationMethod(True,MethodIndex,ActiveMethodSet) then {select global search again}
                                       TerminateSearch;
                                 end;
                              end
                           else begin
                              Exclude(ActiveMethodSet,omGlobalSearch);          {don't activate the global optimization again before some other method has succeeded}
                              if not SelectNextOptimizationMethod(False,MethodIndex,ActiveMethodSet) then
                                 TerminateSearch;
                              end
                      else TerminateSearch;                                     {the global-optimization search was exhaustive, hence, exit the main search loop}
                end;
            end; {case}
    until   SearchHasTerminated
            or
            (TTPurge(Positions.Capacity,True)<0);                               {'<0': purging the transposition table failed because of problems with the best path, such as 2 different positions having the same hash value}

    {$IFDEF CONSOLE_APPLICATION}
      //ShowBoard;
      //if Positions.SolutionPosition<>nil then with Positions do
      //   Writeln('Solution: ',POptimizerPosition(SolutionPosition)^.MoveCount,SLASH,SolutionPosition^.PushCount);
      //Readln;
    {$ENDIF}

    if (Optimizer.Result=prOK) or
       (Optimizer.Result=prGameTooLong) then begin
       if   PostProcessBestPosition then begin
            if Positions.BestPosition<>nil then
               with POptimizerPosition(Positions.BestPosition)^ do with Position do begin
                 Optimizer.GameMetrics:=Optimizer.OriginalMetrics;              {trick 'HasABetterOrEqualScore' to compare the score for the best position with the original best score}
                 Optimizer.GameMetrics.HasPlayerLines:=True;
                 if (not HasABetterOrEqualScore(Positions.BestPosition))        {if ">"}
                    or                                                          {or "=" then the optimizer didn't find any improvements}
                    ((MoveCount      =Optimizer.OriginalMetrics.MoveCount      ) and
                     (PushCount      =Optimizer.OriginalMetrics.PushCount      ) and
                     (BoxLines       =Optimizer.OriginalMetrics.BoxLines       ) and
                     (BoxChanges     =Optimizer.OriginalMetrics.BoxChanges     ) and
                     (PushingSessions=Optimizer.OriginalMetrics.PushingSessions) and
                     (PlayerLines    =Optimizer.OriginalMetrics.PlayerLines    )
                    ) then
                    Optimizer.Result:=prUnsolved;                               {in the end, the result didn't improve, contrary to what the search reported}
                 Optimizer.GameMetrics.HasPlayerLines:=False;
                 end;
            end
       else Optimizer.Result:=prFailed;
       end;

    {$IFDEF CONSOLE_APPLICATION}
      if Optimizer.Result=prFailed then
         Writeln('Optimization failed');
      Writeln('Moves: ',Solver.MoveCount,' Pushes: ',Solver.PushCount,' Positions: ',Positions.Count,' Open: ',Positions.OpenPositions.Count);

      if Positions.BestPosition<>nil then begin
         Writeln('Result: ',OptimizerMetricsAsText(Positions.BestPosition),SPACE,LEFT_PAREN,OptimizerImprovementAsText(Positions.BestPosition),RIGHT_PAREN);
         end;
      {Readln;}
    {$ENDIF}

    Solver.SearchLimits:=OriginalSearchLimits;                                  {restore search limits}
    MovePlayer(OldPlayerPos); {the search destroys the original player position, hence, repair it before exiting}
  end; // OptimizeGame.Search

  function  WasALegalPush(Position__:PPosition):Boolean;
  var SquareOffset:Integer;
  begin // returns 'True' if the move stored in 'Position__' can lead to the current game state;
        // (due to transpositions, this might not be the same move as the one currently under investigation)
        // precondition: 'Position__' (its hash-value) matches the current game state;
    with Position__^ do begin
      SquareOffSet:=Game.SquareOffsetForward[TDirection(Ord(Move.Direction) and DIRECTION_BIT_MASK)];
      // 'PlayerPos ' contains the 'box-from-square' in the move; the direction points to the 'box-to-square'
      Result:=((Game.Board[PlayerPos-SquareOffset] and (WALL+BOX))=0)
              and
              ((Game.Board[PlayerPos+SquareOffset] and BOX)<>0)
              and
              (Move.BoxNo<>0); // '0': the start position has 'Move.BoxNo' = 0
      end;
  end; // OptimizeGame.WasALegalPush

  function  OPENRemoveTaggedPositions(Position__:PPosition):PPosition;
  begin {removes positions on the path to (and including) 'Position__' from the open-queue, but keeps the 'OPEN' tag; returns the last of the positions on the path that was on the open-queue; see also 'OPENAddTaggedPositions'}
    Result:=nil;
    while Position__<>nil do begin
      if (Ord(Position__^.Move.Direction) and POSITION_OPEN_TAG)<>0 then begin
         OPENRemove(Position__);
         Inc(UInt8(Position__^.Move.Direction),POSITION_OPEN_TAG);              {mark that this position was on the open-queue}
         if Result=nil then Result:=Position__;                                 {return the last position on the path that was on the open-queue}
         end;
      Position__:=Position__^.Parent;
      end;
  end;

  procedure OPENAddTaggedPositions(Position__:PPosition);
  begin {adds 'OPEN'-tagged positions on the path to (and including) 'Position__' to the open-queue; precondition: these positions aren't already on the queue; see also 'OPEN}
    while Position__<>nil do begin                                              {put open positions, if any, back on the open-queue}
      if (Ord(Position__^.Move.Direction) and POSITION_OPEN_TAG)<>0 then begin
            Dec(UInt8(Position__^.Move.Direction),POSITION_OPEN_TAG);
            OPENAdd(Position__,True);
            end;
         Position__:=Position__^.Parent;
         end;
  end;

  function  WriteBestPathToLogFile:Boolean;
  var PluginResult:TPluginResult; LastOpenPositionOnPath:PPosition;
  begin
    Result:=LogFile.Enabled and (LogFile.FileName<>'') and (Positions.BestPosition<>nil);
    if Result then begin
       LastOpenPositionOnPath:=OPENRemovePositionsOnPath(Positions.BestPosition,True); {temporarily remove open positions on the path from the open-queue; 'WritePathToFile' uses the overlapping 'TPosition.Successor' field}

       Result:=WritePathToFile(POptimizerPosition(YASS.Positions.BestPosition),LogFile.TextFile,PluginResult) and
               FlushLogFile;

       OPENAddPositionsOnPath(LastOpenPositionOnPath,True);                     {put open positions, if any, back on the open-queue}
       end;
  end; // OptimizeGame.WriteBestPathToLogFile;

begin // OptimizeGame; precondition: the game board has been set up by calling 'InitializeGame' and the game state matches the start position 'YASS.Positions.StartPosition'
  Solver.StartTimeMS:=GetTimeMS;
  Optimizer.Result:=prUnsolved;
  FillChar(Optimizer.OriginalMetrics,SizeOf(Optimizer.OriginalMetrics),0);
  OriginalSolverTimeMS:=Solver.TimeMS; Solver.TimeMS:=0; Optimizer.TimeMS:=0;

  // during processing, when the program is compiled as a plugin module,
  // the status flags must contain the actually performed optimization
  // (which may differ from the one originally requested by the user);
  // the callback function informs the host about the actually performed optimization,
  // hence an optimizer must guarantee that the callback is called at least once;
  // YASS guarantees that by having the call to 'ShowStatus' at the end of this function;
  Solver.SokobanStatusPointer^.Flags:=OPTIMIZATIONS_TO_SOKOBAN_PLUGIN_FLAGS[Optimizer.Optimization];

  if Game.SimpleLowerBound=0 then begin
     {$IFDEF CONSOLE_APPLICATION}
       Writeln(TEXT_TRIVIAL_SOLUTION_1);
     {$ENDIF}
     if Assigned(Solver.SokobanCallBackFunction) then begin
        SetSokobanStatusText(TEXT_TRIVIAL_SOLUTION_1);
        PerformSokobanCallBackFunction;
        end;
     end;

  if TTLoadGame(MovesAsTextBufferByteSize__,MovesAsText__) and                  // note that 'TTLoadGame' may find optimizations in form of pruned repetitions, in which case it sets 'Optimizer.Result:=prOK'
     (not Solver.Terminated) then begin
     Search;
     end;

  Game.History.Count:=0; // so 'WriteLevelToFile' doesn't think there is a game in the history

  {$IFDEF PLUGIN_MODULE}
    ShowStatus; {fill in the final statistics and send it to the call-back function, if any}
  {$ENDIF}

  Solver.TimeMS:=OriginalSolverTimeMS; {restore the solver time, if any; during the optimization it was used for metering the optimizer time}
  with Optimizer do TimeMS:=CalculateElapsedTimeMS(Solver.StartTimeMS,GetTimeMS);

  // as output, the status flags must specify solved state and optimality state;
  // YASS only provides information about the solved state and not the optimality state,
  // hence, keep the solution flag, if any, and clear all other flags
  with Solver.SokobanStatusPointer^ do begin
    Flags:=Flags and SOKOBAN_PLUGIN_FLAG_SOLUTION;
    TimeMS:=UInt32(Solver.TimeMS+Game.InitializationTimeMS+Optimizer.TimeMS);
    end;

  Result:=Optimizer.Result=prOK;
end; // OptimizeGame

{-----------------------------------------------------------------------------}

{Process Levels}

procedure ProcessLevels(InputFileName__:String; FirstLevelNo__,LastLevelNo__:Cardinal);
const TEXT_TITLE_SUFFIX=', '+TEXT_APPLICATION_TITLE+SPACE+TEXT_APPLICATION_VERSION_NUMBER+SPACE+TEXT_SOLUTIONS;
var i,j,CompareResult:Integer; FirstLevel,Solved:Boolean; LevelStatisticsFlags:TLevelStatisticsFlags;
    OutputFileName:String; F:Text;

  {$IFDEF CONSOLE_APPLICATION}
    procedure ShowStatistics;
    var LevelCount,SolvedCount:Integer; TimeMS:TTimeMS; Item:PLevelStatistics;
    begin
      if Solver.Enabled then begin
         LevelCount:=0; SolvedCount:=0; TimeMS:=0;

         Item:=LevelStatistics;
         while Item<>nil do with Item^ do begin
           Inc(LevelCount);
           if PushCount<>0 then Inc(SolvedCount);
           TimeMS:=TimeMS+InitializationTimeMS+SolverTimeMS;
           Item:=Next;
           end;

         Writeln;
         Writeln('Statistics');
         Writeln('Solved: ',SolvedCount,'  Levels: ',LevelCount,'  Time: ',TimeMS,' milli seconds');
         end;
    end;
  {$ENDIF}

begin {ProcessLevels}
  ClearStatistics; FirstLevel:=True;
  OutputFileName:=FileNameWithExtension(InputFileName__,TEXT_TITLE_SUFFIX+SOKOBAN_FILE_EXT);
  if ((not LogFile.Enabled) or CreateLogFile(InputFileName__)) and
     LoadFirstLevelFromFile(InputFileName__,OutputFileName) then
     repeat

       if Reader.LevelCount>=FirstLevelNo__ then begin
          if FirstLevel then begin {first level to process}
             FirstLevel:=False;
             AssignFile(F,OutputFileName); Rewrite(F); CloseFile(F); {clear outputfile}
             //AssignFile(F,'Log.txt'); Rewrite(F); Writeln(F,'Log: ',Reader.InputFileName); CloseFile(F);
             end;

          if (CalculatePlayersReachableSquares(0)<>0) then begin {'<>0': the board has a player on a legal square}

             //ReplayGame(Game.OriginalSolution);

             if Solver.Enabled then begin
                Solved:=Search();

                if Solved then begin
                   {$IFDEF CONSOLE_APPLICATION}
                     ShowBoard;
                     //Readln;
                   {$ENDIF}
                   end
                else begin
                   {$IFDEF CONSOLE_APPLICATION}
                     if   (Solver.LowerBound>=INFINITY)
                          or
                          ((Solver.PushCount>0)
                           and
                           (Positions.OpenPositions.MaxValue>=Low(Positions.OpenPositions.Buckets)-1)
                           {'True': all stored positions were explored without finding a solution}
                           {('.MaxValue' = Low(...) - 2 if the search was terminated before all positions were fully expanded)}
                           and
                           (Solver.LimitExceededPushCount=0) {'True': no positions were dropped because of a depth limit or a push count limit}
                           and
                           (Positions.SearchStatistics.RoomPositionsCount=0) {'True': no room pruning has been performed, i.e., all boxes have been taken into account during node expansion}
                          ) then begin
                          Writeln(TEXT_LEVEL_UNSOLVABLE);
                          if UserInterface.Prompt then Readln;
{
                          if ReplayGame(Game.OriginalSolution) then begin
                             Writeln('Existing solution: ',Game.OriginalSolutionMoveCount,SLASH,Game.OriginalSolutionPushCount);
                             end;
}
                          end
                     else Writeln(TEXT_LEVEL_UNSOLVED);
                     //Readln;
                   {$ENDIF}
                   end;
                end
             else begin
                Optimizer.Result:=prUnsolved;
                if Optimizer.Enabled and (Game.OriginalSolution<>'') then begin
                   OptimizeGame(Length(Game.OriginalSolution),PChar(Addr(Game.OriginalSolution[1])));
                   end
                else begin
                   Positions.Count:=0; Solver.PushCount:=0; Optimizer.TimeMS:=0;
                   end;
                end;

             if not Solver.Terminated then begin
                LevelStatisticsFlags:=[];
                if      Game.IsAnOptimalSolution then Include(LevelStatisticsFlags,lsfOptimalSolution);
                if      High(Positions.Count)-Positions.SearchStatistics.DroppedCount>=Positions.Count then
                        Positions.Count:=Positions.Count+Positions.SearchStatistics.DroppedCount
                else    Positions.Count:=High(Positions.Count);
                if      Solver.Enabled then begin
                        i:=Game.History.Count; j:=i;
                        end
                else if Optimizer.Enabled then
                        if ((Optimizer.Result=prOK) or (Optimizer.Result=prGameTooLong)) and
                           (Positions.BestPosition<>nil) then
                           with POptimizerPosition(Positions.BestPosition)^ do with Position do begin
                             i:=MoveCount; j:=PushCount; Game.History.Count:=0;
                             if i<Optimizer.OriginalMetrics.MoveCount then Include(LevelStatisticsFlags,lsfMovesImproved);
                             if j<Optimizer.OriginalMetrics.PushCount then Include(LevelStatisticsFlags,lsfPushesImproved);
                             CompareResult:=Integer(BoxLines)-Integer(Optimizer.OriginalMetrics.BoxLines);
                             if CompareResult=0 then begin
                                CompareResult:=Integer(BoxChanges)-Integer(Optimizer.OriginalMetrics.BoxChanges);
                                if CompareResult=0 then begin
                                   CompareResult:=Integer(PushingSessions)-Integer(Optimizer.OriginalMetrics.PushingSessions);
                                   if CompareResult=0 then
                                      CompareResult:=Integer(PlayerLines)-Integer(Optimizer.OriginalMetrics.PlayerLines);
                                   end;
                                end;
                             if CompareResult<0 then Include(LevelStatisticsFlags,lsfSecondaryMetricsImproved);
                             end
                        else begin
                           i:=Optimizer.OriginalMetrics.MoveCount;
                           j:=Optimizer.OriginalMetrics.PushCount;
                           end
                     else begin
                        i:=0; j:=0; Game.History.Count:=0;
                        end;
                MakeLevelStatistics(
                  Game.Title,Game.BoardWidth,Game.BoardHeight,
                  i,j,
                  Solver.LowerBound,
                  Positions.Count,
                  Positions.SearchStatistics.CorralPositionsCount,
                  Positions.SearchStatistics.CorralPositionsBoxCount,
                  Positions.SearchStatistics.ForwardPositionCount,
                  Solver.MoveCount,Solver.PushCount,
                  Positions.SearchStatistics.DeadlockedOpenPositionsCount,
                  Positions.SearchStatistics.DeadlockPositionsCount,
                  Game.DeadlockSets.PrecalculatedSetsCount,
                  Game.DeadlockSets.DynamicSetsCount,
                  Game.DeadlockSets.LevelTotalPushCount,
                  Positions.SearchStatistics.NewPathCount,
                  Positions.SearchStatistics.RoomPositionsCount,
                  Game.InitializationTimeMS,
                  Game.DeadlockSets.TimeMS,
                  Solver.PackingOrder.TimeMS,
                  Solver.TimeMS,
                  Optimizer.TimeMS,
                  LevelStatisticsFlags);

                WriteStatistics(OutputFileName);
                AppendLevelToFile(OutputFileName,Game.Title);
                end;

             end;
          end;
     until Solver.Terminated or
           (Reader.LevelCount=LastLevelNo__) or
           (not LoadNextLevelFromFile(OutputFileName));

    {$IFDEF CONSOLE_APPLICATION}
      ShowStatistics;
    {$ENDIF}
end;

{-----------------------------------------------------------------------------}

{Solver and Optimizer Toplevel}

procedure Finalize;
begin
  {all global strings must be cleared;}
  {otherwise, the runtime may hold on to address-space addresses even though}
  {the memory itself is released; the result can be that a later call to}
  {'InitializeSolver' fails because there aren't enough consecutive}
  {address-space for a large transposition table (at least this seems to be a}
  {plausible explanation for some "memory full" problems that have occured in the past)}
  Game.Title:=''; Game.OriginalSolution:='';
  Reader.CurrentTextLine:=''; Reader.InputFileName:=''; Reader.PreviousTextLine:='';

  CloseGraphFile; GraphFile.FileName:=''; {close the file and ensure that the string is cleared}
  CloseLogFile; LogFile.FileName:='';     {close the file and ensure that the string is cleared}
  Optimizer.SearchResultStatusText:=''; Optimizer.SearchStateStatusText:='';
  FinalizeStatistics;
  TTFinalize;
  {$IFDEF CONSOLE_APPLICATION}
    Solver.SokobanStatus.StatusText:='';
  {$ENDIF}
end;

function  Initialize(MemoryByteSize__:Cardinal;
                     PushCountLimit__:Int64;
                     DepthLimit__,
                     BackwardSearchDepthLimit__:Cardinal;
                     OptimizerPushCountLimit__:Int64;
                     OptimizerDepthLimit__,
                     DeadlockSetsAdjacentOpenSquaresLimit__,
                     DeadlockSetsBoxLimitForDynamicSets__,
                     DeadlockSetsBoxLimitForPrecalculatedSets__:Cardinal;
                     SearchMethod__:TSearchMethod;
                     SolverEnabled__,
                     OptimizerEnabled__,
                     OptimizerQuickVicinitySearchEnabled__,
                     ShowBestSolution__,
                     StopWhenSolved__,
                      Prompt__,
                     ReuseNodesEnabled__,
                     LogFileEnabled__,
                     PackingOrderEnabled__:Boolean;
                     PackingOrderBoxCountThreshold__:Integer;
                     TimeLimitMS__,
                     OptimizerTimeLimitMS__,
                     BoxPermutationsSearchTimeLimitMS__:TTimeMS;
                     OptimizationMethodEnabled__:TOptimizationMethodEnabled;
                     OptimizationMethodOrder__:TOptimizationMethodOrder;
                     Optimization__:TOptimization;
                     VicinitySettings__:TVicinitySettings;
                     SokobanCallBackFunction__:TSokobanCallBackFunction;
                     SokobanStatusPointer__:PSokobanStatus
                    ):Boolean;
var a,b,i,j:Integer;
begin
  {ensure that strings are properly released before 'FillChar' clears the data-structures;}
  {after 'FillChar', it's not strictly necessary to initialize the strings to '' because}
  {Delphi handles nil-pointers as empty strings, but the initialization is performed here anyway for completeness}
  Game.Title:=''; Game.OriginalSolution:=''; FillChar(Game     ,SizeOf(Game     ),0); Game.Title:=''; Game.OriginalSolution:='';
  GraphFile.FileName:='';                    FillChar(GraphFile,SizeOf(GraphFile),0); GraphFile.FileName:='';
  LogFile.FileName:='';                      FillChar(LogFile  ,SizeOf(LogFile  ),0); LogFile.FileName:='';
  Optimizer.SearchResultStatusText:='';
  Optimizer.SearchStateStatusText:='';       FillChar(Optimizer,SizeOf(Optimizer),0); Optimizer.SearchResultStatusText:=''; Optimizer.SearchStateStatusText:='';
                                             FillChar(Positions,SizeOf(Positions),0);

  {$IFDEF CONSOLE_APPLICATION}
    Solver.SokobanStatus.StatusText:='';
  {$ENDIF}
                                             FillChar(Solver   ,SizeOf(Solver   ),0);
  {$IFDEF CONSOLE_APPLICATION}
    Solver.SokobanStatus.StatusText:='';
  {$ENDIF}

  InitializeLegend(True);
//InitializeLegend(False);
  InitializeRandomState(0);
  InitializeReader;
  InitializeStatistics;

  Game.DeadlockSets.AdjacentOpenSquaresLimit:=DeadlockSetsAdjacentOpenSquaresLimit__;
  Game.DeadlockSets.BoxLimitForDynamicSets:=DeadlockSetsBoxLimitForDynamicSets__;
  Game.DeadlockSets.BoxLimitForPrecalculatedSets:=DeadlockSetsBoxLimitForPrecalculatedSets__;

  Solver.SearchLimits.PushCountLimit:=PushCountLimit__;
  Solver.SearchLimits.DepthLimit:=DepthLimit__;
  Solver.BackwardSearchDepthLimit:=BackwardSearchDepthLimit__;
  Optimizer.SearchLimits.PushCountLimit:=OptimizerPushCountLimit__;
  Optimizer.SearchLimits.DepthLimit:=OptimizerDepthLimit__;
  Solver.SearchMethod:=SearchMethod__;
  Solver.Enabled:=SolverEnabled__;
  Solver.FindPushOptimalSolution:=True;
  Optimizer.Enabled:=OptimizerEnabled__;
  Optimizer.QuickVicinitySearchEnabled:=OptimizerQuickVicinitySearchEnabled__;
  Solver.ShowBestPosition:=ShowBestSolution__;
  Solver.StopWhenSolved:=StopWhenSolved__;
  UserInterface.Prompt:=Prompt__;
  Solver.ReuseNodesEnabled:=ReuseNodesEnabled__;
  Solver.PackingOrder.Enabled:=PackingOrderEnabled__;
  Solver.PackingOrder.BoxCountThreshold:=PackingOrderBoxCountThreshold__;
  Solver.SearchLimits.TimeLimitMS:=TimeLimitMS__;
  Optimizer.SearchLimits.TimeLimitMS:=OptimizerTimeLimitMS__;
  Optimizer.BoxPermutationsSearchTimeLimitMS:=BoxPermutationsSearchTimeLimitMS__;
  Optimizer.MethodEnabled:=OptimizationMethodEnabled__;
  Optimizer.MethodOrder:=OptimizationMethodOrder__;
  Optimizer.Optimization:=Optimization__;
  Optimizer.VicinitySettings:=VicinitySettings__;
  Optimizer.VicinitySettings[Low (Optimizer.VicinitySettings)]:=0; {the vicinity settings are right-justified and in descending order with first and last element as zero-value sentinels}
  Optimizer.VicinitySettings[High(Optimizer.VicinitySettings)]:=0; {the vicinity settings are right-justified and in descending order with first and last element as zero-value sentinels}
  for i:=         Low(Optimizer.VicinitySettings)  to MAX_VICINITY_BOX_COUNT-1 do {bubble sort the items in ascending order (the order is changed to descending order further down)}
      for j:=Succ(Low(Optimizer.VicinitySettings)) to MAX_VICINITY_BOX_COUNT-1 do begin
          a:=Optimizer.VicinitySettings[j]; b:=Optimizer.VicinitySettings[Succ(j)];
          if a>b then begin
             Optimizer.VicinitySettings[j]:=b; Optimizer.VicinitySettings[Succ(j)]:=a;
             end;
          end;
  {reverse the vicinity settings to descending order}
  i:=Low(Optimizer.VicinitySettings);
  j:=MAX_VICINITY_BOX_COUNT;
  while (i<=High(Optimizer.VicinitySettings)) and (Optimizer.VicinitySettings[i]=0) do Inc(i); // find first non-zero value, if any
  while i<j do begin
    a                            :=Optimizer.VicinitySettings[i];
    Optimizer.VicinitySettings[i]:=Optimizer.VicinitySettings[j];
    Optimizer.VicinitySettings[j]:=a;
    Inc(i); Dec(j);
    end;
  if      Optimizer.VicinitySettings[MAX_VICINITY_BOX_COUNT  ]=0 then {'True': no vicinities specified; perform the initial quick search, i.e., a 1-box 999/0 vicinity search}
          Optimizer.QuickVicinitySearchEnabled:=True
  else if Optimizer.VicinitySettings[MAX_VICINITY_BOX_COUNT-1]=0 then {'True': one single vicinity specified, i.e., a 1-box search; don't perform the initial quick search which also is a 1-box search}
          Optimizer.QuickVicinitySearchEnabled:=False;
  if   Solver.Enabled then
       if   MAX_DEADLOCK_SETS_SEARCH_TIME_MS<=Solver.SearchLimits.TimeLimitMS then
            Game.DeadlockSets.TimeLimitMS:=MAX_DEADLOCK_SETS_SEARCH_TIME_MS
       else Game.DeadlockSets.TimeLimitMS:=Solver.SearchLimits.TimeLimitMS
  else if   MAX_DEADLOCK_SETS_SEARCH_TIME_MS<=Optimizer.SearchLimits.TimeLimitMS then
            Game.DeadlockSets.TimeLimitMS:=MAX_DEADLOCK_SETS_SEARCH_TIME_MS
       else Game.DeadlockSets.TimeLimitMS:=Optimizer.SearchLimits.TimeLimitMS;
  Solver.SokobanCallBackFunction:=SokobanCallBackFunction__;
  if   (SokobanStatusPointer__<>nil) and
       (SokobanStatusPointer__^.Size>=SizeOf(SokobanStatusPointer__^)) then {'>=': otherwise, the program cannot update the fields it expects to find in the record}
       Solver.SokobanStatusPointer:=SokobanStatusPointer__
  else Solver.SokobanStatusPointer:=Addr(Solver.SokobanStatus);
  {initialize the locally defined solver status record (it's only used if a caller doesn't provide its own record)}
  Solver.SokobanStatus.Size:=SizeOf(Solver.SokobanStatus);
  SetSokobanStatusText('');
  Solver.Terminated:=False;
  Optimizer.Result:=prUnsolved;
  LogFile.Enabled:=LogFileEnabled__;

  Result:=TTInitialize(MemoryByteSize__);
end;

procedure Run(const InputFileName__:String; FirstLevelNo__,LastLevelNo__:Cardinal);
begin
  ProcessLevels(InputFileName__,FirstLevelNo__,LastLevelNo__);
end;

procedure Terminate;
begin
  Solver.Terminated:=True; {the instruction sequence is important}
  TerminateSearch;
end;

{-----------------------------------------------------------------------------}

{$IFDEF CONSOLE_APPLICATION}

  {Application Toplevel}

  function  InitializeApplication:Boolean;
  var FirstLevelNo,LastLevelNo:Cardinal; InputFileName:String;
  begin
    ShowTitle;
    //Readln;

    {Write(SizeOf(TGame)); Readln;}
    {Write(SizeOf(TBoxNumberSet)); Readln;}
    {Write(SizeOf(TSearchState)); Readln;}
    {Write(SizeOf(TSolver)); Readln;}
    {Write(SizeOf(Game)+SizeOf(Optimizer)+SizeOf(Solver)+SizeOf(Positions)); Readln;}
    {Write(SizeOf(Solver.SearchStates)); Readln;}
    {Write(SizeOf(TDeadlockSetCandidate)); Readln;}
    {Write(SizeOf(TDeadlockSetFlagsSet)); Readln;}
    {Write(SizeOf(TRooms)); Readln;}

    {$WARNINGS OFF} {warning: Comparison always evaluates to True}
      Result:=(MAX_HISTORY_BOX_MOVES                             <  High(Positions.Positions^[0].PushCount     ) div 2) and {'div 2': only for safety, not really a requirement}
              (MAX_HISTORY_BOX_MOVES                             <  High(Game.History.Count)) and
              (MAX_HISTORY_BOX_MOVES                             <  DEADLOCK_SCORE-2) and {'deadlock score', 'dead end score', and the number below them, are reserved values}
              (MAX_HISTORY_BOX_MOVES                             >  MAX_BOX_COUNT) and {the 'TSolver.SearchStates' vector must be large enough for a depth-first recursive search with one box at each recursion level}
              (MAX_BOX_COUNT*DIRECTION_COUNT+1                   <  High(Positions.Positions^[0].SuccessorCount) div 2) and {'+1': 'SuccessorCount' is increased by 1 during node-expansion}
              (MAX_BOARD_HEIGHT                                  <= High(Int8)) and {board height, board width, and straight-line distances may sometimes be stored in signed 8-bit fields for efficiency}
              (MAX_BOARD_WIDTH                                   <= High(Int8)) and
              (MAX_BOARD_SIZE                                    <= High(Game.DeadlockSets.CenterSquare[0])) and
              (MAX_BOARD_SIZE                                    <= High(Game.DeadlockSets.FloorCount[0])) and
              (MAX_BOARD_SIZE                                    <= PLAYER_POSITION_MASK) and {the high-bit in 'TPosition.PlayerPos' is reserved for the move-axis}
              (MAX_BOARD_SIZE                                    <= High(Positions.Positions^[0].PlayerPos) div 2) and {deadlock sets stored in the normal transposition table have player position stored as = player position +'MAX_BOARD_SIZE'}
              (MAX_BOARD_SIZE*DIRECTION_COUNT                    <  High(TTimeStamp)) and {after clearing (zero-filling) timestamps, it must be possible to use 'CalculatePlayersReachableSquares()' to visit all board squares without timestamp wrap around}
              (High(MAX_BOX_COUNT)                               <= High(UInt8)) and {various fields and vectors depend on that box numbers and goal numbers fit in a byte, i.e., an 8 bit unsigned integer}
              (High(MAX_BOX_COUNT)                               <= MAX_HISTORY_BOX_MOVES) and {the 'Solver.SearchStates' vector must have room for a depth-first search for each box}
              (MAX_OPTIMIZER_SEARCH_DEPTH*4                      <  MAX_HISTORY_BOX_MOVES) and {*4: the search state areas are used for reachable square timestamps, player lines, player line lengths, and legal parent directions on optimal paths}
              (High(Positions.Positions^[0].Score)-1             >  High(Positions.OpenPositions.Buckets)*2) and {*2: the 'Global optimization' optimizer method adds 'High(Buckets)' to the score for positions on the delay update queue}
              (High(Positions.Positions^[0].Score)               >= MAX_BOX_COUNT) and
//            (Low (Positions.Positions^[0].Score)               <=-MAX_BOX_COUNT) and
              (High(Positions.Positions^[0].BestForgottenScore)  >= High(Positions.Positions^[0].PushCount)) and
              (High(Positions.Positions^[0].BestForgottenScore)  >= High(Positions.Positions^[0].Score)) and
              (High(Positions.Positions^[0].PathLengthToSolution)>= High(Positions.Positions^[0].PushCount)) and
              (High(Positions.HashBucketMask)                    >= High(Positions.HashBucketCount)) and
              (DIRECTION_COUNT                                   <= 1 shl DIRECTION_BIT_COUNT) and
              (DIRECTION_BIT_COUNT                               <= 3) and {very dirty: tag-bits are stored in 'TPosition.Move.Direction', e.g., 'POSITION_OPEN_TAG' and 'POSITION_PATH_TAG'}
              (MAX_BOX_COUNT                                     <= High(Game.Board[0]) shr GOAL_BIT_SHIFT_COUNT) and {goal-numbers or goal-packing-order-set-numbers are stored in the upper bits for each square}
              (BOX_GOAL_BIT_MASK                                 <  ((1 shl GOAL_BIT_SHIFT_COUNT) shr BOX_BIT_SHIFT_COUNT)) and {goal numbers and boxnumbers are stored in the upper bits for each square}
              (MAX_DEADLOCK_SETS                                 <= High(Game.DeadlockSets.SquareSetNumbers[0]^[0])) and {for compactness, the set numbers for each square are saved as small 16 bit integers}
              (SizeOf(UInt)                                      =  SizeOf(Pointer)) and
              (SizeOf(Integer)                                   =  SizeOf(Pointer)) and
              (SizeOf(TSmallBoxSet)                              =  SizeOf(Integer)) and
              (High(Game.DeadlockSets.SquaresOutsideFence)       <= {'outside-fence' squares are only saved for some deadlock sets, and for compactness the squares are saved as small 16-bit numbers}
                                                                    High(Game.DeadlockSets.SquaresOutsideFenceIndex[ Low(Game.DeadlockSets.SquaresOutsideFenceIndex) ]))
              ;
    {$WARNINGS ON}

    if Result then begin
       Result:=(SizeOf(TPosition) mod 4)=0;
       if not Result then
          Writeln(TEXT_APPLICATION_TITLE+': Internal error: Positions are not 4-byte aligned (Size=',SizeOf(TPosition),').');
       if Result then begin
          Result:=(SizeOf(TOptimizerPosition) mod 4)=0;
          if not Result then
             Writeln(TEXT_APPLICATION_TITLE+': Internal error: Optimizer positions are not 4-byte aligned (Size=',SizeOf(TOptimizerPosition),').');
          end;
       end
    else begin
       Writeln(TEXT_APPLICATION_TITLE+': Internal error: Basic constraints for the program is violated.');
       end;

    if Result then
       Result:=GetCommandLineParameters(InputFileName,
                                        FirstLevelNo,LastLevelNo,
                                        Positions.MemoryByteSize,
                                        Solver.SearchLimits.PushCountLimit,
                                        Cardinal(Solver.SearchLimits.DepthLimit),
                                        Cardinal(Solver.BackwardSearchDepthLimit),
                                        Optimizer.SearchLimits.PushCountLimit,
                                        Cardinal(Optimizer.SearchLimits.DepthLimit),
                                        Cardinal(Game.DeadlockSets.AdjacentOpenSquaresLimit),
                                        Cardinal(Game.DeadlockSets.BoxLimitForDynamicSets),
                                        Cardinal(Game.DeadlockSets.BoxLimitForPrecalculatedSets),
                                        Solver.SearchMethod,
                                        Solver.Enabled,
                                        Optimizer.Enabled,
                                        Optimizer.QuickVicinitySearchEnabled,
                                        Solver.ShowBestPosition,
                                        Solver.StopWhenSolved,
                                        UserInterface.Prompt,
                                        Solver.ReuseNodesEnabled,
                                        LogFile.Enabled,
                                        Solver.PackingOrder.Enabled,
                                        Cardinal(Solver.PackingOrder.BoxCountThreshold),
                                        Solver.SearchLimits.TimeLimitMS,
                                        Optimizer.SearchLimits.TimeLimitMS,
                                        Optimizer.BoxPermutationsSearchTimeLimitMS,
                                        Optimizer.MethodEnabled,
                                        Optimizer.MethodOrder,
                                        Optimizer.Optimization,
                                        Optimizer.VicinitySettings);

    if Result then begin
       Result:=Initialize(              Positions.MemoryByteSize,
                                        Solver.SearchLimits.PushCountLimit,
                                        Solver.SearchLimits.DepthLimit,
                                        Solver.BackwardSearchDepthLimit,
                                        Optimizer.SearchLimits.PushCountLimit,
                                        Optimizer.SearchLimits.DepthLimit,
                                        Game.DeadlockSets.AdjacentOpenSquaresLimit,
                                        Game.DeadlockSets.BoxLimitForDynamicSets,
                                        Game.DeadlockSets.BoxLimitForPrecalculatedSets,
                                        Solver.SearchMethod,
                                        Solver.Enabled,
                                        Optimizer.Enabled,
                                        Optimizer.QuickVicinitySearchEnabled,
                                        Solver.ShowBestPosition,
                                        Solver.StopWhenSolved,
                                        UserInterface.Prompt,
                                        Solver.ReuseNodesEnabled,
                                        LogFile.Enabled,
                                        Solver.PackingOrder.Enabled,
                                        Solver.PackingOrder.BoxCountThreshold,
                                        Solver.SearchLimits.TimeLimitMS,
                                        Optimizer.SearchLimits.TimeLimitMS,
                                        Optimizer.BoxPermutationsSearchTimeLimitMS,
                                        Optimizer.MethodEnabled,
                                        Optimizer.MethodOrder,
                                        Optimizer.Optimization,
                                        Optimizer.VicinitySettings,
                                        nil, //SokobanCallbackFunction,
                                        nil);
       Reader.InputFileName:=InputFileName; {save command-line arguments}
       Reader.FirstLevelNo:=FirstLevelNo;
       Reader.LastLevelNo:=LastLevelNo;
       end;
    if Result then begin
       Writeln('Static  memory: ',(SizeOf(Game)+SizeOf(GraphFile)+SizeOf(Legend)+
                                   SizeOf(LevelStatistics)+SizeOf(LogFile)+SizeOf(Optimizer)+
                                   SizeOf(Positions)+SizeOf(RandomState)+SizeOf(Reader)+
                                   SizeOf(Solver)
                                   +(ONE_MEBI div 2)
                                 ) div ONE_MEBI:6,' MiB');
       Write(  'Dynamic memory: ',(Positions.MemoryByteSize +(ONE_MEBI div 2)) div ONE_MEBI:6,' MiB');
       if      Solver.Enabled then
               Write('   Position capacity: ',( Cardinal( Positions.EndOfPositions ) - Cardinal( Positions.Positions ) ) div SizeOf( TPosition ),
                     '  Position size: '     ,SizeOf(TPosition))
       else if Optimizer.Enabled then
               Write('   Position capacity: ',( Cardinal( Positions.EndOfPositions ) - Cardinal( Positions.Positions ) ) div SizeOf( TOptimizerPosition ),
                     '  Position size: '     ,SizeOf(TOptimizerPosition));
       Writeln;
       end
    else begin
       UserInterface.Prompt:=True;
       ShowHelp; Msg('','');
       end;
  end;

  procedure RunApplication;
  begin
    with Reader do Run(InputFileName,FirstLevelNo,LastLevelNo);
  end;

  procedure FinalizeApplication;
  begin
    Finalize;
    {$IFDEF CONSOLE_APPLICATION}
      //Writeln('Tested games: ',Game.DeadlockSets.SessionTestedGamesCount);
      //Writeln('Optimizer time: ',Optimizer.TimeMS);
      //Msg('Done','');
    {$ELSE}
    {$ENDIF}
  end;

{$ENDIF} {console application}

begin {main}
  {$IFDEF CONSOLE_APPLICATION}
    if InitializeApplication then
       RunApplication;
    FinalizeApplication;
  {$ELSE} {compile as a plug-in module; ensure that global variables are cleared or initialized}
    FillChar(Game,SizeOf(Game),0); Game.Title:=''; Game.OriginalSolution:='';
    FillChar(GraphFile,SizeOf(GraphFile),0); GraphFile.FileName:='';
    FillChar(LogFile,SizeOf(LogFile),0); LogFile.FileName:='';
    FillChar(Optimizer,SizeOf(Optimizer),0); Optimizer.SearchResultStatusText:=''; Optimizer.SearchStateStatusText:='';
    FillChar(Positions,SizeOf(Positions),0);
    FillChar(Reader,SizeOf(Reader),0);
    Reader.CurrentTextLine:=''; Reader.InputFileName:=''; Reader.PreviousTextLine:='';
    FillChar(Solver,SizeOf(Solver),0);
    UserInterface.Prompt:=True;
  {$ENDIF}
end.

